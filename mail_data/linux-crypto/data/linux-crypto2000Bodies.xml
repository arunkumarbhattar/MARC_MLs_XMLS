<?xml version="1.0" encoding="utf-8"?>
<emails><email><emailId>20000927204825</emailId><senderName>Gisle S{lensminde</senderName><senderEmail>gisle@ii.uib.no</senderEmail><timestampReceived>2000-09-27 20:48:25-0400</timestampReceived><subject>Re: [KERNELI-PATCH] Twofish for the cipherapi.</subject><body>

On Wed, 27 Sep 2000, Marc Mutz wrote:

&gt; Hi Alex!
&gt; 
&gt; As you know, I've ported the Twofish implementation of GnuPG
&gt; (http://www.gnupg.org) to the cipherapi of the kerneli patch
&gt; (http://www.kerneli.org/). You need to patch include/linux/crypto.h and
&gt; util-linux to use a cipher id you like. I don't want to mess around with
&gt; the loop_fish2.c driver. If you find this implementation worth of being
&gt; able to replace the other twofish, then it can take its number. 192 bits
&gt; mode is not working for this twofish.c, but not hard to obtain.
&gt; 
&gt; This patch assumes my changes to loop_gen.c, so no need to patch that
&gt; file. Please consider applying:

The patch seems not to be complete. It does at least miss the definitions
in linux/include/linux/crypto.h. Since I'm too lazy to scan the code to
find the exact size of the key schedule, I would prefere an updated
patch. 


--
Gisle Sælensminde ( gisle@ii.uib.no )   

With sufficient thrust, pigs fly just fine. However, this is not
necessarily a good idea. It is hard to be sure where they are going
to land, and it could be dangerous sitting under them as they fly
overhead. (from RFC 1925)


Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20000927212224</emailId><senderName>Marc Mutz</senderName><senderEmail>marc@mutz.com</senderEmail><timestampReceived>2000-09-27 21:22:24-0400</timestampReceived><subject>Twofish users:attention! (was: Re: [KERNELI-PATCH] Twofish for the</subject><body>

Gisle S{lensminde wrote:
&gt; 
&gt; On Wed, 27 Sep 2000, Marc Mutz wrote:
&gt; 
&gt; &gt; Hi Alex!
&gt; &gt;
&gt; &gt; As you know, I've ported the Twofish implementation of GnuPG
&gt; &gt; (http://www.gnupg.org) to the cipherapi of the kerneli patch
&gt; &gt; (http://www.kerneli.org/). You need to patch include/linux/crypto.h and
&gt; &gt; util-linux to use a cipher id you like. I don't want to mess around with
&gt; &gt; the loop_fish2.c driver. If you find this implementation worth of being
&gt; &gt; able to replace the other twofish, then it can take its number. 192 bits
&gt; &gt; mode is not working for this twofish.c, but not hard to obtain.
&gt; &gt;
&gt; &gt; This patch assumes my changes to loop_gen.c, so no need to patch that
&gt; &gt; file. Please consider applying:
&gt; 
&gt; The patch seems not to be complete. It does at least miss the definitions
&gt; in linux/include/linux/crypto.h. Since I'm too lazy to scan the code to
&gt; find the exact size of the key schedule, I would prefere an updated
&gt; patch.
&gt; 
&lt;snip&gt;

You're right, of course. The sent patch was relative to stuff I sent to
Alex earlier, before this ml was established. The included patch adds
the necessary definitions to include/linux/cryto.h and contains the
changes I made to drivers/block/loop_gen.c.

The driver has been assigned id 9 temporarily. It will not stay there.
Alex should choose number for it when he decides what will become of the
loop_2fish.c driver. Patching lomount.c involves only changing the
static list of ciphers and to add LO_CRYPT_TWOFISH to the 128 bit case
in lomount.c:set_loop()'s switch statement.

As you see, I don't want people to deploy this on a large basis, because
the ID is not assigned yet and there will be _questions_ if it changes
:-)

Hi out there! Anyone using Twofish from patch-int-2.2.17.3 or earlier?
Please contact me! It may well vanish in the future and the cipherapi
implementation might not be compatible then.

Marc

-- 
Marc Mutz &lt;Marc@Mutz.com&gt;        http://marc.mutz.com/Encryption-HOWTO/
University of Bielefeld, Dep. of Mathematics / Dep. of Physics

PGP-keyID's:   0xd46ce9ab (RSA), 0x7ae55b9e (DSS/DH)

["twofish-related.patch;" (text/plain)]

--- i5/drivers/block/loop_gen.c	Mon Sep 25 16:50:54 2000
+++ i5-raidA0-raid1rb15.B2-ext0.0.3a//drivers/block/loop_gen.c	Mon Sep 25 17:48:47 2000
@@ -56,6 +56,7 @@
 static int loop_gen_init2(struct loop_device *lo, struct loop_info *info)
 {
 	int cipher,err = -EINVAL;
+	int mode = CIPHER_CBC;
 	struct cipher_implementation *ci;
 	struct cipher_context *cx;
 
@@ -64,19 +65,7 @@
 	case LO_CRYPT_XOR:      cipher = CIPHER_XOR; break;
 	case LO_CRYPT_DES:      cipher = CIPHER_cbc_DES; break;
 	case LO_CRYPT_FISH2:    cipher = CIPHER_cbc_FISH2; break;
-	case LO_CRYPT_BLOW:     cipher = CIPHER_cbc_BLOWFISH; break;
-	case LO_CRYPT_CAST128:  cipher = CIPHER_cbc_CAST128; break;
-	case LO_CRYPT_IDEA:     cipher = CIPHER_cbc_IDEA; break;
-	case LO_CRYPT_SERPENT:  cipher = CIPHER_cbc_SERPENT; break;
-	case LO_CRYPT_MARS:     cipher = CIPHER_cbc_MARS; break;
-	case LO_CRYPT_SKIPJACK: cipher = CIPHER_cbc_SKIPJACK; break;
-	case LO_CRYPT_RC5:      cipher = CIPHER_cbc_RC5; break;
-	case LO_CRYPT_RC6:      cipher = CIPHER_cbc_RC6; break;
-	case LO_CRYPT_DES_EDE3: cipher = CIPHER_cbc_DES_EDE3; break;
-	case LO_CRYPT_E2:       cipher = CIPHER_cbc_E2; break;
-	case LO_CRYPT_CAST256:  cipher = CIPHER_cbc_CAST256; break;
-	case LO_CRYPT_DFC:      cipher = CIPHER_cbc_DFC; break;
-	default: goto out;
+	default:                cipher = info-&gt;lo_encrypt_type | mode; break;
 	}
 
 	ci = find_cipher_by_id(cipher);
@@ -85,7 +74,7 @@
 
 	if (ci-&gt;trans.t_id != cipher) {
 		printk("find_cipher_by_id gave me the wrong cipher!\n");
-		goto out_ci;
+		goto out;
 	}
 
 	ci-&gt;lock();
--- i5/include/linux/crypto.h	Mon Sep 25 16:50:54 2000
+++ i5-raidA0-raid1rb15.B2-ext0.0.3a//include/linux/crypto.h	Mon Sep 25 17:39:33 2000
@@ -20,6 +20,7 @@
 #define CIPHER_IDEA     6
 #define CIPHER_SERPENT  7
 #define CIPHER_MARS     8
+#define CIPHER_TWOFISH  9
 
 #define CIPHER_SKIPJACK 10
 #define CIPHER_RC6      11
@@ -39,6 +40,8 @@
 #define CIPHER_cbc_IDEA     (CIPHER_IDEA     | CIPHER_CBC)
 #define CIPHER_cbc_SERPENT  (CIPHER_SERPENT  | CIPHER_CBC)
 #define CIPHER_cbc_MARS     (CIPHER_MARS     | CIPHER_CBC)
+#define CIPHER_cbc_TWOFISH  (CIPHER_TWOFISH  | CIPHER_CBC)
+
 #define CIPHER_cbc_SKIPJACK (CIPHER_SKIPJACK | CIPHER_CBC)
 #define CIPHER_cbc_RC5      (CIPHER_RC5      | CIPHER_CBC)
 #define CIPHER_cbc_RC6      (CIPHER_RC6      | CIPHER_CBC)
@@ -257,6 +260,16 @@
 			    const u8 *in, u8 *out, int size);
 extern int blowfish_decrypt(struct cipher_context *cx,
                             const u8 *in, u8 *out, int size);
+
+extern int init_twofish(void);
+#define TWOFISH_KEY_SCHEDULE_SIZE ((4*256+8+32)*sizeof(u32))
+extern int twofish_set_key(struct cipher_context *cx,
+                            unsigned char *key, int key_len);
+extern int twofish_encrypt(struct cipher_context *cx,
+			    const u8 *in, u8 *out, int size);
+extern int twofish_decrypt(struct cipher_context *cx,
+                            const u8 *in, u8 *out, int size);
+
 extern int init_idea(void);
 #define IDEA_KEY_SCHEDULE_SIZE (104*2)
 extern int idea_set_key(struct cipher_context *cx, unsigned char *key, 

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20000927220244</emailId><senderName>Marc Mutz</senderName><senderEmail>marc@mutz.com</senderEmail><timestampReceived>2000-09-27 22:02:44-0400</timestampReceived><subject>[KERNLI PATCH] Configure.help update against 2.2.17.5</subject><body>

Hi Alex!

I've incorporated your suggestions. Have a look.

Marc

-- 
Marc Mutz &lt;Marc@Mutz.com&gt;        http://marc.mutz.com/Encryption-HOWTO/
University of Bielefeld, Dep. of Mathematics / Dep. of Physics

PGP-keyID's:   0xd46ce9ab (RSA), 0x7ae55b9e (DSS/DH)

["Configure.help-2.2.17.5.patch;" (text/plain)]

--- i5/Documentation/Configure.help	Mon Sep 25 16:50:54 2000
+++ i5-raidA0-raid1rb15.B2-ext0.0.3a/Documentation/Configure.help	Wed Sep 27 23:58:05 2000
@@ -287,22 +287,35 @@
 
 Crypto ciphers
 CONFIG_CIPHERS
-  A cipher is a parameter-dependant function E_K that takes a
-  fixed-length block M (usually 64 or 128 bits) and maps it onto
-  another (usually equal-sized) block E_K(M) in such a way that,
-  without knowledge of the "key" K, it is hard to compute
-
-  1. M,      if E_K(M) is given,
-
-  2. E_K(M), if M is given.
-
-  However, there always exists the inverse function D_K of E_K such
-  that D_K(E_K(M))=M for any M. M is called the 'plaintext' and E_K(M)
-  the 'ciphertext'. The ideal cipher is one where it is impossible to
-  compute M, if you have E_K(M), but not K. In this case, the easiest
-  way to break the cipher is to use 'brute-force', i.e. try all K in
-  turn until you hit the right one. With most ciphers in this library,
-  K is a 128-bit number. Here, brute-force attacks are infeasible.
+  Ciphers basically help us scramble data so that other people don't
+  get access to it. Useful applications for this include hiding hard
+  drive contents or network traffic from unauthorized eyes. Compare a
+  file encrypted with a cipher with very good safe: The document is in
+  it, you can carry the document with you (if the safe is not too
+  heavy), but others can steal it, too. However, they will not be able
+  to read the document if the safe is any good.
+
+  Mathematically speaking, a cipher is a parameter-dependant function
+  E(K, ) that takes a fixed-length block M (usually 64 or 128 bits)
+  and maps it onto another (usually equal-sized) block C=E(K,M) in such
+  a way that, without knowledge of the "key" K, it is hard to compute
+
+  1. M, if C and the function E are given,
+
+  2. C, if M is given and the function E is known.
+
+  M is called the 'plaintext' and C the 'ciphertext'. The above
+  properties are commonly described as "All the security of the cipher
+  lies in its key". However, there always exists the inverse function
+  D(K, ) of E(K, ) such that D(K,E(K,M))=M for any M.  The ideal
+  cipher is one where it is impossible to compute M if you have C, but
+  not K. In this case, the easiest way to break the cipher is to use
+  'brute-force', i.e. try all K in turn until you hit the right
+  one. With most ciphers in this library, K is a 128-bit number. Here,
+  brute-force attacks are infeasible since they require testing all
+  2^128 possible keys K, which would take far too long on any
+  conceivable computer (some big multiple of the age of the universe
+  for example).
 
   Unfortunately, the ideal cipher has not been found yet, so most
   ciphers in this library, or certain 'reduced-round' versions

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20000927172014</emailId><senderName>Marc Mutz</senderName><senderEmail>marc@mutz.com</senderEmail><timestampReceived>2000-09-27 17:20:14-0400</timestampReceived><subject>[KERNELI-PATCH] Twofish for the cipherapi.</subject><body>

Hi Alex!

As you know, I've ported the Twofish implementation of GnuPG
(http://www.gnupg.org) to the cipherapi of the kerneli patch
(http://www.kerneli.org/). You need to patch include/linux/crypto.h and
util-linux to use a cipher id you like. I don't want to mess around with
the loop_fish2.c driver. If you find this implementation worth of being
able to replace the other twofish, then it can take its number. 192 bits
mode is not working for this twofish.c, but not hard to obtain.

This patch assumes my changes to loop_gen.c, so no need to patch that
file. Please consider applying:

It works for me:

prompt$ ./speed | grep fish
Registered twofish (9)
Registered twofish-cbc (65545)
Registered blowfish (4)
Registered blowfish-cbc (65540)
Testing cipher blowfish, number 4..seems to work
encrypt blowfish        =    97908 usec/MB; 10.214 MB/s; 81.709 Mb/s
decrypt blowfish        =    78719 usec/MB; 12.703 MB/s; 101.627 Mb/s
encrypt blowfish-cbc    =    67178 usec/MB; 14.886 MB/s; 119.087 Mb/s
decrypt blowfish-cbc    =    87712 usec/MB; 11.401 MB/s; 91.208 Mb/s
Testing cipher twofish, number 9..seems to work
encrypt twofish         =   137124 usec/MB;  7.293 MB/s; 58.341 Mb/s
decrypt twofish         =   127834 usec/MB;  7.823 MB/s; 62.581 Mb/s
encrypt twofish-cbc     =   111974 usec/MB;  8.931 MB/s; 71.445 Mb/s
decrypt twofish-cbc     =   114556 usec/MB;  8.729 MB/s; 69.835 Mb/s

prompt$ ./aes-test twofish ecb_tbl_sans_192.txt | grep -v OK
prompt$

aes-test is a small bash script I wrote on top of testcip. It should go
into crypto/testing. ecb_tbl.txt is contained for each of the fifteen
AES candiadates in their respective known-answer test tables, available
from the NIST-AES homepage www.nist.gov/aes.

-- 
Marc Mutz &lt;Marc@Mutz.com&gt;        http://marc.mutz.com/Encryption-HOWTO/
University of Bielefeld, Dep. of Mathematics / Dep. of Physics

PGP-keyID's:   0xd46ce9ab (RSA), 0x7ae55b9e (DSS/DH)

["twofish+aes_test.patch.bz2" (application/octet-stream)]
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20000927101809</emailId><senderName>Peter van Hove</senderName><senderEmail>peter.van.hove@mind.be</senderEmail><timestampReceived>2000-09-27 10:18:09-0400</timestampReceived><subject>Hardware crypto</subject><body>

Reply-To: 
Hello all,

i was wndering if there already is support for crypto cards in the kernel and if so
can they be used to accelerate IPsec encryption.

Peter Van Hove
Unix &amp; Opensource consultant
Mind NV
http://mind.be

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20000927203709</emailId><senderName>"Maicon Triches"</senderName><senderEmail>maicon@sul-e.com.br</senderEmail><timestampReceived>2000-09-27 20:37:09-0400</timestampReceived><subject>lista</subject><body>

Pedido de inscrição na lista...

Maicon L. Triches
maicon@sul-e.com.br
Sule Eletrodomésticos
Informártica - Suporte 

[Attachment #3 (text/html)]

&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"&gt;
&lt;HTML&gt;&lt;HEAD&gt;
&lt;META http-equiv=Content-Type content="text/html; charset=iso-8859-1"&gt;
&lt;META content="MSHTML 5.50.4134.600" name=GENERATOR&gt;
&lt;STYLE&gt;&lt;/STYLE&gt;
&lt;/HEAD&gt;
&lt;BODY bgColor=#ffffff&gt;
&lt;DIV&gt;&lt;FONT face=Arial size=2&gt;Pedido de inscrição na lista...&lt;/FONT&gt;&lt;/DIV&gt;
&lt;DIV&gt;&lt;FONT face=Arial size=2&gt;&lt;BR&gt;Maicon L. Triches&lt;BR&gt;&lt;A 
href="mailto:maicon@sul-e.com.br"&gt;maicon@sul-e.com.br&lt;/A&gt;&lt;BR&gt;Sule 
Eletrodomésticos&lt;BR&gt;Informártica - Suporte &lt;/FONT&gt;&lt;/DIV&gt;&lt;/BODY&gt;&lt;/HTML&gt;

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20000929201043</emailId><senderName>Gisle S{lensminde</senderName><senderEmail>gisle@ii.uib.no</senderEmail><timestampReceived>2000-09-29 20:10:43-0400</timestampReceived><subject>AES will be announced monday.</subject><body>


See: http://csrc.nist.gov/encryption/aes/

TIME:  11:00 a.m. Eastern Daylight Time.

etc.

--
Gisle Sælensminde ( gisle@ii.uib.no )   

With sufficient thrust, pigs fly just fine. However, this is not
necessarily a good idea. It is hard to be sure where they are going
to land, and it could be dangerous sitting under them as they fly
overhead. (from RFC 1925)


Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001002152313</emailId><senderName>Marc Mutz</senderName><senderEmail>marc@mutz.com</senderEmail><timestampReceived>2000-10-02 15:23:13-0400</timestampReceived><subject>[Fwd: AES for GnuPG, on Mon Oct 2?]</subject><body>

Alex, it might be that we lose:

"Michael H. Warfield" wrote on gnupg-devel:
&gt; 
&lt;snip&gt;
&gt;         Serpent apparently is subject to a claim by Hitachi that it holds
&gt; a patent over some aspect of it.  Rumor has it that it's out of the race.
&gt; That's based on a coderpunks posting which I have not been able to
&gt; independently verify.
&gt; 
&lt;snip&gt;

Marc

-- 
Marc Mutz &lt;Marc@Mutz.com&gt;        http://marc.mutz.com/Encryption-HOWTO/
University of Bielefeld, Dep. of Mathematics / Dep. of Physics

PGP-keyID's:   0xd46ce9ab (RSA), 0x7ae55b9e (DSS/DH)


Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001113102223</emailId><senderName>Marc Mutz</senderName><senderEmail>marc@mutz.com</senderEmail><timestampReceived>2000-11-13 10:22:23-0400</timestampReceived><subject>Concerning AES and -p option support in util-linux.patch</subject><body>

Hi Alex!

There are currently many mails reaching me that claim that AES is not
supported and that there is no -p option in losetup, like I said in the
howto. The latter stems from the fact that aeb has not included the
correspondig patch I sent to him. A reason he did not give to me. The
former is just a slip in the util-linux.patch: The obvious line for AES
is missing from the list of known ciphers in lomount.c.

I think, it would be a good idea to add that line and make a 17.11, even
if that remains the only change.
If you like, you can include the patch I sent to you some time ago that
adds support for a -p option to losetup (for reading the passphrase from
a given file descriptor). You then said that this does not belong to the
realm of the international util-linux patch, but I think aeb waits for
that patch to be submitted for inclusion in the mainstream util-linux,
or so I understood him, though he didn't say it openly. So we may as
well collect the changes to util-linux in the patch and then submit it
together to aeb.

I don't think we should do that at this point, because we would still
need to release a patch along with any changes (e.g. addition of a new
cipher) to the ioctls. It would be best if we'd make losetup/mount
completely independent of the details of the cryptoapi, e.g. using the
information from the /proc files to determine available ciphers and
their key parameters.

Marc

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001201161022</emailId><senderName>Thilo Mezger</senderName><senderEmail>news-innominate.list.linux.crypto@innominate.de</senderEmail><timestampReceived>2000-12-01 16:10:22-0400</timestampReceived><subject>What patch for Red Hat Linux 7?</subject><body>

hi,

has anybody tried to patch the kernel that red hat ships with
rhl-7.0?  that should be a 2.2.16 with lotsa patches or 2.2.17-pre-X
with lots of patches...

Can someone recommend me an international kernel patch that works
very well with this kernel?  Just asking before trying all of these
patches myself...

Some of the patches Red Hat integrated are quite useful and I wouldn't
want to miss them and use a stock 2.2.17 kernel...

Thilo


-- 
thilo.mezger@innominate.com
e-business manager                                      innominate AG
                                                 the linux architects
tel: +49-30-308806-0    fax: -77                   www.innominate.com 

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001201181643</emailId><senderName>Marc Mutz</senderName><senderEmail>marc@mutz.com</senderEmail><timestampReceived>2000-12-01 18:16:43-0400</timestampReceived><subject>Re: What patch for Red Hat Linux 7?</subject><body>

Thilo Mezger wrote:
&gt; 
&lt;snip&gt;
&gt; has anybody tried to patch the kernel that red hat ships with
&gt; rhl-7.0?  that should be a 2.2.16 with lotsa patches or 2.2.17-pre-X
&gt; with lots of patches...
&gt; 
&gt; Can someone recommend me an international kernel patch that works
&gt; very well with this kernel?  Just asking before trying all of these
&gt; patches myself...
&gt; 
&lt;snip&gt;

Haven't you tired patching? I'd bet that the patch applies w/o rejects.
That's because it is pretty self-contained. Yet red hat kernels are
known to sometimes introduce e.g. new parameters to central functions in
the kernel and that may make adopting the patch highly difficult. But
you need not worry until the patch fails with non-trivial rejects. Just
try the latest one (i.e. 2.2.17.10).

Marc

-- 
Marc Mutz &lt;Marc@Mutz.com&gt;     http://EncryptionHOWTO.sourceforge.net/
University of Bielefeld, Dep. of Mathematics / Dep. of Physics

PGP-keyID's:   0xd46ce9ab (RSA), 0x7ae55b9e (DSS/DH)


Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001204104956</emailId><senderName>Thilo Mezger</senderName><senderEmail>news-innominate.list.linux.crypto@innominate.de</senderEmail><timestampReceived>2000-12-04 10:49:56-0400</timestampReceived><subject>Re: What patch for Red Hat Linux 7?</subject><body>

Marc Mutz &lt;Marc@mutz.com&gt; wrote:

&gt; Haven't you tired patching? I'd bet that the patch applies w/o rejects.

I wouldn't dare to post here without having tried patching before... ;-)


&gt; That's because it is pretty self-contained. Yet red hat kernels are
&gt; known to sometimes introduce e.g. new parameters to central functions in
&gt; the kernel and that may make adopting the patch highly difficult. But
&gt; you need not worry until the patch fails with non-trivial rejects. Just
&gt; try the latest one (i.e. 2.2.17.10).

I tried 2.2.17.10 against Red Hat's 2.2.16-22 Kernel and it fails
in loop.c:

4 out of 9 hunks FAILED -- saving rejects to file drivers/block/loop.c.rej

I did not have the time to check what exactly goes wrong here but I'll
try as soon as time permits...

Still, if somebody has run into that same problem as well, please let
me know.

Thilo


-- 
thilo.mezger@innominate.com
e-business manager                                      innominate AG
                                                 the linux architects
tel: +49-30-308806-0    fax: -77                   www.innominate.com 

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001002162229</emailId><senderName>"Ian S. Nelson"</senderName><senderEmail>ian.nelson@echostar.com</senderEmail><timestampReceived>2000-10-02 16:22:29-0400</timestampReceived><subject>Re: [Fwd: AES for GnuPG, on Mon Oct 2?]</subject><body>

Wasn't DES covered by a patent?  I know Lucifer was and DES is closely
related.   Patent or no patent, AES should be fairly liberal in terms of usage
restrictions.  I don't remember the rules but I thought that there was some
provision for patents.

Anyone know who won yet?  The NIST webcast page doesn't work.


Marc Mutz wrote:

&gt; Alex, it might be that we lose:
&gt;
&gt; "Michael H. Warfield" wrote on gnupg-devel:
&gt; &gt;
&gt; &lt;snip&gt;
&gt; &gt;         Serpent apparently is subject to a claim by Hitachi that it holds
&gt; &gt; a patent over some aspect of it.  Rumor has it that it's out of the race.
&gt; &gt; That's based on a coderpunks posting which I have not been able to
&gt; &gt; independently verify.
&gt; &gt;
&gt; &lt;snip&gt;
&gt;
&gt; Marc
&gt;


Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001002162642</emailId><senderName>Matthew Mundy</senderName><senderEmail>mmundy1@gl.umbc.edu</senderEmail><timestampReceived>2000-10-02 16:26:42-0400</timestampReceived><subject>Re: [Fwd: AES for GnuPG, on Mon Oct 2?]</subject><body>

According to sci.crypt it's rijndael.
---Matt

On Mon, 2 Oct 2000, Ian S. Nelson wrote:

&gt; Wasn't DES covered by a patent?  I know Lucifer was and DES is closely
&gt; related.   Patent or no patent, AES should be fairly liberal in terms of usage
&gt; restrictions.  I don't remember the rules but I thought that there was some
&gt; provision for patents.
&gt; 
&gt; Anyone know who won yet?  The NIST webcast page doesn't work.
&gt; 
&gt; 
&gt; Marc Mutz wrote:
&gt; 
&gt; &gt; Alex, it might be that we lose:
&gt; &gt;
&gt; &gt; "Michael H. Warfield" wrote on gnupg-devel:
&gt; &gt; &gt;
&gt; &gt; &lt;snip&gt;
&gt; &gt; &gt;         Serpent apparently is subject to a claim by Hitachi that it holds
&gt; &gt; &gt; a patent over some aspect of it.  Rumor has it that it's out of the race.
&gt; &gt; &gt; That's based on a coderpunks posting which I have not been able to
&gt; &gt; &gt; independently verify.
&gt; &gt; &gt;
&gt; &gt; &lt;snip&gt;
&gt; &gt;
&gt; &gt; Marc
&gt; &gt;
&gt; 
&gt; 
&gt; Linux-crypto:  cryptography in and on the Linux system
&gt; Archive:       http://mail.nl.linux.org/linux-crypto/
&gt; 


Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001002162649</emailId><senderName>Richard Guy Briggs</senderName><senderEmail>rgb@conscoop.ottawa.on.ca</senderEmail><timestampReceived>2000-10-02 16:26:49-0400</timestampReceived><subject>Re: [Fwd: AES for GnuPG, on Mon Oct 2?]</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----

On Mon, Oct 02, 2000 at 10:22:29AM -0600, Ian S. Nelson wrote:
&gt; Wasn't DES covered by a patent?  I know Lucifer was and DES is closely
&gt; related.   Patent or no patent, AES should be fairly liberal in terms of usage
&gt; restrictions.  I don't remember the rules but I thought that there was some
&gt; provision for patents.

The AES rules stipulated that it must be unencumbered by patents if it
won and that entries that were patent encumbered before hand would be
looked upon less favourably.

&gt; Anyone know who won yet?  The NIST webcast page doesn't work.

Rijndael.

&gt; Marc Mutz wrote:
&gt; 
&gt; &gt; Alex, it might be that we lose:
&gt; &gt;
&gt; &gt; "Michael H. Warfield" wrote on gnupg-devel:
&gt; &gt; &gt;
&gt; &gt; &lt;snip&gt;
&gt; &gt; &gt;         Serpent apparently is subject to a claim by Hitachi that it holds
&gt; &gt; &gt; a patent over some aspect of it.  Rumor has it that it's out of the race.
&gt; &gt; &gt; That's based on a coderpunks posting which I have not been able to
&gt; &gt; &gt; independently verify.
&gt; &gt;
&gt; &gt; &lt;snip&gt;
&gt; &gt;
&gt; &gt; Marc

	slainte mhath, RGB
- -- 
Richard Guy Briggs -- PGP key available            Auto-Free Ottawa! Canada
&lt;www.conscoop.ottawa.on.ca/rgb/&gt;                       &lt;www.flora.org/afo/&gt;
Prevent Internet Wiretapping!        --        FreeS/WAN:&lt;www.freeswan.org&gt;
Thanks for voting Green! -- &lt;green.ca&gt;      Marillion:&lt;www.marillion.co.uk&gt;

-----BEGIN PGP SIGNATURE-----
Version: 2.6.3i
Charset: noconv

iQCVAwUBOdi3R9+sBuIhFagtAQGWggP/fwGm+9i7bsp9y+7DxOt3P/5Du601LWyT
FR7IEA7XefayidWr9eNUASzBK6dJIj7cNG8hDjExbRJKiyD4DrkBmgcZsNnNxJNI
pcs1IlmxkT1mri+N6MA0qnjxI1tpKlCigNd1h2ubskOk9xSPMhIhk4XavzBrLFjq
ThUeEdikY/Y=
=8hlS
-----END PGP SIGNATURE-----

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20000929215201</emailId><senderName>Marc Mutz</senderName><senderEmail>marc@mutz.com</senderEmail><timestampReceived>2000-09-29 21:52:01-0400</timestampReceived><subject>Re: AES will be announced monday.</subject><body>

Gisle S{lensminde wrote:
&gt; 
&gt; See: http://csrc.nist.gov/encryption/aes/
&gt; 
&gt; TIME:  11:00 a.m. Eastern Daylight Time.
&gt; 
&lt;snip&gt;

Anyone wants to bet? I'd say one of Twofish, Serpent, Rijndael. To be
precise, I'd say Serpent. Because it is fastest in HW and the most
secure. Software performance was never really high on NISTs list (see
DES). Twofish, while equally secure as Serpent is very complicated and
Rijndael can only be elected if the number of rounds is increased, which
implies a relative performance loss w.r.t. the other two.

RC6, though fast and simple, is patented and I don't like that so I
don't want that. MARS is inefficient everywhere and hasn't got a single
outstanding advantage over the others.

Sssssssserpent.

Marc

-- 
Marc Mutz &lt;Marc@Mutz.com&gt;        http://marc.mutz.com/Encryption-HOWTO/
University of Bielefeld, Dep. of Mathematics / Dep. of Physics

PGP-keyID's:   0xd46ce9ab (RSA), 0x7ae55b9e (DSS/DH)


Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20000929221443</emailId><senderName>"Bill Rugolsky Jr."</senderName><senderEmail>rugolsky@ead.dsa.com</senderEmail><timestampReceived>2000-09-29 22:14:43-0400</timestampReceived><subject>Re: AES will be announced monday.</subject><body>

On Fri, Sep 29, 2000 at 09:52:01PM +0000, Marc Mutz wrote:
&gt; Anyone wants to bet? I'd say one of Twofish, Serpent, Rijndael. To be
&gt; precise, I'd say Serpent. Because it is fastest in HW and the most
&gt; secure. Software performance was never really high on NISTs list (see
&gt; DES). Twofish, while equally secure as Serpent is very complicated and
&gt; Rijndael can only be elected if the number of rounds is increased, which
&gt; implies a relative performance loss w.r.t. the other two.

While specialized hardware may be important, CPU/memory speeds may
favor software implementations that allow one to flexibly and simultaneously
do compression, encryption, checksumming, etc. with minimal data touching.

Look at network stacks; it is not always a win to do the protocol processing
(like checksumming) in hardware; if one has to copy the data once, many
microprocessors have spare cycles to burn to transform the data.  Separating the
tranformations can result in increased latency.

I'd like to see Twofish win (go Bruce!), but we'll just have to wait and see.

Regards,

  Bill Rugolsky
  rugolsky@ead.dsa.com

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20000927212850</emailId><senderName>Marc Mutz</senderName><senderEmail>marc@mutz.com</senderEmail><timestampReceived>2000-09-27 21:28:50-0400</timestampReceived><subject>Re: lista</subject><body>

Maicon Triches wrote:
&gt; 
&gt;    Part 1.1    Type: Plain Text (text/plain)
&gt;            Encoding: quoted-printable

Please don't send MIME multipart messages when not attaching something.
I use netscape messenger and it only shows an attachment with your
message. I will skip such messages in the future. Sorry.

Yes, iknow that it is possibly netscapes fault, but sending multipart
messages when plain test would suffice is abuse of MIME. IMO. YMMV.

Marc

-- 
Marc Mutz &lt;Marc@Mutz.com&gt;        http://marc.mutz.com/Encryption-HOWTO/
University of Bielefeld, Dep. of Mathematics / Dep. of Physics

PGP-keyID's:   0xd46ce9ab (RSA), 0x7ae55b9e (DSS/DH)


Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20000927220533</emailId><senderName>David Ford</senderName><senderEmail>david@kalifornia.com</senderEmail><timestampReceived>2000-09-27 22:05:33-0400</timestampReceived><subject>Re: lista</subject><body>

Netscape sent it multipart because he chose both text and html for the
message.  The message was sent as both text and html.  This allows for the
reader to choose plain or 'enriched' viewing.  This is having it both
ways.  People who gripe about enriched content can read the plain text.
People who want the markup can view it as well.

It's a configuration choice issue.  What you viewed was his entire
message, regardless of whether your reader displayed it in text or html.
I also use NS messenger as one of my preferred readers and I'm able to
view his message perfectly.

-d

Marc Mutz wrote:

&gt; &gt;    Part 1.1    Type: Plain Text (text/plain)
&gt; &gt;            Encoding: quoted-printable
&gt;
&gt; Please don't send MIME multipart messages when not attaching something.
&gt; I use netscape messenger and it only shows an attachment with your
&gt; message. I will skip such messages in the future. Sorry.
&gt;
&gt; Yes, iknow that it is possibly netscapes fault, but sending multipart
&gt; messages when plain test would suffice is abuse of MIME. IMO. YMMV.

--
      "There is a natural aristocracy among men. The grounds of this are
      virtue and talents", Thomas Jefferson [1742-1826], 3rd US President



["david.vcf" (text/x-vcard)]
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20000927225301</emailId><senderName>Richard Guy Briggs</senderName><senderEmail>rgb@conscoop.ottawa.on.ca</senderEmail><timestampReceived>2000-09-27 22:53:01-0400</timestampReceived><subject>Re: lista</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----

On Wed, Sep 27, 2000 at 03:05:33PM -0700, David Ford wrote:
&gt; Netscape sent it multipart because he chose both text and html for the
&gt; message.  The message was sent as both text and html.  This allows for the
&gt; reader to choose plain or 'enriched' viewing.  This is having it both
&gt; ways.  People who gripe about enriched content can read the plain text.
&gt; People who want the markup can view it as well.

It also uses a lot more bandwidth.  It is unnecessary.  Please kill it.

&gt; -d

	slainte mhath, RGB
- -- 
Richard Guy Briggs -- PGP key available            Auto-Free Ottawa! Canada
&lt;www.conscoop.ottawa.on.ca/rgb/&gt;                       &lt;www.flora.org/afo/&gt;
Prevent Internet Wiretapping!        --        FreeS/WAN:&lt;www.freeswan.org&gt;
Thanks for voting Green! -- &lt;green.ca&gt;      Marillion:&lt;www.marillion.co.uk&gt;

-----BEGIN PGP SIGNATURE-----
Version: 2.6.3i
Charset: noconv

iQCVAwUBOdJ6St+sBuIhFagtAQHw9AQAr934PrJfsOxrPCh7Jw7yoEF+VmFAOvzA
oJY0VBaLZpPQiBatjD6C9ctg0xT0XGF0F6AL+uqcaIvzKn10fWHZ3pLiLOZ4nCO7
+mPWd6SLdNCNBM+KQ2fBFsCudc3gqO0K22zvhQxVxpG6flix14V/DyblUF/W6QXQ
kLGeCHEXb7A=
=DWdA
-----END PGP SIGNATURE-----

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20000927110456</emailId><senderName>Alexander S A Kjeldaas</senderName><senderEmail>alexander.kjeldaas@fast.no</senderEmail><timestampReceived>2000-09-27 11:04:56-0400</timestampReceived><subject>Re: Hardware crypto</subject><body>

On Wed, Sep 27, 2000 at 12:18:09PM +0200, Peter van Hove wrote:
&gt; Hello all,
&gt; 
&gt; i was wndering if there already is support for crypto cards in the
&gt; kernel and if so can they be used to accelerate IPsec encryption.

There is a product from Redcreek with linux drivers. I have not tried
it.

http://www.redcreek.com/products/ipsec_card.html

astor

-- 
Alexander Kjeldaas                Mail:  astor@fast.no
finger astor@master.kernel.org for OpenPGP key.

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20000927133831</emailId><senderName>Marc Mutz</senderName><senderEmail>marc@mutz.com</senderEmail><timestampReceived>2000-09-27 13:38:31-0400</timestampReceived><subject>Re: Hardware crypto</subject><body>

Peter van Hove wrote:
&gt; 
&lt;snip&gt;
&gt; i was wndering if there already is support for crypto cards in the kernel and if so
&gt; can they be used to accelerate IPsec encryption.
&gt; 

Lee Cremeans &lt;leec@gtgi.com&gt; is working on a driver for a crypto card
for Linux. He posted an unrelated question on lkml, but has not said
anything more about it. If it is there, I'll try and make this work for
the cryptoapi (kerneli patch). But so far, both frees/wan and (this is a
guess) the nist implementation of ipsec for linux do not use the crypto
api. The redcreek thing might be the better way for now.

Marc

-- 
Marc Mutz &lt;Marc@Mutz.com&gt;        http://marc.mutz.com/Encryption-HOWTO/
University of Bielefeld, Dep. of Mathematics / Dep. of Physics

PGP-keyID's:   0xd46ce9ab (RSA), 0x7ae55b9e (DSS/DH)


Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20000927142522</emailId><senderName>Richard Guy Briggs</senderName><senderEmail>rgb@conscoop.ottawa.on.ca</senderEmail><timestampReceived>2000-09-27 14:25:22-0400</timestampReceived><subject>Re: Hardware crypto</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----

On Wed, Sep 27, 2000 at 01:38:31PM +0000, Marc Mutz wrote:
&gt; Peter van Hove wrote:
&gt; &gt; 
&gt; &lt;snip&gt;
&gt; &gt; i was wndering if there already is support for crypto cards in the
&gt; &gt; kernel and if so can they be used to accelerate IPsec encryption.
&gt; &gt; 
&gt; 
&gt; Lee Cremeans &lt;leec@gtgi.com&gt; is working on a driver for a crypto card
&gt; for Linux. He posted an unrelated question on lkml, but has not said
&gt; anything more about it. If it is there, I'll try and make this work for
&gt; the cryptoapi (kerneli patch). But so far, both frees/wan and (this is a
&gt; guess) the nist implementation of ipsec for linux do not use the crypto
&gt; api. The redcreek thing might be the better way for now.

We (FreeS/WAN) are not directly working on hardware crypto support,
but are certainly willing to morally support its development and
include well-formed unencumbered code to do so.  Bart Trojanovsky
(sp?) of Chrysalis-ITS here in Ottawa is working on linux drivers for
their hardware crypto accellerator and on integrating them into
FreeS/WAN.  We were hoping that libgcrypt from the GnuPG project could
be used for this, having options to compile it as a userspace or
kernelspace lib.  I doubt we would need and strongly hope we would not
need gmp in the kernel portions since libgcrypt would abstract all
this away so we don't care what is doing encryption/decryption.  It
would also be not only SMP-safe, but able to take advantage of
parallelism by queueing jobs.

I really need to take a serious look at the kerneli patch and see what
we can do to co-operate...

&gt; Marc Mutz &lt;Marc@Mutz.com&gt;        http://marc.mutz.com/Encryption-HOWTO/

	slainte mhath, RGB
- -- 
Richard Guy Briggs -- PGP key available            Auto-Free Ottawa! Canada
&lt;www.conscoop.ottawa.on.ca/rgb/&gt;                       &lt;www.flora.org/afo/&gt;
Prevent Internet Wiretapping!        --        FreeS/WAN:&lt;www.freeswan.org&gt;
Thanks for voting Green! -- &lt;green.ca&gt;      Marillion:&lt;www.marillion.co.uk&gt;

-----BEGIN PGP SIGNATURE-----
Version: 2.6.3i
Charset: noconv

iQCVAwUBOdIDT9+sBuIhFagtAQGz6AP+OasY+eeu3F2FveHIA37Lvrk5v3SHyCry
diHiSUBZLc6bIA6v7cZ4PHC2hXXY5UhsP4VI/UWIWM7biNGXm2qDi0NSXog3/SfZ
X6u7RrxsB0KFAqpUI4iRw0ZmnXGZK+3LMeQ/5E7BlfWeoVPdTkbDFVLViH+WSSCT
vlsG3zpwqJo=
=4PcW
-----END PGP SIGNATURE-----

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20000927155204</emailId><senderName>Alexander S A Kjeldaas</senderName><senderEmail>alexander.kjeldaas@fast.no</senderEmail><timestampReceived>2000-09-27 15:52:04-0400</timestampReceived><subject>Re: Hardware crypto</subject><body>

On Wed, Sep 27, 2000 at 01:38:31PM +0000, Marc Mutz wrote:
&gt; Peter van Hove wrote:
&gt; &gt; 
&gt; &lt;snip&gt;
&gt; &gt; i was wndering if there already is support for crypto cards in the kernel and if so
&gt; &gt; can they be used to accelerate IPsec encryption.
&gt; &gt; 
&gt; 
&gt; Lee Cremeans &lt;leec@gtgi.com&gt; is working on a driver for a crypto card
&gt; for Linux. He posted an unrelated question on lkml, but has not said
&gt; anything more about it. If it is there, I'll try and make this work for
&gt; the cryptoapi (kerneli patch). But so far, both frees/wan and (this is a
&gt; guess) the nist implementation of ipsec for linux do not use the crypto
&gt; api. The redcreek thing might be the better way for now.
&gt; 

I think there are some interesting issues to be solved when we want to
get hardware crypto cards running under Linux.  For one, we want to
have a queue of processing requests for the device instead of having a
synchronous interface like most crypto libraries offer.  We also
probably want to use the CPU if the queue starts to have too many
entries, or load-balance between several cards, so we need a
"crypto-provider" concept.  Also, for programmable crypto-cards we
might want to consider the cost of switching ciphers on the card when
choosing which requests should be done by which cards/CPU.  This will
be interesting to look at when the first drivers emerge.

astor

-- 
Alexander Kjeldaas                Mail:  astor@fast.no
finger astor@master.kernel.org for OpenPGP key.

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20000927161030</emailId><senderName>"Michael T. Babcock"</senderName><senderEmail>mbabcock@fibrespeed.net</senderEmail><timestampReceived>2000-09-27 16:10:30-0400</timestampReceived><subject>Re: Hardware crypto</subject><body>

&gt; On Wed, Sep 27, 2000 at 01:38:31PM +0000, Marc Mutz wrote:
&gt; I think there are some interesting issues to be solved when we want to
&gt; get hardware crypto cards running under Linux.  For one, we want to
&gt; have a queue of processing requests for the device instead of having a
&gt; synchronous interface like most crypto libraries offer.  We also
&gt; probably want to use the CPU if the queue starts to have too many
&gt; entries, or load-balance between several cards, so we need a
&gt; "crypto-provider" concept.  Also, for programmable crypto-cards we
&gt; might want to consider the cost of switching ciphers on the card when
&gt; choosing which requests should be done by which cards/CPU.  This will
&gt; be interesting to look at when the first drivers emerge.

A queuing concept is definately needed if this is to be done right the first
time (so to speak).  The configuration of this interface, however, would be
the interesting challenge here.  How to present to the user (the sysadmin,
most likely) the options for dealing with crypto on a per-system, perhaps
per-app basis.  Prioritising certain applications over others, perhaps,
would end up being an issue as well.

For example:
OpenSSL uses the "crypto accel api" for web serving.
FreeS/WAN uses it for VPN traffic.
GPG uses it to encrypt E-mails or generate signatures.

I would probably set the FreeS/WAN requests to have a slightly lower
priority than the OpenSSL requests because we host E-commerce sites ... and
the GPG traffic would be lowest, but I wouldn't want it to get swamped out
of the picture if the crypto card were at full use.  Having it send a
suitable? number of requests to the software crypto system would be
necessary as well.

It becomes quite interestingly complex ;-).



Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20000927161624</emailId><senderName>Neil Dunbar</senderName><senderEmail>nd@hplb.hpl.hp.com</senderEmail><timestampReceived>2000-09-27 16:16:24-0400</timestampReceived><subject>Re: Hardware crypto</subject><body>

Alexander S A Kjeldaas wrote:
&gt; 
&gt; I think there are some interesting issues to be solved when we want to
&gt; get hardware crypto cards running under Linux.  For one, we want to
&gt; have a queue of processing requests for the device instead of having a
&gt; synchronous interface like most crypto libraries offer.  We also
&gt; probably want to use the CPU if the queue starts to have too many
&gt; entries, or load-balance between several cards, so we need a
&gt; "crypto-provider" concept.

So you need an abstraction interface. If we're talking
kernel here (ie for IPsec/filesystem crypto/stego), then
all we should need is an abstraction over symmetric key
operations - IKE is done in userspace, after all. I suppose
that it would be possible to leave the slot open for
message digests as well, although I haven't seen a card
which accelerates MD5/SHA-1, or HMAC over them.

The only plea that I would make is to not make it too
fancy - otherwise we end up with CDSA and other such
monsters.

Neil
["nd.vcf" (text/x-vcard)]
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20000927161717</emailId><senderName>Richard Guy Briggs</senderName><senderEmail>rgb@conscoop.ottawa.on.ca</senderEmail><timestampReceived>2000-09-27 16:17:17-0400</timestampReceived><subject>Re: Hardware crypto</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----

On Wed, Sep 27, 2000 at 05:52:04PM +0200, Alexander S A Kjeldaas wrote:
&gt; On Wed, Sep 27, 2000 at 01:38:31PM +0000, Marc Mutz wrote:
&gt; &gt; Peter van Hove wrote:
&gt; &gt; &gt; 
&gt; &gt; &lt;snip&gt;
&gt; &gt; &gt; i was wndering if there already is support for crypto cards in the kernel and if so
&gt; &gt; &gt; can they be used to accelerate IPsec encryption.
&gt; &gt; &gt; 
&gt; &gt; 
&gt; &gt; Lee Cremeans &lt;leec@gtgi.com&gt; is working on a driver for a crypto card
&gt; &gt; for Linux. He posted an unrelated question on lkml, but has not said
&gt; &gt; anything more about it. If it is there, I'll try and make this work for
&gt; &gt; the cryptoapi (kerneli patch). But so far, both frees/wan and (this is a
&gt; &gt; guess) the nist implementation of ipsec for linux do not use the crypto
&gt; &gt; api. The redcreek thing might be the better way for now.
&gt; 
&gt; I think there are some interesting issues to be solved when we want to
&gt; get hardware crypto cards running under Linux.  For one, we want to
&gt; have a queue of processing requests for the device instead of having a
&gt; synchronous interface like most crypto libraries offer.  We also
&gt; probably want to use the CPU if the queue starts to have too many
&gt; entries, or load-balance between several cards, so we need a
&gt; "crypto-provider" concept.  Also, for programmable crypto-cards we
&gt; might want to consider the cost of switching ciphers on the card when
&gt; choosing which requests should be done by which cards/CPU.  This will
&gt; be interesting to look at when the first drivers emerge.

I completely agree that it should be queue-based.  SMP is the other
obvious reason for a queue.

Alan Cox has publicly stated that he thinks this is the right way to
do things, but at the moment, asynchrony and queues for this type of
processing will be a big challenge to accomplish this in the present
Linux kernels.  This is something that needs to get Linus' ear when
planning for 2.5.

&gt; astor
&gt; 
&gt; -- 
&gt; Alexander Kjeldaas                Mail:  astor@fast.no
&gt; finger astor@master.kernel.org for OpenPGP key.
&gt; 
&gt; Linux-crypto:  cryptography in and on the Linux system
&gt; Archive:       http://mail.nl.linux.org/linux-crypto/

	slainte mhath, RGB
- -- 
Richard Guy Briggs -- PGP key available            Auto-Free Ottawa! Canada
&lt;www.conscoop.ottawa.on.ca/rgb/&gt;                       &lt;www.flora.org/afo/&gt;
Prevent Internet Wiretapping!        --        FreeS/WAN:&lt;www.freeswan.org&gt;
Thanks for voting Green! -- &lt;green.ca&gt;      Marillion:&lt;www.marillion.co.uk&gt;

-----BEGIN PGP SIGNATURE-----
Version: 2.6.3i
Charset: noconv

iQCVAwUBOdIdh9+sBuIhFagtAQEmnAP/R3edd683P1+XsiHEZOMJ2kRDwDdsQE9J
HvD6pD1KbdG80Lcy0vogGJezXKGJY74wd1RB5Uq0iGsBRTofOamqN1tMOpqR6FZ1
2UM1Gk6AtIr42MyGp9wnL/q0DPmMwLEv1T+Mzn/8C6Tliqx3L5Fw/uJA4g5Dm2o9
Z56K4bY+2jw=
=Jfbh
-----END PGP SIGNATURE-----

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20000927161847</emailId><senderName>Sandy Harris</senderName><senderEmail>sandy@storm.ca</senderEmail><timestampReceived>2000-09-27 16:18:47-0400</timestampReceived><subject>Re: Hardware crypto</subject><body>

Peter van Hove wrote:

&gt; i was wndering if there already is support for crypto cards in the kernel and if so
&gt; can they be used to accelerate IPsec encryption.

This question has come up a number of times on FreeS/WAN's linux-ipsec@clinet.fi
list, including being asked by several hardware vendors. So far the answer has
been that FreeS/WAN wasn't designed for that, but the kernel parts are in the
process of re-design for other reasons and we'll try to provide a clean interface
to hardware in the new design. It is not one of the top considerations, though.

Meanwhile, someone at chip/board vendor Chrysalis (www.chrysalis-its.com)
is working on kernel patches to support their stuff, with the co-operation of the
FreeS/WAN kernel hacker. The intention is to define an interface generic enough
that other hardware could use it as well.

For details, search that list's archive:

http://www.sandelman.ottawa.on.ca/linux-ipsec/

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20000927162415</emailId><senderName>"Michael T. Babcock"</senderName><senderEmail>mbabcock@fibrespeed.net</senderEmail><timestampReceived>2000-09-27 16:24:15-0400</timestampReceived><subject>Re: Hardware crypto</subject><body>

&gt; Alexander S A Kjeldaas wrote:
&gt;
&gt; So you need an abstraction interface. If we're talking
&gt; kernel here (ie for IPsec/filesystem crypto/stego), then
&gt; all we should need is an abstraction over symmetric key
&gt; operations - IKE is done in userspace, after all. I suppose
&gt; that it would be possible to leave the slot open for
&gt; message digests as well, although I haven't seen a card
&gt; which accelerates MD5/SHA-1, or HMAC over them.

I would be tempted to do (some of) what another company did (what's their
name ... Microsoft?) when they implemented an acceleration layer for video /
sound, etc.  That is, add hooks for things that aren't necessarily
accelerated everywhere, but might be, and then report back to the caller
whether those things are or are not accelerated (like a CPU-ID).

Session = CryptoAccel_Init();
if (CryptoAccel_Available(CRYPTA_SHA1))
    /* send data to be accelerated */
else
    /* do it yourself, or let the un-accelerated library do it */

&gt; The only plea that I would make is to not make it too
&gt; fancy - otherwise we end up with CDSA and other such
&gt; monsters.

True enough ...

--
Michael T. Babcock


Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20000927164513</emailId><senderName>Neil Dunbar</senderName><senderEmail>nd@hplb.hpl.hp.com</senderEmail><timestampReceived>2000-09-27 16:45:13-0400</timestampReceived><subject>Re: Hardware crypto</subject><body>

"Michael T. Babcock" wrote:
&gt; 
&gt; &gt; Alexander S A Kjeldaas wrote:
&gt; &gt;
&gt; &gt; So you need an abstraction interface.

Oh, don't go attributing my random wibbling to
poor Alexander!

&gt; I would be tempted to do (some of) what another company did (what's their
&gt; name ... Microsoft?) when they implemented an acceleration layer for video /
&gt; sound, etc.

Perhaps. Or perhaps the implementation of DRI/DRM in
the current kernel (ie for 3D acceleration) would
be a starting point.

If I yank the tdfx.o module from the active list,
OpenGL works on my machine - just goes slowly, so
this sort of thing has been thought of and implemented
already.

Neil
["nd.vcf" (text/x-vcard)]
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20000927180827</emailId><senderName>Marc Mutz</senderName><senderEmail>marc@mutz.com</senderEmail><timestampReceived>2000-09-27 18:08:27-0400</timestampReceived><subject>Re: Hardware crypto</subject><body>

"Michael T. Babcock" wrote:
&gt; 
&lt;snip&gt;
&gt; Session = CryptoAccel_Init();
&gt; if (CryptoAccel_Available(CRYPTA_SHA1))
&gt;     /* send data to be accelerated */
&gt; else
&gt;     /* do it yourself, or let the un-accelerated library do it */
&lt;snip&gt;

What we have so far is the following (w/o error checking):

userspace scans /proc/cipher/* for a cipher-id, kernel spaces can search
a table.
with this ID you do: (look at driver/block/loop_gen.c in a kernel
patched with the kerneli patch)

struct cipher_implementation *ci;
struct cipher_context *cx;

ci = find_cipher_by_id(cipherid);

/* in case the cipher is implemented in a loadable module: */
ci-&gt;lock()

cx = (struct cipher_context *) kmalloc(
	sizeof(struct cipher_context),GFP_KERNEL);

cx-&gt;ci=ci;
cx-&gt;keyinfo = kmalloc(ci-&gt;key_schedule_size, GFP_KERNEL);
ci-&gt;set_key(cx,key,keysize);

/* save away cx and later: */
cx-&gt;iv = ... /* for modes requiring an IV */
cx-&gt;ci-&gt;encrypt(cx,plaintext,ciphertext,length);
/* or */
cx-&gt;ci-&gt;decrypt(cx,ciphertext,plaintext,length);
/* or for re-keying */
cx-&gt;ci-&gt;setkey(cx,newkey,newkeylength);

/* if you don't need it anymoe */
kfree(cx-&gt;keyinfo);
kfree(cx);
ci-&gt;unlock();

It would be easy to hide knowledge of ci-&gt;key_schedule_size from the
user of this api and make the second kmalloc call inside ci-&gt;setkey.
Also, we could add constructors and destructors (ci-&gt;init and ci-&gt;exit,
e.g.). For now, they would be no-ops, but they might be necessary for hw
crypto.

I think that with some minor additions and changes this api (which, btw,
does exist similarly for hash functions) would be capable of carrying
even hw crypto. The backend has to be changed, of course, but the user
interface would be stable.

And something we are working on, too, is to benchmark cipher
implementations on boot/module load and publish the results via /proc,
so kernelspace users of this api can choose a suiting implementation by
having a userspace deamon look at the encryption speed vs. key agility
figures.

And the best: It's there! Get it at
ftp.*.kernel.org/pub/linux/kernel/crypto/.

Marc

-- 
Marc Mutz &lt;Marc@Mutz.com&gt;        http://marc.mutz.com/Encryption-HOWTO/
University of Bielefeld, Dep. of Mathematics / Dep. of Physics

PGP-keyID's:   0xd46ce9ab (RSA), 0x7ae55b9e (DSS/DH)


Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20000927210830</emailId><senderName>Alexander S A Kjeldaas</senderName><senderEmail>alexander.kjeldaas@fast.no</senderEmail><timestampReceived>2000-09-27 21:08:30-0400</timestampReceived><subject>Re: Hardware crypto</subject><body>

On Wed, Sep 27, 2000 at 05:16:24PM +0100, Neil Dunbar wrote:
&gt; Alexander S A Kjeldaas wrote:
&gt; &gt; 
&gt; &gt; I think there are some interesting issues to be solved when we want to
&gt; &gt; get hardware crypto cards running under Linux.  For one, we want to
&gt; &gt; have a queue of processing requests for the device instead of having a
&gt; &gt; synchronous interface like most crypto libraries offer.  We also
&gt; &gt; probably want to use the CPU if the queue starts to have too many
&gt; &gt; entries, or load-balance between several cards, so we need a
&gt; &gt; "crypto-provider" concept.
&gt; 
&gt; So you need an abstraction interface. If we're talking
&gt; kernel here (ie for IPsec/filesystem crypto/stego), then
&gt; all we should need is an abstraction over symmetric key
&gt; operations - IKE is done in userspace, after all. I suppose
&gt; that it would be possible to leave the slot open for
&gt; message digests as well, although I haven't seen a card
&gt; which accelerates MD5/SHA-1, or HMAC over them.
&gt; 

The API in the kerneli patch only deals with ciphers and digests.  I
really haven't thought about adding public-key stuff as I can't think
of any applications for it.  The only additional interface one might
want is for random numbers, and that already esists.  The goal of the
kerneli project has simply been to provide high-performance
ciphers/digests for the kernel that other crypto-projects can build
upon.  

&gt; The only plea that I would make is to not make it too
&gt; fancy - otherwise we end up with CDSA and other such
&gt; monsters.

I agree.  However there is a case for having a more higher-level
interface than the typical vanilla crypto-API you see in OpenSSL.  It
is possible to do IDEA+SHA1 _at the same time_ on a normal Pentium II
processor in roughly the same time it takes to do just one of them.
This is how you do it: You run the IDEA algorithm using the MMX
instruction set, and the SHA1 using plain C code, and then merge the
two.  The reason you can do this "for free" on a modern CPU is that
the issue-width is pretty high combined with the fact that most crypto
algorithms don't lend themselves to parallel implementations.  So when
executing a cipher, most CPUs have lots of extra memory bandwidth and
instruction-issue bandwidth left unused.  Making use of this requires
some complexity in how ciphers/digest algorithms are implemented, but
I plan on trying out this idea in the future.  However since this has
never been done in a crypto API AFAIK, it might require a slightly
higher-level API.  Something along a "transform" that is both a cipher
and a digest at the same time.  You should tell the API to "encrypt
this datastream while calculating SHA1 and doing IP checksumming". 

Until the kerneli patch has a screaming implementation of the above,
I'll let the idea rest, but you have been warned :-).

Similarly, in some situations where you want to calculate 3des_cbc of
lots of streams at the same time, you might want to be able to switch
over to vector processing of lots of packets.  Using AltiVec (Power
PC) or SSE (Intel) vector instructions you can theoretically have a
bitslice implementation of 3des_cbc that can handle 128 streams in
parallel.  This could be interesting for some IPsec gateways where you
can sacrifice some latency for throughput.

So keep the API simple unless the numbers tell you otherwise.

astor

-- 
Alexander Kjeldaas                Mail:  astor@fast.no
finger astor@master.kernel.org for OpenPGP key.

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20000927212532</emailId><senderName>Alexander S A Kjeldaas</senderName><senderEmail>alexander.kjeldaas@fast.no</senderEmail><timestampReceived>2000-09-27 21:25:32-0400</timestampReceived><subject>Re: Hardware crypto</subject><body>

On Wed, Sep 27, 2000 at 12:17:17PM -0400, Richard Guy Briggs wrote:
&gt; -----BEGIN PGP SIGNED MESSAGE-----
&gt; 
&gt; On Wed, Sep 27, 2000 at 05:52:04PM +0200, Alexander S A Kjeldaas wrote:
&gt; &gt; 
&gt; &gt; I think there are some interesting issues to be solved when we want to
&gt; &gt; get hardware crypto cards running under Linux.  For one, we want to
&gt; &gt; have a queue of processing requests for the device instead of having a
&gt; &gt; synchronous interface like most crypto libraries offer.  We also
&gt; &gt; probably want to use the CPU if the queue starts to have too many
&gt; &gt; entries, or load-balance between several cards, so we need a
&gt; &gt; "crypto-provider" concept.  Also, for programmable crypto-cards we
&gt; &gt; might want to consider the cost of switching ciphers on the card when
&gt; &gt; choosing which requests should be done by which cards/CPU.  This will
&gt; &gt; be interesting to look at when the first drivers emerge.
&gt; 
&gt; I completely agree that it should be queue-based.  SMP is the other
&gt; obvious reason for a queue.
&gt; 
&gt; Alan Cox has publicly stated that he thinks this is the right way to
&gt; do things, but at the moment, asynchrony and queues for this type of
&gt; processing will be a big challenge to accomplish this in the present
&gt; Linux kernels.  

Could you expand on some of the issues?  Are the problems related to
where you are allowed to sleep in the tcp/ip stack?  The part of
creating the async crypto API seems doable.

astor

-- 
Alexander Kjeldaas                Mail:  astor@fast.no
finger astor@master.kernel.org for OpenPGP key.

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20000927213213</emailId><senderName>Alexander S A Kjeldaas</senderName><senderEmail>alexander.kjeldaas@fast.no</senderEmail><timestampReceived>2000-09-27 21:32:13-0400</timestampReceived><subject>Re: Hardware crypto</subject><body>

On Wed, Sep 27, 2000 at 12:10:30PM -0400, Michael T. Babcock wrote:
&gt; 
&gt; A queuing concept is definately needed if this is to be done right the first
&gt; time (so to speak).  The configuration of this interface, however, would be
&gt; the interesting challenge here.  How to present to the user (the sysadmin,
&gt; most likely) the options for dealing with crypto on a per-system, perhaps
&gt; per-app basis.  Prioritising certain applications over others, perhaps,
&gt; would end up being an issue as well.
&gt; 
&gt; For example:
&gt; OpenSSL uses the "crypto accel api" for web serving.
&gt; FreeS/WAN uses it for VPN traffic.

ok

&gt; GPG uses it to encrypt E-mails or generate signatures.

This is a stretch!  Unless there is a painfully obvious win of
involving the kernel in GPGs activities I it should be left to do its
stuff in userland.

&gt; 
&gt; I would probably set the FreeS/WAN requests to have a slightly lower
&gt; priority than the OpenSSL requests because we host E-commerce sites ... and
&gt; the GPG traffic would be lowest, but I wouldn't want it to get swamped out
&gt; of the picture if the crypto card were at full use.  Having it send a
&gt; suitable? number of requests to the software crypto system would be
&gt; necessary as well.
&gt;

Hopefully this could be (indirectly) handled by other parts of the
kernel, namely the QoS modules or the traffic shaper.

&gt; 
&gt; It becomes quite interestingly complex ;-).
&gt; 

It certainly _can_ be made complex.

astor

-- 
Alexander Kjeldaas                Mail:  astor@fast.no
finger astor@master.kernel.org for OpenPGP key.

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20000927224528</emailId><senderName>Richard Guy Briggs</senderName><senderEmail>rgb@conscoop.ottawa.on.ca</senderEmail><timestampReceived>2000-09-27 22:45:28-0400</timestampReceived><subject>Re: Hardware crypto</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----

On Wed, Sep 27, 2000 at 11:32:13PM +0200, Alexander S A Kjeldaas wrote:
&gt; On Wed, Sep 27, 2000 at 12:10:30PM -0400, Michael T. Babcock wrote:
&gt; &gt; 
&gt; &gt; A queuing concept is definately needed if this is to be done right the first
&gt; &gt; time (so to speak).  The configuration of this interface, however, would be
&gt; &gt; the interesting challenge here.  How to present to the user (the sysadmin,
&gt; &gt; most likely) the options for dealing with crypto on a per-system, perhaps
&gt; &gt; per-app basis.  Prioritising certain applications over others, perhaps,
&gt; &gt; would end up being an issue as well.
&gt; &gt; 
&gt; &gt; For example:
&gt; &gt; OpenSSL uses the "crypto accel api" for web serving.
&gt; &gt; FreeS/WAN uses it for VPN traffic.
&gt; 
&gt; ok
&gt; 
&gt; &gt; GPG uses it to encrypt E-mails or generate signatures.
&gt; 
&gt; This is a stretch!  Unless there is a painfully obvious win of
&gt; involving the kernel in GPGs activities I it should be left to do its
&gt; stuff in userland.

I agree that it is better off in a shared object library for
userspace.  Having said that, how do we get the shared object library
to share the one or more hardware crypto accellerators with such a
facility provided to kernel consumers?

&gt; &gt; I would probably set the FreeS/WAN requests to have a slightly lower
&gt; &gt; priority than the OpenSSL requests because we host E-commerce sites ... and
&gt; &gt; the GPG traffic would be lowest, but I wouldn't want it to get swamped out
&gt; &gt; of the picture if the crypto card were at full use.  Having it send a
&gt; &gt; suitable? number of requests to the software crypto system would be
&gt; &gt; necessary as well.
&gt; 
&gt; Hopefully this could be (indirectly) handled by other parts of the
&gt; kernel, namely the QoS modules or the traffic shaper.

Hopefully.

&gt; &gt; It becomes quite interestingly complex ;-).
&gt; 
&gt; It certainly _can_ be made complex.

Let's not make it complex.  Complexity is the enemy of good security.

&gt; astor
&gt; 
&gt; -- 
&gt; Alexander Kjeldaas                Mail:  astor@fast.no
&gt; finger astor@master.kernel.org for OpenPGP key.
&gt; 
&gt; Linux-crypto:  cryptography in and on the Linux system
&gt; Archive:       http://mail.nl.linux.org/linux-crypto/

	slainte mhath, RGB
- -- 
Richard Guy Briggs -- PGP key available            Auto-Free Ottawa! Canada
&lt;www.conscoop.ottawa.on.ca/rgb/&gt;                       &lt;www.flora.org/afo/&gt;
Prevent Internet Wiretapping!        --        FreeS/WAN:&lt;www.freeswan.org&gt;
Thanks for voting Green! -- &lt;green.ca&gt;      Marillion:&lt;www.marillion.co.uk&gt;

-----BEGIN PGP SIGNATURE-----
Version: 2.6.3i
Charset: noconv

iQCVAwUBOdJ4ht+sBuIhFagtAQHYiQP9F297j/EI9GZMP5LwNL620VPwFR8NmYai
Z+1XGQzi5kvbXqU/K19K02F6Rh5r3DHqPdA/FWrSkueqitWMVEfGkYs/vPeBR/Zz
VCvB5w8LV6EKEaMgbgPQv+VNRQD2ikwIFOzoapb6sHsbNirAP0SmGhULR487AWGH
SDtb4rZekS0=
=YxDH
-----END PGP SIGNATURE-----

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001201061213</emailId><senderName>"Louis Lam"</senderName><senderEmail>lsauchun@hotmail.com</senderEmail><timestampReceived>2000-12-01 06:12:13-0400</timestampReceived><subject>ppdd: creation of working passphrase</subject><body>

Hi,

This is a question for ppdd

file=pass.c
function=newpass

In this function, during the creation of the working passphrase, I can see 
that the existing information in the "mkey" field of the control block is 
being encrypted with the Key that is derived from the Working Passphrase, 
but why is it decrypted with the Key derived from the master passphrase 
before writing back to the control block?

Thanks in advance

Louis Lam
_____________________________________________________________________________________
Get more from the Web.  FREE MSN Explorer download : http://explorer.msn.com


Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001201172038</emailId><senderName>Marc Mutz</senderName><senderEmail>marc@mutz.com</senderEmail><timestampReceived>2000-12-01 17:20:38-0400</timestampReceived><subject>Re: block ciphers &amp; plaintext attacks</subject><body>

John Kennedy wrote:
&gt; 
&lt;snip&gt;
&gt;   To get back to the main point, the cipher-encrypted data isn't any more
&gt; or less secure if you look at the cipher aspect alone.  It is the key
&gt; that is important, and the difficulty perceived in brute-forcing it.
&gt; 

Ahh, this I understand. And you are right (assuming for the moment that
the cipher does not have any attacks that are faster than brute-force).

Another well-know quote: "All security rests in the key" (this should be
true of a cipher algorithm and you consider such an algorithm broken, if
that is not so).

&lt;snip&gt;
&gt; &gt; Yes, is does not help, but it is still moot. That is because you can be
&gt; &gt; in the following two cases:
&gt; &gt;
&gt; &gt; a.) Your encrypted second key is accessible by the attacker.
&gt; &gt; b.) It is not.
&gt; 
&gt;   Yup.  And if it isn't, it is perceived as being a lot more difficult.
&gt; I could lie and say that my password as 100 characters long and it is
&gt; suddenly more secure (if you believe me).  You can't just look at the
&gt; key and know how much entropy went into it (as far as I know).
&gt; 

Yes, that is also right. Yet, the smart attacker would probably try the
'easy' keys first (e.g.
ripemd('A'),ripemd('B'),...,ripemd('Z'),Ripemd('AA'),...)

&lt;snip&gt;
&gt; &gt; Bottomline: Choose a passphrase that has at least 64 bits of entropy and
&gt; &gt; you should be as secure as you need to be.
&gt; 
&gt;   Presumably a good rule of thumb.
&gt; 
Cryptography is also about making it 'hard enough'. E.g., you don't need
to protect against the computing power of the NSA (which you probably
cannot, because they have more mathematicians than the whole public
cryptographic scientific society) if you just want to hide your diary
from your familiy.

Marc

-- 
Marc Mutz &lt;Marc@Mutz.com&gt;     http://EncryptionHOWTO.sourceforge.net/
University of Bielefeld, Dep. of Mathematics / Dep. of Physics

PGP-keyID's:   0xd46ce9ab (RSA), 0x7ae55b9e (DSS/DH)


Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001202163833</emailId><senderName>"Allan Latham"</senderName><senderEmail>alatham@flexsys-group.com</senderEmail><timestampReceived>2000-12-02 16:38:33-0400</timestampReceived><subject>Re: creation of working passphrase</subject><body>

Because the whole control block gets encrypted later with the master key.
By decrypting that part in advance of encrypting the whole block effectively
leaves it unencrypted (by the master key).

i.e. you can do the encrypt and decrypt in any order. Which function you
call decrypt and which encrypt is your choice! The one simply undoes what
the other did.

Best regards

Allan
----- Original Message -----
From: "Louis Lam" &lt;lsauchun@hotmail.com&gt;
To: &lt;alatham@flexsys-group.com&gt;
Cc: &lt;linux-crypto@nl.linux.org&gt;; &lt;ppdd@linux01.gwdg.de&gt;
Sent: Friday, December 01, 2000 7:12 AM
Subject: ppdd: creation of working passphrase


&gt; Hi,
&gt;
&gt; This is a question for ppdd
&gt;
&gt; file=pass.c
&gt; function=newpass
&gt;
&gt; In this function, during the creation of the working passphrase, I can see
&gt; that the existing information in the "mkey" field of the control block is
&gt; being encrypted with the Key that is derived from the Working Passphrase,
&gt; but why is it decrypted with the Key derived from the master passphrase
&gt; before writing back to the control block?
&gt;
&gt; Thanks in advance
&gt;
&gt; Louis Lam
&gt;
____________________________________________________________________________
_________
&gt; Get more from the Web.  FREE MSN Explorer download :
http://explorer.msn.com
&gt;
&gt;


Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001203055907</emailId><senderName>"Louis Lam"</senderName><senderEmail>lsauchun@hotmail.com</senderEmail><timestampReceived>2000-12-03 05:59:07-0400</timestampReceived><subject>Re: [PPDD] Re: creation of working passphrase</subject><body>

Hi,

I see, so it is possible to do encryption and decryption in any order.
I see it as sort of like commutative property.

I'm not so "savvy" about the mechanisms of encryption and decryption at tis 
moment, is this property only applicable for the Blowfish algorithm or does 
it apply to only some symmetric ciphers?

Where can I find mo' information about this?

Thanks in advance,

Louis Lam

&gt;From: "Allan Latham" &lt;alatham@flexsys-group.com&gt;
&gt;Reply-To: ppdd@linux01.gwdg.de
&gt;To: "Louis Lam" &lt;lsauchun@hotmail.com&gt;
&gt;CC: &lt;linux-crypto@nl.linux.org&gt;, &lt;ppdd@linux01.gwdg.de&gt;
&gt;Subject: [PPDD] Re: creation of working passphrase
&gt;Date: Sat, 2 Dec 2000 17:38:33 +0100
&gt;
&gt;Because the whole control block gets encrypted later with the master key.
&gt;By decrypting that part in advance of encrypting the whole block 
&gt;effectively
&gt;leaves it unencrypted (by the master key).
&gt;
&gt;i.e. you can do the encrypt and decrypt in any order. Which function you
&gt;call decrypt and which encrypt is your choice! The one simply undoes what
&gt;the other did.
&gt;
&gt;Best regards
&gt;
&gt;Allan
&gt;----- Original Message -----
&gt;From: "Louis Lam" &lt;lsauchun@hotmail.com&gt;
&gt;To: &lt;alatham@flexsys-group.com&gt;
&gt;Cc: &lt;linux-crypto@nl.linux.org&gt;; &lt;ppdd@linux01.gwdg.de&gt;
&gt;Sent: Friday, December 01, 2000 7:12 AM
&gt;Subject: ppdd: creation of working passphrase
&gt;
&gt;
&gt; &gt; Hi,
&gt; &gt;
&gt; &gt; This is a question for ppdd
&gt; &gt;
&gt; &gt; file=pass.c
&gt; &gt; function=newpass
&gt; &gt;
&gt; &gt; In this function, during the creation of the working passphrase, I can 
&gt;see
&gt; &gt; that the existing information in the "mkey" field of the control block 
&gt;is
&gt; &gt; being encrypted with the Key that is derived from the Working 
&gt;Passphrase,
&gt; &gt; but why is it decrypted with the Key derived from the master passphrase
&gt; &gt; before writing back to the control block?
&gt; &gt;
&gt; &gt; Thanks in advance
&gt; &gt;
&gt; &gt; Louis Lam
&gt; &gt;
&gt;____________________________________________________________________________
&gt;_________
&gt; &gt; Get more from the Web.  FREE MSN Explorer download :
&gt;http://explorer.msn.com
&gt; &gt;
&gt; &gt;
&gt;

_____________________________________________________________________________________
Get more from the Web.  FREE MSN Explorer download : http://explorer.msn.com


Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001205091555</emailId><senderName>Marc Mutz</senderName><senderEmail>marc@mutz.com</senderEmail><timestampReceived>2000-12-05 09:15:55-0400</timestampReceived><subject>Re: What patch for Red Hat Linux 7?</subject><body>

Thilo Mezger wrote:
&gt; 
&lt;snip&gt; 
&gt; I tried 2.2.17.10 against Red Hat's 2.2.16-22 Kernel and it fails
&gt; in loop.c:
&gt; 
&gt; 4 out of 9 hunks FAILED -- saving rejects to file drivers/block/loop.c.rej
&gt; 
&gt; I did not have the time to check what exactly goes wrong here but I'll
&gt; try as soon as time permits...
&gt; 
&lt;snip&gt;

Now, working at innomate, you should be aware of the importance of good
failure reports. It was not clear whether you tried the patch and if
yes, whether that patch failed horribly or with trivial rejects. And up
to now I haven't seen a hint about what the reject looks like. If you
could provide that, we may help you better.

Marc

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001213070259</emailId><senderName>Alexander S A Kjeldaas</senderName><senderEmail>alexander.kjeldaas@fast.no</senderEmail><timestampReceived>2000-12-13 07:02:59-0400</timestampReceived><subject>Re: Intl. patch 2.2.18.1</subject><body>

On Tue, Dec 12, 2000 at 12:25:34PM +0100, Alexander S A Kjeldaas wrote:
&gt; International kernel patch 2.2.18.1 is out.  This is simply a port of
&gt; 2.2.17.10 to the new upstream kernel release.  It contains none of the
&gt; changes in 2.2.17.11pre1, but patches cleanly against the new kernel.
&gt; 
&gt; It can be found at:
&gt; ftp://ftp.kernel.org/pub/linux/kernel/crypto/v2.2/patch-int-2.2.18.1.gz
&gt; 

There were some /proc-interface compatibility problems, so now we're
at 2.2.18.3.  This version should compile. No major changes.

astor

-- 
Alexander Kjeldaas                Mail:  astor@fast.no
finger astor@master.kernel.org for OpenPGP key.

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001213145157</emailId><senderName>Harald Welte</senderName><senderEmail>laforge@gnumonks.org</senderEmail><timestampReceived>2000-12-13 14:51:57-0400</timestampReceived><subject>Re: 2.2.x &lt;=&gt; 2.4.x compatibility</subject><body>

On Wed, Dec 13, 2000 at 02:45:38PM +0100, Alexander S A Kjeldaas wrote:
&gt; On Wed, Dec 13, 2000 at 12:40:01PM +0000, David Sobon wrote:
&gt; &gt; Hi,
&gt; &gt; 	I'm wondering if encrypted images are forward/backward 
&gt; &gt; compatible between 2.2.x and 2.4.x.  I have a test image created in 
&gt; &gt; 2.2.18 (kerneli version 2.2.17.9, created on 2.2.13.2) and works well. 
&gt; &gt; Trying to mount the images in 2.4.0-test12 fails.  Is it supposed to be 
&gt; &gt; compatible 
&gt; 
&gt; yes.

yes, indeed.

&gt; &gt; or is 2.4.x support incomplete? 
&gt; 
&gt; not sure if it's incomplete.  Harald might know.

I had some reports that mounting of old loopback files (from 2.2.x)
doesn't work.

I don't have enough time currently to work on that. Maybe in two weeks or
something

&gt; Alexander Kjeldaas                Mail:  astor@fast.no
&gt; finger astor@master.kernel.org for OpenPGP key.

-- 
Live long and prosper
- Harald Welte / laforge@gnumonks.org                http://www.gnumonks.org
============================================================================
GCS/E/IT d- s-: a-- C+++ UL++++$ P+++ L++++$ E--- W- N++ o? K- w--- O- M- 
V-- PS+ PE-- Y+ PGP++ t++ 5-- !X !R tv-- b+++ DI? !D G+ e* h+ r% y+(*)

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001214124428</emailId><senderName>"Louis Lam"</senderName><senderEmail>lsauchun@hotmail.com</senderEmail><timestampReceived>2000-12-14 12:44:28-0400</timestampReceived><subject>Using CDSA on Linux(or compiling a program that uses cdsa on linux)</subject><body>

Hi! Linux CDSA users,

I have problems compiling a very simple test program that was intended to 
test the MDS.

I have included "mds_utils_api.h" and "mds_utils_helper.h" headers and tried 
to compile with gcc, but it returns "parse errors" in a number of places in 
the included header files, more specifically on "cssmtype.h".

On closer inspection of those lines which gave errors, many of those were 
something like:

	typedef xxxx xxxx;

I was suspecting that I haven't used the correct compiler flags, what are 
the necessary flags needed for compilation?

My own test program does absolutely nothing yet:

#include&lt;cdsa/mds_utils.h&gt;
#include&lt;cdsa/mds_utils_helper.h&gt;
main(){;}

thats about it.

If I can get it to compile at least, the next step would be to link it to 
the 2 libraries: MDS_UTIL_API.LIB and MDS300.LIB. On Linux MDS_UTIL_API.LIB 
would be libmds_util_api.a but I couldn't find the equivalent to MDS300.LIB. 
What is MDS300.LIB on linux?

How do I link those libraries?


Thank you,

Louis Lam
_____________________________________________________________________________________
Get more from the Web.  FREE MSN Explorer download : http://explorer.msn.com


Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001219211201</emailId><senderName>Gisle S{lensminde</senderName><senderEmail>gisle@ii.uib.no</senderEmail><timestampReceived>2000-12-19 21:12:01-0400</timestampReceived><subject>Re: Almost working...</subject><body>

On Tue, 19 Dec 2000, Marc Mutz wrote:

&gt; Chris Kuklewicz wrote:
&gt; &gt;
&gt; &gt; Okay...so I missed some documentation.  Documentation/crypto/faq.txt
&gt; &gt; helped get blowfish working.  And I found the error doucmented in the
&gt; &gt; last chapter (the FAQ) of the howto at EncryptionHOWTO.sourceforge.net.
&gt; &gt;
&gt; &gt; So the revised question is:
&gt; &gt;
&gt; &gt; Out of curiousity, what non trivial work needs to be done to losetup
&gt; &gt; to add a cipher (e.g. twofish or aes)?
&gt; &gt;
&gt; &lt;snip&gt;
&gt;
&gt; There is a list of known ciphers in lomount.c. You have to do the
&gt; obvious additions (just copy one of the existing lines and modify.
&gt; Keylength for Twofish is 128 or 256 bits, not sure if losetup works with
&gt; the latter.

Each cipher has a predefined keylength. For all the aes candidates
128 bits is chosen, even all of them support at least 192 and 256
bits. The current hash scheme supports up to 320 bits of key bits
(two ripmd hashes). However, so much entropy is almost certainly
not found in a passphrase, so using more than 128 bits keys will not
add security. It must also be added that 128 bits is more than
good enough today. 90 bits is the recomended minimum key length.


--
Gisle Sælensminde ( gisle@ii.uib.no )

With sufficient thrust, pigs fly just fine. However, this is not
necessarily a good idea. It is hard to be sure where they are going
to land, and it could be dangerous sitting under them as they fly
overhead. (from RFC 1925)


Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001215014503</emailId><senderName>Harald Welte</senderName><senderEmail>laforge@gnumonks.org</senderEmail><timestampReceived>2000-12-15 01:45:03-0400</timestampReceived><subject>Re: Ciphers which may sleep</subject><body>

On Thu, Dec 14, 2000 at 06:55:58PM +0100, Alexander S A Kjeldaas wrote:

&gt;  3) A work-queue w/callback one.  You want this when dealing with the
&gt; network stack.  You don't care about processes.

yes, indeed. We're certainly going to need this in the long run.

&gt; ciphers optional.  Currently I feel that all three interfaces should
&gt; be supported.  Off the top of my head - something like:

now this sounds like a really nice proposal. This should be flexible 
enough to cover all practical scenarios.

&gt; astor

-- 
Live long and prosper
- Harald Welte / laforge@gnumonks.org                http://www.gnumonks.org
============================================================================
GCS/E/IT d- s-: a-- C+++ UL++++$ P+++ L++++$ E--- W- N++ o? K- w--- O- M- 
V-- PS+ PE-- Y+ PGP++ t++ 5-- !X !R tv-- b+++ DI? !D G+ e* h+ r% y+(*)

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001220152212</emailId><senderName>"Ryan W. Maple"</senderName><senderEmail>ryan@guardiandigital.com</senderEmail><timestampReceived>2000-12-20 15:22:12-0400</timestampReceived><subject>Re: Tinkering....</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

On Wed, 20 Dec 2000, Henry Spencer wrote:

&gt; On Wed, 20 Dec 2000, Gisle S{lensminde wrote:
&gt; &gt; I have no idea why Rijndael and AES is assigned different numbers, since
&gt; &gt; Rijndael simply is the winner algorithm of the AES competition...
&gt; 
&gt; If memory serves, Rijndael has more options -- for things like key size --
&gt; than AES permits, so it is technically more accurate to say that AES is a
&gt; (slight) subset of Rijndael. 

This is right.  AFAIK, AES is required to be a 128-bit, 192-bit, or
256-bit and Rijndael is a variable-sized cipher.  From the Rijndael
homepage:  

  "The cipher has a variable block length and key length. We currently
   specified how to use keys with a length of 128, 192, or 256 bits to
   encrypt blocks with al length of 128, 192 or 256 bits (all nine
   combinations of key length and block length are possible). Both block
   length and key length can be extended very easily to multiples of 32
   bits.  Rijndael can be implemented very efficiently on a wide range of
   processors and in hardware."

So to be AES compliant, it must must use one of the pre-set sizes.  But
the algorithim itself is capabible of using many others (32bit multiples).

Cheers,
Ryan

 +-- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --+
   Ryan W. Maple          "I dunno, I dream in Perl sometimes..."  -LW
   Guardian Digital, Inc.                     ryan@guardiandigital.com
 +-- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --+
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.0.4 (GNU/Linux)
Comment: For info see http://www.gnupg.org

iD8DBQE6QM6nIwAIA9MpKWcRAvDRAKCAJgvFnFWyC+Njgj/VLfm/wpj8BQCfd49Q
N7BYttaKMmOYY+D+IKWRQ1o=
=PKvB
-----END PGP SIGNATURE-----



Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001222192048</emailId><senderName>Marc Mutz</senderName><senderEmail>marc@mutz.com</senderEmail><timestampReceived>2000-12-22 19:20:48-0400</timestampReceived><subject>Re: Done tinkering</subject><body>

Chris Kuklewicz wrote:
&gt; 
&gt; &gt;
&gt; &gt; A little modules.conf magic will work when losetup tells the kernel the
&gt; &gt; cipher by name (someday soon?).
&gt; &gt;
&gt; 
&gt; That would be part of the main kernel crypto patch, which I have not
&gt; looked at.
&gt; 

It's not there yet. But I guess it is planned that cipher--ids are then
dynamically allocated (like handles) and you identify ciphers solely by
name. Alex?

&gt; &gt; &gt; The current losetup has no command line flag to get the password or
&gt; &gt; &gt; the key from stdin or a file.  Hmmmm...
&gt; &gt; &gt;
&gt; &gt;
&gt; &gt; Patch exists. Was posted to this ml. Search the archive for "a better
&gt; &gt; util-linux.getpass.patch"
&gt; &gt;
&gt; 
&gt; I'll go back and grab it.  Since my attachments bounced for being too
&gt; large, I will have to drop them on my web page.  I'll wait until after
&gt; I look at this other patch first.
&gt; 

Someone should implement a command line switch '--key-fd' that is
analoguos to '--pass-fd' but gives a fd where the _key_ (as opposed to
the passphrase) is to be read from. Something along this line is
mandatory for the support of transparent mounting of crypted home
directories. There is a PAM module (pam_mount), which is not too far
away from suppporting this. Search the PAM list, if anyone is
interested. IIRC, it should be doable in the next revision 0.0.3 (or
0.3.0?), if losetup supports a '--key-fd' option. '--pass-fd' would
suffice in theory, but that would disallow users to change their
password.

&gt; &gt; &gt; Stupid crypto question...are the -cbc versions useful to losetup?
&gt; &gt; &gt;
&gt; &gt; loop_gen always uses CBC mode implicitely. You cannot tell it to use
&gt; &gt; another mode.
&gt; &gt;
&gt; 
&gt; Okay.  I was confused by the /proc cipher id, which has a high bit set
&gt; for cbc modes, and so the LO_CRYPT_xxxx numbers only matched the non
&gt; cbc cipher ids.
&gt; 

Basically, as I interpret it, the low 16 bits of a cipher-ID are the for
the cipher algorithm and the high 16 bits are for the mode. Currently
mode can take values of 0x00000 (ECB) and 0x10000 (CBC). You get the
cipher-ID by or'ing mode and algorithm, see loop_gen.c (or wherever that
file got merged into loop.c in 2.2.18.x)...

I currently have not much free time as our working groups has to write a
report on the past three years of research and I have to collect
everything ... :-(
I try not to lose to much grip on the sources, though...

Marc

-- 
Marc Mutz &lt;Marc@Mutz.com&gt;     http://EncryptionHOWTO.sourceforge.net/
University of Bielefeld, Dep. of Mathematics / Dep. of Physics

PGP-keyID's:   0xd46ce9ab (RSA), 0x7ae55b9e (DSS/DH)


Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001212112534</emailId><senderName>Alexander S A Kjeldaas</senderName><senderEmail>alexander.kjeldaas@fast.no</senderEmail><timestampReceived>2000-12-12 11:25:34-0400</timestampReceived><subject>Intl. patch 2.2.18.1</subject><body>

International kernel patch 2.2.18.1 is out.  This is simply a port of
2.2.17.10 to the new upstream kernel release.  It contains none of the
changes in 2.2.17.11pre1, but patches cleanly against the new kernel.

It can be found at:
ftp://ftp.kernel.org/pub/linux/kernel/crypto/v2.2/patch-int-2.2.18.1.gz

astor

-- 
Alexander Kjeldaas                Mail:  astor@fast.no
finger astor@master.kernel.org for OpenPGP key.

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001229012509</emailId><senderName>Marc Mutz</senderName><senderEmail>marc@mutz.com</senderEmail><timestampReceived>2000-12-29 01:25:09-0400</timestampReceived><subject>Re: Problems with losetup</subject><body>

David Lambert wrote:
&gt; 
&gt; I hope this ius the right place to post problems to the mailgroup
&gt; linux-crypto, if not, please excuse my ignorance.
&gt; 
&gt; I think I have followed the instructions in your HOWTO to patch my linux
&gt; 2.2.18 system and utils for crpto, but I get the following error when using
&gt; losetup with any of the new ciphers.
&gt; 
&gt; [root@localhost dlambert]# losetup -e twofish /dev/loop0 /tmp/.crypto
&gt; Password :
&gt; ioctl: LOOP_SET_STATUS: Invalid argument
&gt; 
&lt;snip&gt;

The util-.linux patch and the kernel are out of sync for some ciphers.
Either use the stand-along twofish module (near loop support under block
devices) or patch lomount.c's table of known ciphers to use '9' as the
Twofish ID instead of 2/3/whatever...

Marc

-- 
Marc Mutz &lt;Marc@Mutz.com&gt;     http://EncryptionHOWTO.sourceforge.net/
University of Bielefeld, Dep. of Mathematics / Dep. of Physics

PGP-keyID's:   0xd46ce9ab (RSA), 0x7ae55b9e (DSS/DH)


Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001213124001</emailId><senderName>David Sobon</senderName><senderEmail>xk@leguin.org.uk</senderEmail><timestampReceived>2000-12-13 12:40:01-0400</timestampReceived><subject>2.2.x &lt;=&gt; 2.4.x compatibility</subject><body>

Hi,
	I'm wondering if encrypted images are forward/backward 
compatible between 2.2.x and 2.4.x.  I have a test image created in 
2.2.18 (kerneli version 2.2.17.9, created on 2.2.13.2) and works well. 
Trying to mount the images in 2.4.0-test12 fails.  Is it supposed to be 
compatible or is 2.4.x support incomplete? Here is some output from the 
kernel:
	loop: enabling 8 loop devices
	cryptoapi: Registered serpent (7)
	cryptoapi: Registered serpent-cbc (65543)
	VFS: Can't find an ext2 filesystem on dev loop(7,1).

	Also,  does the current util-linux patch support creating 
crypted images in AES/Rijndael format?  I tried modifying util-linux 
(specifically lomount.c) to support RIJNDAEL but it did not help.

Thanks

-David Sobon.

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001213134538</emailId><senderName>Alexander S A Kjeldaas</senderName><senderEmail>alexander.kjeldaas@fast.no</senderEmail><timestampReceived>2000-12-13 13:45:38-0400</timestampReceived><subject>Re: 2.2.x &lt;=&gt; 2.4.x compatibility</subject><body>

On Wed, Dec 13, 2000 at 12:40:01PM +0000, David Sobon wrote:
&gt; Hi,
&gt; 	I'm wondering if encrypted images are forward/backward 
&gt; compatible between 2.2.x and 2.4.x.  I have a test image created in 
&gt; 2.2.18 (kerneli version 2.2.17.9, created on 2.2.13.2) and works well. 
&gt; Trying to mount the images in 2.4.0-test12 fails.  Is it supposed to be 
&gt; compatible 

yes.

&gt; or is 2.4.x support incomplete? 

not sure if it's incomplete.  Harald might know.

&gt; Here is some output from the 
&gt; kernel:
&gt; 	loop: enabling 8 loop devices
&gt; 	cryptoapi: Registered serpent (7)
&gt; 	cryptoapi: Registered serpent-cbc (65543)
&gt; 	VFS: Can't find an ext2 filesystem on dev loop(7,1).
&gt; 
&gt; 	Also,  does the current util-linux patch support creating 
&gt; crypted images in AES/Rijndael format?  I tried modifying util-linux 
&gt; (specifically lomount.c) to support RIJNDAEL but it did not help.
&gt; 

no it doesn't.  2.2.17.11pre1 should work if you rename the rijndael
module to "cipher-aes.o" after installation.  I'll get the stuff from
2.2.17.11pre1 ported to 2.2.18 soonish.

astor

-- 
Alexander Kjeldaas                Mail:  astor@fast.no
finger astor@master.kernel.org for OpenPGP key.

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001231153434</emailId><senderName>Jan-Benedict Glaw</senderName><senderEmail>jbglaw@lug-owl.de</senderEmail><timestampReceived>2000-12-31 15:34:34-0400</timestampReceived><subject>Re: Patch for losetup</subject><body>

On Sun, Dec 31, 2000 at 04:12:28PM +0100, Gisle S{lensminde wrote:
&gt; --- lomount.c.orig      Sat Dec 30 01:56:28 2000
&gt; +++ lomount.c   Sat Dec 30 16:53:48 2000
&gt; @@ -53,6 +53,8 @@
&gt;         { LO_CRYPT_DES_EDE3, "DES_EDE3",24},
&gt;         { LO_CRYPT_DFC, "dfc",16 },
&gt;         { LO_CRYPT_IDEA, "idea",16},
&gt; +       { LO_CRYPT_RIJNDAEL, "rijndael", 16},
                                           ^^
&gt; +       { LO_CRYPT_AES, "aes", 16},
                                 ^^
&gt; --- loop.h.orig Sat Dec 30 01:53:23 2000
&gt; +++ loop.h      Sat Dec 30 01:54:15 2000
&gt; @@ -106,6 +106,7 @@
&gt;  #define LO_CRYPT_DFC      15
&gt;  #define LO_CRYPT_RIJNDAEL 16
&gt;  #define LO_CRYPT_RC5      17
&gt; +#define LO_CRYPT_AES      18
                             ^^--- You better define this to 16, right?
&gt;  #define MAX_LO_CRYPT   20
&gt; 
&gt;  #ifdef __KERNEL__

MfG, JBG

-- 
Fehler eingestehen, Größe zeigen: Nehmt die Rechtschreibreform zurück!!!
/* Jan-Benedict Glaw &lt;jbglaw@lug-owl.de&gt; -- +49-177-5601720 */
keyID=0x8399E1BB fingerprint=250D 3BCF 7127 0D8C A444 A961 1DBD 5E75 8399 E1BB
     "insmod vi.o and there we go..." (Alexander Viro on linux-kernel)

[Attachment #3 (application/pgp-signature)]
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20001214110426</emailId><senderName>Olaf Titz</senderName><senderEmail>olaf@bigred.inka.de</senderEmail><timestampReceived>2000-12-14 11:04:26-0400</timestampReceived><subject>Ciphers which may sleep</subject><body>

As stated in &lt;linux/crypto.h&gt; the encrypt and decrypt functions of the
cipher implementations may sleep. This is very unfortunate, as there
is no way to use them in atomic context (e.g. network driver output
routine, required for CIPE etc.)

What is the actual state on this:
- Are there implementations which really do sleep? I can't think of a
  reason why they _have_ to.
- Is there a way to find out whether an implementation does this?
- How can it be fixed? Usually this would require a GFP_* argument to
  each function which may allocate memory.

Olaf

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001218013753</emailId><senderName>Chris Kuklewicz</senderName><senderEmail>chrisk@mit.edu</senderEmail><timestampReceived>2000-12-18 01:37:53-0400</timestampReceived><subject>Almost working...</subject><body>

I bet there is simple fix.  Here is a fairly complete description of
my current situation:

Okay, I am trying to setup, on a RH6.2 system these pieces:

linux-2.2.18.tar.bz2 with patch-int-2.2.18.3.gz and freeswan-1.8.tar.gz

Which seems to work.  In particular, "modprobe twofish" works.
[root@kuklewicz /sbin]# ls /proc/crypto/cipher/ -l
total 0
-r--r--r--    1 root     root            0 Dec 17 20:24 twofish
-r--r--r--    1 root     root            0 Dec 17 20:24 twofish-cbc

On top of the programs from the util-linux-2.10p-1 rpm, I have created
a second rpm ( called util-linux-2.10r-13_crypto ) with just the
mount, umount, and losetup commands.  I compiled these 3 commands from
util-linux-2.10r.tar.bz2 with the util-linux-2.10o.int.patch from
patch-int-2.2.18.3.gz.  So now I get

[root@kuklewicz /sbin]# ./losetup
usage:
  ./losetup loop_device                                      # give info
  ./losetup -d loop_device                                   # delete
  ./losetup [ -e encryption ] [ -o offset ] loop_device file # setup
    where encryption is one of:
       no
       none
       xor
       DES
       twofish
       blowfish
       cast128
       serpent
       mars
       rc6
       DES_EDE3
       dfc
       idea

Which is odd, since I expected aes to be listed, but oh well.  The "no" and "xor"
types seem to work, but I cannot use the ciphers.  The error message is:

[root@kuklewicz /sbin]# losetup -e twofish /dev/loop0 ~/testing 
Password :
ioctl: LOOP_SET_STATUS: Invalid argument

So this is my question: How do I fix this error?  Did I miss a step?
Mix the wrong set of patches?  Forget to sacrfice a young enough goat?

I have strace output, but it is not very illuminating to me:

write(6, "Password :", 10)              = 10
read(6, "frogs\n", 4096)                = 6
write(6, "\n", 1)                       = 1
ioctl(6, SNDCTL_TMR_CONTINUE, {B38400 opost isig icanon echo ...}) = 0
close(6)                                = 0
munmap(0x4012c000, 4096)                = 0
ioctl(5, LOOP_SET_FD, 0x4)              = 0
ioctl(5, LOOP_SET_STATUS, 0xbffff9a0)   = -1 ENOSYS (Function not implemented)
ioctl(5, LOOP_SET_STATUS, 0xbffff9a0)   = -1 ENOSYS (Function not implemented)
ioctl(5, LOOP_SET_STATUS, 0xbffff9a0)   = -1 EINVAL (Invalid argument)
ioctl(5, LOOP_CLR_FD, 0)                = 0
open("/usr/share/locale/en_US/LC_MESSAGES/libc.mo", O_RDONLY) = -1 ENOENT (No such file or directory)
open("/usr/share/locale/en/LC_MESSAGES/libc.mo", O_RDONLY) = -1 ENOENT (No such file or directory)
write(2, "ioctl: LOOP_SET_STATUS: Invalid "..., 41) = 41
_exit(1)                                = ?

The relevant loopback and CRYPTO sections of the kernel .config file are

#
# Additional Block Devices
#
CONFIG_BLK_DEV_LOOP=y
CONFIG_BLK_DEV_LOOP_USE_REL_BLOCK=y
CONFIG_BLK_DEV_LOOP_GEN_SEL="1"
CONFIG_BLK_DEV_LOOP_GEN=y
# CONFIG_BLK_DEV_LOOP_CAST is not set
# CONFIG_BLK_DEV_LOOP_FISH2 is not set

#
# Crypto options
#
CONFIG_CRYPTO=y
CONFIG_CIPHERS=y
CONFIG_CIPHER_AES=m
CONFIG_CIPHER_RIJNDAEL=y

#
# AES Finalist Ciphers (128 bit blocksize)
#
CONFIG_CIPHER_TWOFISH=m
CONFIG_CIPHER_MARS=m
CONFIG_CIPHER_RC6=m
CONFIG_CIPHER_SERPENT=m

#
# Other Ciphers submitted as AES Candidates:
#
CONFIG_CIPHER_DFC=m

#
# Other ciphers (64 bit blocksize)
#
CONFIG_CIPHER_BLOWFISH=m
CONFIG_CIPHER_IDEA=m
CONFIG_CIPHER_RC5=m
# CONFIG_CIPHER_DES_EDE3 is not set
# CONFIG_CIPHER_DES is not set
# CONFIG_DIGEST is not set

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001220034508</emailId><senderName>Chris Kuklewicz</senderName><senderEmail>chrisk@mit.edu</senderEmail><timestampReceived>2000-12-20 03:45:08-0400</timestampReceived><subject>Re: Tinkering....</subject><body>

Thanks for the help.

Midstream...as I work on util-linux....

1 fish, 2 fish, FISH2, TWOFISH, DUMMY ?

From linux/cypto.h:

What is CIPHER_FISH2 and what is CIPHER_TWOFISH?
Are they the same, like CIPHER_AES and CIPHER_RIJNDAEL are?

#define CIPHER_NONE     0
#define CIPHER_XOR      1
#define CIPHER_DES      2
#define CIPHER_FISH2    3
#define CIPHER_BLOWFISH 4
#define CIPHER_CAST128  5
#define CIPHER_IDEA     6
#define CIPHER_SERPENT  7
#define CIPHER_MARS     8
#define CIPHER_TWOFISH  9
#define CIPHER_SKIPJACK 10
#define CIPHER_RC6      11
#define CIPHER_DES_EDE3 12
#define CIPHER_E2       13
#define CIPHER_CAST256  14
#define CIPHER_DFC      15
#define CIPHER_RIJNDAEL 16
#define CIPHER_RC5      17
#define CIPHER_AES      18
#define MAX_CIPHER      20
#define CIPHER_CBC    0x00010000

And then from linux/loop.h, 9 is DUMMY and 18 (AES) is not listed:

#define LO_CRYPT_NONE     0
#define LO_CRYPT_XOR      1
#define LO_CRYPT_DES      2
#define LO_CRYPT_FISH2    3
#define LO_CRYPT_BLOW     4
#define LO_CRYPT_CAST128  5
#define LO_CRYPT_IDEA     6
#define LO_CRYPT_SERPENT  7
#define LO_CRYPT_MARS     8
#define LO_CRYPT_DUMMY    9
#define LO_CRYPT_SKIPJACK 10
#define LO_CRYPT_RC6      11
#define LO_CRYPT_DES_EDE3 12
#define LO_CRYPT_E2       13
#define LO_CRYPT_CAST256  14
#define LO_CRYPT_DFC      15
#define LO_CRYPT_RIJNDAEL 16
#define LO_CRYPT_RC5      17
#define MAX_LO_CRYPT    20

DUMMY does not look appetizing, but the module name is twofish.o, not
fish2.o

Currently lomount.c uses LO_CRYPT_FISH2, but that fails, so perhaps I
will try DUMMY...

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001220050137</emailId><senderName>Chris Kuklewicz</senderName><senderEmail>chrisk@mit.edu</senderEmail><timestampReceived>2000-12-20 05:01:37-0400</timestampReceived><subject>Re: Done tinkering</subject><body>

&gt; 
&gt; Currently lomount.c uses LO_CRYPT_FISH2, but that fails, so perhaps I
&gt; will try DUMMY...
&gt; 

Poking at /proc/crypto/cipher/twofish revealed the cipher number is 9,
so LO_CRYPT_DUMMY is twofish.  Go figure.  Also, I changed the
previous twofish blocksize of 20 to 16.

So everything recompiled and worked, with twofish and aes.  The updated
patch for util-linux is attached.

Do people want an improved version of losetup?  It could read the
/proc/crypto/cipher/ directory...but that would require loading the
module before running losetup (if you use modules...).

Or it could have additional command line options to pass in the cipher
number and blocksize.  Then it would not need to be recompiled, and
overly paranoid people could use the longer cipher block sizes.

The current losetup has no command line flag to get the password or
the key from stdin or a file.  Hmmmm...

Stupid crypto question...are the -cbc versions useful to losetup?

-- 
Chris

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001228225632</emailId><senderName>David Lambert</senderName><senderEmail>dave_lambert@ev1.net</senderEmail><timestampReceived>2000-12-28 22:56:32-0400</timestampReceived><subject>Problems with losetup</subject><body>

I hope this ius the right place to post problems to the mailgroup 
linux-crypto, if not, please excuse my ignorance.

I think I have followed the instructions in your HOWTO to patch my linux 
2.2.18 system and utils for crpto, but I get the following error when using 
losetup with any of the new ciphers.

[root@localhost dlambert]# losetup -e twofish /dev/loop0 /tmp/.crypto
Password :
ioctl: LOOP_SET_STATUS: Invalid argument

This does not occur if I use XOR or NONE

I do seem to be getting the crypto modules installed in the kernel as 
witnessed by the following extract from my dmesg log.


MD5 Message Digest Algorithm (c) RSA Systems, Inc
cryptoapi: Registered md5 (5)
cryptoapi: Registered twofish (9)
cryptoapi: Registered twofish-cbc (65545)
cryptoapi: Registered serpent (7)
cryptoapi: Registered serpent-cbc (65543)
cryptoapi: Registered blowfish (4)
cryptoapi: Registered blowfish-cbc (65540)
cryptoapi: Registered des_ede3 (12)
cryptoapi: Registered des_ede3-cbc (65548)   

Any suggestions as to where to look next would be greatly appreciated.

Best regards,


David Lambert

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001231151228</emailId><senderName>Gisle S{lensminde</senderName><senderEmail>gisle@ii.uib.no</senderEmail><timestampReceived>2000-12-31 15:12:28-0400</timestampReceived><subject>Patch for losetup</subject><body>


Many have talked about adding AES/Rijndael to losetup, but it
seems like this still not is done. I've
added this capability to util-linux 2.10o with the patch in
kerneli 2.2.18.int3, and I have also added definition of AES
to loop.h in the kernel. These changes are trivial and shoud
be added in the next verion of kerneli. Pathes follows

In mount/lomount.c in util-linux:

--- lomount.c.orig      Sat Dec 30 01:56:28 2000
+++ lomount.c   Sat Dec 30 16:53:48 2000
@@ -53,6 +53,8 @@
        { LO_CRYPT_DES_EDE3, "DES_EDE3",24},
        { LO_CRYPT_DFC, "dfc",16 },
        { LO_CRYPT_IDEA, "idea",16},
+       { LO_CRYPT_RIJNDAEL, "rijndael", 16},
+       { LO_CRYPT_AES, "aes", 16},
        { -1, NULL,0   }
 };

@@ -267,6 +269,8 @@
        case LO_CRYPT_RC6:
        case LO_CRYPT_DES_EDE3:
        case LO_CRYPT_DFC:
+       case LO_CRYPT_RIJNDAEL:
+       case LO_CRYPT_AES:
                pass = getpass("Password :");
                strncpy(passwdbuff+1,pass,PASSWDBUFFLEN-1);
                passwdbuff[0] = 'A';

And in include/linux/loop.h in the kernel:

--- loop.h.orig Sat Dec 30 01:53:23 2000
+++ loop.h      Sat Dec 30 01:54:15 2000
@@ -106,6 +106,7 @@
 #define LO_CRYPT_DFC      15
 #define LO_CRYPT_RIJNDAEL 16
 #define LO_CRYPT_RC5      17
+#define LO_CRYPT_AES      18
 #define MAX_LO_CRYPT   20

 #ifdef __KERNEL__


--
Gisle Sælensminde ( gisle@ii.uib.no )

With sufficient thrust, pigs fly just fine. However, this is not
necessarily a good idea. It is hard to be sure where they are going
to land, and it could be dangerous sitting under them as they fly
overhead. (from RFC 1925)


Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001220172420</emailId><senderName>Marc Mutz</senderName><senderEmail>marc@mutz.com</senderEmail><timestampReceived>2000-12-20 17:24:20-0400</timestampReceived><subject>Re: Done tinkering</subject><body>

Chris Kuklewicz wrote:
&gt; 
&lt;snip&gt;
&gt; Do people want an improved version of losetup?  It could read the
&gt; /proc/crypto/cipher/ directory...but that would require loading the
&gt; module before running losetup (if you use modules...).
&gt; 

Alex is working on this, I guess.

&gt; Or it could have additional command line options to pass in the cipher
&gt; number and blocksize.  Then it would not need to be recompiled, and
&gt; overly paranoid people could use the longer cipher block sizes.
&gt; 

A little modules.conf magic will work when losetup tells the kernel the
cipher by name (someday soon?).

&gt; The current losetup has no command line flag to get the password or
&gt; the key from stdin or a file.  Hmmmm...
&gt; 

Patch exists. Was posted to this ml. Search the archive for "a better
util-linux.getpass.patch"

&gt; Stupid crypto question...are the -cbc versions useful to losetup?
&gt; 
loop_gen always uses CBC mode implicitely. You cannot tell it to use
another mode.

Are you by chance using an old version of the kerneli patch? Current is
2.2.17.10 or 2.2.18.3, depending upon whether you use kernels &lt; or =
2.2.18, resp.

Marc

-- 
Marc Mutz &lt;Marc@Mutz.com&gt;     http://EncryptionHOWTO.sourceforge.net/
University of Bielefeld, Dep. of Mathematics / Dep. of Physics

PGP-keyID's:   0xd46ce9ab (RSA), 0x7ae55b9e (DSS/DH)



Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001220080657</emailId><senderName>Gisle S{lensminde</senderName><senderEmail>gisle@ii.uib.no</senderEmail><timestampReceived>2000-12-20 08:06:57-0400</timestampReceived><subject>Re: Tinkering....</subject><body>

On Tue, 19 Dec 2000, Chris Kuklewicz wrote:

&gt; Thanks for the help.
&gt;
&gt; Midstream...as I work on util-linux....
&gt;
&gt; 1 fish, 2 fish, FISH2, TWOFISH, DUMMY ?
&gt;
&gt; #define CIPHER_RIJNDAEL 16
&gt; #define CIPHER_AES      18
&gt;
&gt; And then from linux/loop.h, 9 is DUMMY and 18 (AES) is not listed:
&gt;
&gt; #define LO_CRYPT_RIJNDAEL 16
&gt;
&gt; DUMMY does not look appetizing, but the module name is twofish.o, not
&gt; fish2.o

I have no idea why Rijndael and AES is assigned different numbers, since
Rijndael simply is the winner algorithm of the AES competition. AES should
therefore be an alias of Rijndael, not an independent cipher. The
insertion of an independent number for AES is a mistake IMHO.

&gt;
&gt; Currently lomount.c uses LO_CRYPT_FISH2, but that fails, so perhaps I
&gt; will try DUMMY...

Try to make an alias for Rijndeal instead:

in cipher.h:

#define CIPHER_RIJNDAEL 16
#define CIPHER_AES      CIPHER_RIJNDAEL

and in loop.h:

#define LO_CRYPT_RIJNDAEL 16
#define LO_CRYPT_AES      LO_CRYPT_RIJNDAEL


--
Gisle Sælensminde ( gisle@ii.uib.no )

With sufficient thrust, pigs fly just fine. However, this is not
necessarily a good idea. It is hard to be sure where they are going
to land, and it could be dangerous sitting under them as they fly
overhead. (from RFC 1925)


Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001220132718</emailId><senderName>Henry Spencer</senderName><senderEmail>henry@spsystems.net</senderEmail><timestampReceived>2000-12-20 13:27:18-0400</timestampReceived><subject>Re: Tinkering....</subject><body>

On Wed, 20 Dec 2000, Gisle S{lensminde wrote:
&gt; I have no idea why Rijndael and AES is assigned different numbers, since
&gt; Rijndael simply is the winner algorithm of the AES competition...

If memory serves, Rijndael has more options -- for things like key size --
than AES permits, so it is technically more accurate to say that AES is a
(slight) subset of Rijndael. 

                                                          Henry Spencer
                                                       henry@spsystems.net


Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001218090320</emailId><senderName>Chris Kuklewicz</senderName><senderEmail>chrisk@mit.edu</senderEmail><timestampReceived>2000-12-18 09:03:20-0400</timestampReceived><subject>Re: Almost working...</subject><body>

Okay...so I missed some documentation.  Documentation/crypto/faq.txt
helped get blowfish working.  And I found the error doucmented in the
last chapter (the FAQ) of the howto at EncryptionHOWTO.sourceforge.net.

So the revised question is: 

Out of curiousity, what non trivial work needs to be done to losetup
to add a cipher (e.g. twofish or aes)?

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001219165434</emailId><senderName>Marc Mutz</senderName><senderEmail>marc@mutz.com</senderEmail><timestampReceived>2000-12-19 16:54:34-0400</timestampReceived><subject>Re: Almost working...</subject><body>

Chris Kuklewicz wrote:
&gt; 
&gt; Okay...so I missed some documentation.  Documentation/crypto/faq.txt
&gt; helped get blowfish working.  And I found the error doucmented in the
&gt; last chapter (the FAQ) of the howto at EncryptionHOWTO.sourceforge.net.
&gt; 
&gt; So the revised question is:
&gt; 
&gt; Out of curiousity, what non trivial work needs to be done to losetup
&gt; to add a cipher (e.g. twofish or aes)?
&gt; 
&lt;snip&gt;

There is a list of known ciphers in lomount.c. You have to do the
obvious additions (just copy one of the existing lines and modify.
Keylength for Twofish is 128 or 256 bits, not sure if losetup works with
the latter.

Marc

-- 
Marc Mutz &lt;Marc@Mutz.com&gt;     http://EncryptionHOWTO.sourceforge.net/
University of Bielefeld, Dep. of Mathematics / Dep. of Physics

PGP-keyID's:   0xd46ce9ab (RSA), 0x7ae55b9e (DSS/DH)


Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001214124448</emailId><senderName>Alexander S A Kjeldaas</senderName><senderEmail>alexander.kjeldaas@fast.no</senderEmail><timestampReceived>2000-12-14 12:44:48-0400</timestampReceived><subject>Re: Ciphers which may sleep</subject><body>

On Thu, Dec 14, 2000 at 12:04:26PM +0100, Olaf Titz wrote:
&gt; As stated in &lt;linux/crypto.h&gt; the encrypt and decrypt functions of the
&gt; cipher implementations may sleep. This is very unfortunate, as there
&gt; is no way to use them in atomic context (e.g. network driver output
&gt; routine, required for CIPE etc.)
&gt; 
&gt; What is the actual state on this:
&gt; - Are there implementations which really do sleep? I can't think of a
&gt;   reason why they _have_ to.

Currently only to reduce latency.  Loopback crypto latency doesn't
look good on tests.  Also, I documented that these functions could
sleep to get users who can't have their crypto functions sleep out of
the wood :-).  The sleeping interface can be hooked up to harware
accelleration, while a non-sleeping version will have to be
implemented in software.

&gt; - Is there a way to find out whether an implementation does this?

It is done in crypto/gen_cbc.h for instance.  It checks
current-&gt;need_reshed and reshedules if needed.

&gt; - How can it be fixed? Usually this would require a GFP_* argument to
&gt;   each function which may allocate memory.

In the current implementation, getting a version that doesn't sleep
simply requires disabling the if (current-&gt;need_reshed) test.  This
can be implemented by having a flag in cipher_context telling the
cipher implementation to avoid sleeping.

However, in the future this means we always have to have a
software-version of any hardware-accellerated cipher, or _only_
provide hardware-accelleration using a work-queue interface where we
invoke a callback when the job is done.

astor

-- 
Alexander Kjeldaas                Mail:  astor@fast.no
finger astor@master.kernel.org for OpenPGP key.

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001214160357</emailId><senderName>Olaf Titz</senderName><senderEmail>olaf@bigred.inka.de</senderEmail><timestampReceived>2000-12-14 16:03:57-0400</timestampReceived><subject>Re: Ciphers which may sleep</subject><body>

&gt; In the current implementation, getting a version that doesn't sleep
&gt; simply requires disabling the if (current-&gt;need_reshed) test.  This

Is this enough? Sleeping can be achieved e.g. by sleep_on() which is a
common way for drivers, and calling this in an interrupt context
already causes a kernel panic. If we want to use the cipher in this
way we must have some means to either tell the cipher to never ever
sleep, or to have the cipher tell us whether it _can_ sleep (and then
reject to use it; to the user this behaviour is nonobvious and it does
not look good to have a cipher work or not depending on how it's
implemented).

&gt; However, in the future this means we always have to have a
&gt; software-version of any hardware-accellerated cipher, or _only_
&gt; provide hardware-accelleration using a work-queue interface where we
&gt; invoke a callback when the job is done.

Hm, didn't think about that. One easy possibility would be to put the
output packets in the (existing) input queue and handle them in the
ciped process context. However, this could increase packet output
latency by a degree I just don't want to bear, and it will definitely
interfere with any packet queuing mechanism the kernel employs itself.
A kernel thread would have the same problems.

A callback solution looks cleaner to me. A non sleeping software-only
solution could do that too, to avoid dealing with a double API.

Olaf

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001214175558</emailId><senderName>Alexander S A Kjeldaas</senderName><senderEmail>alexander.kjeldaas@fast.no</senderEmail><timestampReceived>2000-12-14 17:55:58-0400</timestampReceived><subject>Re: Ciphers which may sleep</subject><body>

On Thu, Dec 14, 2000 at 05:03:57PM +0100, Olaf Titz wrote:
&gt; &gt; In the current implementation, getting a version that doesn't sleep
&gt; &gt; simply requires disabling the if (current-&gt;need_reshed) test.  This
&gt; 
&gt; Is this enough? Sleeping can be achieved e.g. by sleep_on() which is a
&gt; common way for drivers, and calling this in an interrupt context
&gt; already causes a kernel panic. If we want to use the cipher in this
&gt; way we must have some means to either tell the cipher to never ever
&gt; sleep, or to have the cipher tell us whether it _can_ sleep (and then
&gt; reject to use it; to the user this behaviour is nonobvious and it does
&gt; not look good to have a cipher work or not depending on how it's
&gt; implemented).
&gt; 
&gt; &gt; However, in the future this means we always have to have a
&gt; &gt; software-version of any hardware-accellerated cipher, or _only_
&gt; &gt; provide hardware-accelleration using a work-queue interface where we
&gt; &gt; invoke a callback when the job is done.
&gt; 
&gt; Hm, didn't think about that. One easy possibility would be to put the
&gt; output packets in the (existing) input queue and handle them in the
&gt; ciped process context. However, this could increase packet output
&gt; latency by a degree I just don't want to bear, and it will definitely
&gt; interfere with any packet queuing mechanism the kernel employs itself.
&gt; A kernel thread would have the same problems.
&gt; 

Actually there are three possible interfaces.

 1) A software-based non-sleeping one.  You want this to encrypt
atomically.  However, encrypting 512 bytes in cbc-mode is something
you don't _want_ to do atomically because it takes too long, so you
have:

 2) A software-based sleeping one.  You want this to encrypt large
amounts of data with a simple interface.  This interface can support
hardware accelleration.  You want this when you don't want to loose
sight of a user-level process (for instance loopback block device).
This _might_ be due to a broken design though.

 3) A work-queue w/callback one.  You want this when dealing with the
network stack.  You don't care about processes.

&gt; A callback solution looks cleaner to me. A non sleeping software-only
&gt; solution could do that too, to avoid dealing with a double API.
&gt; 

For atomic operation we need special atomic software implementations,
and the current interface is a natural interface for this, so I don't
see the need for any change except making the rescheduling in the
ciphers optional.  Currently I feel that all three interfaces should
be supported.  Off the top of my head - something like:

struct cipher_implementation {
        ...

        int (*encrypt)(struct cipher_context *cx, 
                       const u8 *in, u8 *out, int size);

        int (*decrypt)(struct cipher_context *cx,
                       const u8 *in, u8 *out, int size);

        int (*set_key)(struct cipher_context *cx, 
                       unsigned char *key, int key_len);

        int (*encrypt_atomic)(struct cipher_context *cx, 
	                      const u8 *in, u8 *out, int size);

        int (*decrypt_atomic)(struct cipher_context *cx,
                              const u8 *in, u8 *out, int size);

        int (*set_key_atomic)(struct cipher_context *cx, 
	                      unsigned char *key, int key_len);

        int (*wq_encrypt)(struct cipher_context *cx,
                	  const u8 *in, u8 *out, int size,
			  void *cookie, void (*callback)(void *));

        int (*wq_decrypt)(struct cipher_context *cx,
                          const u8 *in, u8 *out, int size,
			  void *cookie, void (*callback)(void *));

        int (*wq_set_key)(struct cipher_context *cx,
			  unsigned char *key, int key_len,
			  void *cookie, void (*callback)(void *));

};


Most of these functions can point to defaults.  However, the *_encrypt
functions could be NULL, so find_cipher_by_name would have to take an
additional parameter indicating whether the cipher should support
atomic encryption.

static inline struct cipher_implementation *
find_cipher_by_name(const char *name, int atomic);


astor

-- 
Alexander Kjeldaas                Mail:  astor@fast.no
finger astor@master.kernel.org for OpenPGP key.

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001214175916</emailId><senderName>Alexander S A Kjeldaas</senderName><senderEmail>alexander.kjeldaas@fast.no</senderEmail><timestampReceived>2000-12-14 17:59:16-0400</timestampReceived><subject>Re: Ciphers which may sleep</subject><body>

On Thu, Dec 14, 2000 at 06:55:58PM +0100, Alexander S A Kjeldaas wrote:
&gt; 
&gt; Most of these functions can point to defaults.  However, the *_encrypt
                                                               ^^^^^^^
*_atomic

&gt; functions could be NULL, 

astor

-- 
Alexander Kjeldaas                Mail:  astor@fast.no
finger astor@master.kernel.org for OpenPGP key.

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001102224006</emailId><senderName>Gisle S{lensminde</senderName><senderEmail>gisle@ii.uib.no</senderEmail><timestampReceived>2000-11-02 22:40:06-0400</timestampReceived><subject>Re: Int Crypto Patch and FreeS/Wan</subject><body>

On Fri, 27 Oct 2000, William Ahern wrote:

&gt; On Friday 27 October 2000 00:56, you wrote:
&gt; &gt; On Thu, 26 Oct 2000, William Ahern wrote:
&gt; &gt; &gt; I have the 2.2.17 kernel, 2.2.17.9 international kernel patch and
&gt; &gt; &gt; frees/wan 1.6. any tips on how to get it to compile? DES, MD5 and SHA1
&gt; &gt; &gt; routines seems to be conflicting. everything compiles fine until it hits
&gt; &gt; &gt; these....
&gt; &gt; &gt;
&gt; &gt; &gt; i ran the freeswan-import script.... no beans....
&gt; &gt;
&gt; &gt; Could you please tell which symboles that are conflicting. It
&gt; &gt; would make it easier to find the problem and/or fix problems
&gt; &gt; in kerneli.
&gt; 
&gt; I've compiled w/ freeswan and the crypto patch, seperately. freeswan won't 
&gt; patch w/ the crypto patch already in, but the crypto patch will take after 
&gt; the freeswan patch. here are the compile errors:

I think the problem simply is that freeswan and kerneli use the same
names of functions and types. This is not surprising, since both have
used the most obvious names. 

This could be solved by one or both the following ways:

1. Kerneli stops exporting these symbols, and let all export happen
   through the cipher_implementation struct. This is allerady discussed on
   this list, and will not break any existing code AFAIK. There are
   already a patch for this submitted to this list, but is not in the
   kerneli patch yet.

2. Modify freeswan to use the crypto API.


1. is the quick soulution, while 2. is a more long-term goal IMHO.
They don't exclude each other, so both can be applied. We could of
cause start that process right now, but the problem is that freeswan
have faster implementations of 3DES, which is used for encryption,
and that implementation has a licence that is problemetic for
kerneli. A faster 3DES should therefore be implemented first.


--
Gisle Sælensminde ( gisle@ii.uib.no )   

With sufficient thrust, pigs fly just fine. However, this is not
necessarily a good idea. It is hard to be sure where they are going
to land, and it could be dangerous sitting under them as they fly
overhead. (from RFC 1925)



Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001113113959</emailId><senderName>Terrapin Station</senderName><senderEmail>sclam@singnet.com.sg</senderEmail><timestampReceived>2000-11-13 11:39:59-0400</timestampReceived><subject>File Encryption</subject><body>

hi all,


    I was wondering if anybody has come across an open source
implementation for Linux that does the following:

    1. Encrypt files based on individual users' keys (similar to that of
TCFS)

    2. There is no need to mount with a particular file system like TCFS
and CryptFS does. The user is able to create files ANYWHERE (where
permission is allowed) and the file will be encrypted with his/her key.

    3. The operation of encryption and decryption should be transparent
to the user. User should be able to work with the file(s) with any
application.

    4. Any temporary files , like ".filename.swp' created by "vi" should
also be encrypted.


    Well, maybe that was just a wish list, but if there is one, that
will be very nice indeed. Otherwise, I was thinking about writing one.
In that case, where do I start? Perhaps by working on the existing VFS?
Any suggestions?


Thank You


Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001113182106</emailId><senderName>Ahmed Warsame</senderName><senderEmail>awarsame@bbm.ca</senderEmail><timestampReceived>2000-11-13 18:21:06-0400</timestampReceived><subject>Linuxconfig</subject><body>



Whenever I run Linuxconf form the console and try to change something it
will disconnect all networks I don not understand why.

Using any other alternative is not interrupting my network.

FYI am using netemulator.

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001113115639</emailId><senderName></senderName><senderEmail>gshekar</senderEmail><timestampReceived>2000-11-13 11:56:39-0400</timestampReceived><subject>Re: File Encryption</subject><body>



&gt;2. There is no need to mount with a particular file system like TCFS
&gt;and CryptFS does. The user is able to create files ANYWHERE (where
&gt;permission is allowed) and the file will be encrypted with his/her key.
&gt;3. The operation of encryption and decryption should be transparent
&gt;to the user. User should be able to work with the file(s) with any
&gt;application.

How do you distinguish between ordinary files and encrypted files


Thanks and regards
Girish.c




Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001106094201</emailId><senderName>Marc Mutz</senderName><senderEmail>marc@mutz.com</senderEmail><timestampReceived>2000-11-06 09:42:01-0400</timestampReceived><subject>Fwd: Problems regarding loopback-crypto (was: Re: )</subject><body>

Hi Dave!

The first thing I would look into would be to use 2.2.17.10. Then, if
you have configured as modules, make sure you have them loaded. Also,
make sure the cryptoapi is functioning (look at /proc/crypto/ciphers/;
the cipher you want to use should be listed there.)

If these do not help, please send a complete command history of what you
did.

Marc


dave@damiel.freeserve.co.uk wrote:
&gt; 
&gt; Hi Marc,
&gt; 
&gt; I've been trying to get loopback encryption working. Details:
&gt; 
&gt;         kernel:                 2.2.17
&gt;         international patch:    2.2.17.9
&gt;         util-linux:             2.10p
&gt; 
&gt; I've followed the instructions as follows:
&gt; 
&gt;         - patch kernel source
&gt;         - configure and build kernel
&gt;         - reboot with new kernel
&gt;         - patch util-linux
&gt;         - build and install mount, umount, losetup
&gt; 
&gt; However, when I try to do losetup I get one of the errors reported in
&gt; the 'frequently asked questions' section of your Encryption HOWTO:
&gt; 
&gt;         ioctl: LOOP_SET_STATUS: Invalid argument
&gt; 
&gt; I've checked that this happens with each of the following ciphers:
&gt; 
&gt;         idea, DES, blowfish, twofish, cast128, serpent, mars
&gt; 
&gt; which suggests its something fundamental.
&gt; 
&gt; I've tried searching for a solution on the web, but have found nothing
&gt; particularly clear. There are a lot of posts about DES doing something
&gt; funny with getpass, but no indication that this would cause a problem
&gt; with the other ciphers. There were some posts in 1999 about there
&gt; being a fundamental incompatibility between the kernel and libc-2.0
&gt; regarding the definition of dev_t, which could cause problems with
&gt; loopback mounts. (My libc is at version 2.0.7.)
&gt; 
&gt; Any ideas?
&gt; 
&gt; Thanks,
&gt; Dave.

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001113133938</emailId><senderName>Alexander S A Kjeldaas</senderName><senderEmail>alexander.kjeldaas@fast.no</senderEmail><timestampReceived>2000-11-13 13:39:38-0400</timestampReceived><subject>Re: Concerning AES and -p option support in util-linux.patch</subject><body>

On Mon, Nov 13, 2000 at 11:22:23AM +0100, Marc Mutz wrote:
&gt; Hi Alex!
&gt; 
&gt; There are currently many mails reaching me that claim that AES is not
&gt; supported and that there is no -p option in losetup, like I said in the
&gt; howto. The latter stems from the fact that aeb has not included the
&gt; correspondig patch I sent to him. A reason he did not give to me. The
&gt; former is just a slip in the util-linux.patch: The obvious line for AES
&gt; is missing from the list of known ciphers in lomount.c.
&gt; 
&gt; I think, it would be a good idea to add that line and make a 17.11, even
&gt; if that remains the only change.
&gt; If you like, you can include the patch I sent to you some time ago that
&gt; adds support for a -p option to losetup (for reading the passphrase from
&gt; a given file descriptor). You then said that this does not belong to the
&gt; realm of the international util-linux patch, but I think aeb waits for
&gt; that patch to be submitted for inclusion in the mainstream util-linux,
&gt; or so I understood him, though he didn't say it openly. So we may as
&gt; well collect the changes to util-linux in the patch and then submit it
&gt; together to aeb.
&gt; 

Could you send me that patch again? I can't find it.

astor

-- 
Alexander Kjeldaas                Mail:  astor@fast.no
finger astor@master.kernel.org for OpenPGP key.

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001113175702</emailId><senderName></senderName><senderEmail>stephan.eckner</senderEmail><timestampReceived>2000-11-13 17:57:02-0400</timestampReceived><subject>Kein Krypto Vortrag am 14.11 (morgen)</subject><body>

Hi 

bin gerade ein bischen angeschlagen (Erkaeltung)
Deshalb kein Vortrag Morgen :(

Aber naechste Woche

bestimmt :))

Gruss

Stephan 

-- 
stephan.eckner@innominate.com
dipl.-math.                                              innominate AG
system engineer                                   the linux architects
tel: +49.30.308806-354  fax: -77             http://www.innominate.com


Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001113225747</emailId><senderName>Marc Mutz</senderName><senderEmail>marc@mutz.com</senderEmail><timestampReceived>2000-11-13 22:57:47-0400</timestampReceived><subject>Re: File Encryption</subject><body>

Terrapin Station wrote:
&gt; 
&gt; hi all,
&gt; 
&gt;     I was wondering if anybody has come across an open source
&gt; implementation for Linux that does the following:
&gt; 
&gt;     1. Encrypt files based on individual users' keys (similar to that of
&gt; TCFS)
&gt; 
&gt;     2. There is no need to mount with a particular file system like TCFS
&gt; and CryptFS does. The user is able to create files ANYWHERE (where
&gt; permission is allowed) and the file will be encrypted with his/her key.
&gt; 
&gt;     3. The operation of encryption and decryption should be transparent
&gt; to the user. User should be able to work with the file(s) with any
&gt; application.
&gt; 

You could code up such a thing with podfuk a.k.a. userfs and gnupg, I
guess.

&gt;     4. Any temporary files , like ".filename.swp' created by "vi" should
&gt; also be encrypted.
&gt; 
A loopback encrypted /tmp would be the only thing I can think of.

&gt;     Well, maybe that was just a wish list, but if there is one, that
&gt; will be very nice indeed. Otherwise, I was thinking about writing one.
&gt; In that case, where do I start? Perhaps by working on the existing VFS?
&gt; Any suggestions?
&gt; 
There is said userfs. It can be used like the following, IIRC:

user$ ls /path/to/file.tar.gz#.
file1	file2	file3

You shoud be able to extend that to encryption via gnupg.

Marc

-- 
Marc Mutz &lt;Marc@Mutz.com&gt;     http://EncryptionHOWTO.sourceforge.net/
University of Bielefeld, Dep. of Mathematics / Dep. of Physics

PGP-keyID's:   0xd46ce9ab (RSA), 0x7ae55b9e (DSS/DH)


Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001113232459</emailId><senderName>Marc Mutz</senderName><senderEmail>marc@mutz.com</senderEmail><timestampReceived>2000-11-13 23:24:59-0400</timestampReceived><subject>Re: Linuxconfig</subject><body>

Ahmed Warsame wrote:
&gt; 
&gt; Whenever I run Linuxconf form the console and try to change something it
&gt; will disconnect all networks I don not understand why.
&gt; 
&gt; Using any other alternative is not interrupting my network.
&gt; 
&gt; FYI am using netemulator.
&gt; 
&lt;snip&gt;

Either

a) You posted to the wrong list
b) I don't know netemulator. Maybe it has to do with crypto.
c) You gave too few details.

or any subset thereof.

Marc

-- 
Marc Mutz &lt;Marc@Mutz.com&gt;     http://EncryptionHOWTO.sourceforge.net/
University of Bielefeld, Dep. of Mathematics / Dep. of Physics

PGP-keyID's:   0xd46ce9ab (RSA), 0x7ae55b9e (DSS/DH)



Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001113232907</emailId><senderName>Marc Mutz</senderName><senderEmail>marc@mutz.com</senderEmail><timestampReceived>2000-11-13 23:29:07-0400</timestampReceived><subject>[RESENT][PATCH] A better util-linux.getpass.patch</subject><body>

Hi Alex!

I've implemented the
Q&gt; --pass-fd &lt;num&gt;
alias
Q&gt; -p &lt;num&gt;
option for both mount(8) and losetup(8). It expects a number (&lt;num&gt;) as
argument and instructs mount/losetup to read the passphrase from file
descriptor &lt;num&gt; instead of from the terminal. man pages have been
updated, too. I have tested the xgetpass() routine both with a
passphrase below 128 bytes and with the to-do-list I sent you some days
ago with every newline removed, like
Q&gt; cat my-ikp-todo.txt | tr -d $'\n' | \
Q&gt; losetup -e blowfish -p 0 /dev/loop0 crypto-file
It works!

Also, it teaches losetup long options, see losetup.8 for more.

The patch applies to util-linux-2.10o, patched with the patch from
2.2.17.3. It will conflict with Gisle's and my previous stuff, no doubt.
but AFAICS, only in the switch statement, where my patch is trivial:
Just
Q&gt; getpass("...")-&gt;xgetpass(pfd,"...")
everywhere. Please consider applying. if it makes too much noise when
patching, I'll rediff against 17.4 when that is out.


Marc

PS: I have also fixed the loop vs. remount bug described in my todo
list. A patch to Andries has been sent and he applied it. It is a
two-liner in mount.c:try_mount_one() and thus will not collide with the
kerneli-util-linux patches. But the difference in remount loop semantics
is _great_.

-- 
Marc Mutz &lt;Marc@Mutz.com&gt;        http://marc.mutz.com/Encryption-HOWTO/
University of Bielefeld, Dep. of Mathematics / Dep. of Physics

PGP-keyID's:   0xd46ce9ab (RSA), 0x7ae55b9e (DSS/DH)

["util-linux-2.10o-passfd.patch;" (text/plain)]

diff -urN util-linux-2.10o.i3/mount/lomount.c util-linux-2.10o.i3-getpass/mount/lomount.c
--- util-linux-2.10o.i3/mount/lomount.c	Sun Sep 24 16:46:02 2000
+++ util-linux-2.10o.i3-getpass/mount/lomount.c	Sun Sep 24 23:26:00 2000
@@ -6,6 +6,11 @@
  * - added Native Language Support
  * Sun Mar 21 1999 - Arnaldo Carvalho de Melo &lt;acme@conectiva.com.br&gt;
  * - fixed strerr(errno) in gettext calls
+ * 2000-09-24 Marc Mutz &lt;Marc@Mutz.com&gt;
+ * - added long option names and the --pass-fd option to pass
+ *   passphrases via fd's to losetup/mount. Used for encryption in
+ *   non-interactive environments. The idea behind xgetpass() is stolen
+ *   from GnuPG, v.1.0.3 (http://www.gnupg.org/).
  */
 
 #define PROC_DEVICES	"/proc/devices"
@@ -176,9 +181,47 @@
 	return 0;
 }
 
+/* A function to read the passphrase either from the terminal or from
+ * an open file descriptor */
+static char *
+xgetpass (int pfd, const char *prompt)
+{
+        if (pfd &lt; 0) /* terminal */
+	        return (getpass(prompt));
+	else {       /* file descriptor */
+	        char *pass = NULL;
+		int buflen, i;
+
+		buflen=0;
+		for (i=0; ; i++) {
+		        if (i &gt;= buflen-1) {
+		                /* we're running out of space in the buffer. 
+				 * Make it bigger: */
+		                char *tmppass = pass;
+				buflen += 128;
+				pass = realloc(tmppass,buflen);
+				if (pass == NULL) {
+					/* realloc failed. Stop reading _now_. */
+			                error("not enough memory while reading passphrase");
+					pass = tmppass; /* the old buffer hasn't changed */
+					break;
+				}
+			};
+			if ( read(pfd,pass+i, 1) != 1 || pass[i] == '\n' )
+			        break;
+		}
+		if (pass == NULL)
+		        return "";
+		else {
+		        pass[i] = 0;
+		        return pass;
+		}
+	}
+}
+
 int
 set_loop (const char *device, const char *file, int offset,
-	  const char *encryption, int *loopro) {
+	  const char *encryption, int pfd, int *loopro) {
 	struct loop_info loopinfo;
 	int fd, ffd, mode, i;
 	char *pass;
@@ -227,14 +270,16 @@
 		loopinfo.lo_encrypt_key_size = 0;
 		break;
 	case LO_CRYPT_XOR:
-		pass = getpass (_("Password: "));
+          /* WARNING: xgetpass() can return massive amounts of data,
+           * not only 128 bytes like the original getpass(3) */
+		pass = xgetpass (pfd,_("Password: "));
 		strncpy (loopinfo.lo_encrypt_key, pass, LO_KEY_SIZE);
 		loopinfo.lo_encrypt_key[LO_KEY_SIZE - 1] = 0;
 		loopinfo.lo_encrypt_key_size = strlen(loopinfo.lo_encrypt_key);
 		break;
 	case LO_CRYPT_DES:
 		printf(_("WARNING: Use of DES is depreciated.\n"));
-		pass = getpass (_("Password: "));
+		pass = xgetpass (pfd,_("Password: "));
 		strncpy (loopinfo.lo_encrypt_key, pass, 8);
 		loopinfo.lo_encrypt_key[8] = 0;
 		loopinfo.lo_encrypt_key_size = 8;
@@ -252,7 +297,7 @@
 		break;
 	case LO_CRYPT_FISH2:
 	case LO_CRYPT_BLOW:
-		pass = getpass("Password :");
+		pass = xgetpass(pfd,_("Password :"));
 		MDcalc((byte *)loopinfo.lo_encrypt_key,pass,strlen(pass));
 		loopinfo.lo_encrypt_key_size=20; /* 160 Bit key */
 		break;
@@ -262,7 +307,7 @@
 	case LO_CRYPT_MARS:
 	case LO_CRYPT_RC6:
 	case LO_CRYPT_DFC:
-		pass = getpass("Password :");
+		pass = xgetpass(pfd,_("Password :"));
 		MDcalc((byte *)loopinfo.lo_encrypt_key,pass,strlen(pass));
 		loopinfo.lo_encrypt_key_size=16; /* 128 Bit key */
 		break;
@@ -319,7 +364,7 @@
 
 int
 set_loop (const char *device, const char *file, int offset,
-	  const char *encryption, int *loopro) {
+	  const char *encryption, int pfd, int *loopro) {
 	mutter();
 	return 1;
 }
@@ -348,20 +393,34 @@
 int verbose = 0;
 static char *progname;
 
+static struct option longopts[] = {
+	{ "delete", 0, 0, 'd' },
+	{ "detach", 0, 0, 'd' },
+	{ "encryption", 1, 0, 'e' },
+	{ "help", 0, 0, 'h' },
+	{ "offset", 1, 0, 'o' },
+	{ "pass-fd", 1, 0, 'p' },
+	{ "verbose", 0, 0, 'v' },
+	{ NULL, 0, 0, 0 }
+};
+
+
 static void
 usage(void) {
-	struct crypt_type_struct *c;
 	fprintf(stderr, _("usage:\n\
   %s loop_device                                      # give info\n\
   %s -d loop_device                                   # delete\n\
-  %s [ -e encryption ] [ -o offset ] loop_device file # setup\n"),
+  %s [ options ] loop_device file                     # setup\n\
+    where options include\n\
+    --offset &lt;num&gt;, -o &lt;num&gt;\n\
+        start at offset &lt;num&gt; into file.\n\
+    --pass-fd &lt;num&gt;, -p &lt;num&gt;\n\
+        read passphrase from file descriptor &lt;num&gt;\n\
+        instead of the terminal.\n\
+    --encryption &lt;cipher&gt;, -e &lt;cipher&gt;\n\
+        encrypt with &lt;cipher&gt;.\n\
+        Check /proc/cipher for available ciphers."),
 		progname, progname, progname);
-	fprintf(stderr, "    where encryption is one of:\n");
-	c = &amp;crypt_type_tbl[0];
-	while(c-&gt;name) {
-		fprintf(stderr, "       %s\n", c-&gt;name);
-		c++;
-	}
 	exit(1);
 }
 
@@ -394,8 +453,9 @@
 
 int
 main(int argc, char **argv) {
-	char *offset, *encryption;
+	char *offset, *encryption, *passfd;
 	int delete,off,c;
+	int pfd = -1; 
 	int res = 0;
 	int ro = 0;
 
@@ -404,9 +464,10 @@
 	textdomain(PACKAGE);
 
 	delete = off = 0;
-	offset = encryption = NULL;
+	offset = encryption = passfd = NULL;
 	progname = argv[0];
-	while ((c = getopt(argc,argv,"de:o:v")) != EOF) {
+	while ((c = getopt_long(argc,argv,"de:ho:p:v",
+				longopts, NULL)) != EOF) {
 		switch (c) {
 		case 'd':
 			delete = 1;
@@ -417,6 +478,9 @@
 		case 'o':
 			offset = optarg;
 			break;
+		case 'p':
+		        passfd = optarg;
+			break;
 		case 'v':
 			verbose = 1;
 			break;
@@ -425,7 +489,7 @@
 		}
 	}
 	if (argc == 1) usage();
-	if ((delete &amp;&amp; (argc != optind+1 || encryption || offset)) ||
+	if ((delete &amp;&amp; (argc != optind+1 || encryption || offset || passfd)) ||
 	    (!delete &amp;&amp; (argc &lt; optind+1 || argc &gt; optind+2)))
 		usage();
 	if (argc == optind+1) {
@@ -436,7 +500,9 @@
 	} else {
 		if (offset &amp;&amp; sscanf(offset,"%d",&amp;off) != 1)
 			usage();
-		res = set_loop(argv[optind],argv[optind+1],off,encryption,&amp;ro);
+		if (passfd &amp;&amp; sscanf(passfd,"%d",&amp;pfd) != 1)
+		        usage();
+		res = set_loop(argv[optind],argv[optind+1],off,encryption,pfd,&amp;ro);
 	}
 	return res;
 }
diff -urN util-linux-2.10o.i3/mount/lomount.h util-linux-2.10o.i3-getpass/mount/lomount.h
--- util-linux-2.10o.i3/mount/lomount.h	Fri Jul  9 04:56:39 1999
+++ util-linux-2.10o.i3-getpass/mount/lomount.h	Sun Sep 24 17:20:01 2000
@@ -1,4 +1,4 @@
 extern int verbose;
-extern int set_loop (const char *, const char *, int, const char *, int *);
+extern int set_loop (const char *, const char *, int, const char *, int, int *);
 extern int del_loop (const char *);
 extern char * find_unused_loop_device (void);
diff -urN util-linux-2.10o.i3/mount/losetup.8 util-linux-2.10o.i3-getpass/mount/losetup.8
--- util-linux-2.10o.i3/mount/losetup.8	Sun Sep 24 16:46:02 2000
+++ util-linux-2.10o.i3-getpass/mount/losetup.8	Sun Sep 24 23:01:14 2000
@@ -10,6 +10,9 @@
 ] [
 .B \-o
 .I offset
+] [
+.B \-p
+.I num
 ]
 .I loop_device file
 .br
@@ -26,9 +29,9 @@
 \fIloop_device\fP argument is given, the status of the corresponding loop
 device is shown.
 .SH OPTIONS
-.IP \fB\-d\fP
+.IP "\fB\-\-delete, \-\-detach, \-d\fP"
 detach the file or device associated with the specified loop device.
-.IP "\fB\-e \fIencryption\fP"
+.IP "\fB\-\-encryption, \-e \fIencryption\fP"
 .RS
 enable data encryption. The following keywords are recognized:
 .IP \fBNONE\fP
@@ -79,9 +82,12 @@
 enabled in the Crypto API.
 .PD
 .RE
-.IP "\fB\-o \fIoffset\fP"
+.IP "\fB\-\-offset, \-o \fIoffset\fP"
 the data start is moved \fIoffset\fP bytes into the specified file or
 device.
+.IP "\fB\-\-pass-fd, \-p \fInum\fP"
+read the passphrase from file descriptor \fInum\fP instead of the
+terminal.
 .SH RETURN VALUE
 .B losetup
 returns 0 on success, nonzero on failure. When
diff -urN util-linux-2.10o.i3/mount/mount.8 util-linux-2.10o.i3-getpass/mount/mount.8
--- util-linux-2.10o.i3/mount/mount.8	Sun Jul 30 22:26:41 2000
+++ util-linux-2.10o.i3-getpass/mount/mount.8	Sun Sep 24 23:19:47 2000
@@ -252,6 +252,12 @@
 .B \-v
 Verbose mode.
 .TP
+.B \-p "\fInum\fP"
+If the mount requires a passphrase to be entered, read it from file
+descriptor
+.IR num\fP
+instead of from the terminal.
+.TP
 .B \-a
 Mount all filesystems (of the given types) mentioned in
 .IR fstab .
@@ -1240,7 +1246,10 @@
 .BR loop ", " offset " and " encryption ,
 that are really options to
 .BR losetup (8).
-If no explicit loop device is mentioned
+If the mount requires a passphrase, you will be prompted for one unless
+you specify a file descriptor to read from instead with the 
+.BR \-\-pass-fd
+option. If no explicit loop device is mentioned
 (but just an option `\fB\-o loop\fP' is given), then
 .B mount
 will try to find some unused loop device and use that.
diff -urN util-linux-2.10o.i3/mount/mount.c util-linux-2.10o.i3-getpass/mount/mount.c
--- util-linux-2.10o.i3/mount/mount.c	Fri Aug 11 14:50:10 2000
+++ util-linux-2.10o.i3-getpass/mount/mount.c	Sun Sep 24 23:24:09 2000
@@ -105,6 +105,9 @@
 /* True if ruid != euid.  */
 static int suid = 0;
 
+/* Contains the fd no. to read the passphrase from, if any */
+static int pfd = -1;
+
 /* Map from -o and fstab option strings to the flag argument to mount(2).  */
 struct opt_map {
   const char *opt;		/* option name */
@@ -536,7 +539,7 @@
       if (verbose)
 	printf(_("mount: going to use the loop device %s\n"), *loopdev);
       offset = opt_offset ? strtoul(opt_offset, NULL, 0) : 0;
-      if (set_loop (*loopdev, *loopfile, offset, opt_encryption, &amp;loopro)) {
+      if (set_loop (*loopdev, *loopfile, offset, opt_encryption, pfd, &amp;loopro)) {
 	if (verbose)
 	  printf(_("mount: failed setting up loop device\n"));
 	return EX_FAIL;
@@ -1226,6 +1229,7 @@
 	{ "read-write", 0, 0, 'w' },
 	{ "rw", 0, 0, 'w' },
 	{ "options", 1, 0, 'o' },
+	{ "pass-fd", 1, 0, 'p' },
 	{ "types", 1, 0, 't' },
 	{ "bind", 0, 0, 128 },
 	{ "replace", 0, 0, 129 },
@@ -1259,7 +1263,7 @@
 	  "or by label, using  -L label  or by uuid, using  -U uuid .\n"
 	  "Union or stack mounts are specified using one of\n"
 	  "       --replace, --after, --before, --over\n"
-	  "Other options: [-nfFrsvw] [-o options].\n"
+	  "Other options: [-nfFrsvw] [-o options] [-p num].\n"
 	  "For many more details, say  man 8 mount .\n"
 	));
 	unlock_mtab();
@@ -1271,6 +1275,7 @@
 	int c, result = 0, specseen;
 	char *options = NULL, *spec, *node;
 	char *volumelabel = NULL;
+	char *passfd = NULL;
 	char *uuid = NULL;
 	string_list types = NULL;
 	struct mntentchn *mc;
@@ -1291,7 +1296,7 @@
 	initproctitle(argc, argv);
 #endif
 
-	while ((c = getopt_long (argc, argv, "afFhlL:no:rsU:vVwt:",
+	while ((c = getopt_long (argc, argv, "afFhlL:no:p:rsU:vVwt:",
 				 longopts, NULL)) != EOF) {
 		switch (c) {
 		case 'a':		/* mount everything in fstab */
@@ -1321,6 +1326,9 @@
 			else
 				options = xstrdup(optarg);
 			break;
+		case 'p':               /* read passphrase from given fd */
+		        passfd = optarg;
+			break;
 		case 'r':		/* mount readonly */
 			readonly = 1;
 			readwrite = 0;
@@ -1405,6 +1413,9 @@
 			printf(_("mount: mounting %s\n"), spec);
 	} else
 		spec = NULL;		/* just for gcc */
+
+	if (passfd &amp;&amp; sscanf(passfd,"%d",&amp;pfd) != 1)
+	        die (EX_USAGE, _("mount: argument to --pass-fd or -p must be a number"));
 
 	switch (argc+specseen) {
 	case 0:


Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20001123191518</emailId><senderName>Marc Mutz</senderName><senderEmail>marc@mutz.com</senderEmail><timestampReceived>2000-11-23 19:15:18-0400</timestampReceived><subject>Re: ppdd</subject><body>

Louis Lam wrote:
&gt; 
&gt; hi,
&gt; 
&gt; I was able to use ppdd to get an encrypted root file system and swap
&gt; partition. Both the root file system and the swap were formatted with a
&gt; blocksize of 1024 as suggested.
&gt; 
&gt; Is there anyone in this list who is able to get encrypted root and swap that
&gt; are based on blocksize of 4096?
&lt;snip&gt;

I hope this message from the ppdd mailing list answers your question,
but probably not as you wished:

"Michael H. Warfield" wrote:
&gt; 
&gt; On Fri, Jun 02, 2000 at 09:29:32AM +1000, Bob Hepple wrote:
&gt; &gt; Nathaniel Daw wrote:
&gt; 
&gt; &gt; &gt; hey,
&gt; 
&gt; &gt; &gt; I'm new to the list but have been watching several days for the answer
&gt; &gt; &gt; to this probably common question: I'm thinking of bumping my kernel up
&gt; &gt; &gt; to a 2.3/2.4 prerelease &amp; I want to bring my encrypted disks with
&gt; &gt; &gt; me. I was planning on seeing if I could get the old ppdd patches to
&gt; &gt; &gt; apply, but I wonder if (a) anyone has already done this work, or (b)
&gt; &gt; &gt; anyone knows of any major gotchas that will bite me if I try to do
&gt; &gt; &gt; this. Should it go smoothly?
&gt; 
&gt; &gt; For what it's worth, I did 2.2.14 with no problems - except I can't
&gt; &gt; mount partitions greater than 500Mb - is this a known problem.
&gt; 
&gt;         It's probably an RTFM, but it's not obvious.  Partitions greater
&gt; than about 500Meg are going to get build with a block size other then
&gt; 1024.  They will most likely end with with a block size of 4096 or 8192.
&gt; The doco's are pretty clear that ppdd is busted for anything other than
&gt; block size of 1024 (THIS NEEDS TO BE FIXED!).  You have to rebuild the
&gt; filesystem (mke2fs) with a block size of 1024.  WARNING - this WILL destroy
&gt; everything on the filesystem!
&gt; 
&gt;         My laptop is even worse.  The 12Gig drive insists on a transfer
&gt; size of 4096 to and from the IDE drive.  That means I have to rebuild ALL
&gt; of my partitions for 1024 block size, but the drive itself is NOT 1024,
&gt; it's 4096.  Then I have to specify a transfer block size of 4096 when
&gt; initializing and starting ppdd.  Sigh...
&gt; 
&gt;         If you are going to use the block size option to the ppdd utilities
&gt; be forewarned that there are parsing bugs.  The utilities expect exact
&gt; parameter counts and that screws up depending on whether or not you combine
&gt; parameters in the way the program expects.
&gt; 
&gt; &gt; I also used the USB patches from www.linux-usb.org with no conflict, so
&gt; &gt; if you only want 2.3/4 for USB you might be able to scrape by.
&gt; &gt;
&gt; &gt; Bob
&gt; &gt;
&gt; &gt; --
&gt; &gt; Bob Hepple
&gt; &gt; mailto:bhepple@bit.net.au
&gt; 
&gt;         Mike
&gt; --
&gt;  Michael H. Warfield    |  (770) 985-6132   |  mhw@WittsEnd.com
&gt;   (The Mad Wizard)      |  (770) 331-2437   |  http://www.wittsend.com/mhw/
&gt;   NIC whois:  MHW9      |  An optimist believes we live in the best of all
&gt;  PGP Key: 0xDF1DD471    |  possible worlds.  A pessimist is sure of it!

Marc

-- 
Marc Mutz &lt;Marc@Mutz.com&gt;     http://EncryptionHOWTO.sourceforge.net/
University of Bielefeld, Dep. of Mathematics / Dep. of Physics

PGP-keyID's:   0xd46ce9ab (RSA), 0x7ae55b9e (DSS/DH)


Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001124113452</emailId><senderName>Gisle S{lensminde</senderName><senderEmail>gisle@ii.uib.no</senderEmail><timestampReceived>2000-11-24 11:34:52-0400</timestampReceived><subject>Re: AES</subject><body>

On Thu, 23 Nov 2000, John Kennedy wrote:

&gt; On Mon, Nov 06, 2000 at 10:34:54AM +0100, Marc Mutz wrote:
&gt; &gt; Emil wrote:
&gt; &gt; &gt; util-linux-2.10o.int.patch still doesn't include the AES encryption
&gt; &gt; &gt; Anyone plans to do it ?
&gt; &gt;
&gt; &gt; You can easily add it to the list of known ciphers in
&gt; &gt; util-linux/mount/lomount.c
&gt; &gt; Then re-compile both mount and losetup.
&gt;
&gt;   I've been looking into what I would have to do to try and enable that.
&gt; Right now I'm using serpent (in the readme and in the source, plus
&gt; it works), but AES is supposed to be much faster (looking at NIST's
&gt; benchmarks).

Well, not much in kerneli. The reason for that is that serpent is very
well optimised, but rijndael is not that well optimised. The reason for
that is that serpent is more "compiler frendly" than rijndael. To get a
really fast rijndael implementation, we must implement one in assembly.


--
Gisle Sælensminde ( gisle@ii.uib.no )

With sufficient thrust, pigs fly just fine. However, this is not
necessarily a good idea. It is hard to be sure where they are going
to land, and it could be dangerous sitting under them as they fly
overhead. (from RFC 1925)


Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001127061614</emailId><senderName>"Louis Lam"</senderName><senderEmail>lsauchun@hotmail.com</senderEmail><timestampReceived>2000-11-27 06:16:14-0400</timestampReceived><subject>Where is the ppdd mailing list archive?</subject><body>

Hi,

Just like to know where is the PPDD mailing list archive where previous 
messages from the mailing list are stored.

Thanks

Louis



_____________________________________________________________________________________
Get more from the Web.  FREE MSN Explorer download : http://explorer.msn.com


Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001127150044</emailId><senderName>Marc Mutz</senderName><senderEmail>marc@mutz.com</senderEmail><timestampReceived>2000-11-27 15:00:44-0400</timestampReceived><subject>Re: [PPDD] Where is the ppdd mailing list archive?</subject><body>

Louis Lam wrote:
&gt; 
&gt; Hi,
&gt; 
&gt; Just like to know where is the PPDD mailing list archive where previous
&gt; messages from the mailing list are stored.
&gt; 
&lt;snip&gt;

http://marc.theaimsgroup.com should have them.

Marc

-- 
Marc Mutz &lt;Marc@Mutz.com&gt;     http://EncryptionHOWTO.sourceforge.net/
University of Bielefeld, Dep. of Mathematics / Dep. of Physics

PGP-keyID's:   0xd46ce9ab (RSA), 0x7ae55b9e (DSS/DH)



Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001129114333</emailId><senderName>Alexander S A Kjeldaas</senderName><senderEmail>alexander.kjeldaas@fast.no</senderEmail><timestampReceived>2000-11-29 11:43:33-0400</timestampReceived><subject>Re: Intl. patch 2.2.17.11pre1</subject><body>

On Tue, Nov 28, 2000 at 07:39:24PM -0800, John Kennedy wrote:
&gt; On Tue, Nov 28, 2000 at 07:33:51PM +0100, Alexander S A Kjeldaas wrote:
&gt; &gt; Forgot to mention this.. it's not in the kernel/crypto directory, but
&gt; &gt; rather in:
&gt; &gt; 
&gt; &gt; ftp://ftp.kernel.org/pub/linux/kernel/people/astor/v2.2/
&gt; 
&gt;   I think Alan has been backporting some code.  I've needed this with
&gt; everything I've tried against 2.2.18pre* so far.

Ok.

astor

-- 
Alexander Kjeldaas                Mail:  astor@fast.no
finger astor@master.kernel.org for OpenPGP key.

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001123124549</emailId><senderName>"Louis Lam"</senderName><senderEmail>lsauchun@hotmail.com</senderEmail><timestampReceived>2000-11-23 12:45:49-0400</timestampReceived><subject>ppdd</subject><body>

hi,

I was able to use ppdd to get an encrypted root file system and swap 
partition. Both the root file system and the swap were formatted with a 
blocksize of 1024 as suggested.

Is there anyone in this list who is able to get encrypted root and swap that 
are based on blocksize of 4096?

I am still trying to do that but so far I wasn't able to do so. I understand 
that using the blocksize of 4096 may not be so efficient for random access. 
More will have to be decrypted before u can get to the part of the block 
that U want. The reason I want to do this is just for seeing the difference, 
and maybe able to encrypt some existing data which is actually a linux 
installation from redhat 6.2 which by default formats the partition with a 
blocksize of 4096.

Thanks &amp;

Happy Thanksgiving

Louis


_____________________________________________________________________________________
Get more from the Web.  FREE MSN Explorer download : http://explorer.msn.com


Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001106093454</emailId><senderName>Marc Mutz</senderName><senderEmail>marc@mutz.com</senderEmail><timestampReceived>2000-11-06 09:34:54-0400</timestampReceived><subject>Re: AES</subject><body>

Emil wrote:
&gt; 
&gt; util-linux-2.10o.int.patch still doesn't include the AES encryption
&gt; Anyone plans to do it ?
&gt; 
&gt; --
&gt;                                                                 Regards,
&gt;                                                                 Emil
&lt;snip&gt;

You can easily add it to the list of known ciphers in
util-linux/mount/lomount.c
Then re-compile both mount and losetup.

Marc

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001128144758</emailId><senderName>Alexander S A Kjeldaas</senderName><senderEmail>alexander.kjeldaas@fast.no</senderEmail><timestampReceived>2000-11-28 14:47:58-0400</timestampReceived><subject>Intl. patch 2.2.17.11pre1</subject><body>


A new prepatch is out.  I have made it a prepatch because it includes
more changes than normal, and also because some more changes are
needed before a new stable patch can be released.

Short list of changes:

o New util-linux patch (util-linux-2.10o.int2).  You need to recompile
  util-linux using this patch!

o key schedule size and declarations for ciphers/digests moved out of
crypto.h

o New functions in cipher_implementation
   - realloc_context - to (re)allocate a cipher_context
   - wipe_context    - to wipe a cipher_context
   - free_context    - to free a cipher_context
  Cipher-implementations with fixed size key schedules don't have to
  provide any of the above, and default implementation will be provided.

o find_transfer_by_name now tries to load missing ciphers/digests.

o ECB ciphers now called &lt;name&gt;-ecb, not just &lt;name&gt;.

o Lots of functions that should be static are now static.  No more
conflicts with freeswan over the SHA/MD5.

o loop_gen.c is no more.  Integrated loop_gen.c with loop.c.  Reverted
a lot of changes to loop.{c,h} - It is now pretty much like vanilla
linux 2.2.x.


-----


Based on some feedback I got from people trying to write plugins to
the cryptoapi, it became evident that the current scheme for finding
ciphers is inadequate.  We now have two ways of finding ciphers/digests:

find_{cipher,digest}_by_id, and
find_{cipher,digest}_by_name

The problem is that the id scheme isn't useful for plug-ins.  It also
means we have to have translation tables all over the place
translating from cipher name to id.  Generally, a system where all
ciphers have to register an ID is very cumbersome.  Just look at how
we deal with ciphers in the case of losetup:

- We have /etc/modules.conf which has a mapping:
   - from loop_xfer_number -&gt; loop_xfer_module
   - from cipher_id -&gt; cipher
   - from digest_id -&gt; digest

- We have losetup which has a mapping from loop_xfer_number -&gt; name
  of cipher and keysize in order to handle user-interface issues and
  to make sure that it gives enough key data to the kernel.

- We have the loop_gen module registering a number of loop_xfers in
  the loop module and then translating the xfer number to the
  corresponding cipher number.

:-)

Quite messy.  It is the loopback system which led to these problems.
If we can get losetup to use _strings_ to select its cipher, _none_ of
the above tables would be needed anymore, we could support plug-in
crypto modules more easily, and we wouldn't have to keep losetup in
synch with the kernel all the time.

This patch does this by killing the old loop_gen.c stuff, and adding a
new loop_xfer called LO_CRYPT_CRYPTOAPI.  It works like this: There is
a field in struct loop_status (used to set password, transfer type
etc.) called lo_name which contains the path of the underlying file.
It seems that this field is not used by the kernel in any way, and is
just an old workaround for not having dentries in early linux kernels.
So when user-space requests to set up a transfer of type
LO_CRYPT_CRYPTOAPI, we expect the name of the cipher to be specified
in this field.  This is all handled in the init-function of the
LO_CRYPT_CRYPTOAPI transfer.

There is also similar changes in the util-linux patch.  I've removed
all the tables with kerneli-specific cipher information.  Then, if
losetup doesn't find any information about the cipher the user
specifies, is assumes it is a LO_CRYPT_CRYPTOAPI cipher.  It parses
/proc/crypto/cipher/%s-cbc to find information about allowed key
sizes.  This patch is called util-linux-2.10o.int2.patch.


The kernel will now try to load ciphers if it can't find them (and
CONFIG_KMOD is on).  It works like this: Say you want to look for
"serpent-cbc", it will try to load the following modules until it
finds the cipher or run out of options:

cipher-serpent-cbc
cipher-serpent
cipher

This supports the way modules are written today where a single module
implements both serpent-cbc, and serpent-ecb.  In a later patch, the
various cipher and digest modules should be renamed to work with the
above scheme.  For the time being, you should rename your favorite
cipher (i.e, rename /lib/modules/2.2.17/misc/serp6f.o -&gt;
/lib/modules/2.2.17/misc/cipher-serpent.o) to play with this patch.

astor

-- 
Alexander Kjeldaas                Mail:  astor@fast.no
finger astor@master.kernel.org for OpenPGP key.

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001125165101</emailId><senderName>John Kennedy</senderName><senderEmail>jk@csuchico.edu</senderEmail><timestampReceived>2000-11-25 16:51:01-0400</timestampReceived><subject>block ciphers &amp; plaintext attacks</subject><body>

  Ok, I've made a little proof-of-concept system that seems to be working,
but I'm wondering how effective it will be over the long run.

  I've made a bootable CD-ROM with an initrd losetup-like bootstrap.  The
only unencrypted data will be on the boot floppy/cdrom which can be
removed after bootup.  That leaves me with about 8GB of serpent-encrypted
filesystems on the harddrive.

  This has some different issues than I normally think about.  The box is
designed to be shut-down-secure (to the point of using an ext3 journalled
filesystem for abrupt powerdowns), which is fine since getting caught with
the filesystems mounted makes the encryption issues moot.  In theory,
you could send me something like known-plaintext-email or something,
but then you would still need before-and-after access to my harddrive
to compare.  If anything, I'm wondering about its security in the face
of someone having possession of the computer and trying to decrypt it.

  Right now, worst offense, I have a 1K bit of (fixed) random garbage
on the front of my filesystem that I use to identify my filesystems
before I try to mount them.  Right now, that is a kludge (mostly because
I didn't feel like trying to validate the superblock and I thought I
might have to store some information).  There are all kinds of ways I
could take the curse off of it, but just how bad is that?

  Once you get past that, look at the filesystem superblocks.  You get
a lot more variables in it which would make it harder to bruteforce,
but a *lot* of them are based on filesystem size and be a lot more
predictable that you might think.  How secure is that, really?

  At what point is someone going to get burned?  I started out looking
into it as a security and anti-tampering system -- even if someone did
have physical possession or access to the hardware, it wouldn't do them
a lot of good without a LOT (hopefully horribly prohibitive) of work.
How many bits do I have to give them before my effort is all for naught?

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001126155745</emailId><senderName>Marc Mutz</senderName><senderEmail>marc@mutz.com</senderEmail><timestampReceived>2000-11-26 15:57:45-0400</timestampReceived><subject>Re: block ciphers &amp; plaintext attacks</subject><body>

John Kennedy wrote:
&gt; 
&lt;snip&gt;
&gt;   At what point is someone going to get burned?  I started out looking
&gt; into it as a security and anti-tampering system -- even if someone did
&gt; have physical possession or access to the hardware, it wouldn't do them
&gt; a lot of good without a LOT (hopefully horribly prohibitive) of work.
&gt; How many bits do I have to give them before my effort is all for naught?
&lt;snip&gt;

In short: None.
Long version: That is because you make the common mistake of
Q&gt; encryption == integrety.
That is not so! The right equality is:
Q&gt; encryption == confidelity.
You said, you wanted security and tamper-proofness. You got nothing of
that, since anyone could substitute blocks. If you want a system that is
tamper-proof, start by installing tripwire on that floppy disk and run
it daily (YMMV).

It is of course right that given an encrypted disk it is computationally
infeasible (at least to the extent known to the public) to make a
_subtle_ change. Poking around encrypted blocks and changing some of
them will in general yield garbage. But the point is that, given that
garbage, you cannot deduce from that whether the ciphertext has been
tampered with or the garbage was there before encryption took place.

So, I _guess_ that you want not only integrety-checking, but also
confidelity. Serpent-encryption will buy you that. It is probably the
most secure cipher known to the public at this point. But if you want
integrety, then you should additionally install tripwire, read the
Security-HOWTO and B. Schneier's Applied Cryptography.

Marc

-- 
Marc Mutz &lt;Marc@Mutz.com&gt;     http://EncryptionHOWTO.sourceforge.net/
University of Bielefeld, Dep. of Mathematics / Dep. of Physics

PGP-keyID's:   0xd46ce9ab (RSA), 0x7ae55b9e (DSS/DH)



Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001126194450</emailId><senderName>John Kennedy</senderName><senderEmail>jk@csuchico.edu</senderEmail><timestampReceived>2000-11-26 19:44:50-0400</timestampReceived><subject>Re: block ciphers &amp; plaintext attacks</subject><body>

On Sun, Nov 26, 2000 at 03:57:45PM +0000, Marc Mutz wrote:
&gt; John Kennedy wrote:
&gt; &lt;snip&gt;
&gt; &gt;   At what point is someone going to get burned?  I started out looking
&gt; &gt; into it as a security and anti-tampering system -- even if someone did
&gt; &gt; have physical possession or access to the hardware, it wouldn't do them
&gt; &gt; a lot of good without a LOT (hopefully horribly prohibitive) of work.
&gt; &gt; How many bits do I have to give them before my effort is all for naught?
&gt; &lt;snip&gt;
&gt; 
&gt; In short: None.

  I think you're missing my point, but you come around to it, below.

&gt; Long version: That is because you make the common mistake of
&gt; Q&gt; encryption == integrety.
&gt; That is not so! The right equality is:
&gt; Q&gt; encryption == confidelity.

  Well, no I didn't but I didn't say that in the email.  It isn't like
we're talking digital signatures here, but the inability to change blocks
on the disk without garbaging it comes close.

  I do get your "encryption == confidentiality" point though.

&gt; You said, you wanted security and tamper-proofness. You got nothing of
&gt; that, since anyone could substitute blocks. If you want a system that is
&gt; tamper-proof, start by installing tripwire ...

  I'm looking at AUGMENTING tripwire-like security, not replacing it.  I'm
exploiting the encryption, taking advantage of the fact that improperly
encrypted blocks will yield garbage instead of compromised data.

  Yes, I'm sort of abusing the cryptography to achieve this goal.
It is a whole lot easier dealing with garbaged data than tampered data.

&gt; It is of course right that given an encrypted disk it is computationally
&gt; infeasible (at least to the extent known to the public) to make a
&gt; _subtle_ change. Poking around encrypted blocks and changing some of
&gt; them will in general yield garbage. But the point is that, given that
&gt; garbage, you cannot deduce from that whether the ciphertext has been
&gt; tampered with or the garbage was there before encryption took place.

  Yes, this is what I'm exploiting.  I'm looking at potential garbage as
a denial-of-service.  Tampering can be far worse, but I'm digressing again.

&gt; So, I _guess_ that you want not only integrety-checking, but also
&gt; confidelity. Serpent-encryption will buy you that. It is probably the
&gt; most secure cipher known to the public at this point. But if you want
&gt; integrety, then you should additionally install tripwire, read the
&gt; Security-HOWTO and B. Schneier's Applied Cryptography.

  Bingo, exactly.  Using tripwire or equivalent to augment.

  I think this negates your short answer though.


  Which sort of gets us back to my original question.  I have an encrypted
filesystem that an attacker will have to get through before they can get
at the data that is on it.  They don't know the password, but they have
a statisticly good idea of what some of it is (primarily the superblock,
with a lot of the information contained in it being based on the partition
size, etc).

  I'm sort of looking for an experience-based answer off of the top of
your (or anyone's) head, but we're mixing generalities with math and
crypto (not a good combo).  I'm wanting to know how much encrypted-
knowntext you would need to really compromise the serpent password,
which would let you turn around and compromise the rest of the disk.

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001127080939</emailId><senderName>Marc Mutz</senderName><senderEmail>marc@mutz.com</senderEmail><timestampReceived>2000-11-27 08:09:39-0400</timestampReceived><subject>Re: block ciphers &amp; plaintext attacks</subject><body>

John Kennedy wrote:
&gt; 
&lt;snip&gt;
&gt;   I'm sort of looking for an experience-based answer off of the top of
&gt; your (or anyone's) head, but we're mixing generalities with math and
&gt; crypto (not a good combo).  I'm wanting to know how much encrypted-
&gt; knowntext you would need to really compromise the serpent password,
&gt; which would let you turn around and compromise the rest of the disk.
&gt;
For what is publicly nown, serpent is secure, no matter what. There are
academic attacks against reduced-round versions, but the cipher as
defined in the AES paper is secure. Yet that is no guarantee. Tomorrow
may see a complete break of serpent, but that is unlikely, of course.
Serpent is a 128 bit blockcipher, meaning, you can encrypt many, _many_
Gigabytes with it before you get equal ciphertext blocks, which would
give an attacker some hints. So no problems from that front, too. The
most probable point of attack is your passphrase. I'd almost bet that it
does not contain 128 bits of entropy. and if it is just an English
sentence, it would only contain 1.3 bits/char of entropy.

If you want to know about the feasibilty of a known-plaintext attack: No
such attack is known that is faster than brute force. Yet brute-forcing
your passphrase may be well feasible.

Does that answer your question?

Marc

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001127192915</emailId><senderName>John Kennedy</senderName><senderEmail>jk@csuchico.edu</senderEmail><timestampReceived>2000-11-27 19:29:15-0400</timestampReceived><subject>Re: block ciphers &amp; plaintext attacks</subject><body>

On Mon, Nov 27, 2000 at 09:09:39AM +0100, Marc Mutz wrote:
&gt; John Kennedy wrote:
&gt; &lt;snip&gt;
&gt; &gt;   I'm sort of looking for an experience-based answer off of the top of
&gt; &gt; your (or anyone's) head, but we're mixing generalities with math and
&gt; &gt; crypto (not a good combo).  I'm wanting to know how much encrypted-
&gt; &gt; knowntext you would need to really compromise the serpent password,
&gt; &gt; which would let you turn around and compromise the rest of the disk.
&gt;
&gt; For what is publicly nown, serpent is secure, no matter what. There are
&gt; academic attacks against reduced-round versions, but the cipher as
&gt; defined in the AES paper is secure. Yet that is no guarantee. Tomorrow
&gt; may see a complete break of serpent, but that is unlikely, of course.
&gt; Serpent is a 128 bit blockcipher, meaning, you can encrypt many, _many_
&gt; Gigabytes with it before you get equal ciphertext blocks, which would
&gt; give an attacker some hints. So no problems from that front, too. The
&gt; most probable point of attack is your passphrase. I'd almost bet that it
&gt; does not contain 128 bits of entropy. and if it is just an English
&gt; sentence, it would only contain 1.3 bits/char of entropy.

  As I understand them so far, those are the words I wanted to hear.
I was actually assuming that my passphrase was what was going to be
attacked (I expected that it would be the easier of the two).

  As far as passphrase entropy, I'm a bit ignorant at the moment.  I
initially coded to be compatible with losetup, presuming that it would
be coded in a secure fashion.  Without a lot more reading, I can't say
if that is true or not though.

  I'm under the impression that the 1.3 bits/char problem is pretty common
and that one of the first things you do is run it through a one-way hash,
generating something that looks far more like random bits.  I see the
two calls to rmd160_hash_buffer(), but I haven't confirmed that what
they're actually doing is something like what I've been told.

&gt; If you want to know about the feasibilty of a known-plaintext attack: No
&gt; such attack is known that is faster than brute force. Yet brute-forcing
&gt; your passphrase may be well feasible.
&gt; 
&gt; Does that answer your question?

  Enough to spend my time productively on the passphrase, yes.  (:  Either
the current losetup code will be secure or not and, if not, I'll just
add another layer with a passphrase protecting an encrypted passphrase
to the real data on the disk.

  (Yes, you could still try to brute-force the first passphrase, but it
   and the encrypted 2nd passphrase can easily be kept apart from the
   hard-drive encrypted with the 2nd passphrase.  If rmd160_hash_buffer()
   doesn't introduce enough entropy, that ought to help a lot.)

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001128180822</emailId><senderName>Marc Mutz</senderName><senderEmail>marc@mutz.com</senderEmail><timestampReceived>2000-11-28 18:08:22-0400</timestampReceived><subject>Re: block ciphers &amp; plaintext attacks</subject><body>

John Kennedy wrote:
&gt; 
&lt;snip&gt;
&gt;   As far as passphrase entropy, I'm a bit ignorant at the moment.  I
&gt; initially coded to be compatible with losetup, presuming that it would
&gt; be coded in a secure fashion.  Without a lot more reading, I can't say
&gt; if that is true or not though.
&gt; 
&gt;   I'm under the impression that the 1.3 bits/char problem is pretty common
&gt; and that one of the first things you do is run it through a one-way hash,
&gt; generating something that looks far more like random bits.  I see the
&gt; two calls to rmd160_hash_buffer(), but I haven't confirmed that what
&gt; they're actually doing is something like what I've been told.
&gt; 

losetup takes the passphrase-string, calculates the ripe-md hash
function of that string and uses the resulting bitstring as the key to
the cipher (serpent, in your case).

&lt;snip&gt;
&gt;   Enough to spend my time productively on the passphrase, yes.  (:  Either
&gt; the current losetup code will be secure or not and, if not, I'll just
&gt; add another layer with a passphrase protecting an encrypted passphrase
&gt; to the real data on the disk.
&gt; 

The losetup code is as secure as it can get.

&gt;   (Yes, you could still try to brute-force the first passphrase, but it
&gt;    and the encrypted 2nd passphrase can easily be kept apart from the
&gt;    hard-drive encrypted with the 2nd passphrase.  If rmd160_hash_buffer()
&gt;    doesn't introduce enough entropy, that ought to help a lot.)

Hashing _never_ (!!!) introduces entropy. It might even _decrease_ your
entropy by a few bits. Entropy can be rougly defined as the number of
bits you need to store a certain data set. E.g. a random 32 bit value
has 32 bits of entropy, because you can store 2^32 states with it. Yet a
4-character string containing only the 26 letters can have at most
lb(26^4)=18.75 bits of entropy (where lb is logarithm w.r.t. base 2),
since you can only encode 26^4 ~= 2^18.75 states with this. The famous
1.3 bits/char are valid for english running text.

So, if you want to have a passphrase that is as secure as the cipher is
(i.e attacking the passphrase is not much faster than attacking the key
directly), you have to enter approx. 100 characters of english text.
This will give you a passphrase of ca. 130 bits entropy which in turn is
fed into the hash function to produce a bit string with around 128 bits
of entropy (hashes lose entropy because they are not bijective from
GF(2^128) onto itself). Yet that string is 160 bits long and only the
frst 128 bits of it are taken as the passphrase. Thus, your key's
entropy can be approximated to be 128*(128/160)=102 bits. But that is
good enough.

You see, there's a _lot_ more to security than ciphers. You should
really read (and understand) Applied Cryptography, if you take your
thing serious.

Marc

-- 
Marc Mutz &lt;Marc@Mutz.com&gt;     http://EncryptionHOWTO.sourceforge.net/
University of Bielefeld, Dep. of Mathematics / Dep. of Physics

PGP-keyID's:   0xd46ce9ab (RSA), 0x7ae55b9e (DSS/DH)


Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001129142201</emailId><senderName>John Kennedy</senderName><senderEmail>jk@csuchico.edu</senderEmail><timestampReceived>2000-11-29 14:22:01-0400</timestampReceived><subject>Re: block ciphers &amp; plaintext attacks</subject><body>

On Tue, Nov 28, 2000 at 06:08:22PM +0000, Marc Mutz wrote:
&gt; John Kennedy wrote:
&gt; &lt;snip&gt;
&gt; &gt;   As far as passphrase entropy, I'm a bit ignorant at the moment.  I
&gt; &gt; initially coded to be compatible with losetup, presuming that it would
&gt; &gt; be coded in a secure fashion.  Without a lot more reading, I can't say
&gt; &gt; if that is true or not though.
&gt; &gt; 
&gt; &gt;   I'm under the impression that the 1.3 bits/char problem is pretty common
&gt; &gt; and that one of the first things you do is run it through a one-way hash,
&gt; &gt; generating something that looks far more like random bits.  I see the
&gt; &gt; two calls to rmd160_hash_buffer(), but I haven't confirmed that what
&gt; &gt; they're actually doing is something like what I've been told.
&gt; &gt; 
&gt; 
&gt; losetup takes the passphrase-string, calculates the ripe-md hash
&gt; function of that string and uses the resulting bitstring as the key to
&gt; the cipher (serpent, in your case).
&gt; 
&gt; &lt;snip&gt;
&gt; &gt;   Enough to spend my time productively on the passphrase, yes.  (:  Either
&gt; &gt; the current losetup code will be secure or not and, if not, I'll just
&gt; &gt; add another layer with a passphrase protecting an encrypted passphrase
&gt; &gt; to the real data on the disk.
&gt; 
&gt; The losetup code is as secure as it can get.

  Ok, I'm not wasting anybody's time up through here.  (:

&gt; &gt;   (Yes, you could still try to brute-force the first passphrase, but it
&gt; &gt;    and the encrypted 2nd passphrase can easily be kept apart from the
&gt; &gt;    hard-drive encrypted with the 2nd passphrase.  If rmd160_hash_buffer()
&gt; &gt;    doesn't introduce enough entropy, that ought to help a lot.)
&gt; 
&gt; Hashing _never_ (!!!) introduces entropy. It might even _decrease_ your
&gt; entropy by a few bits. Entropy can be rougly defined as the number of
&gt; bits you need to store a certain data set. E.g. a random 32 bit value
&gt; has 32 bits of entropy, because you can store 2^32 states with it. Yet a
&gt; 4-character string containing only the 26 letters can have at most
&gt; lb(26^4)=18.75 bits of entropy (where lb is logarithm w.r.t. base 2),
&gt; since you can only encode 26^4 ~= 2^18.75 states with this. The famous
&gt; 1.3 bits/char are valid for english running text.

  Here I'm just using the wrong keyword and wasting your time, making
you excitable and giving you the wrong impression.

  I thought, for whatever reason, we were comparing the non-merits of
plain ascii text as the key to the cipher serpent rather than the result
of the ripe-md hash and talking about the non-merits of [A-Za-z0-9]*4
vs. a 32-bit number generated by the hash as the key contents.

  Of course, being ignorant got the following gem out of you:

&gt; So, if you want to have a passphrase that is as secure as the cipher is
&gt; (i.e attacking the passphrase is not much faster than attacking the key
&gt; directly), you have to enter approx. 100 characters of english text.
&gt; This will give you a passphrase of ca. 130 bits entropy which in turn is
&gt; fed into the hash function to produce a bit string with around 128 bits
&gt; of entropy (hashes lose entropy because they are not bijective from
&gt; GF(2^128) onto itself). Yet that string is 160 bits long and only the
&gt; frst 128 bits of it are taken as the passphrase. Thus, your key's
&gt; entropy can be approximated to be 128*(128/160)=102 bits. But that is
&gt; good enough.

  So, to try and convert that to a horrible generalization, if I use
the letter `A' as my passphrase, my true entropy is somewhere between
1.3 and 8 bits (depending on if you know I'm using english text or not).
Yes, it may be hashed out and effectively padded to 128 bits, but it looks
far more random than it actually is.

  I'm not going to touch the math without cracking the AC book some more.

  No, my longest passphrase is ~50 characters, which gives me about
half the entropy I could have if I'm lucky.


  In addition, my blabbing about using two keys really doesn't make things
more secure from a mathematical point since we're talking about the
weakest link.  Break the first key (using it to decrypt the 2nd) and
it doesn't really matter how much entropy the 2nd key may really have,
you have it handed to you on a platter.

  As far as a real (but not mathematical) brute-force attempt goes,
it may do some good.  If all they have is the data encrypted by the 2nd
key, it (the 2nd key) has more entropy in the cipher key (and presumably
passes on the benefits of that in a mathematically tangible way).
They have to have possession of the 2nd key encrypted with the 1st key
to exploit the lack of entropy in the 1st key.  The 2nd key (encrypted)
is more mobile than the data encrypted by the 2nd key, which means that
it is physically much more difficult to get (something that can't be
factored into the mathematical attacks, but may be irrelevant from their
point of view anyway).

  Oh hell, I'll just shut up now.  Trying not to trip over the differences
between a mathematical/academic attack vs. real brute-force decryption
is just going to get me in trouble anyway.  (:

&gt; You see, there's a _lot_ more to security than ciphers. You should
&gt; really read (and understand) Applied Cryptography, if you take your
&gt; thing serious.

  I went out and bought it last night.  (:

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001129190930</emailId><senderName>John Kennedy</senderName><senderEmail>jk@csuchico.edu</senderEmail><timestampReceived>2000-11-29 19:09:30-0400</timestampReceived><subject>Re: block ciphers &amp; plaintext attacks</subject><body>

  I should just shut up but this is bugging me and I haven't done the
math yet.  Hopefully this will be a good question.

On Wed, Nov 29, 2000 at 06:22:01AM -0800, John Kennedy wrote:
&gt;   As far as a real (but not mathematical) brute-force attempt goes,
&gt; it may do some good.  If all they have is the data encrypted by the 2nd
&gt; key, it (the 2nd key) has more entropy in the cipher key (and presumably
&gt; passes on the benefits of that in a mathematically tangible way).
&gt; They have to have possession of the 2nd key encrypted with the 1st key
&gt; to exploit the lack of entropy in the 1st key.  The 2nd key (encrypted)
&gt; is more mobile than the data encrypted by the 2nd key, which means that
&gt; it is physically much more difficult to get (something that can't be
&gt; factored into the mathematical attacks, but may be irrelevant from their
&gt; point of view anyway).

  Right now, we're operating under the assumption that the serpent cipher
is secure and that I could encrypt gigabytes of zeros securely and it
wouldn't do any good to a brute-force attacker, at least directly.
The easiest way in is still through attacking the key.

  The key is just a bitstream, X bits long.  I could try all 2^X possible
values to try and brute-force it, knowing I got it right when I see the
gigabyte of zeros.  That should be made computationally infeasible for
a reasonable period of time, so the trick is to really cut back and find
the smallest possible subset of 2^X to try.

  [tradeoff between security and the time it takes to decrypt
   the data.  typically you want it to decrypt as fast as possible
   and still keep it as painful as possible for the brute-forcers,
   trusting that the cpu-expensive key generation will stop people
   from generating and trying to use a lot of keys very quickly.]

  The hash that makes the key is there to make that difficult.  It takes
a small amount of human-friendly bits and converts it into a much longer
bitstream with a wide output-value range.  It won't be any more random,
but it hopefully guarantees you that brute-forcers can't eliminate any
of the 2^X possibilities for the cipher key.

  The brute-forcers then have to attack the key itself.  It is a one-way
hash and should be computationally expensive to generate, which cuts down
on the number of attempts you can make in a time interval.  Once again,
you're trying to figure out ways to cut down on the possible input.

  [this can be very painful to generate, since it is a one-time cost
   if you know the correct password and it is good to make it as
   painful as you can if you don't.]

  Here is where the entropy comes into play and where I start to
tie knots with my brain, tongue and fingers.

  You want N bits of entropy (good, random numbers).  If those N bits
are from a keyboard, you only get ~1.3 bits per key (byte).  If they're
a nice secure number from /dev/random (presuming it has good entropy)
you should be able to get all 8 bits/byte.  The only trick is that you
have to remember those bits or you won't be able to decrypt your data.


  Is the cipher-encrypted data any more secure with less entropy than
with more entropy?  I think the bit that I have to bend my brain around
is that the answer is *NO*.  Less entropy just means that the attacker
has to try fewer hashes, and in the end fewer cipher keys.

  As an example, if I got *really* unlucky and my high-entropy bitstream
happened to be all zeros, the data isn't encrypted any more securely than
if I had a really bad hash generator that only let me pick a single digit
between 0 and 9 as the bitstream.  It makes a great deal of difference to
an attacker that is thinking about trying to brute-force me.  2^X vs. 10.


  It seems like it really doesn't matter what I use as the hash input, so
long as it has sufficient entropy to provide a good range of output.


  In my original email, above, I'm protecting a key (key2, with a
good range of input) with encryption, that is decoded by another key
(key1, with a smaller range of input).  If I knew I had decrypted key2
correctly with key1 then I would have a weakest-link situation.  If I
don't know, then an incorrect key2 complicates the hell out of finding
the correct cipher key.  It may not magnify it, but I doubt if it helps
to eliminates anything.

  It may not contribute a whole lot to the security, but if key2 is
disposed of the pulling-fingernails approach won't work for decryption.  (:

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001129222104</emailId><senderName>Marc Mutz</senderName><senderEmail>marc@mutz.com</senderEmail><timestampReceived>2000-11-29 22:21:04-0400</timestampReceived><subject>Re: block ciphers &amp; plaintext attacks</subject><body>

John Kennedy wrote:
&gt; 
&lt;snip&gt;
&gt;   Right now, we're operating under the assumption that the serpent cipher
&gt; is secure and that I could encrypt gigabytes of zeros securely and it
&gt; wouldn't do any good to a brute-force attacker, at least directly.
&gt; The easiest way in is still through attacking the key.
&gt; 

Yes. Provided you don't use ECB encryption. Sorry yet another term for
you... But this one is easy:

ECB (Electronic CodeBook) is just the simplest form of encryption using
block ciphers: Let P[0],...,P[n] be the plaintext blocks (each of size
equal blocksize of the cipher). Then the resulting ciphertext
C[0],...,C[n] will be

     C[i] = Serpent(K,P[i]) for i = 1,...,n (K = key).

Ie. you encrpyt each block individually. Thus, if you encrpyt an
all-zreros plaintext, all P[i] will be equal (zero) and hence all C[i]
will be equal. Not good.

Therefore, the linux loop_gen driver uses CBC encryption (Cipher Block
Chaining):

With the notation above, the ciphertext will be calculated as follows:

     C[0] = Serpent( K, IV+P[0] ),
     C[i] = Serpent( K, C[i-1]+P[i] ),

where '+' is XOR and IV is an Initialization Vector that can be choosen
randomly. Strictly speaking, the ciphertext now becomes
(IV,C[0],...,C[n]), because you must remember the IV to be able to
decrypt. Thus, if you encrypt all zeros, the ciphertext blocks will
still be different.

&gt;   The key is just a bitstream, X bits long.  I could try all 2^X possible
&gt; values to try and brute-force it, knowing I got it right when I see the
&gt; gigabyte of zeros.  That should be made computationally infeasible for
&gt; a reasonable period of time, so the trick is to really cut back and find
&gt; the smallest possible subset of 2^X to try.
&gt; 

Exactly.

&gt;   [tradeoff between security and the time it takes to decrypt
&gt;    the data.  typically you want it to decrypt as fast as possible
&gt;    and still keep it as painful as possible for the brute-forcers,
&gt;    trusting that the cpu-expensive key generation will stop people
&gt;    from generating and trying to use a lot of keys very quickly.]
&gt; 

Not really. It helps if you have an expensive key-setup procedure. But
that can be pipelined, so that the actual throughput will not be
decreased (speaking of hardware decryption, of course).
Usually, you obtain the desired security margin by making the possible
number of keys so vast, that trying all of them in turn would require
thousands of times the age of the universe if you had one million
computers that can test one million keys per second each (the normal
example of the order of complexity brute-force should have).


&gt;   The hash that makes the key is there to make that difficult.

No. It's there to make it convenient for the user. Instead of trying to
remember
	key = 580687838abb0ae8ad77a8192c6fc6be,
he only has to remember some nice passphrase.

&gt;  It takes
&gt; a small amount of human-friendly bits and converts it into a much longer
&gt; bitstream with a wide output-value range.  It won't be any more random,
&gt; but it hopefully guarantees you that brute-forcers can't eliminate any
&gt; of the 2^X possibilities for the cipher key.
&gt; 

Or make it harder to do, yes.

&gt;   The brute-forcers then have to attack the key itself.  It is a one-way
&gt; hash and should be computationally expensive to generate, which cuts down
&gt; on the number of attempts you can make in a time interval.  Once again,
&gt; you're trying to figure out ways to cut down on the possible input.
&gt; 
Exactly.

&gt;   [this can be very painful to generate, since it is a one-time cost
&gt;    if you know the correct password and it is good to make it as
&gt;    painful as you can if you don't.]
&gt; 
Yes, but it would be more effective to increase the cipher's key length
instead.

&gt;   Here is where the entropy comes into play and where I start to
&gt; tie knots with my brain, tongue and fingers.
&gt; 
&gt;   You want N bits of entropy (good, random numbers).  If those N bits
&gt; are from a keyboard, you only get ~1.3 bits per key (byte).  If they're
&gt; a nice secure number from /dev/random (presuming it has good entropy)
&gt; you should be able to get all 8 bits/byte.  The only trick is that you
&gt; have to remember those bits or you won't be able to decrypt your data.
&gt; 
Yep. Though entropy is not about random numbers. It's more about
information that is contained in the data. Suppose you want to compess
some data. And you want to know how well you can do that. If that data
is english text then the famous 1.3 bits/char tell you that you cannot
do better than to appox. 1.3/8=16.25%. If you have C source code, then
you might do better, simply because it has more structure, the text is
more predictable (you know that if you have a word 'for' then the next
few character will most probably be whitespace, followed by '(' and most
probably "i=0;i&lt;somethung;i++" ), it has less entropy. Any if you have a
sequence of real random numbers, then you cannot compress them at all.

&gt;   Is the cipher-encrypted data any more secure with less entropy than
&gt; with more entropy?

You mean the other way round, no? It's more secure iff the key contains
more entropy, ie. there are simply more possibilities.

&gt; I think the bit that I have to bend my brain around
&gt; is that the answer is *NO*.  Less entropy just means that the attacker
&gt; has to try fewer hashes, and in the end fewer cipher keys.
&gt; 
Yes. If you take your question as you asked it, and not as I answered
it.

&gt;   As an example, if I got *really* unlucky and my high-entropy bitstream
&gt; happened to be all zeros, the data isn't encrypted any more securely than
&gt; if I had a really bad hash generator that only let me pick a single digit
&gt; between 0 and 9 as the bitstream.  It makes a great deal of difference to
&gt; an attacker that is thinking about trying to brute-force me.  2^X vs. 10.
&gt; 
No. If you have an key with entropy 128 bits and it happens to be all
zeros (this has then probability 2^{-128}), this will be nothing the
attacker can take advantage of. An all-zeros sequence will be just as
likely to occur as the sequence I gave you above in the line with "key
=". Yet, brute-force key search may of course start at an all-zeros key,
yet it could as well start with 580687838abb0ae8ad77a8192c6fc6be.
Entropy is not about a given key. It is about the size of the set of
possibilities this key has been chosen from.

&gt;   It seems like it really doesn't matter what I use as the hash input, so
&gt; long as it has sufficient entropy to provide a good range of output.
&gt; 
Yes. You can enter 100 chars of english text, or 32 chars of hexadecimal
digits, representing output from /dev/random.

&gt;   In my original email, above, I'm protecting a key (key2, with a
&gt; good range of input) with encryption, that is decoded by another key
&gt; (key1, with a smaller range of input).  If I knew I had decrypted key2
&gt; correctly with key1 then I would have a weakest-link situation.  If I
&gt; don't know, then an incorrect key2 complicates the hell out of finding
&gt; the correct cipher key.  It may not magnify it, but I doubt if it helps
&gt; to eliminates anything.
&gt; 
Yes, is does not help, but it is still moot. That is because you can be
in the following two cases:

a.) Your encrypted second key is accessible by the attacker.
b.) It is not.

ad a) You increase the complexity of the attack by 2. That is because
the attacker can attack your passphrase, decrypt the second key (he may
not know whether that decryption yields the real key, but he can check
so by) decrypting the first ciphertext block and check for all-zeros. So
instead of one decryption using the direct method, he has to do two.

ad b) Then you need not encrypt the second key at all (at least not in
theory).


&gt;   It may not contribute a whole lot to the security, but if key2 is
&gt; disposed of the pulling-fingernails approach won't work for decryption.  (:
&gt; 

How can you? If you throw away key2, then you are no longer able to
decrypt the data yourself. And an attacker, not believing you, may still
pull your fingernails while slowly asking the question "Where do you
have it?" again and again (repeat 10 times).

Bottomline: Choose a passphrase that has at least 64 bits of entropy and
you should be as secure as you need to be.

Marc

-- 
Marc Mutz &lt;Marc@Mutz.com&gt;     http://EncryptionHOWTO.sourceforge.net/
University of Bielefeld, Dep. of Mathematics / Dep. of Physics

PGP-keyID's:   0xd46ce9ab (RSA), 0x7ae55b9e (DSS/DH)



Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001129231029</emailId><senderName>Mike Touloumtzis</senderName><senderEmail>miket@bluemug.com</senderEmail><timestampReceived>2000-11-29 23:10:29-0400</timestampReceived><subject>Re: block ciphers &amp; plaintext attacks</subject><body>

On Wed, Nov 29, 2000 at 10:21:04PM +0000, Marc Mutz wrote:
&gt; 
&gt; Therefore, the linux loop_gen driver uses CBC encryption (Cipher Block
&gt; Chaining):

Delurking for a moment:

This is something I've been meaning to ask about for
a while.  Obviously ECB is more random-access friendly.
How long are the CBC chains used by loopback encryption?
Does one chain span the whole device?  Are they limited
in length to make random access and updates easier?
Or is there a third approach which I'm not clued into?

thanks,
miket


Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001130012537</emailId><senderName>John Kennedy</senderName><senderEmail>jk@csuchico.edu</senderEmail><timestampReceived>2000-11-30 01:25:37-0400</timestampReceived><subject>Re: block ciphers &amp; plaintext attacks</subject><body>

On Wed, Nov 29, 2000 at 10:21:04PM +0000, Marc Mutz wrote:
&gt;&gt;[me]
&gt;&gt;   Is the cipher-encrypted data any more secure with less entropy than
&gt;&gt; with more entropy?
&gt; 
&gt; You mean the other way round, no? It's more secure iff the key contains
&gt; more entropy, ie. there are simply more possibilities.
&gt; 
&gt;&gt; I think the bit that I have to bend my brain around
&gt;&gt; is that the answer is *NO*.  Less entropy just means that the attacker
&gt;&gt; has to try fewer hashes, and in the end fewer cipher keys.
&gt;
&gt; Yes. If you take your question as you asked it, and not as I answered it.

  No, I meant it as asked, but it might be a bit more ambiguous than
I intended.  As far as the cipher key is concerned, if I have a 128-bit
key and you don't know how I generated the bits, it might as well be
very secure.  You don't know how much entropy "input range" I have,
so you end up assuming the worst.

  If I tell you I've used some known-good ripe-md hash function with a
100-character passphrase, it is even more secure.  It is a known algorithm
with more than adequate entropy and you're probably really discouraged,
without much hope that I've done something stupid generating it.

  On the other hand, if I told you that the password the hash was
generated from only had four digits in it, suddenly the key is very
insecure and trivial to break.

  Either way, I think, the (serpent) CIPHER doesn't care.  Entropy is
of concern for the KEY, not the cipher.  The 1-in-2^128 chance that you
got all-zeros with a high-entropy bitstream or the null-password that
generated the same bitstream is all the same to the cipher.  The amount
of entropy just lets us have an idea of how worthwhile it is to attack
the key.

&gt; &gt;   As an example, if I got *really* unlucky and my high-entropy bitstream
&gt; &gt; happened to be all zeros, the data isn't encrypted any more securely than
&gt; &gt; if I had a really bad hash generator that only let me pick a single digit
&gt; &gt; between 0 and 9 as the bitstream.  It makes a great deal of difference to
&gt; &gt; an attacker that is thinking about trying to brute-force me.  2^X vs. 10.
&gt;
&gt; No. If you have an key with entropy 128 bits and it happens to be all
&gt; zeros (this has then probability 2^{-128}), this will be nothing the
&gt; attacker can take advantage of. An all-zeros sequence will be just as
&gt; likely to occur as the sequence I gave you above in the line with "key
&gt; =". Yet, brute-force key search may of course start at an all-zeros key,
&gt; yet it could as well start with 580687838abb0ae8ad77a8192c6fc6be.
&gt; Entropy is not about a given key. It is about the size of the set of
&gt; possibilities this key has been chosen from.

  Would your answer change with my clarification, above?

  The 10-in-2^128 chance vs. 10-in-10 is for guessing the correct key.
The data isn't written any differently regardless of the key.

  Another ridiculous example to make my point would be if I generated
10 different high-entropy keys and use one of them.  Cipher and key
are very secure, and it would be a waste of time to brute-force it.  If
I told you all 10 keys that I considered, it is suddenly trivially easy.

  To get back to the main point, the cipher-encrypted data isn't any more
or less secure if you look at the cipher aspect alone.  It is the key
that is important, and the difficulty perceived in brute-forcing it.


&gt;&gt;   In my original email, above, I'm protecting a key (key2, with a
&gt;&gt; good range of input) with encryption, that is decoded by another key
&gt;&gt; (key1, with a smaller range of input).  If I knew I had decrypted key2
&gt;&gt; correctly with key1 then I would have a weakest-link situation.  If I
&gt;&gt; don't know, then an incorrect key2 complicates the hell out of finding
&gt;&gt; the correct cipher key.  It may not magnify it, but I doubt if it helps
&gt;&gt; to eliminates anything.
&gt;
&gt; Yes, is does not help, but it is still moot. That is because you can be
&gt; in the following two cases:
&gt; 
&gt; a.) Your encrypted second key is accessible by the attacker.
&gt; b.) It is not.

  Yup.  And if it isn't, it is perceived as being a lot more difficult.
I could lie and say that my password as 100 characters long and it is
suddenly more secure (if you believe me).  You can't just look at the
key and know how much entropy went into it (as far as I know).

&gt;&gt;   It may not contribute a whole lot to the security, but if key2 is
&gt;&gt; disposed of the pulling-fingernails approach won't work for decryption.  (:
&gt; 
&gt; How can you? If you throw away key2, then you are no longer able to
&gt; decrypt the data yourself. And an attacker, not believing you, may still
&gt; pull your fingernails while slowly asking the question "Where do you
&gt; have it?" again and again (repeat 10 times).

  Nope, I can't.  Maybe I'm a good little spy and don't want the secrets
to fall into the wrong hands.  Maybe I'm a bad little cracker and the
feds have just knocked down the front door (and I have backups, protected
by a different key, etc).  Anyway, the data is suddenly very secure,
even from myself.

  Not much I can do about the fingernails, either way.  (:

&gt; Bottomline: Choose a passphrase that has at least 64 bits of entropy and
&gt; you should be as secure as you need to be.

  Presumably a good rule of thumb.

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001130024352</emailId><senderName></senderName><senderEmail>sen_ml</senderEmail><timestampReceived>2000-11-30 02:43:52-0400</timestampReceived><subject>Re: block ciphers &amp; plaintext attacks</subject><body>

From: Mike Touloumtzis &lt;miket@bluemug.com&gt;
Subject: Re: block ciphers &amp; plaintext attacks
Date: Wed, 29 Nov 2000 15:10:29 -0800

&gt; On Wed, Nov 29, 2000 at 10:21:04PM +0000, Marc Mutz wrote:
&gt; &gt; 
&gt; &gt; Therefore, the linux loop_gen driver uses CBC encryption (Cipher Block
&gt; &gt; Chaining):
&gt; 
&gt; Delurking for a moment:
&gt; 
&gt; This is something I've been meaning to ask about for
&gt; a while.  Obviously ECB is more random-access friendly.
&gt; How long are the CBC chains used by loopback encryption?
&gt; Does one chain span the whole device?  Are they limited
&gt; in length to make random access and updates easier?
&gt; Or is there a third approach which I'm not clued into?
&gt; 
&gt; thanks,
&gt; miket
&gt; 
&gt; 
&gt; Linux-crypto:  cryptography in and on the Linux system
&gt; Archive:       http://mail.nl.linux.org/linux-crypto/

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001130113837</emailId><senderName>Alexander S A Kjeldaas</senderName><senderEmail>alexander.kjeldaas@fast.no</senderEmail><timestampReceived>2000-11-30 11:38:37-0400</timestampReceived><subject>Re: block ciphers &amp; plaintext attacks</subject><body>

On Wed, Nov 29, 2000 at 03:10:29PM -0800, Mike Touloumtzis wrote:
&gt; On Wed, Nov 29, 2000 at 10:21:04PM +0000, Marc Mutz wrote:
&gt; &gt; 
&gt; &gt; Therefore, the linux loop_gen driver uses CBC encryption (Cipher Block
&gt; &gt; Chaining):
&gt; 
&gt; Delurking for a moment:
&gt; 
&gt; This is something I've been meaning to ask about for
&gt; a while.  Obviously ECB is more random-access friendly.
&gt; How long are the CBC chains used by loopback encryption?
&gt; Does one chain span the whole device?  Are they limited
&gt; in length to make random access and updates easier?
&gt; Or is there a third approach which I'm not clued into?
&gt; 

The size of a chain is linked to the blocksize of the underlying
device, or the underlying file.  The loopback device is a block
device, so it is only random access on a block-granularity.

The IV for a given block is based on the offset of that block relative
to the start of the physical device.  The IV can also be based on the
offset of the block relative to the start of the file, which is
recommended since it makes it possible to move/take backup of an
encrypted file.  

astor

-- 
Alexander Kjeldaas                Mail:  astor@fast.no
finger astor@master.kernel.org for OpenPGP key.

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001128182554</emailId><senderName>John Kennedy</senderName><senderEmail>jk@csuchico.edu</senderEmail><timestampReceived>2000-11-28 18:25:54-0400</timestampReceived><subject>Re: Intl. patch 2.2.17.11pre1</subject><body>

On Tue, Nov 28, 2000 at 03:47:58PM +0100, Alexander S A Kjeldaas wrote:
&gt; A new prepatch is out.  I have made it a prepatch because it includes
&gt; more changes than normal, ...

  It doesn't seem to be propagating around.  Can you mail it to me or
point me to a site that is actually carrying it?

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001128183351</emailId><senderName>Alexander S A Kjeldaas</senderName><senderEmail>alexander.kjeldaas@fast.no</senderEmail><timestampReceived>2000-11-28 18:33:51-0400</timestampReceived><subject>Re: Intl. patch 2.2.17.11pre1</subject><body>

On Tue, Nov 28, 2000 at 10:25:54AM -0800, John Kennedy wrote:
&gt; On Tue, Nov 28, 2000 at 03:47:58PM +0100, Alexander S A Kjeldaas wrote:
&gt; &gt; A new prepatch is out.  I have made it a prepatch because it includes
&gt; &gt; more changes than normal, ...
&gt; 
&gt;   It doesn't seem to be propagating around.  Can you mail it to me or
&gt; point me to a site that is actually carrying it?


Forgot to mention this.. it's not in the kernel/crypto directory, but
rather in:

ftp://ftp.kernel.org/pub/linux/kernel/people/astor/v2.2/

astor

-- 
Alexander Kjeldaas                Mail:  astor@fast.no
finger astor@master.kernel.org for OpenPGP key.

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001129033924</emailId><senderName>John Kennedy</senderName><senderEmail>jk@csuchico.edu</senderEmail><timestampReceived>2000-11-29 03:39:24-0400</timestampReceived><subject>Re: Intl. patch 2.2.17.11pre1</subject><body>

On Tue, Nov 28, 2000 at 07:33:51PM +0100, Alexander S A Kjeldaas wrote:
&gt; Forgot to mention this.. it's not in the kernel/crypto directory, but
&gt; rather in:
&gt; 
&gt; ftp://ftp.kernel.org/pub/linux/kernel/people/astor/v2.2/

  I think Alan has been backporting some code.  I've needed this with
everything I've tried against 2.2.18pre* so far.

["patch-int-2.2.17.11pre1+cryptoapi" (text/plain)]

--- ./crypto/cryptoapi.c.OLD	Tue Nov 28 18:57:09 2000
+++ ./crypto/cryptoapi.c	Tue Nov 28 19:30:58 2000
@@ -65,7 +65,7 @@
 };
 
 #ifdef CONFIG_PROC_FS
-#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,3,0)
+#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,2,18)
 /* We have to emulate the 2.4 function proc_mkdir, because it is not
  * present in 2.2 - HW */
 static struct proc_dir_entry *

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20001129061534</emailId><senderName>John Kennedy</senderName><senderEmail>jk@csuchico.edu</senderEmail><timestampReceived>2000-11-29 06:15:34-0400</timestampReceived><subject>Re: Intl. patch 2.2.17.11pre1</subject><body>

On Tue, Nov 28, 2000 at 03:47:58PM +0100, Alexander S A Kjeldaas wrote:
&gt; Short list of changes:
&gt; o New util-linux patch (util-linux-2.10o.int2).  You need to recompile
&gt;   util-linux using this patch! ...

  I think you're missing a few files from your patch.  rmd160.c &amp; .h
are missing and the prototype in lomount.h for set_loop() doesn't match
what is in mount.c (and my patch is probably incorrect since I'm more
interested in exercising my kernel patches than testing mount at the
moment).  Anyway, you may want to take a look at it.

["PATCH.util-linux-2.10q+crypto+jk" (text/plain)]

--- ./mount/mount.c.OLD	Tue Nov 28 21:36:03 2000
+++ ./mount/mount.c	Tue Nov 28 21:52:55 2000
@@ -575,7 +575,7 @@
       if (verbose)
 	printf(_("mount: going to use the loop device %s\n"), *loopdev);
       offset = opt_offset ? strtoul(opt_offset, NULL, 0) : 0;
-      if (set_loop (*loopdev, *loopfile, offset, opt_encryption, pfd, &amp;loopro)) {
+      if (set_loop (*loopdev, *loopfile, offset, opt_encryption, pfd, 0, &amp;loopro)) {
 	if (verbose)
 	  printf(_("mount: failed setting up loop device\n"));
 	return EX_FAIL;
--- ./mount/rmd160.c.OLD	Tue Nov 28 22:03:14 2000
+++ ./mount/rmd160.c	Thu Nov  9 22:47:04 2000
@@ -0,0 +1,532 @@
+/* rmd160.c  -	RIPE-MD160
+ *	Copyright (C) 1998 Free Software Foundation, Inc.
+ */
+
+/* This file was part of GnuPG. Modified for use within the Linux
+ * mount utility by Marc Mutz &lt;Marc@Mutz.com&gt;. None of this code is
+ * by myself. I just removed everything that you don't need when all
+ * you want to do is to use rmd160_hash_buffer().
+ * My comments are marked with (mm).  */
+
+/* GnuPG is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * GnuPG is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA */
+
+#include &lt;string.h&gt; /* (mm) for memcpy */
+#include &lt;endian.h&gt; /* (mm) for BIG_ENDIAN and BYTE_ORDER */
+#include "rmd160.h"
+
+/* (mm) these are used by the original GnuPG file. In order to modify
+ * that file not too much, we keep the notations. maybe it would be
+ * better to include linux/types.h and typedef __u32 to u32 and __u8
+ * to byte?  */
+typedef unsigned int u32; /* taken from e.g. util-linux's minix.h */
+typedef unsigned char byte;
+
+typedef struct {
+    u32  h0,h1,h2,h3,h4;
+    u32  nblocks;
+    byte buf[64];
+    int  count;
+} RMD160_CONTEXT;
+
+/****************
+ * Rotate a 32 bit integer by n bytes
+ */
+#if defined(__GNUC__) &amp;&amp; defined(__i386__)
+static inline u32
+rol( u32 x, int n)
+{
+	__asm__("roll %%cl,%0"
+		:"=r" (x)
+		:"0" (x),"c" (n));
+	return x;
+}
+#else
+  #define rol(x,n) ( ((x) &lt;&lt; (n)) | ((x) &gt;&gt; (32-(n))) )
+#endif
+
+/*********************************
+ * RIPEMD-160 is not patented, see (as of 25.10.97)
+ *   http://www.esat.kuleuven.ac.be/~bosselae/ripemd160.html
+ * Note that the code uses Little Endian byteorder, which is good for
+ * 386 etc, but we must add some conversion when used on a big endian box.
+ *
+ *
+ * Pseudo-code for RIPEMD-160
+ *
+ * RIPEMD-160 is an iterative hash function that operates on 32-bit words.
+ * The round function takes as input a 5-word chaining variable and a 16-word
+ * message block and maps this to a new chaining variable. All operations are
+ * defined on 32-bit words. Padding is identical to that of MD4.
+ *
+ *
+ * RIPEMD-160: definitions
+ *
+ *
+ *   nonlinear functions at bit level: exor, mux, -, mux, -
+ *
+ *   f(j, x, y, z) = x XOR y XOR z		  (0 &lt;= j &lt;= 15)
+ *   f(j, x, y, z) = (x AND y) OR (NOT(x) AND z)  (16 &lt;= j &lt;= 31)
+ *   f(j, x, y, z) = (x OR NOT(y)) XOR z	  (32 &lt;= j &lt;= 47)
+ *   f(j, x, y, z) = (x AND z) OR (y AND NOT(z))  (48 &lt;= j &lt;= 63)
+ *   f(j, x, y, z) = x XOR (y OR NOT(z))	  (64 &lt;= j &lt;= 79)
+ *
+ *
+ *   added constants (hexadecimal)
+ *
+ *   K(j) = 0x00000000	    (0 &lt;= j &lt;= 15)
+ *   K(j) = 0x5A827999	   (16 &lt;= j &lt;= 31)	int(2**30 x sqrt(2))
+ *   K(j) = 0x6ED9EBA1	   (32 &lt;= j &lt;= 47)	int(2**30 x sqrt(3))
+ *   K(j) = 0x8F1BBCDC	   (48 &lt;= j &lt;= 63)	int(2**30 x sqrt(5))
+ *   K(j) = 0xA953FD4E	   (64 &lt;= j &lt;= 79)	int(2**30 x sqrt(7))
+ *   K'(j) = 0x50A28BE6     (0 &lt;= j &lt;= 15)      int(2**30 x cbrt(2))
+ *   K'(j) = 0x5C4DD124    (16 &lt;= j &lt;= 31)      int(2**30 x cbrt(3))
+ *   K'(j) = 0x6D703EF3    (32 &lt;= j &lt;= 47)      int(2**30 x cbrt(5))
+ *   K'(j) = 0x7A6D76E9    (48 &lt;= j &lt;= 63)      int(2**30 x cbrt(7))
+ *   K'(j) = 0x00000000    (64 &lt;= j &lt;= 79)
+ *
+ *
+ *   selection of message word
+ *
+ *   r(j)      = j		      (0 &lt;= j &lt;= 15)
+ *   r(16..31) = 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8
+ *   r(32..47) = 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12
+ *   r(48..63) = 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2
+ *   r(64..79) = 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
+ *   r0(0..15) = 5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12
+ *   r0(16..31)= 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2
+ *   r0(32..47)= 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13
+ *   r0(48..63)= 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14
+ *   r0(64..79)= 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
+ *
+ *
+ *   amount for rotate left (rol)
+ *
+ *   s(0..15)  = 11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8
+ *   s(16..31) = 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12
+ *   s(32..47) = 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5
+ *   s(48..63) = 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12
+ *   s(64..79) = 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
+ *   s'(0..15) = 8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6
+ *   s'(16..31)= 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11
+ *   s'(32..47)= 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5
+ *   s'(48..63)= 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8
+ *   s'(64..79)= 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
+ *
+ *
+ *   initial value (hexadecimal)
+ *
+ *   h0 = 0x67452301; h1 = 0xEFCDAB89; h2 = 0x98BADCFE; h3 = 0x10325476;
+ *							h4 = 0xC3D2E1F0;
+ *
+ *
+ * RIPEMD-160: pseudo-code
+ *
+ *   It is assumed that the message after padding consists of t 16-word blocks
+ *   that will be denoted with X[i][j], with 0 &lt;= i &lt;= t-1 and 0 &lt;= j &lt;= 15.
+ *   The symbol [+] denotes addition modulo 2**32 and rol_s denotes cyclic left
+ *   shift (rotate) over s positions.
+ *
+ *
+ *   for i := 0 to t-1 {
+ *	 A := h0; B := h1; C := h2; D = h3; E = h4;
+ *	 A' := h0; B' := h1; C' := h2; D' = h3; E' = h4;
+ *	 for j := 0 to 79 {
+ *	     T := rol_s(j)(A [+] f(j, B, C, D) [+] X[i][r(j)] [+] K(j)) [+] E;
+ *	     A := E; E := D; D := rol_10(C); C := B; B := T;
+ *	     T := rol_s'(j)(A' [+] f(79-j, B', C', D') [+] X[i][r'(j)]
+						       [+] K'(j)) [+] E';
+ *	     A' := E'; E' := D'; D' := rol_10(C'); C' := B'; B' := T;
+ *	 }
+ *	 T := h1 [+] C [+] D'; h1 := h2 [+] D [+] E'; h2 := h3 [+] E [+] A';
+ *	 h3 := h4 [+] A [+] B'; h4 := h0 [+] B [+] C'; h0 := T;
+ *   }
+ */
+
+/* Some examples:
+ * ""                    9c1185a5c5e9fc54612808977ee8f548b2258d31
+ * "a"                   0bdc9d2d256b3ee9daae347be6f4dc835a467ffe
+ * "abc"                 8eb208f7e05d987a9b044a8e98c6b087f15a0bfc
+ * "message digest"      5d0689ef49d2fae572b881b123a85ffa21595f36
+ * "a...z"               f71c27109c692c1b56bbdceb5b9d2865b3708dbc
+ * "abcdbcde...nopq"     12a053384a9c0c88e405a06c27dcf49ada62eb2b
+ * "A...Za...z0...9"     b0e20b6e3116640286ed3a87a5713079b21f5189
+ * 8 times "1234567890"  9b752e45573d4b39f4dbd3323cab82bf63326bfb
+ * 1 million times "a"   52783243c1697bdbe16d37f97f68f08325dc1528
+ */
+
+
+static void
+rmd160_init( RMD160_CONTEXT *hd )
+{
+    hd-&gt;h0 = 0x67452301;
+    hd-&gt;h1 = 0xEFCDAB89;
+    hd-&gt;h2 = 0x98BADCFE;
+    hd-&gt;h3 = 0x10325476;
+    hd-&gt;h4 = 0xC3D2E1F0;
+    hd-&gt;nblocks = 0;
+    hd-&gt;count = 0;
+}
+
+
+
+/****************
+ * Transform the message X which consists of 16 32-bit-words
+ */
+static void
+transform( RMD160_CONTEXT *hd, byte *data )
+{
+    u32 a,b,c,d,e,aa,bb,cc,dd,ee,t;
+  #if BYTE_ORDER == BIG_ENDIAN
+    u32 x[16];
+    { int i;
+      byte *p2, *p1;
+      for(i=0, p1=data, p2=(byte*)x; i &lt; 16; i++, p2 += 4 ) {
+	p2[3] = *p1++;
+	p2[2] = *p1++;
+	p2[1] = *p1++;
+	p2[0] = *p1++;
+      }
+    }
+  #else
+   #if 0
+    u32 *x =(u32*)data;
+   #else
+    /* this version is better because it is always aligned;
+     * The performance penalty on a 586-100 is about 6% which
+     * is acceptable - because the data is more local it might
+     * also be possible that this is faster on some machines.
+     * This function (when compiled with -02 on gcc 2.7.2)
+     * executes on a 586-100 (39.73 bogomips) at about 1900kb/sec;
+     * [measured with a 4MB data and "gpgm --print-md rmd160"] */
+    u32 x[16];
+    memcpy( x, data, 64 );
+   #endif
+  #endif
+
+
+#define K0  0x00000000
+#define K1  0x5A827999
+#define K2  0x6ED9EBA1
+#define K3  0x8F1BBCDC
+#define K4  0xA953FD4E
+#define KK0 0x50A28BE6
+#define KK1 0x5C4DD124
+#define KK2 0x6D703EF3
+#define KK3 0x7A6D76E9
+#define KK4 0x00000000
+#define F0(x,y,z)   ( (x) ^ (y) ^ (z) )
+#define F1(x,y,z)   ( ((x) &amp; (y)) | (~(x) &amp; (z)) )
+#define F2(x,y,z)   ( ((x) | ~(y)) ^ (z) )
+#define F3(x,y,z)   ( ((x) &amp; (z)) | ((y) &amp; ~(z)) )
+#define F4(x,y,z)   ( (x) ^ ((y) | ~(z)) )
+#define R(a,b,c,d,e,f,k,r,s) do { t = a + f(b,c,d) + k + x[r]; \
+				  a = rol(t,s) + e;	       \
+				  c = rol(c,10);	       \
+				} while(0)
+
+    /* left lane */
+    a = hd-&gt;h0;
+    b = hd-&gt;h1;
+    c = hd-&gt;h2;
+    d = hd-&gt;h3;
+    e = hd-&gt;h4;
+    R( a, b, c, d, e, F0, K0,  0, 11 );
+    R( e, a, b, c, d, F0, K0,  1, 14 );
+    R( d, e, a, b, c, F0, K0,  2, 15 );
+    R( c, d, e, a, b, F0, K0,  3, 12 );
+    R( b, c, d, e, a, F0, K0,  4,  5 );
+    R( a, b, c, d, e, F0, K0,  5,  8 );
+    R( e, a, b, c, d, F0, K0,  6,  7 );
+    R( d, e, a, b, c, F0, K0,  7,  9 );
+    R( c, d, e, a, b, F0, K0,  8, 11 );
+    R( b, c, d, e, a, F0, K0,  9, 13 );
+    R( a, b, c, d, e, F0, K0, 10, 14 );
+    R( e, a, b, c, d, F0, K0, 11, 15 );
+    R( d, e, a, b, c, F0, K0, 12,  6 );
+    R( c, d, e, a, b, F0, K0, 13,  7 );
+    R( b, c, d, e, a, F0, K0, 14,  9 );
+    R( a, b, c, d, e, F0, K0, 15,  8 );
+    R( e, a, b, c, d, F1, K1,  7,  7 );
+    R( d, e, a, b, c, F1, K1,  4,  6 );
+    R( c, d, e, a, b, F1, K1, 13,  8 );
+    R( b, c, d, e, a, F1, K1,  1, 13 );
+    R( a, b, c, d, e, F1, K1, 10, 11 );
+    R( e, a, b, c, d, F1, K1,  6,  9 );
+    R( d, e, a, b, c, F1, K1, 15,  7 );
+    R( c, d, e, a, b, F1, K1,  3, 15 );
+    R( b, c, d, e, a, F1, K1, 12,  7 );
+    R( a, b, c, d, e, F1, K1,  0, 12 );
+    R( e, a, b, c, d, F1, K1,  9, 15 );
+    R( d, e, a, b, c, F1, K1,  5,  9 );
+    R( c, d, e, a, b, F1, K1,  2, 11 );
+    R( b, c, d, e, a, F1, K1, 14,  7 );
+    R( a, b, c, d, e, F1, K1, 11, 13 );
+    R( e, a, b, c, d, F1, K1,  8, 12 );
+    R( d, e, a, b, c, F2, K2,  3, 11 );
+    R( c, d, e, a, b, F2, K2, 10, 13 );
+    R( b, c, d, e, a, F2, K2, 14,  6 );
+    R( a, b, c, d, e, F2, K2,  4,  7 );
+    R( e, a, b, c, d, F2, K2,  9, 14 );
+    R( d, e, a, b, c, F2, K2, 15,  9 );
+    R( c, d, e, a, b, F2, K2,  8, 13 );
+    R( b, c, d, e, a, F2, K2,  1, 15 );
+    R( a, b, c, d, e, F2, K2,  2, 14 );
+    R( e, a, b, c, d, F2, K2,  7,  8 );
+    R( d, e, a, b, c, F2, K2,  0, 13 );
+    R( c, d, e, a, b, F2, K2,  6,  6 );
+    R( b, c, d, e, a, F2, K2, 13,  5 );
+    R( a, b, c, d, e, F2, K2, 11, 12 );
+    R( e, a, b, c, d, F2, K2,  5,  7 );
+    R( d, e, a, b, c, F2, K2, 12,  5 );
+    R( c, d, e, a, b, F3, K3,  1, 11 );
+    R( b, c, d, e, a, F3, K3,  9, 12 );
+    R( a, b, c, d, e, F3, K3, 11, 14 );
+    R( e, a, b, c, d, F3, K3, 10, 15 );
+    R( d, e, a, b, c, F3, K3,  0, 14 );
+    R( c, d, e, a, b, F3, K3,  8, 15 );
+    R( b, c, d, e, a, F3, K3, 12,  9 );
+    R( a, b, c, d, e, F3, K3,  4,  8 );
+    R( e, a, b, c, d, F3, K3, 13,  9 );
+    R( d, e, a, b, c, F3, K3,  3, 14 );
+    R( c, d, e, a, b, F3, K3,  7,  5 );
+    R( b, c, d, e, a, F3, K3, 15,  6 );
+    R( a, b, c, d, e, F3, K3, 14,  8 );
+    R( e, a, b, c, d, F3, K3,  5,  6 );
+    R( d, e, a, b, c, F3, K3,  6,  5 );
+    R( c, d, e, a, b, F3, K3,  2, 12 );
+    R( b, c, d, e, a, F4, K4,  4,  9 );
+    R( a, b, c, d, e, F4, K4,  0, 15 );
+    R( e, a, b, c, d, F4, K4,  5,  5 );
+    R( d, e, a, b, c, F4, K4,  9, 11 );
+    R( c, d, e, a, b, F4, K4,  7,  6 );
+    R( b, c, d, e, a, F4, K4, 12,  8 );
+    R( a, b, c, d, e, F4, K4,  2, 13 );
+    R( e, a, b, c, d, F4, K4, 10, 12 );
+    R( d, e, a, b, c, F4, K4, 14,  5 );
+    R( c, d, e, a, b, F4, K4,  1, 12 );
+    R( b, c, d, e, a, F4, K4,  3, 13 );
+    R( a, b, c, d, e, F4, K4,  8, 14 );
+    R( e, a, b, c, d, F4, K4, 11, 11 );
+    R( d, e, a, b, c, F4, K4,  6,  8 );
+    R( c, d, e, a, b, F4, K4, 15,  5 );
+    R( b, c, d, e, a, F4, K4, 13,  6 );
+
+    aa = a; bb = b; cc = c; dd = d; ee = e;
+
+    /* right lane */
+    a = hd-&gt;h0;
+    b = hd-&gt;h1;
+    c = hd-&gt;h2;
+    d = hd-&gt;h3;
+    e = hd-&gt;h4;
+    R( a, b, c, d, e, F4, KK0,	5,  8);
+    R( e, a, b, c, d, F4, KK0, 14,  9);
+    R( d, e, a, b, c, F4, KK0,	7,  9);
+    R( c, d, e, a, b, F4, KK0,	0, 11);
+    R( b, c, d, e, a, F4, KK0,	9, 13);
+    R( a, b, c, d, e, F4, KK0,	2, 15);
+    R( e, a, b, c, d, F4, KK0, 11, 15);
+    R( d, e, a, b, c, F4, KK0,	4,  5);
+    R( c, d, e, a, b, F4, KK0, 13,  7);
+    R( b, c, d, e, a, F4, KK0,	6,  7);
+    R( a, b, c, d, e, F4, KK0, 15,  8);
+    R( e, a, b, c, d, F4, KK0,	8, 11);
+    R( d, e, a, b, c, F4, KK0,	1, 14);
+    R( c, d, e, a, b, F4, KK0, 10, 14);
+    R( b, c, d, e, a, F4, KK0,	3, 12);
+    R( a, b, c, d, e, F4, KK0, 12,  6);
+    R( e, a, b, c, d, F3, KK1,	6,  9);
+    R( d, e, a, b, c, F3, KK1, 11, 13);
+    R( c, d, e, a, b, F3, KK1,	3, 15);
+    R( b, c, d, e, a, F3, KK1,	7,  7);
+    R( a, b, c, d, e, F3, KK1,	0, 12);
+    R( e, a, b, c, d, F3, KK1, 13,  8);
+    R( d, e, a, b, c, F3, KK1,	5,  9);
+    R( c, d, e, a, b, F3, KK1, 10, 11);
+    R( b, c, d, e, a, F3, KK1, 14,  7);
+    R( a, b, c, d, e, F3, KK1, 15,  7);
+    R( e, a, b, c, d, F3, KK1,	8, 12);
+    R( d, e, a, b, c, F3, KK1, 12,  7);
+    R( c, d, e, a, b, F3, KK1,	4,  6);
+    R( b, c, d, e, a, F3, KK1,	9, 15);
+    R( a, b, c, d, e, F3, KK1,	1, 13);
+    R( e, a, b, c, d, F3, KK1,	2, 11);
+    R( d, e, a, b, c, F2, KK2, 15,  9);
+    R( c, d, e, a, b, F2, KK2,	5,  7);
+    R( b, c, d, e, a, F2, KK2,	1, 15);
+    R( a, b, c, d, e, F2, KK2,	3, 11);
+    R( e, a, b, c, d, F2, KK2,	7,  8);
+    R( d, e, a, b, c, F2, KK2, 14,  6);
+    R( c, d, e, a, b, F2, KK2,	6,  6);
+    R( b, c, d, e, a, F2, KK2,	9, 14);
+    R( a, b, c, d, e, F2, KK2, 11, 12);
+    R( e, a, b, c, d, F2, KK2,	8, 13);
+    R( d, e, a, b, c, F2, KK2, 12,  5);
+    R( c, d, e, a, b, F2, KK2,	2, 14);
+    R( b, c, d, e, a, F2, KK2, 10, 13);
+    R( a, b, c, d, e, F2, KK2,	0, 13);
+    R( e, a, b, c, d, F2, KK2,	4,  7);
+    R( d, e, a, b, c, F2, KK2, 13,  5);
+    R( c, d, e, a, b, F1, KK3,	8, 15);
+    R( b, c, d, e, a, F1, KK3,	6,  5);
+    R( a, b, c, d, e, F1, KK3,	4,  8);
+    R( e, a, b, c, d, F1, KK3,	1, 11);
+    R( d, e, a, b, c, F1, KK3,	3, 14);
+    R( c, d, e, a, b, F1, KK3, 11, 14);
+    R( b, c, d, e, a, F1, KK3, 15,  6);
+    R( a, b, c, d, e, F1, KK3,	0, 14);
+    R( e, a, b, c, d, F1, KK3,	5,  6);
+    R( d, e, a, b, c, F1, KK3, 12,  9);
+    R( c, d, e, a, b, F1, KK3,	2, 12);
+    R( b, c, d, e, a, F1, KK3, 13,  9);
+    R( a, b, c, d, e, F1, KK3,	9, 12);
+    R( e, a, b, c, d, F1, KK3,	7,  5);
+    R( d, e, a, b, c, F1, KK3, 10, 15);
+    R( c, d, e, a, b, F1, KK3, 14,  8);
+    R( b, c, d, e, a, F0, KK4, 12,  8);
+    R( a, b, c, d, e, F0, KK4, 15,  5);
+    R( e, a, b, c, d, F0, KK4, 10, 12);
+    R( d, e, a, b, c, F0, KK4,	4,  9);
+    R( c, d, e, a, b, F0, KK4,	1, 12);
+    R( b, c, d, e, a, F0, KK4,	5,  5);
+    R( a, b, c, d, e, F0, KK4,	8, 14);
+    R( e, a, b, c, d, F0, KK4,	7,  6);
+    R( d, e, a, b, c, F0, KK4,	6,  8);
+    R( c, d, e, a, b, F0, KK4,	2, 13);
+    R( b, c, d, e, a, F0, KK4, 13,  6);
+    R( a, b, c, d, e, F0, KK4, 14,  5);
+    R( e, a, b, c, d, F0, KK4,	0, 15);
+    R( d, e, a, b, c, F0, KK4,	3, 13);
+    R( c, d, e, a, b, F0, KK4,	9, 11);
+    R( b, c, d, e, a, F0, KK4, 11, 11);
+
+
+    t	   = hd-&gt;h1 + d + cc;
+    hd-&gt;h1 = hd-&gt;h2 + e + dd;
+    hd-&gt;h2 = hd-&gt;h3 + a + ee;
+    hd-&gt;h3 = hd-&gt;h4 + b + aa;
+    hd-&gt;h4 = hd-&gt;h0 + c + bb;
+    hd-&gt;h0 = t;
+}
+
+
+/* Update the message digest with the contents
+ * of INBUF with length INLEN.
+ */
+static void
+rmd160_write( RMD160_CONTEXT *hd, byte *inbuf, size_t inlen)
+{
+    if( hd-&gt;count == 64 ) { /* flush the buffer */
+	transform( hd, hd-&gt;buf );
+	hd-&gt;count = 0;
+	hd-&gt;nblocks++;
+    }
+    if( !inbuf )
+	return;
+    if( hd-&gt;count ) {
+	for( ; inlen &amp;&amp; hd-&gt;count &lt; 64; inlen-- )
+	    hd-&gt;buf[hd-&gt;count++] = *inbuf++;
+	rmd160_write( hd, NULL, 0 );
+	if( !inlen )
+	    return;
+    }
+
+    while( inlen &gt;= 64 ) {
+	transform( hd, inbuf );
+	hd-&gt;count = 0;
+	hd-&gt;nblocks++;
+	inlen -= 64;
+	inbuf += 64;
+    }
+    for( ; inlen &amp;&amp; hd-&gt;count &lt; 64; inlen-- )
+	hd-&gt;buf[hd-&gt;count++] = *inbuf++;
+}
+
+/* The routine terminates the computation
+ */
+
+static void
+rmd160_final( RMD160_CONTEXT *hd )
+{
+    u32 t, msb, lsb;
+    byte *p;
+
+    rmd160_write(hd, NULL, 0); /* flush */;
+
+    msb = 0;
+    t = hd-&gt;nblocks;
+    if( (lsb = t &lt;&lt; 6) &lt; t ) /* multiply by 64 to make a byte count */
+	msb++;
+    msb += t &gt;&gt; 26;
+    t = lsb;
+    if( (lsb = t + hd-&gt;count) &lt; t ) /* add the count */
+	msb++;
+    t = lsb;
+    if( (lsb = t &lt;&lt; 3) &lt; t ) /* multiply by 8 to make a bit count */
+	msb++;
+    msb += t &gt;&gt; 29;
+
+    if( hd-&gt;count &lt; 56 ) { /* enough room */
+	hd-&gt;buf[hd-&gt;count++] = 0x80; /* pad */
+	while( hd-&gt;count &lt; 56 )
+	    hd-&gt;buf[hd-&gt;count++] = 0;  /* pad */
+    }
+    else { /* need one extra block */
+	hd-&gt;buf[hd-&gt;count++] = 0x80; /* pad character */
+	while( hd-&gt;count &lt; 64 )
+	    hd-&gt;buf[hd-&gt;count++] = 0;
+	rmd160_write(hd, NULL, 0);  /* flush */;
+	memset(hd-&gt;buf, 0, 56 ); /* fill next block with zeroes */
+    }
+    /* append the 64 bit count */
+    hd-&gt;buf[56] = lsb	   ;
+    hd-&gt;buf[57] = lsb &gt;&gt;  8;
+    hd-&gt;buf[58] = lsb &gt;&gt; 16;
+    hd-&gt;buf[59] = lsb &gt;&gt; 24;
+    hd-&gt;buf[60] = msb	   ;
+    hd-&gt;buf[61] = msb &gt;&gt;  8;
+    hd-&gt;buf[62] = msb &gt;&gt; 16;
+    hd-&gt;buf[63] = msb &gt;&gt; 24;
+    transform( hd, hd-&gt;buf );
+
+    p = hd-&gt;buf;
+  #if BYTE_ORDER == BIG_ENDIAN
+    #define X(a) do { *p++ = hd-&gt;h##a	   ; *p++ = hd-&gt;h##a &gt;&gt; 8;	\
+		      *p++ = hd-&gt;h##a &gt;&gt; 16; *p++ = hd-&gt;h##a &gt;&gt; 24; } while(0)
+  #else /* little endian */
+    #define X(a) do { *(u32*)p = hd-&gt;h##a ; p += 4; } while(0)
+  #endif
+    X(0);
+    X(1);
+    X(2);
+    X(3);
+    X(4);
+  #undef X
+}
+
+/****************
+ * Shortcut functions which puts the hash value of the supplied buffer
+ * into outbuf which must have a size of 20 bytes.
+ */
+void
+rmd160_hash_buffer( char *outbuf, const char *buffer, size_t length )
+{
+    RMD160_CONTEXT hd;
+
+    rmd160_init( &amp;hd );
+    rmd160_write( &amp;hd, (byte*)buffer, length );
+    rmd160_final( &amp;hd );
+    memcpy( outbuf, hd.buf, 20 );
+}
--- ./mount/rmd160.h.OLD	Tue Nov 28 22:03:17 2000
+++ ./mount/rmd160.h	Thu Nov  9 22:47:04 2000
@@ -0,0 +1,9 @@
+#ifndef RMD160_H
+#define RMD160_H
+
+void
+rmd160_hash_buffer( char *outbuf, const char *buffer, size_t length );
+
+#endif /*RMD160_H*/
+
+

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20001123145524</emailId><senderName>John Kennedy</senderName><senderEmail>jk@csuchico.edu</senderEmail><timestampReceived>2000-11-23 14:55:24-0400</timestampReceived><subject>Re: AES</subject><body>

On Mon, Nov 06, 2000 at 10:34:54AM +0100, Marc Mutz wrote:
&gt; Emil wrote:
&gt; &gt; util-linux-2.10o.int.patch still doesn't include the AES encryption
&gt; &gt; Anyone plans to do it ?
&gt; 
&gt; You can easily add it to the list of known ciphers in
&gt; util-linux/mount/lomount.c
&gt; Then re-compile both mount and losetup.

  I've been looking into what I would have to do to try and enable that.
Right now I'm using serpent (in the readme and in the source, plus
it works), but AES is supposed to be much faster (looking at NIST's
benchmarks).

  You should need to fix it in two places.  crypt_type_tbl which has the
number, text-name and keylength (which I don't know for AES) and lower
for the big switch on lo_encrypt_type, where it would presumably be
included with LO_CRYPT_SERPENT and the rest.


  I've been saving this particular hack for a rainy day, but I think
that is correct.  Most of my losetup-like hacking has been done in my
own personal bootloader and outside of the normal utilities.

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001123144636</emailId><senderName>John Kennedy</senderName><senderEmail>jk@csuchico.edu</senderEmail><timestampReceived>2000-11-23 14:46:36-0400</timestampReceived><subject>Re: ppdd</subject><body>

On Thu, Nov 23, 2000 at 08:45:49PM +0800, Louis Lam wrote:
&gt; I was able to use ppdd to get an encrypted root file system and swap
&gt; partition. Both the root file system and the swap were formatted
&gt; with a blocksize of 1024 as suggested.
&gt;
&gt; Is there anyone in this list who is able to get encrypted root and
&gt; swap that are based on blocksize of 4096?

  I'm just using the regular kernel API, not ppdd.  Using ext2/ext3, you
tend to end up with 4K blocks by default and left them that way.

&gt; I am still trying to do that but so far I wasn't able to do so. I
&gt; understand that using the blocksize of 4096 may not be so efficient
&gt; for random access.  More will have to be decrypted before u can get
&gt; to the part of the block that U want. The reason I want to do this
&gt; is just for seeing the difference, and maybe able to encrypt some
&gt; existing data which is actually a linux installation from redhat
&gt; 6.2 which by default formats the partition with a blocksize of 4096.

  You'll have to decrypt the entire block before you get to play with
any part of it, yes.  For user home directories, I would think that
smaller block-sizes would be a plus (you're not dealing with horribly
large files as a general case, for example).  For encrypting an entire
filesystem, I would think you would get into the same kinds of efficiency
issues that made 4K blocks attractive in the first place.

  I tend to think of encryption as more of a latency issue.  All else
being equal, I've added encryption latency to my reads and writes,
but the underlying issues should all be the same.

  You could probably benchmark it.  The added latency might be so
great that it makes the raw 1K/4K blocksize issue moot.

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001130024824</emailId><senderName></senderName><senderEmail>sen_ml</senderEmail><timestampReceived>2000-11-30 02:48:24-0400</timestampReceived><subject>oops and request (was Re: block ciphers &amp; plaintext attacks)</subject><body>

may i request that people not post to:

  linux-crypto@humbolt.nl.linux.org

and instead post to:

  linux-crypto@nl.linux.org

p.s. sorry for the null-content message earlier, C-c C-c is not a
     great key sequence for sending mail!

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001130031155</emailId><senderName></senderName><senderEmail>sen_ml</senderEmail><timestampReceived>2000-11-30 03:11:55-0400</timestampReceived><subject>OT: Re: oops and request</subject><body>

how ironic...

it seems that posts are coming from humbolt now.

is this a permanent change in the mailing list?

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001130115836</emailId><senderName>Alexander S A Kjeldaas</senderName><senderEmail>alexander.kjeldaas@fast.no</senderEmail><timestampReceived>2000-11-30 11:58:36-0400</timestampReceived><subject>Re: block ciphers &amp; plaintext attacks</subject><body>

On Wed, Nov 29, 2000 at 11:09:30AM -0800, John Kennedy wrote:
&gt; 
&gt;   In my original email, above, I'm protecting a key (key2, with a
&gt; good range of input) with encryption, that is decoded by another key
&gt; (key1, with a smaller range of input).  If I knew I had decrypted key2
&gt; correctly with key1 then I would have a weakest-link situation.  If I
&gt; don't know, then an incorrect key2 complicates the hell out of finding
&gt; the correct cipher key.  It may not magnify it, but I doubt if it helps
&gt; to eliminates anything.
&gt; 

Having a key encrypted by another key doesn't bother the attacker one
bit.  Consider the case where key1 has the same entropy as key2.  The
attacker can simply try all possible key1 combinations, and for each
one, find the corresponding key2 key which is then used to decrypt the
data.  This requires 2x the time to brute-force, but that is
comparable to having a single key with 1 bit more entropy.  It is also
such a low constant that using a cipher which require more time during
key-setup will have the same, or greater, effect.

However, having a key encrypted with another key can be very practical
in many ways:

o For instance if you create a random 256-bit key to use for your
encrypted filesystem, you can encrypt this key with PGP.  If you fear
that your password might be compromized, you can change the password
for your encrypted key without having to re-encrypt the whole dataset.

o You can also use more advanced crypto-software such as letting N
people know parts of a key and requiring that m out of N be agreeing
to unlock the encrypted disk.

o If you rarely need to decrypt your 256-bit key, you can physically
store the weakly encrypted key somewhere else.  A 256-bit key
encrypted with another 10-bit enthropy key stored in a sufficiently
secure vault isn't necessary a weak link.

astor

-- 
Alexander Kjeldaas                Mail:  astor@fast.no
finger astor@master.kernel.org for OpenPGP key.

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001130222445</emailId><senderName>John Kennedy</senderName><senderEmail>jk@csuchico.edu</senderEmail><timestampReceived>2000-11-30 22:24:45-0400</timestampReceived><subject>loopback block sizes</subject><body>

  In trying to test patch-2.2.17.11pre1 I was doing some QA on my
bootloader program.  It looks like the loopback device will return
EOF before a file is finished.

  In my case in particular, I was using files instead of block devices
(again, for testing) and had a nulled loop_info so I wasn't dealing with
encryption at that point.  I had a 7851-byte test file, which happens
to be (7*1024)+683.  The general setup was:

	(&lt;stdin&gt; -&gt; /dev/loop0) -&gt; &lt;stdout&gt;	[ &lt; /tmp/in &gt; /tmp/out ]

			... which should equate to

			(/tmp/in -&gt; /dev/loop0) -&gt; /tmp/out

  I was getting a output file truncated at 7168 (7*1024) bytes.  That
wasn't even a multiple of 4096, which is st_blksize if you stat() the
input, output, or loopback file descriptors.

  I assume it is just giving me the finger because the leftover 683
bytes aren't a multiple of the block size, but right now I'm not being
given the proper block size anyway.


  No real problem dealing with it, but it made me wonder what was going
on with the whole 1K/4K filesystem block size again.

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001001112649</emailId><senderName>Alexander S A Kjeldaas</senderName><senderEmail>alexander.kjeldaas@fast.no</senderEmail><timestampReceived>2000-10-01 11:26:49-0400</timestampReceived><subject>Re: AES will be announced monday.</subject><body>

On Sat, Sep 30, 2000 at 10:49:30AM +0200, Alexander S A Kjeldaas wrote:
&gt; 
&gt; The newest implementation in the kerneli patch is almost twice as
&gt; fast as the previous one on Pentium III, and thus the fastest of all
&gt; the AES candicates in software too!

Correction. It's not in the kerneli patch yet, it's in a separate tree
of mine.

astor

-- 
Alexander Kjeldaas                Mail:  astor@fast.no
finger astor@master.kernel.org for OpenPGP key.

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001002105358</emailId><senderName>Marc Mutz</senderName><senderEmail>marc@mutz.com</senderEmail><timestampReceived>2000-10-02 10:53:58-0400</timestampReceived><subject>[Encryption-HOWTO] now on sourceforge!</subject><body>

Hi out there!

The old 486DX-40 (clocked at 20MHz due to hardware problems) was totally
overloaded with accesses to the HOWTO after the posting to /. (not by
me!). So I've taken the tast to move its homepage to sourceforge. I've
succeeded, but currently there is no added value (no CVS, no FTP, only
the web site as you know it). I will make at least CVS and anon-FTP
available in a few days, meaning that anyone who feels he could
contribute something "worthy" to the HOWTO will be able to do so. The
new address is (surprisingly)
http://EncryptionHOWTO.sourceforge.net/
and is up and running for a few minutes by now. If you see any dead
links or the like, please let me know and I'll fix them ASAP.

The old site remains existent, put points to the new one.

Marc

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001002163018</emailId><senderName>Simos Xenitellis</senderName><senderEmail>root@pc96.ma.rhbnc.ac.uk</senderEmail><timestampReceived>2000-10-02 16:30:18-0400</timestampReceived><subject>Re: [Fwd: AES for GnuPG, on Mon Oct 2?]</subject><body>

On Mon, 2 Oct 2000, Ian S. Nelson wrote:

&gt; Wasn't DES covered by a patent?  I know Lucifer was and DES is closely
&gt; related.   Patent or no patent, AES should be fairly liberal in terms of usage
&gt; restrictions.  I don't remember the rules but I thought that there was some
&gt; provision for patents.

At the NIST AES WWW site (http://csrc.nist.gov/encryption/aes/) it says:

===
SPECIAL NOTE - Intellectual Property 
NIST reminds all interested
parties that the adoption of AES is being conducted as an open
standards-setting activity. Specifically, NIST has
requested that all interested parties identify to NIST any patents or
inventions that may be required for the use of AES. NIST
hereby gives public notice that it may seek redress under the antitrust
laws of the United States against any party in the
future who might seek to exercise patent rights against any user of AES
that have not been disclosed to NIST in response to this
request for information. 
===

So, there is no worry.

&gt; 
&gt; Anyone know who won yet?  The NIST webcast page doesn't work.

It is supposed to be announce on http://csrc.nist.gov/encryption/aes/,
just keep refreshing the page.

simos


Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001002164139</emailId><senderName>Simos Xenitellis</senderName><senderEmail>root@pc96.ma.rhbnc.ac.uk</senderEmail><timestampReceived>2000-10-02 16:41:39-0400</timestampReceived><subject>Semi-official announcement: Rijndael</subject><body>


From: Quisquater &lt;jjq@dice.ucl.ac.be&gt;
on USENET, sci.crypt, 

http://www.esat.kuleuven.ac.be/cosic/#press

simos


Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001002164833</emailId><senderName>Gisle S{lensminde</senderName><senderEmail>gisle@ii.uib.no</senderEmail><timestampReceived>2000-10-02 16:48:33-0400</timestampReceived><subject>Rijndael</subject><body>


Is Rijndael working, now when it seems to have become AES?

In changelog:

       * rijndael3.c updates from Marc Mutz &lt;marc@mutz.com&gt; should get
       this cipher working again.


But in config.in you will find:

+# Rijndael isn't working
+#      dep_tristate 'Rijndael cipher (EXPERIMENTAL)'\
CONFIG_CIPHER_RIJNDAEL $CONFIG_CIPHERS


--
Gisle Sælensminde ( gisle@ii.uib.no )   

With sufficient thrust, pigs fly just fine. However, this is not
necessarily a good idea. It is hard to be sure where they are going
to land, and it could be dangerous sitting under them as they fly
overhead. (from RFC 1925)



Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001002165640</emailId><senderName>Marc Mutz</senderName><senderEmail>marc@mutz.com</senderEmail><timestampReceived>2000-10-02 16:56:40-0400</timestampReceived><subject>Re: Rijndael</subject><body>

Gisle S{lensminde wrote:
&gt; 
&gt; Is Rijndael working, now when it seems to have become AES?
&gt; 
No.

&gt; In changelog:
&gt; 
&gt;        * rijndael3.c updates from Marc Mutz &lt;marc@mutz.com&gt; should get
&gt;        this cipher working again.
&gt; 
This was for people to play with and test.

&gt; But in config.in you will find:
&gt; 
&gt; +# Rijndael isn't working
&gt; +#      dep_tristate 'Rijndael cipher (EXPERIMENTAL)'\
&gt; CONFIG_CIPHER_RIJNDAEL $CONFIG_CIPHERS
&gt; 
&lt;snip&gt;

That is correct. It loads, registers, but on use it crashes the machine
hard.
Someone should look into it in userspace. I'm currently busy (it's not
weekend, you know).

Marc

-- 
Marc Mutz &lt;Marc@Mutz.com&gt;        http://marc.mutz.com/Encryption-HOWTO/
University of Bielefeld, Dep. of Mathematics / Dep. of Physics

PGP-keyID's:   0xd46ce9ab (RSA), 0x7ae55b9e (DSS/DH)


Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001003103433</emailId><senderName>Alexander S A Kjeldaas</senderName><senderEmail>alexander.kjeldaas@fast.no</senderEmail><timestampReceived>2000-10-03 10:34:33-0400</timestampReceived><subject>2.2.17.7</subject><body>

2.2.17.7 is released with the AES cipher integrated.  

2000-10-03 Alexander Kjeldaas &lt;astor@fast.no&gt;

	* International kernel patch 2.2.17.7 released.

	* speed.c cleanups.

	* The crypto API now compiles when proc support has been disabled.
	
	* AES cipher added.  The AES cipher is implemented by the rijndael
	module, but with a separate cipher id/name.
	
	* Updated Rijndael implementation from Brian Gladman merged.

	* ECB testvectors for rijndael from the AES submission added.

This patch is available from:

ftp.*.kernel.org:/pub/linux/kernel/crypto/v2.2/

astor

-- 
Alexander Kjeldaas                Mail:  astor@fast.no
finger astor@master.kernel.org for OpenPGP key.

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001003143807</emailId><senderName>Alexander S A Kjeldaas</senderName><senderEmail>alexander.kjeldaas@fast.no</senderEmail><timestampReceived>2000-10-03 14:38:07-0400</timestampReceived><subject>Re: Rijndael</subject><body>

On Mon, Oct 02, 2000 at 04:56:40PM +0000, Marc Mutz wrote:

&gt;  That is correct. It loads, registers, but on use it crashes the
&gt; machine hard.  Someone should look into it in userspace. I'm
&gt; currently busy (it's not weekend, you know).

The current version works and passes the AES test vectors.

astor

-- 
Alexander Kjeldaas                Mail:  astor@fast.no
finger astor@master.kernel.org for OpenPGP key.

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001001111702</emailId><senderName>Alexander S A Kjeldaas</senderName><senderEmail>alexander.kjeldaas@fast.no</senderEmail><timestampReceived>2000-10-01 11:17:02-0400</timestampReceived><subject>Re: [experimantal patch] show allowed keylengths in /proc/cipher/*</subject><body>

On Fri, Sep 29, 2000 at 03:13:27PM +0000, Marc Mutz wrote:
&gt; Hi out there!
&gt; 
&gt; This little patch allows /proc/cipher/* to show a bitmask of allowed
&gt; keysizes. Simple as it may ssem, it breaks the current jungle of
&gt; #define's quite thoroughly. Ciphers that want to take advantage of this
&gt; patch and actually _provide_ more than one keylength per cipher
&gt; implementation (and most ciphers could), will not be able to use the
&gt; DEFINE_CIPHER construct any more.
&gt; 

Why not just let all ciphers accept any key-length up to a maximum key
length, and have the cipher internally treat shorter keys as a
possible optimization opportunities.  For example, the rijndael cipher
could exploit that kind of stuff to select the correct number of
rounds.  So the user wouldn't really care about which intermediate
keylengths a cipher was designed for, just the maximum keylength it
was designed for.

&gt; So what now? I'd like to remove the DEFINE_CIPHER construct althogether.
&gt; It makes defining "dumb" ciphers easy, but it obfuscates the definition
&gt; of a cipher for unexperienced (w.r.t. cipherapi) coders and interested
&gt; eyes that read the source, since the meaning of the numbers and strings
&gt; appearing in DEFINE_CIPHER is not obvious. Even when you have read over
&gt; a few cipher sources you catch yourself going back to
&gt; include/linux/crypto.h to look up what each entry means.
&gt; 
&gt; On the opposite, having the struct cipher_implementation populated
&gt; without the help of macros goes a long way towards transparency, because
&gt; the field identifiers show up alongside their values. Or not?
&gt; 
&gt; Now my inexprience with C comes up again: Is there a C construct that
&gt; shows the field identifiers even in static const definitions? Like in
&gt; perl:
&gt; 
&gt; %an_associative_array = {
&gt; 	field1 -&gt; value1,
&gt; 	field2 -&gt; value2,
&gt; 	 :          :
&gt; }
&gt; 

You are free to not use DEFINE_CIPHER if you want.  There are two
constructs that can be used to initialize C structs.  One is a gcc
extension and looks like this:

struct foo bar = {
	membera: 1,
	memberb: 2
};

The other one is part of C99 and goes like this:

struct foo bar = {
	.membera = 1,
	.memberb = 2
};

In the kernel, the first form is used since it is programmed in GNU C,
and not standard C.

astor

-- 
Alexander Kjeldaas                Mail:  astor@fast.no
finger astor@master.kernel.org for OpenPGP key.

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001002150529</emailId><senderName>Marc Mutz</senderName><senderEmail>marc@mutz.com</senderEmail><timestampReceived>2000-10-02 15:05:29-0400</timestampReceived><subject>Using kerneli w/o compiling a kernel?</subject><body>

Hi!

I've run into the problem of explaining how to make an encrypted folder
with kerneli to someone who merely survived a linux install. I kow that
the answer to the following is NO, but does someone out there know of
RPMs for the major dirtributions of both the kernel modules and the
patched mount and losetup? Is anyone willing to do this or tell me how
to? This would greatly simplify my task.

However if - as is expected - the answer to the above question is NO, is
there a way to completely module out the kerneli parts so that there is
no need to recompile the kernel. I know that everything can be compiled
as modules, but when I try this, I don't get a cryptoapi.o module. I've
selected it as being a module, but is is compiled into the kernel
nevertheless:

Q&gt; $ cat /proc/ksyms | grep cipher
Q&gt; c02462e8 cipher_group

Marc

-- 
Marc Mutz &lt;Marc@Mutz.com&gt;  http://Encryption-HOWTO.sourceforge.net/
University of Bielefeld, Dep. of Mathematics / Dep. of Physics

PGP-keyID's:   0xd46ce9ab (RSA), 0x7ae55b9e (DSS/DH)



Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001005210752</emailId><senderName>Andreas Schuldei</senderName><senderEmail>andreas@schuldei.org</senderEmail><timestampReceived>2000-10-05 21:07:52-0400</timestampReceived><subject>fast encryption of large files with asymetric keys</subject><body>

Is there a program/lib/... for fast encryption of large files with asymetric
keys? gpg would do, but the minimal keylegth is 768 and with that key it is to
slow. In fact a much smaller key would do. 60-200 Bits should be enough.

Is there such a beast? Where?

Please cc me, i am not on this list.

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001006130341</emailId><senderName>Marc Mutz</senderName><senderEmail>marc@mutz.com</senderEmail><timestampReceived>2000-10-06 13:03:41-0400</timestampReceived><subject>Q: Can in and out buffers of xxx_encrypt() be the same?</subject><body>

Hi!

We should clarify the issues:

Must cipher implementations

1) expect that *in and *out may be the same buffer?
2) use no additional memory for operation after set_key() is called?

Point (1) is not that terribly importatnt. It's just that such things
should be defined somewhere.

ad (2): I'm particularly thinking of encrypting swap here. There was a
thread[1] about this about a year ago or so on lkml where it was said
that it was necessary that encrypt() and decrypt() don't use additional
memory for their run.
However, whether this includes local variables placed on the stack I
don't know. Maybe there is a limitation on the overall size of local
variables so that it is not neccessay to claim a new page for the stack.

Marc

[1] message-id of the stating post was:
&lt;1E7F3E867C2DD3119D7F00A0C9D858639AC087@excnlle001.wang.nl&gt;

-- 
Marc Mutz &lt;Marc@Mutz.com&gt;     http://EncryptionHOWTO.sourceforge.net/
University of Bielefeld, Dep. of Mathematics / Dep. of Physics

PGP-keyID's:   0xd46ce9ab (RSA), 0x7ae55b9e (DSS/DH)



Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001014015017</emailId><senderName>Alexander S A Kjeldaas</senderName><senderEmail>alexander.kjeldaas@fast.no</senderEmail><timestampReceived>2000-10-14 01:50:17-0400</timestampReceived><subject>2.2.17.8</subject><body>

2.2.17.8 has now been released.  This patch includes some
reorganization of the code, but also some important API changes.  Or
rather, the interface is now defined :-).  The encrypt/decrypt
functions are allowed to sleep, and they have to tackle all
input/output sizes.  This is the new interface as defined in crypto.h:

	/*
	 * Encrypt the plaintext pointed to by "in".  Write output to
	 * "out". Size of plaintext is "size".  Output buffer must be
	 * able to hold "size" bytes plus padding necessary to make it
	 * a multiple of the cipher blocksize. size &lt;= 0 is
	 * undefined. Returns 0 on success, non-zero on
	 * failure. Function might sleep.
	 * 
	 */
	int (*encrypt)(struct cipher_context *cx, 
		       const u8 *in, u8 *out, int size);

	/*
	 * Decrypt the ciphertext pointed to by "in".  Write output to
	 * "out". Size of plaintext is "size".  Input buffer is "size"
	 * bytes plus padding necessary to make it a multiple of the
	 * cipher blocksize. size &lt;= 0 is undefined. Returns 0 on
	 * success, non-zero on failure. Function might sleep.
	 *
	 */
	int (*decrypt)(struct cipher_context *cx,
		       const u8 *in, u8 *out, int size);


ChangeLog:

2000-10-14 Alexander Kjeldaas &lt;astor@fast.no&gt;

	* International kernel patch 2.2.17.8 released.

	* Configure.help updates with the AES results.  Patch from Marc
 	Mutz &lt;marc@mutz.com&gt;

	* Cipher list in config organized according to block-size with AES
 	at the top.  Patch from Marc Mutz &lt;marc@mutz.com&gt;

	* The set of allowed key-sizes for a cipher is now exported as a
 	mask in /proc. Constants for allowed key-sizes are defined in
 	crypto.h. Patch from Marc Mutz &lt;marc@mutz.com&gt;
	
	* Ability to build cryptoapi.c as a module was missing from
 	Config.in. Fixed.

	* DEFINE_{DIGEST,CIPHER} et. al. removed and replaced by explicit
 	struct {digest,cipher}_implementation initializations making the
 	code more readable.

	* API change.  Encryp/Decrypt now accepts any input/output byte
 	count.

	* gen-cbc.h changed to allow any input-size for encryption, or
 	output-size for decryption.  When encrypting large blocks,
 	gen-cbc.h will now sleep (you can play music while using an
 	encrypted file-system).  Added gen-ecb.h which implements the same
 	for ECB mode.  All ciphers changed to use gen-ecb.h to implement
 	their ECB mode.

	* Removed old cruft (crypto/cipherapi.c crypto/digestapi.c)

	* crypto/cryptoapi.c implementation made simpler.

	* Crypto API functions are documented in kernel-doc style.

	* crypto/testing updates.  digesttest now compiles. A lot of
 	duplicated functions are now available in misc.c.  None of the
 	programs include glibc headers any more, all necessary functions
 	are declared in libcfuncs.h. New program "testapi" for testing
 	that a cipher deals with the new API.



astor

-- 
Alexander Kjeldaas                Mail:  astor@fast.no
finger astor@master.kernel.org for OpenPGP key.

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001017075954</emailId><senderName>Alexander S A Kjeldaas</senderName><senderEmail>alexander.kjeldaas@fast.no</senderEmail><timestampReceived>2000-10-17 07:59:54-0400</timestampReceived><subject>2.2.17.10</subject><body>

2.2.17.10 has now been released.  Harald Welte has started 2.4
porting.  We're trying to make the linux/crypto directory as portable
as possible, so this patch integrates his changes. In 2.4, /proc
entries are created by service functions so cryptoapi.c now has its
own proc_mkdir implementation for 2.2.

Available from
ftp.kernel.org/pub/linux/kernel/crypto/v2.2/patch-int-2.2.17.10.gz

ChangeLog:

2000-10-17 Alexander Kjeldaas &lt;astor@fast.no&gt;

	* International kernel patch 2.2.17.10 released.

	* Changes from 2.4 kernel port by Harald Welte
 	&lt;laforge@gnumonks.org&gt; merged. 

	* Added AES-style testvectors "ecb_vk.txt" for all AES finalists.

	* Removed cipher_context-&gt;key - nobody was using it. Changed
 	cipher_context-&gt;iv from u32[] to u8[].

	* In loop_gen.c: IV for cbc-mode initialized in little-endian
 	manner.  NOTE: This breaks old loopback files on big-endian
 	machines.

	* testing: New option -s to testcip to swab32 the ciphertext
 	before comparisons.  Compile fixes.

2000-10-16 Alexander Kjeldaas &lt;astor@fast.no&gt;

	* International kernel patch 2.2.17.9 released.

	* loop_gen.c fix. Do not check blocksize of a cipher to decide
 	whether it supports encrypting a variable-length block. It always
 	does.


astor

-- 
Alexander Kjeldaas                Mail:  astor@fast.no
finger astor@master.kernel.org for OpenPGP key.

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001017155243</emailId><senderName>Marc Mutz</senderName><senderEmail>marc@mutz.com</senderEmail><timestampReceived>2000-10-17 15:52:43-0400</timestampReceived><subject>[PATCH] clean up include/linux/crypto.h and [RFC] API changes</subject><body>

Hi!

I've noticed that quite a lot of stuff in crypto.h is unneeded. In
particular, all the encrypt/decrypt/set_key declarations don't need to
be there, since the symbols aren't exported anyway and placing them in
the crypto.h file might make people do the wrong thing and calling them
directly.

I have also added a little description of the meaning of the
CIPHER_KEYSIZE_* constants, and a CIPHER_ECB and CIPHER_CTR to accopany
CIPHER_CBC, which should rather be CIPHER_MODE_CBC.

This patch does not touch anything except crypto.h. This is the reason
that *_KEY_SCHEULE_SIZE is still alive. After all, it is exported via
the cipher_implementation structure of each cipher and only used in the
module implementing the cipher. It was best to create a struct
CIPHERNAME_context for each cipher and use sizeof(CIPHERNAME_context)
to determine CIPHERNAME_KEY_SCHEDULE_SIZE. Also, the size parameter can
be dropped from the vanilla encrypt/decrypt routines, now that we have
*_ecb_encrypt. After all, those functions were supposed to only encrypt
one block at a time.

All this would be confined 'below the surface', i.e. would require no
change to the user-side API. The following changes would affect the
user-side API:

In the next step, we could get rid of exporting that number entirely and
make set_key or the constuct() method below allocate the required memory
and fill in the keyinfo pointer into struct cipher_context.
Then we could move the lock() and unlock() methods into constuct() and
destruct() methods, resp. where the keyinfo memory could be freed in
destruct(). This makes for a nice object-oriented API. The current
version is almost there, but the caller needs too much information about
the cipher, IMO.
For all implementations of digests/ciphers in the current kerneli, the
constructors and destructors would be no-ops except for calling lock(),
unlock() and kfree(). For future hw crypto accelerators, however, the
use of constructors and destructors would enable them to set up quite
complicated data structures, such as wait queues, to handle concurrent
accesses or to wake the hw from a powersave mode.

The constructors could be loaded with all the things that need to be
(re-)defined only seldomly, if at all:

o block size (for ciphers that support variable block sizes, e.g. AES)
o key length (dto.)
o mode (either ECB or CBC or Counter or...)
o encryption/keysetup speed tradeoffs. (??)
etc.

set_key() would then only accept a pointer to the key. This could also
speed up implementations where re-keying can be done faster than an
initial key-setup (e.g. twofish's 'compiled' option).

Comments?

Marc

-- 
Marc Mutz &lt;Marc@Mutz.com&gt;     http://EncryptionHOWTO.sourceforge.net/
University of Bielefeld, Dep. of Mathematics / Dep. of Physics

PGP-keyID's:   0xd46ce9ab (RSA), 0x7ae55b9e (DSS/DH)

["crypto_h-cleanup-2.2.17.8.patch;" (text/plain)]

--- linux/include/linux/crypto.h~	Sat Oct 14 10:41:43 2000
+++ linux/include/linux/crypto.h	Tue Oct 17 16:56:38 2000
@@ -44,8 +44,21 @@
 #define CIPHER_RC5      17
 #define CIPHER_AES      18
 #define MAX_CIPHER	20
+#define CIPHER_ECB    0x00000000
 #define CIPHER_CBC    0x00010000
+#define CIPHER_CTR    0x00020000 /* not implemented yet */
 
+/* Allowed keysizes: This is just a set of commonly found values. If
+ * you need additional ones, you can place them here. Note that
+ * CIPHER_KEY_ANY really means _any_ key length (that is a multiple of
+ * 8 bits, just limited by MAX_KEY_SIZE*32. This is not important now,
+ * but might become so if we choose to support keylengths greater than
+ * 256 bits. There are many ciphers that can take keys that are longer
+ * (e.g. blowfish: 448 bits). If you want to say all key lengths up to
+ * 256, play safe and use 0xFFFFFFFF-1 as keysize_mask.
+ * CIPHER_KEYSIZE_NONE means that the cipher does not expect a key. It
+ * is only used for 'none' encryption.
+ */
 
 #define CIPHER_KEYSIZE_ANY  0xFFFFFFFF
 #define CIPHER_KEYSIZE_NONE 0x00000000
@@ -247,136 +260,51 @@
 
 extern int init_cast256(void);
 #define CAST256_KEY_SCHEDULE_SIZE (96*sizeof(u32))
-extern  int cast256_set_key(struct cipher_context *cx, unsigned char *key, 
-			    int key_len);
-extern  int cast256_encrypt(struct cipher_context *cx, 
-			    const u8 *in, u8 *out, int size);
-extern  int cast256_decrypt(struct cipher_context *cx, 
-			    const u8 *in, u8 *out, int size);
 
 extern int init_crypton(void);
 #define CRYPTON_KEY_SCHEDULE_SIZE (104*sizeof(u32))
-extern  int crypton_set_key(struct cipher_context *cx, unsigned char *key, 
-			    int key_len);
-extern  int crypton_encrypt(struct cipher_context *cx, 
-			    const u8 *in, u8 *out, int size);
-extern  int crypton_decrypt(struct cipher_context *cx,
-			    const u8 *in, u8 *out, int size);
 
 extern int init_serpent(void);
 #define SERPENT_KEY_SCHEDULE_SIZE (140*sizeof(u32))
-extern  int serpent_set_key(struct cipher_context *cx, unsigned char *key, 
-			    int key_len);
-extern  int serpent_encrypt(struct cipher_context *cx,
-			    const u8 *in, u8 *out, int size);
-extern  int serpent_decrypt(struct cipher_context *cx, 
-			    const u8 *in, u8 *out, int size);
 
 extern int init_mars(void);
 #define MARS_KEY_SCHEDULE_SIZE (40*sizeof(u32))
-extern int mars_set_key(struct cipher_context *cx, unsigned char *key, 
-			int key_len);
-extern int mars_encrypt(struct cipher_context *cx, 
-			const u8 *in, u8 *out, int size);
-extern int mars_decrypt(struct cipher_context *cx, 
-			const u8 *in, u8 *out, int size);
 
 extern int init_rc5(void);
 #define RC5_KEY_SCHEDULE_SIZE (34*sizeof(u32))
-extern int rc5_set_key(struct cipher_context *cx, unsigned char *key, 
-		       int key_len);
-extern int rc5_encrypt(struct cipher_context *cx, 
-		       const u8 *in, u8 *out, int size);
-extern int rc5_decrypt(struct cipher_context *cx, 
-		       const u8 *in, u8 *out, int size);
 
 extern int init_rc6(void);
 #define RC6_KEY_SCHEDULE_SIZE (44*sizeof(u32))
-extern int rc6_set_key(struct cipher_context *cx, unsigned char *key, 
-		       int key_len);
-extern int rc6_encrypt(struct cipher_context *cx, 
-		       const u8 *in, u8 *out, int size);
-extern int rc6_decrypt(struct cipher_context *cx, 
-		       const u8 *in, u8 *out, int size);
 
 extern int init_dfc(void);
 #define DFC_KEY_SCHEDULE_SIZE (32*sizeof(u32))
-extern int dfc_set_key(struct cipher_context *cx, unsigned char *key, 
-		       int key_len);
-extern int dfc_encrypt(struct cipher_context *cx, 
-		       const u8 *in, u8 *out, int size);
-extern int dfc_decrypt(struct cipher_context *cx, 
-		       const u8 *in, u8 *out, int size);
 
 extern int init_rijndael(void);
 #define RIJNDAEL_KEY_SCHEDULE_SIZE ((60+60)*sizeof(u32))
-extern int rijndael_set_key(struct cipher_context *cx, unsigned char *key, 
-			    int key_len);
-extern int rijndael_encrypt(struct cipher_context *cx, 
-		       const u8 *in, u8 *out, int size);
-extern int rijndael_decrypt(struct cipher_context *cx, 
-		       const u8 *in, u8 *out, int size);
 
 extern int init_blowfish(void);
 #define BLOWFISH_KEY_SCHEDULE_SIZE ((18+1024)*sizeof(u32))
-extern int blowfish_set_key(struct cipher_context *cx,
-                            unsigned char *key, int key_len);
-extern int blowfish_encrypt(struct cipher_context *cx,
-			    const u8 *in, u8 *out, int size);
-extern int blowfish_decrypt(struct cipher_context *cx,
-                            const u8 *in, u8 *out, int size);
 
 extern int init_twofish(void);
 #define TWOFISH_KEY_SCHEDULE_SIZE ((4*256+8+32)*sizeof(u32))
-extern int twofish_set_key(struct cipher_context *cx,
-                            unsigned char *key, int key_len);
-extern int twofish_encrypt(struct cipher_context *cx,
-			    const u8 *in, u8 *out, int size);
-extern int twofish_decrypt(struct cipher_context *cx,
-                            const u8 *in, u8 *out, int size);
 
 extern int init_idea(void);
 #define IDEA_KEY_SCHEDULE_SIZE (104*2)
-extern int idea_set_key(struct cipher_context *cx, unsigned char *key, 
-			int key_len);
-extern int idea_encrypt(struct cipher_context *cx,
-			const u8 *in, u8 *out, int size);
-extern int idea_decrypt(struct cipher_context *cx,
-			const u8 *in, u8 *out, int size);
 
 extern int init_des(void);
 #define DES_KEY_SCHEDULE_SIZE (32*sizeof(u32))
-extern int des_set_key(struct cipher_context *cx, unsigned char *key, 
-		       int key_len);
-extern int des_encrypt(struct cipher_context *cx,
-		       const u8 *in, u8 *out, int size);
-extern int des_decrypt(struct cipher_context *cx,
-		       const u8 *in, u8 *out, int size);
 
 extern int init_des_ede3(void);
 #define DES_EDE3_KEY_SCHEDULE_SIZE (3*32*sizeof(u32))
-extern int des_ede3_set_key(struct cipher_context *cx, unsigned char *key,
-			    int key_len);
-extern int des_ede3_encrypt(struct cipher_context *cx,
-			    const u8 *in, u8 *out, int size);
-extern int des_ede3_decrypt(struct cipher_context *cx,
-			    const u8 *in, u8 *out, int size);
+
 
 /* Digest implementations */
 
 extern int init_md5(void);
 #define MD5_WORKING_SIZE ((4+2+16)*sizeof(u32))
-extern int md5_open(struct digest_context *cx);
-extern int md5_update(struct digest_context *cx, u8 *in, int size);
-extern int md5_current(struct digest_context *cx, u8 *out);
-extern int md5_close(struct digest_context *cx, u8 *out);
 
 extern int init_sha1(void);
 #define SHA1_WORKING_SIZE ((5+2+16)*sizeof(u32))
-extern int sha1_open(struct digest_context *cx);
-extern int sha1_update(struct digest_context *cx, u8 *in, int size);
-extern int sha1_current(struct digest_context *cx, u8 *out);
-extern int sha1_close(struct digest_context *cx, u8 *out);
 
 
 /* Utility macros */


Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20001023112106</emailId><senderName>Pierre PEIFFER</senderName><senderEmail>ppe@sxb.bsf.alcatel.fr</senderEmail><timestampReceived>2000-10-23 11:21:06-0400</timestampReceived><subject>Problem booting kernel.</subject><body>

Hello everybody,

    I'm a newby and I'm trying to test encrypted loobpack file. So I
have to apply a patch to my kernel.

    I currently use kernel 2.2.13 (for some internals reason, I can not
upgrade to kernel 2.2.17). with patch 2.2.17.10. I've read the Linux
Encryption HOWTO from Marc Mutz (which is very well done, I think, thank
you to him) v0.2.2 from october, 4th.

(according to this howto, the latest patch should apply without rejects
to all 2.2.1x kernels, and it really does)

Once having a patched kernel, I've added the following options to my
(previously working) kernel.

# Crypto options
#
CONFIG_CRYPTO=m
CONFIG_CIPHERS=m
CONFIG_CIPHER_AES=m
# CONFIG_CIPHER_RIJNDAEL is not set

#
# AES Finalist Ciphers (128 bit blocksize)
#
CONFIG_CIPHER_TWOFISH=m
# CONFIG_CIPHER_MARS is not set
# CONFIG_CIPHER_RC6 is not set
CONFIG_CIPHER_SERPENT=m

#
# Other Ciphers submitted as AES Candidates:
#
# CONFIG_CIPHER_DFC is not set

#
# Other ciphers (64 bit blocksize)
#
CONFIG_CIPHER_BLOWFISH=m
# CONFIG_CIPHER_IDEA is not set
# CONFIG_CIPHER_RC5 is not set
CONFIG_CIPHER_DES_EDE3=m
CONFIG_CIPHER_DES=m
CONFIG_DIGEST=m
# CONFIG_DIGEST_MD5 is not set
CONFIG_DIGEST_SHA1=m

#
#
# Additional Block Devices
#
CONFIG_BLK_DEV_LOOP_USE_REL_BLOCK=y
CONFIG_BLK_DEV_LOOP_GEN_SEL="m"
CONFIG_BLK_DEV_LOOP_GEN=m
# CONFIG_BLK_DEV_LOOP_CAST is not set
# CONFIG_BLK_DEV_LOOP_FISH2 is not set
# CONFIG_CIPE is not set

I compile and install everything. But when restaring my new kernel,
after the LILO prompt, I have.

"Uncompressing Linux... Ok, booting the kernel."

But nothing else, my kernel doesn't boot. As far I'm, I've not read
something about such a problem and have no idea. So, do you see
something wrong somewhere ? It will be very great if somebody could just
help me to have a booting kernel.... Thank you very much.

    Pierre


Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001027052825</emailId><senderName>William Ahern</senderName><senderEmail>wahern@25thandclement.com</senderEmail><timestampReceived>2000-10-27 05:28:25-0400</timestampReceived><subject>Int Crypto Patch and FreeS/Wan</subject><body>

I have the 2.2.17 kernel, 2.2.17.9 international kernel patch and frees/wan 
1.6. any tips on how to get it to compile? DES, MD5 and SHA1 routines
seems to be conflicting. everything compiles fine until it hits these....

i ran the freeswan-import script.... no beans....

please cc me...

tia,

Bill


Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001031081701</emailId><senderName>Doug VanLeuven</senderName><senderEmail>roamdad@attglobal.net</senderEmail><timestampReceived>2000-10-31 08:17:01-0400</timestampReceived><subject>Re: encrypting large files - revisited</subject><body>

Would someone please point me to the original thread on this?
I use tar across ssh &amp; would like to know what the problem
with this is, but I can't locate the original discussion
in the archive.

&gt;Andreas Schuldei wrote:
&gt;&gt;
&gt;&gt; I used ssh exactly in the (just now shown) insecure way: I
&gt;&gt;transfered big files over an encrypted scp tunnel to my computer at home using cron.
&gt;&gt;
&gt;&gt; Now I need an other way to shovel my 20-30Mbyte per night over the net.
&gt;&gt;
&gt;&lt;snip&gt;
&gt;
&gt;Why not use the way that was proposed as the alternative:
&gt;
&gt;ssh peer "tar cfz - files" &gt; files.tar.gz
&gt;tar tfz files.tar | grep for unusual files
&gt;
&gt;if nothing is found, untar and rm the tar.gz file. Or use ssh2.
&gt;
&gt;Marc
&gt;
&gt;--
&gt;Marc Mutz &lt;Marc@Mutz.com&gt;     http://EncryptionHOWTO.sourceforge.net/
&gt;University of Bielefeld, Dep. of Mathematics / Dep. of Physics



-- Doug VanLeuven 707-545-6933 (voice) / 707-545-6945 (fax)
Chief Engineer, USMM - roamdad@attglobal.net
Programmer/Analyst, SCWA - doug@scwa.ca.gov



Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001027071335</emailId><senderName>Marc Mutz</senderName><senderEmail>marc@mutz.com</senderEmail><timestampReceived>2000-10-27 07:13:35-0400</timestampReceived><subject>Re: Int Crypto Patch and FreeS/Wan</subject><body>

William Ahern wrote:
&gt; 
&gt; I have the 2.2.17 kernel, 2.2.17.9 international kernel patch and frees/wan
&gt; 1.6. any tips on how to get it to compile? DES, MD5 and SHA1 routines
&gt; seems to be conflicting. everything compiles fine until it hits these....
&gt; 
&gt; i ran the freeswan-import script.... no beans....
&gt; 
&lt;snip&gt;

The freeswan import script is/was for freeswan 1.1. I would be impressed
if it still worked for 1.6. Please provide more details such as exact
error messages. Another option is to make the freeswan install first,
then patch the kernel (which should have been patched with freeswan
stuff be the freeswan installation) with the kernli patch. because the
latter is highly localized, you can expect fewer and easier rejects, if
any.

If the patching isn't the problem but only compilation is then try to
disable DES, 3DES, and message digests in the crypto options menu. It
won't hurt because freeswan doesn't use'em anyway.

Marc

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001027075616</emailId><senderName>Gisle S{lensminde</senderName><senderEmail>gisle@ii.uib.no</senderEmail><timestampReceived>2000-10-27 07:56:16-0400</timestampReceived><subject>Re: Int Crypto Patch and FreeS/Wan</subject><body>

On Thu, 26 Oct 2000, William Ahern wrote:

&gt; I have the 2.2.17 kernel, 2.2.17.9 international kernel patch and frees/wan 
&gt; 1.6. any tips on how to get it to compile? DES, MD5 and SHA1 routines
&gt; seems to be conflicting. everything compiles fine until it hits these....
&gt; 
&gt; i ran the freeswan-import script.... no beans....
&gt; 


Could you please tell which symboles that are conflicting. It
would make it easier to find the problem and/or fix problems
in kerneli.

--
Gisle Sælensminde ( gisle@ii.uib.no )   

With sufficient thrust, pigs fly just fine. However, this is not
necessarily a good idea. It is hard to be sure where they are going
to land, and it could be dangerous sitting under them as they fly
overhead. (from RFC 1925)


Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001023133737</emailId><senderName>Gisle S{lensminde</senderName><senderEmail>gisle@ii.uib.no</senderEmail><timestampReceived>2000-10-23 13:37:37-0400</timestampReceived><subject>Re: Problem booting kernel.</subject><body>

On Mon, 23 Oct 2000, Pierre PEIFFER wrote:

&gt; Hello everybody,
&gt; 
&gt;     I'm a newby and I'm trying to test encrypted loobpack file. So I
&gt; have to apply a patch to my kernel.
&gt; 
&gt;     I currently use kernel 2.2.13 (for some internals reason, I can not
&gt; upgrade to kernel 2.2.17). with patch 2.2.17.10. I've read the Linux
&gt; Encryption HOWTO from Marc Mutz (which is very well done, I think, thank
&gt; you to him) v0.2.2 from october, 4th.
&gt; 
&gt; (according to this howto, the latest patch should apply without rejects
&gt; to all 2.2.1x kernels, and it really does)
&gt; 
&gt; Once having a patched kernel, I've added the following options to my
&gt; (previously working) kernel.

That the patch don't give rejects, does not mean that everything is
OK. There may be things in the kernel that makes things no longer works.
I would rather installed an old patch. Then you won't get the recent
features (like rijndael and 3des), but if you purpose is to encrypt
disks that should be OK if you don't need compatibility with partitions
on other computers.

Alexander Kjeldaas should be the right person to answer this question.

&gt; 
&gt; # Crypto options
&gt; #
&gt; CONFIG_CRYPTO=m
&gt; CONFIG_CIPHERS=m
&gt; CONFIG_CIPHER_AES=m
&gt; # CONFIG_CIPHER_RIJNDAEL is not set
&gt; 
&gt; #
&gt; # AES Finalist Ciphers (128 bit blocksize)
&gt; #
&gt; CONFIG_CIPHER_TWOFISH=m
&gt; # CONFIG_CIPHER_MARS is not set
&gt; # CONFIG_CIPHER_RC6 is not set
&gt; CONFIG_CIPHER_SERPENT=m
&gt; 
&gt; #
&gt; # Other Ciphers submitted as AES Candidates:
&gt; #
&gt; # CONFIG_CIPHER_DFC is not set
&gt; 
&gt; #
&gt; # Other ciphers (64 bit blocksize)
&gt; #
&gt; CONFIG_CIPHER_BLOWFISH=m
&gt; # CONFIG_CIPHER_IDEA is not set
&gt; # CONFIG_CIPHER_RC5 is not set
&gt; CONFIG_CIPHER_DES_EDE3=m
&gt; CONFIG_CIPHER_DES=m
&gt; CONFIG_DIGEST=m
&gt; # CONFIG_DIGEST_MD5 is not set
&gt; CONFIG_DIGEST_SHA1=m
&gt; 
&gt; #
&gt; #
&gt; # Additional Block Devices
&gt; #
&gt; CONFIG_BLK_DEV_LOOP_USE_REL_BLOCK=y
&gt; CONFIG_BLK_DEV_LOOP_GEN_SEL="m"
&gt; CONFIG_BLK_DEV_LOOP_GEN=m
&gt; # CONFIG_BLK_DEV_LOOP_CAST is not set
&gt; # CONFIG_BLK_DEV_LOOP_FISH2 is not set
&gt; # CONFIG_CIPE is not set
&gt; 
&gt; I compile and install everything. But when restaring my new kernel,
&gt; after the LILO prompt, I have.
&gt; 
&gt; "Uncompressing Linux... Ok, booting the kernel."
&gt; 
&gt; But nothing else, my kernel doesn't boot. As far I'm, I've not read
&gt; something about such a problem and have no idea. So, do you see
&gt; something wrong somewhere ? It will be very great if somebody could just
&gt; help me to have a booting kernel.... Thank you very much.
&gt; 

--
Gisle Sælensminde ( gisle@ii.uib.no )   

With sufficient thrust, pigs fly just fine. However, this is not
necessarily a good idea. It is hard to be sure where they are going
to land, and it could be dangerous sitting under them as they fly
overhead. (from RFC 1925)



Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001024151857</emailId><senderName>Marc Mutz</senderName><senderEmail>marc@mutz.com</senderEmail><timestampReceived>2000-10-24 15:18:57-0400</timestampReceived><subject>Re: Problem booting kernel.</subject><body>

Pierre PEIFFER wrote:
&gt; 
&gt; Hello everybody,
&gt; 
&gt;     I'm a newby and I'm trying to test encrypted loobpack file. So I
&gt; have to apply a patch to my kernel.
&gt; 
&lt;snip&gt;
&gt; "Uncompressing Linux... Ok, booting the kernel."
&gt; 
&gt; But nothing else, my kernel doesn't boot. As far I'm, I've not read
&gt; something about such a problem and have no idea. So, do you see
&gt; something wrong somewhere ? It will be very great if somebody could just
&gt; help me to have a booting kernel.... Thank you very much.
&gt; 
&lt;snip&gt;

Is this the first time you compile a custom kernel?
It looks to me that you just added the options for the crypto stuff but
did not go through all the other options that need to be adjusted to fit
your box. The vanilla kernel tarball is not configured by any means. You
have to go through all menus and select what you need. Or copy a working
.config into the main directory and run make oldconfig. See the
Kernel-HOWTO for more.

If that is not the case and you successfully compiled kernels before,
then it might be a good idea to tell us the exact commands you used and
actions you did so we have a clue of where things could have gone wrong.

Marc

-- 
Marc Mutz &lt;Marc@Mutz.com&gt;     http://EncryptionHOWTO.sourceforge.net/
University of Bielefeld, Dep. of Mathematics / Dep. of Physics

PGP-keyID's:   0xd46ce9ab (RSA), 0x7ae55b9e (DSS/DH)



Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001018112524</emailId><senderName>Alexander S A Kjeldaas</senderName><senderEmail>alexander.kjeldaas@fast.no</senderEmail><timestampReceived>2000-10-18 11:25:24-0400</timestampReceived><subject>Re: [PATCH] clean up include/linux/crypto.h and [RFC] API changes</subject><body>

On Tue, Oct 17, 2000 at 03:52:43PM +0000, Marc Mutz wrote:
&gt; Hi!
&gt; 
&gt; I've noticed that quite a lot of stuff in crypto.h is unneeded. In
&gt; particular, all the encrypt/decrypt/set_key declarations don't need to
&gt; be there, since the symbols aren't exported anyway and placing them in
&gt; the crypto.h file might make people do the wrong thing and calling them
&gt; directly.

I agree that we need some changes, but I think going the other way is
better :-).  Keep the functions in crypto.h, but add even more.
Include the *_cbc and *_ecb versions, and wrap the various
declarations in #ifdef CONFIG_CIPHER_XXX ... #endif pairs.  That way,
if the cipher is compiled in, and some part of the kernel that
explicitly requires 3des for instance will not have to incur the (very
small) performance penalty of calling the function through the
function pointer in cipher_implementation.  If there is a potential
performance win of calling the functions directly, I think that option
should be available.  For instance, freeswan does not really win a lot
by using the crypto API before other parts of their system supports
specifying alternative ciphers.  So they could use
des_ede3_encrypt_cbc directly.  Or the crypto API could provide inline
functions that emulate libdes.

&gt; 
&gt; I have also added a little description of the meaning of the
&gt; CIPHER_KEYSIZE_* constants, and a CIPHER_ECB and CIPHER_CTR to accopany
&gt; CIPHER_CBC, which should rather be CIPHER_MODE_CBC.
&gt; 
&gt; This patch does not touch anything except crypto.h. This is the reason
&gt; that *_KEY_SCHEULE_SIZE is still alive. After all, it is exported via
&gt; the cipher_implementation structure of each cipher and only used in the
&gt; module implementing the cipher. It was best to create a struct
&gt; CIPHERNAME_context for each cipher and use sizeof(CIPHERNAME_context)
&gt; to determine CIPHERNAME_KEY_SCHEDULE_SIZE. 

The *_KEY_SCHEDULE_SIZE definitions are a tradeoff between clutter in
crypto.h, and availability of low-level information on the ciphers.
Adding a 
struct des_ede3_context { ... };
#define DES_EDE3_KEY_SCHEDULE_SIZE sizeof(struct des_ede_context)
is probably a good idea to make sure things are in sync.  But as I
said I would like to keep stuff in crypto.h to make the low-level
functions available if someone wants to use them.

&gt; Also, the size parameter can be dropped from the vanilla
&gt; encrypt/decrypt routines, now that we have *_ecb_encrypt. After all,
&gt; those functions were supposed to only encrypt one block at a time.

Agreed.

&gt; All this would be confined 'below the surface', i.e. would require no
&gt; change to the user-side API. The following changes would affect the
&gt; user-side API:
&gt; 
&gt; In the next step, we could get rid of exporting that number entirely and
&gt; make set_key or the constuct() method below allocate the required memory
&gt; and fill in the keyinfo pointer into struct cipher_context.
&gt; Then we could move the lock() and unlock() methods into constuct() and
&gt; destruct() methods, resp. where the keyinfo memory could be freed in
&gt; destruct(). This makes for a nice object-oriented API. The current
&gt; version is almost there, but the caller needs too much information about
&gt; the cipher, IMO.
&gt;
&gt; For all implementations of digests/ciphers in the current kerneli, the
&gt; constructors and destructors would be no-ops except for calling lock(),
&gt; unlock() and kfree(). For future hw crypto accelerators, however, the
&gt; use of constructors and destructors would enable them to set up quite
&gt; complicated data structures, such as wait queues, to handle concurrent
&gt; accesses or to wake the hw from a powersave mode.
&gt; 

I also think we need something like constructors and destructors for
"transform_contexts" which basically becomes an opaque type.

&gt; The constructors could be loaded with all the things that need to be
&gt; (re-)defined only seldomly, if at all:
&gt; 
&gt; o block size (for ciphers that support variable block sizes, e.g. AES)
&gt; o key length (dto.)
&gt; o mode (either ECB or CBC or Counter or...)
&gt; o encryption/keysetup speed tradeoffs. (??)
&gt; etc.
&gt; 
&gt; set_key() would then only accept a pointer to the key. This could also
&gt; speed up implementations where re-keying can be done faster than an
&gt; initial key-setup (e.g. twofish's 'compiled' option).

I am not sure I follow you.  Could you expand on this with example
function prototypes?

set_key is currently:

	cipherXYZ_set_key)(struct cipher_context *cx, 
		  	   unsigned char *key, int key_len);

so in the case of a rekeying, it should be able to access the previous
key.  No change of interface needed.  However, something would have to
be done to make it know when to ignore the previously set key.


astor

-- 
Alexander Kjeldaas                Mail:  astor@fast.no
finger astor@master.kernel.org for OpenPGP key.

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001018113417</emailId><senderName>Christoph Hellwig</senderName><senderEmail>hch@ns.caldera.de</senderEmail><timestampReceived>2000-10-18 11:34:17-0400</timestampReceived><subject>Re: [PATCH] clean up include/linux/crypto.h and [RFC] API changes</subject><body>

On Wed, Oct 18, 2000 at 01:25:24PM +0200, Alexander S A Kjeldaas wrote:
&gt; On Tue, Oct 17, 2000 at 03:52:43PM +0000, Marc Mutz wrote:
&gt; &gt; Hi!
&gt; &gt; 
&gt; &gt; I've noticed that quite a lot of stuff in crypto.h is unneeded. In
&gt; &gt; particular, all the encrypt/decrypt/set_key declarations don't need to
&gt; &gt; be there, since the symbols aren't exported anyway and placing them in
&gt; &gt; the crypto.h file might make people do the wrong thing and calling them
&gt; &gt; directly.
&gt; 
&gt; I agree that we need some changes, but I think going the other way is
&gt; better :-).  Keep the functions in crypto.h, but add even more.
&gt; Include the *_cbc and *_ecb versions, and wrap the various
&gt; declarations in #ifdef CONFIG_CIPHER_XXX ... #endif pairs.

No, this doesn't make sense at all. Adding every function in a whole
class of modules to one header is not a good idea. Because it strikes
against modular additions outside the main (kerneli) tree.
If you really want to make them aviable to the whole kernel add a
separate header for each algorithm, like &lt;crypto/des.h&gt; or
&lt;crypto/blowfish.h&gt;. Anyway you have to export the symbols using
EXPORT_SYMBOL, too.

	Christoph

-- 
Always remember that you are unique.  Just like everyone else.

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001018121213</emailId><senderName>Alexander S A Kjeldaas</senderName><senderEmail>alexander.kjeldaas@fast.no</senderEmail><timestampReceived>2000-10-18 12:12:13-0400</timestampReceived><subject>Re: [PATCH] clean up include/linux/crypto.h and [RFC] API changes</subject><body>

On Wed, Oct 18, 2000 at 01:34:17PM +0200, Christoph Hellwig wrote:
&gt; On Wed, Oct 18, 2000 at 01:25:24PM +0200, Alexander S A Kjeldaas wrote:
&gt; &gt; 
&gt; &gt; I agree that we need some changes, but I think going the other way is
&gt; &gt; better :-).  Keep the functions in crypto.h, but add even more.
&gt; &gt; Include the *_cbc and *_ecb versions, and wrap the various
&gt; &gt; declarations in #ifdef CONFIG_CIPHER_XXX ... #endif pairs.
&gt; 
&gt; No, this doesn't make sense at all. Adding every function in a whole
&gt; class of modules to one header is not a good idea. Because it strikes
&gt; against modular additions outside the main (kerneli) tree.
&gt; If you really want to make them aviable to the whole kernel add a
&gt; separate header for each algorithm, like &lt;crypto/des.h&gt; or
&gt; &lt;crypto/blowfish.h&gt;. Anyway you have to export the symbols using
&gt; EXPORT_SYMBOL, too.
&gt; 

Although I think using separate header files is ok, I do not see an
advantage in this case.  Why optimize on an extremely remotely
probable case - that the following happens:

o Someone wants to develop a cipher _outside_ the kerneli patch tree
_using_ the kerneli crypto API.

o That some _other_ developer wants to use the aforementioned cipher
_without_ using the crypto API, _but insists_ on the functions being
available by #including &lt;linux/crypto.h&gt; and nothing else.


But this is not a big deal for me.  I will accept a patch that does it
either way.

astor

-- 
Alexander Kjeldaas                Mail:  astor@fast.no
finger astor@master.kernel.org for OpenPGP key.

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001018133445</emailId><senderName>Marc Mutz</senderName><senderEmail>marc@mutz.com</senderEmail><timestampReceived>2000-10-18 13:34:45-0400</timestampReceived><subject>Re: [PATCH] clean up include/linux/crypto.h and [RFC] API changes</subject><body>

The patch against i10 was sent befor I read this mail, so don't feel
like being ignored :-)

Alexander S A Kjeldaas wrote:
&gt; 
&lt;snip&gt; 
&gt; I also think we need something like constructors and destructors for
&gt; "transform_contexts" which basically becomes an opaque type.
&gt; 
&gt; &gt; The constructors could be loaded with all the things that need to be
&gt; &gt; (re-)defined only seldomly, if at all:
&gt; &gt;
&gt; &gt; o block size (for ciphers that support variable block sizes, e.g. AES)
&gt; &gt; o key length (dto.)
&gt; &gt; o mode (either ECB or CBC or Counter or...)
&gt; &gt; o encryption/keysetup speed tradeoffs. (??)
&gt; &gt; etc.
&gt; &gt;
&gt; &gt; set_key() would then only accept a pointer to the key. This could also
&gt; &gt; speed up implementations where re-keying can be done faster than an
&gt; &gt; initial key-setup (e.g. twofish's 'compiled' option).
&gt; 
&gt; I am not sure I follow you.  Could you expand on this with example
&gt; function prototypes?
&gt; 
&gt; set_key is currently:
&gt; 
&gt;         cipherXYZ_set_key)(struct cipher_context *cx,
&gt;                            unsigned char *key, int key_len);
&gt; 
&gt; so in the case of a rekeying, it should be able to access the previous
&gt; key.  No change of interface needed.  However, something would have to
&gt; be done to make it know when to ignore the previously set key.
&gt; 

/* spits out a cipher_context for a given ci and other parameters.
 + flags could contain bits that indicate if the call to encrypt
 * should be sync or async, if encrytion functions might sleep or not,
 * a bit field indicating encrypt/key setup speed tradeoffs and cipher 
 * implementation specific stuff.
 +/
struct cipher_context
*cipherXYZ_construct (struct cipher_implementation *ci,
		int blocksize, int keysize, int mode, u32 flags);

/* sets the key. The keylength has been set with a call to
 * construct() */
int cipherXYZ_set_key (struct cipher_context *cx, u8 *key);

Marc

-- 
Marc Mutz &lt;Marc@Mutz.com&gt;     http://EncryptionHOWTO.sourceforge.net/
University of Bielefeld, Dep. of Mathematics / Dep. of Physics

PGP-keyID's:   0xd46ce9ab (RSA), 0x7ae55b9e (DSS/DH)



Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001018135818</emailId><senderName>Marc Mutz</senderName><senderEmail>marc@mutz.com</senderEmail><timestampReceived>2000-10-18 13:58:18-0400</timestampReceived><subject>Re: [PATCH] clean up include/linux/crypto.h and [RFC] API changes</subject><body>

Alexander S A Kjeldaas wrote:
&gt; 
&lt;snip&gt; 
&gt; Although I think using separate header files is ok, I do not see an
&gt; advantage in this case.  Why optimize on an extremely remotely
&gt; probable case - that the following happens:
&gt; 

It's not for optimizing something, except the case of readable code.
There's a lot of redundancy in the source as is and that is bad for
maintainability. We already have a dozen ciphers and two hash functions
in the API, adding RIPEMD, Tiger and SHA-256, -384 and -512 is just a
matter of time. I just experienced what is takes to go through all
cipher files by hand and changing similar things in each of them. Ugh.
Don't want to do that for 20 ciphers and 10 digests.

IMO we should not change the code for something that might come or might
not come in the future. No-one has to my knowledge made a move to use
the ciphers directly. The current usage is confined to the API and the
purpose of an API is to simplify the interface. If we let THEM use the
ciphers directly, why do we want to have a crypto-api at all? Let them
use the ciphers directly. Sorry.

Let's just wait for the first poor soul that wants to use the ciphers
directly. Make him submit the necessary changes, exporting all those
symbols and then let him watch the CryptoAPI selecting the fastest
implementation of a given cipher at run time and he'll probably will go
back to using the API. That's what it's for.

Imagine crypto.h with the following contained in it for a two dozen
ciphers:

cipher_mode0_encrypt (..)
cipher_mode0_decrypt (..)
 :
cipher_mode5_encrypt (..)
cipher_mode5_decrypt (..)
cipher_set_key (..)

Let there be various size/speed tradeoffs:

twofish_zerokeying_ecb_encypt ()
      :
twofish_compile_ecb_encrypt ()
      ::

This is also the reason why we might want to add a _separate_ mode layer
in the near future instead of the gen-mode.h method.

Marc

-- 
Marc Mutz &lt;Marc@Mutz.com&gt;     http://EncryptionHOWTO.sourceforge.net/
University of Bielefeld, Dep. of Mathematics / Dep. of Physics

PGP-keyID's:   0xd46ce9ab (RSA), 0x7ae55b9e (DSS/DH)


Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001017194622</emailId><senderName>Marc Mutz</senderName><senderEmail>marc@mutz.com</senderEmail><timestampReceived>2000-10-17 19:46:22-0400</timestampReceived><subject>Re: 2.2.17.10</subject><body>

Alexander S A Kjeldaas wrote:
&gt; 
&gt; 2.2.17.10 has now been released.  Harald Welte has started 2.4
&gt; porting.  We're trying to make the linux/crypto directory as portable
&gt; as possible, so this patch integrates his changes. In 2.4, /proc
&gt; entries are created by service functions so cryptoapi.c now has its
&gt; own proc_mkdir implementation for 2.2.
&gt; 
&gt; Available from
&gt; ftp.kernel.org/pub/linux/kernel/crypto/v2.2/patch-int-2.2.17.10.gz
&gt; 
&lt;snip&gt;

Not there a of now. Not on ftp.kernel.org, nor on ftp.de.kernel.org?

Marc

-- 
Marc Mutz &lt;Marc@Mutz.com&gt;     http://EncryptionHOWTO.sourceforge.net/
University of Bielefeld, Dep. of Mathematics / Dep. of Physics

PGP-keyID's:   0xd46ce9ab (RSA), 0x7ae55b9e (DSS/DH)

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001011154141</emailId><senderName>Marc Mutz</senderName><senderEmail>marc@mutz.com</senderEmail><timestampReceived>2000-10-11 15:41:41-0400</timestampReceived><subject>Re: A patch to loop.c for better cryption support</subject><body>

[added cc: linux-crypto]

Ingo Rohloff wrote:
&gt; 
&gt; Hi,
&gt; 
&gt; First some explanation. Most cryption algorithms initialize
&gt; the cryption process with some init values, called IV (by me :-).
&gt; This means that two identical clear messages will give
&gt; different encrypted messages, if different IVs are used.
&gt; 
&gt; The loop device supports different IVs;
&gt; the IVs are initilized with the requested block
&gt; number.
&gt; 
&gt; I believe a better way is to use the requested
&gt; sector number from CURRENT-&gt;sector.
&gt; Using this value should make the encryption and decryption
&gt; process completely independent from the underlying device.
&gt; 

Two times no.

First: This breaks backward-compatibility.
Second: I don't know much of the block device handling
	in Linux, but what you produced seems like a quick
	shot. I can see this e.g. at the point where you
	declare 'sector' to be 'int' (7th hunk), whereas in
	include/linux/blkdev.h request.sector is declared
	_unsigned_ int.
	  I don't know what request.sector is for loop
	devices (The block number of the underlying
	filesystem, if any? The hard sector number of the
	underlying blockdevice? Always the 512-byte-blocks
	number?), but if it is not the latter, i.e. always
	"position &gt;&gt; 9", you have just shifted the issue
	from one level (the fs block size) to another
	(whatever units sector is in).

The better solution (for 2.2. and 2.4; in 2.5 Andries Brouwer has
something more clean in his mind, IIUHC) is to add a new field to struct
loop_info to indicate the encryption chunk size and patch losetup/mount
to set this to 512 by default and to the filesystem block size if asked
to by some command line switch. This allows people to convert their
stuff.

You may want to join linux-crypto@nl.linux.org (majordomo) if you want
to work on this.

Marc

-- 
Marc Mutz &lt;Marc@Mutz.com&gt;     http://EncryptionHOWTO.sourceforge.net/
University of Bielefeld, Dep. of Mathematics / Dep. of Physics

PGP-keyID's:   0xd46ce9ab (RSA), 0x7ae55b9e (DSS/DH)


Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001011175905</emailId><senderName>Ingo Rohloff</senderName><senderEmail>lundril@gmx.net</senderEmail><timestampReceived>2000-10-11 17:59:05-0400</timestampReceived><subject>Re: A patch to loop.c for better cryption support</subject><body>

Hi again,

&gt; &gt; The loop device supports different IVs;
&gt; &gt; the IVs are initilized with the requested block
&gt; &gt; number.

&gt; &gt; I believe a better way is to use the requested
&gt; &gt; sector number from CURRENT-&gt;sector.
&gt; &gt; Using this value should make the encryption and decryption
&gt; &gt; process completely independent from the underlying device.

&gt; Two times no.
&gt; 
&gt; First: This breaks backward-compatibility.
Right, (I mentioned this), but the backward-compatible
way means:

You might get problems over NFS using a backing file.
You get problems if you burn a backing file to a CD
(at least that's what it says in the FAQ),
or if you copy it to another partition with a different
file system (which handles blocks differently) or ...

Has anyone tried to use an encrypted backing file
on ReiserFS. I would be interested if it works
with the old patch set.
I even created an encrypted ReiserFS in a backing
file, which was hosted on an uncrypted ReiserFS.
(ReiserFS doesn't care about sector boundries, so
 it is especially useful for testing in this
 case.)
I bet that this won't work with the old approach.
(Even if this might be, because the cryption algorithms
 don't care about block boundries too :-( )
I know it works with my approach because I tried
(even over NFS).

&gt; Second: I don't know much of the block device handling
&gt; 	in Linux, but what you produced seems like a quick
&gt; 	shot. I can see this e.g. at the point where you
&gt; 	declare 'sector' to be 'int' (7th hunk), whereas in
&gt; 	include/linux/blkdev.h request.sector is declared
&gt; 	_unsigned_ int.
Well ok, my fault.

BUT: "unsigned int" and "int" have the same bit size right ?
     The crypto algorithms only care about the bits not the
     signedness (and if they do, they only have to interpret
     the IV as signed... no problem...)

&gt; 	I don't know what request.sector is for loop
&gt; 	devices (The block number of the underlying
&gt; 	filesystem, if any? The hard sector number of the
&gt; 	underlying blockdevice? Always the 512-byte-blocks
&gt; 	number?), but if it is not the latter, i.e. always
&gt; 	"position &gt;&gt; 9", you have just shifted the issue
&gt; 	from one level (the fs block size) to another
&gt; 	(whatever units sector is in).
No I haven't. Because as you can see from the source:
1. The CURRENT-&gt;sector is the requested sector of
   the loop device, which has nothing (whatsoever) to do
   with the underlying backing medium (it is even independent,
   of using a backing file or device.)

2. It is ALWAYS assumed to be 512 bytes. 
   (This doesn't change, even if the blocksize of the backing
    device is SMALLER than 512 bytes.)

You got it right, it is (position &gt;&gt; 9). But "position" means
requested position within the loop device, which is as I said
completely independent of the backing medium.

You can even have two DIFFERENT (using different passwords)
encrypted filesystems in the same backing file.
Both mounted at the same time.
(For example in a 2Mb file you can use the first MB
 for the first FS and the second Mb for the second FS.)

you can do that like this:
dd if=/dev/zero of=crypt.tst bs=1024 count=2048
losetup -e twofish /dev/loop0 crypt.tst             (give Password 1)
losetup -e twofish -o 1048576 /dev/loop1 crypt.tst   (give Password 2)
mke2fs -b 1024 /dev/loop0 1024
mke2fs -b 1024 /dev/loop1 1024
mount /dev/loop0 /mnt1
mount /dev/loop1 /mnt2

BTW this is _tested_. It works. (And you can do it over NFS
And you can burn crypt.tst to a CD without any problems.)
Try this with the current approach... It won't work.

&gt; The better solution (for 2.2. and 2.4; in 2.5 Andries Brouwer has
&gt; something more clean in his mind, IIUHC) is to add a new field to struct
&gt; loop_info to indicate the encryption chunk size and patch losetup/mount
&gt; to set this to 512 by default and to the filesystem block size if asked
&gt; to by some command line switch. This allows people to convert their
&gt; stuff.

This makes things more complicated. (It also gives you more choices,
but I don't think that the choices are very useful. It only gives
you a higher chance of corrupting your data.)

Converting the stuff is not so difficult. Copy your encrypted
stuff to somewhere else (if you like use PGP to crypt it anyway).
Change kernel. 
Remake filesystem on crypted medium. 
Copy your stuff back.

&gt; You may want to join linux-crypto@nl.linux.org (majordomo) if you want
&gt; to work on this.

Ah thanks for the hint, I didn't know this mailing list.

I hope it is not in dutch ? If it is I apologize for posting in
english. (I can't speak dutch).

so long
  Ingo

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001017223746</emailId><senderName>Marc Mutz</senderName><senderEmail>marc@mutz.com</senderEmail><timestampReceived>2000-10-17 22:37:46-0400</timestampReceived><subject>Re: 2.2.17.10</subject><body>

Marc Mutz wrote:
&gt; 
&lt;snip&gt;
&gt; &gt; ftp.kernel.org/pub/linux/kernel/crypto/v2.2/patch-int-2.2.17.10.gz
&gt; &gt;
&gt; &lt;snip&gt;
&gt; 
&gt; Not there a of now. Not on ftp.kernel.org, nor on ftp.de.kernel.org?
&gt; 
Sorry, the .gz is there, I've been doing ls *.bz2 and they were not
there.

Marc

-- 
Marc Mutz &lt;Marc@Mutz.com&gt;     http://EncryptionHOWTO.sourceforge.net/
University of Bielefeld, Dep. of Mathematics / Dep. of Physics

PGP-keyID's:   0xd46ce9ab (RSA), 0x7ae55b9e (DSS/DH)


Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001014092832</emailId><senderName>Marc Mutz</senderName><senderEmail>marc@mutz.com</senderEmail><timestampReceived>2000-10-14 09:28:32-0400</timestampReceived><subject>Re: 2.2.17.8</subject><body>

Alexander S A Kjeldaas wrote:
&gt; 
&gt; 2.2.17.8 has now been released.  This patch includes some
&gt; reorganization of the code, but also some important API changes.  Or
&gt; rather, the interface is now defined :-).  The encrypt/decrypt
&gt; functions are allowed to sleep, and they have to tackle all
&gt; input/output sizes.  This is the new interface as defined in crypto.h:
&gt; 
&lt;snip&gt;

This release breaks my blowfish-encrypted filesystem. I don't get any
error messages from mount, like I did in pre2, besides "wrong
superblock". There is not even a

Q&gt; VFS: Can't find an ext2 fs on loop...

in /var/log/messages, as it usually shows up when you get the passphrase
wrong. Strange.

Marc

-- 
Marc Mutz &lt;Marc@Mutz.com&gt;     http://EncryptionHOWTO.sourceforge.net/
University of Bielefeld, Dep. of Mathematics / Dep. of Physics

PGP-keyID's:   0xd46ce9ab (RSA), 0x7ae55b9e (DSS/DH)


Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001016121505</emailId><senderName>Alexander S A Kjeldaas</senderName><senderEmail>alexander.kjeldaas@fast.no</senderEmail><timestampReceived>2000-10-16 12:15:05-0400</timestampReceived><subject>Re: 2.2.17.8</subject><body>

On Sat, Oct 14, 2000 at 09:28:32AM +0000, Marc Mutz wrote:
&gt; Alexander S A Kjeldaas wrote:
&gt; &gt; 
&gt; &gt; 2.2.17.8 has now been released.  This patch includes some
&gt; &gt; reorganization of the code, but also some important API changes.  Or
&gt; &gt; rather, the interface is now defined :-).  The encrypt/decrypt
&gt; &gt; functions are allowed to sleep, and they have to tackle all
&gt; &gt; input/output sizes.  This is the new interface as defined in crypto.h:
&gt; &gt; 
&gt; &lt;snip&gt;
&gt; 
&gt; This release breaks my blowfish-encrypted filesystem. I don't get any
&gt; error messages from mount, like I did in pre2, besides "wrong
&gt; superblock". There is not even a
&gt; 
&gt; Q&gt; VFS: Can't find an ext2 fs on loop...
&gt; 
&gt; in /var/log/messages, as it usually shows up when you get the passphrase
&gt; wrong. Strange.
&gt; 

It was an unused code-path in loop_gen.c that was triggered by the
changes in 2.2.17.8.  A magic block-size of 0 no longer indicates that
a cipher supports encrypting variable-length blocks.  I think the
following patch should fix the problem:

--- int.2.2.17.8/drivers/block/loop_gen.c       Mon Oct 16 13:57:41 2000
+++ int.2.2.17.x/drivers/block/loop_gen.c       Mon Oct 16 13:54:37 2000
@@ -17,7 +17,6 @@
 { 
        struct cipher_context * cx = (struct cipher_context *) lo-&gt;key_data;
        struct cipher_implementation *ci = cx-&gt;ci;
-       int bsize = ci-&gt;blocksize;
        int (*encdecfunc)(struct cipher_context *cx, const u8 *in, u8 *out, int 
size);
        char *in, *out;
 
@@ -35,20 +34,7 @@
                return -EINVAL;
        }
        cx-&gt;iv[0] = real_block;
-       if (bsize) {
-               while (size &gt;= bsize) {
-                       encdecfunc(cx, in, out, bsize);
-                       in += bsize;
-                       out += bsize;
-                       size -= bsize;
-               }
-               if (size != 0) {
-                       return -EINVAL;
-               }
-       } else { /* variable-size cipher */
-               encdecfunc(cx, in, out, size);
-       }
-
+       encdecfunc(cx, in, out, size);
        return 0;
 }


astor

-- 
Alexander Kjeldaas                Mail:  astor@fast.no
finger astor@master.kernel.org for OpenPGP key.

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001016130235</emailId><senderName>Gisle S{lensminde</senderName><senderEmail>gisle@ii.uib.no</senderEmail><timestampReceived>2000-10-16 13:02:35-0400</timestampReceived><subject>Re: 2.2.17.8</subject><body>


When compiling the tests in the linux/crypto/testing directory, I
got a compile error for the tests. The symbol 'schedule' was missing
for several of the ciphers (maybe all), so I got a linker error.
The kernel itself on the other hand, linked fine.

I have not the configuration files here since I'm not at home,
so I cannot find the actual configuretion, but I did not compile
the actual ciphers as modules. Have anyone else seen the same
errors?

--
Gisle Sælensminde ( gisle@ii.uib.no )   

With sufficient thrust, pigs fly just fine. However, this is not
necessarily a good idea. It is hard to be sure where they are going
to land, and it could be dangerous sitting under them as they fly
overhead. (from RFC 1925)


Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001013152217</emailId><senderName>Marc Mutz</senderName><senderEmail>marc@mutz.com</senderEmail><timestampReceived>2000-10-13 15:22:17-0400</timestampReceived><subject>Re: A patch to loop.c for better cryption support</subject><body>

Ingo Rohloff wrote:
&gt; 
&lt;snip&gt;
&gt; &gt; First: This breaks backward-compatibility.
&gt; Right, (I mentioned this), but the backward-compatible
&gt; way means:
&gt; 

Don't confuse the backwards-compatible way with the current (broken, of
course) way of doing things. It is right that the _current_ approach of
using the blocks of the underlying as encryption units has all the
problems that you describe. Yet, the fix that I suggested is clean and
works exactly as what you want to do. There is only one difference:

_I_ can use my approach, but not yours, to bring my already existing
crypted fs into the new state. The losetup option to set the encryption
chunk size is used only once for each fs, but at that one time you can
do:

Q&gt; losetup -e blowfish --use-fs-blocksize \
	/dev/loop0 cryptfile
Q&gt; losetup -e blowfish /dev/loop1 cryptfile
Q&gt; dd if=/dev/loop0 of=/dev/loop1 bs=4k
Q&gt; losetup -d /dev/loop1
Q&gt; losetup -d /dev/loop0

(Replace bs=4k" with the blocksize of your underlying filesystem). I.e.,
I can convert the stuff _in place_ (it actually works, anyone please
complain loudly if it shouldn't) even when my 'cryptfile' is /dev/hdax
and I don't have sizeof(/dev/hdax) space left on my hard drives.

&lt;snip&gt;
&gt; BUT: "unsigned int" and "int" have the same bit size right ?
&gt;      The crypto algorithms only care about the bits not the
&gt;      signedness (and if they do, they only have to interpret
&gt;      the IV as signed... no problem...)

Whether you use a signed or unsigned int for the sector address does not
affect the encryption at all. So I don't see your point here...

&lt;snip&gt;

Your approach is not so far away from what I suggested (which is a
simplification of what Alex suggested to me when I came up with pretty
much the same idea as you). In fact, your approach could well be default
way of encryption, but there should be a way to set the block size. At
least to the block size of the underlying (call it compatibility mode or
so). Yet, I think that there may be some clever uses for a completely
free choice of the encryption chunk size, down to one cipher block size
and up to the underlying's block size. IV generation is what I am
worried about. There is a paper about why it is a bad idea to use
sequence numbers for CBC IV's. I just have to find the reference to it.

Marc

-- 
Marc Mutz &lt;Marc@Mutz.com&gt;     http://EncryptionHOWTO.sourceforge.net/
University of Bielefeld, Dep. of Mathematics / Dep. of Physics

PGP-keyID's:   0xd46ce9ab (RSA), 0x7ae55b9e (DSS/DH)



Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001005160441</emailId><senderName>Sandy Harris</senderName><senderEmail>sandy@storm.ca</senderEmail><timestampReceived>2000-10-05 16:04:41-0400</timestampReceived><subject>Re: linux-ipsec: freeswan .... using OpenSSL ?</subject><body>

Crispin Cowan wrote:
&gt; 
&gt; Marc Mutz wrote:
&gt; 
&gt; &gt; &lt;snip&gt;
&gt; &gt; &gt; Oh yes, it would be nice if the library didn't insist on inventing its own
&gt; &gt; &gt; big-number support, but used the existing GMP library.
&gt; &gt; &lt;snip&gt;
&gt; &gt;
&gt; &gt; You won't ever be able to get public-key encryption into the kernel
&gt; &gt; proper (and there is no reason to try), so what do you want big number
&gt; &gt; support for?
&gt; 
&gt; Actually, we already have both bignum support and public key crypto in the
&gt; kernel for this project http://immunix.org/cryptomark.html
&gt; 
&gt; We use it to do crypto certification of executables, so as to prevent trojan
&gt; horse attacks.
&gt; 
&gt; It will be released under the GPL, as it is a union of the Linux kernel and the
&gt; GPG code body.  Unfortunately for freeswan, it has American taint.

Methinks this is no longer FreeS/WAN-specific and should continue on the
linux-crypto@nl.linux.org list.

We need quite a lot of crypto in the kernel:

FreeS/WAN currently has 3DES, and HMAC authentication based on SHA and MD5.
It is almost certain to add Rijndael at some point and likely any successor
to SHA that NIST standardises as well. The RFCs allow other algorithms for
both authentication and encryption, and some IPSEC implementations support
them (e.g. PGPnet uses CAST-128) but FreeS/WAN is unlikely to use those.

Note that IPv6 requires IPSEC, so at some point this all needs to be in
the standard kernel.

Last I looked, /dev/random could use SHA or MD5 for the main stuff, but for
some reason also had MD4 included in the TCP nonce code.

Your stuff needs bignums and public key operations. Methinks these are
necessary for any signature scheme.

Will DNS security require similar things, or is all its key validation
done in user space?

Do the encrypting file systems require anything besides a good block cipher?

So what does it take to get a library into the kernel that does at least:

	3DES
	Rijndael
	SHA hash (initialise with fixed constants)
	SHA HMAC (initialise with secret key material)
	public key primitives (probably signature only)

What else is necessary or desirable? Would the maintainers of the various
packages use such a library?

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001005163224</emailId><senderName>Marc Mutz</senderName><senderEmail>marc@mutz.com</senderEmail><timestampReceived>2000-10-05 16:32:24-0400</timestampReceived><subject>Re: linux-ipsec: freeswan .... using OpenSSL ?</subject><body>

Sandy Harris wrote:
&gt; 
&lt;snip&gt;
&gt; Do the encrypting file systems require anything besides a good block cipher?
&gt; 

No.

&gt; So what does it take to get a library into the kernel that does at least:
&gt; 
&gt;         3DES
&gt;         Rijndael
&gt;         SHA hash (initialise with fixed constants)

We have all that already in kerneli.

&gt;         SHA HMAC (initialise with secret key material)

probably trivial to add.

&gt;         public key primitives (probably signature only)
&gt; 
I thought that Pk encryption was only used for key exchange. That could
happily live in userspace. However, I now wonder how authentication is
done? Is is done via symmetric enciphering of the hash value or using
PK? If it's the latter, does all and every IPv6 packet require a PK run?
Good bye performance.

I should look at the RFC's But it's so _much_ stuff. There is shorter
treatment by TimeStep and I'll look at it _now_.
....
OK, apparently AH consists of a MAC, and that should be SHA HMAC, no? So
where is the need for PK in IPSec other than probably for key exchange?

&gt; What else is necessary or desirable? Would the maintainers of the various
&gt; packages use such a library?

Apparently not. The kerneli patch is out there since 1998 and the only
user of this is still loopback crypto. I have not heard of a reason for
why it is not used, except maybe from the FreeS/WAN people: It's not
free of US hands.

Hmm, maybe it is? Most cipher implementations are taken from Brian
Gladman, according to his homepage location he's a UK citizen. Alex,
Gisle and myself from Norway (?) and Germany, resp. 

Sorry for the train of toughts running over you all...

marc

-- 
Marc Mutz &lt;Marc@Mutz.com&gt;     http://EncryptionHOWTO.sourceforge.net/
University of Bielefeld, Dep. of Mathematics / Dep. of Physics

PGP-keyID's:   0xd46ce9ab (RSA), 0x7ae55b9e (DSS/DH)


Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001005170601</emailId><senderName>Sandy Harris</senderName><senderEmail>sandy@storm.ca</senderEmail><timestampReceived>2000-10-05 17:06:01-0400</timestampReceived><subject>Re: linux-ipsec: freeswan .... using OpenSSL ?</subject><body>

Marc Mutz wrote:
&gt; 
&gt; Sandy Harris wrote:
&gt; &gt;
&gt; &lt;snip&gt;
&gt; &gt; Do the encrypting file systems require anything besides a good block cipher?
&gt; &gt;
&gt; 
&gt; No.
&gt; 
&gt; &gt; So what does it take to get a library into the kernel that does at least:
&gt; &gt;
&gt; &gt;         3DES
&gt; &gt;         Rijndael
&gt; &gt;         SHA hash (initialise with fixed constants)
&gt; 
&gt; We have all that already in kerneli.
&gt; 
&gt; &gt;         SHA HMAC (initialise with secret key material)
&gt; 
&gt; probably trivial to add.
&gt; 
&gt; &gt;         public key primitives (probably signature only)
&gt; &gt;
&gt; I thought that Pk encryption was only used for key exchange. That could
&gt; happily live in userspace.

Yes, for IPSEC. But if you want the kernel to authenticate binaries before
loading them, then you may need public key stuff in the kernel.

&gt; However, I now wonder how authentication is
&gt; done? Is is done via symmetric enciphering of the hash value or using
&gt; PK? If it's the latter, does all and every IPv6 packet require a PK run?
&gt; Good bye performance.

For IPSEC, you use the public key stuff to authenticate a key negotiation,
preventing a man-in-the-middle from posing as either player and subverting
the negotiation. The negotiation produces an encryption key and an HMAC
key.

Packet authentication is done with the HMAC. This is an SHA or MD5 hash of
the packet data, except with the registers in the hashing code initialised
from the HMAC key rather than from standard constants. It therefore does
more than a simple hash would, authenticating not just that the packet data
was not changed in transit but also that the sender knew the HMAC key. 
 
&gt; I should look at the RFC's But it's so _much_ stuff. There is shorter
&gt; treatment by TimeStep and I'll look at it _now_.
&gt; ....
&gt; OK, apparently AH consists of a MAC, and that should be SHA HMAC, no? So
&gt; where is the need for PK in IPSec other than probably for key exchange?

For IPSEC, there's no need I can see. To secure program loads, though,
you appear to need some variant of PK to sign the executables. I wonder
if that could be in a user-space loader though, rather than the kernel.

Or would some variant of the HMAC scheme be enough to control loading?
Instead of a signature on each file, just store an HMAC? Checking it
shows both that the file is uncorrupted and that the storer had the
required key. Overheads are essentially identical to calculating a
hash. Methinks you need the hash anyway to verify non-corruption.
For a public key signature you need both the hash and the public
key operations, so this is much cheaper.

Of course this can be subverted by an attacker who has root on the
machine, but so can the public key scheme, I think.

&gt; &gt; What else is necessary or desirable? Would the maintainers of the various
&gt; &gt; packages use such a library?
&gt; 
&gt; Apparently not. The kerneli patch is out there since 1998 and the only
&gt; user of this is still loopback crypto. I have not heard of a reason for
&gt; why it is not used, except maybe from the FreeS/WAN people: It's not
&gt; free of US hands.

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001005194915</emailId><senderName>Gisle S{lensminde</senderName><senderEmail>gisle@ii.uib.no</senderEmail><timestampReceived>2000-10-05 19:49:15-0400</timestampReceived><subject>Re: linux-ipsec: freeswan .... using OpenSSL ?</subject><body>

On Thu, 5 Oct 2000, Sandy Harris wrote:

&gt; 
&gt; So what does it take to get a library into the kernel that does at least:
&gt; 
&gt; 	3DES
&gt; 	Rijndael
&gt; 	SHA hash (initialise with fixed constants)
&gt; 	SHA HMAC (initialise with secret key material)
&gt; 	public key primitives (probably signature only)

Marc has told what things that is found in kerneli. Now Freeswan/ipsec
uses Eric Young's libdes, which both has a fast C implementation and
a fast x86 implementation. Unfortunatly it is specially stated in the
library source that the code is not GPL, and cannot be changed to GPL
either. 

&lt;quote&gt;
this code cannot simply be copied and put under another distrubution
license [including the GNU Public License.]  
&lt;/quote&gt;

AFAIK, this means that the code cannot simply be put into the crypto-
API without permission. Do you think it's possible to get the 
necessary permission to insert the the libdes 3DES implementation into 
the kernel.

--
Gisle Sælensminde ( gisle@ii.uib.no )   

With sufficient thrust, pigs fly just fine. However, this is not
necessarily a good idea. It is hard to be sure where they are going
to land, and it could be dangerous sitting under them as they fly
overhead. (from RFC 1925)


Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001005212759</emailId><senderName>Henry Spencer</senderName><senderEmail>henry@spsystems.net</senderEmail><timestampReceived>2000-10-05 21:27:59-0400</timestampReceived><subject>Re: linux-ipsec: freeswan .... using OpenSSL ?</subject><body>

On Thu, 5 Oct 2000, Sandy Harris wrote:
&gt; Will DNS security require similar things, or is all its key validation
&gt; done in user space?

With the usual implementation approach, at least, DNSsec should be
entirely user-space. 

&gt; So what does it take to get a library into the kernel that does at least:
&gt;...
&gt; 	public key primitives (probably signature only)

It is conceivable that one might want public-key encryption as well, and
if RSA is being used, that's a trivial addition.

                                                          Henry Spencer
                                                       henry@spsystems.net


Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001005222509</emailId><senderName>"Michael T. Babcock"</senderName><senderEmail>mbabcock@fibrespeed.net</senderEmail><timestampReceived>2000-10-05 22:25:09-0400</timestampReceived><subject>Re: linux-ipsec: freeswan .... using OpenSSL ?</subject><body>

&gt; Marc has told what things that is found in kerneli. Now Freeswan/ipsec
&gt; uses Eric Young's libdes, which both has a fast C implementation and
&gt; a fast x86 implementation. Unfortunatly it is specially stated in the
&gt; library source that the code is not GPL, and cannot be changed to GPL
&gt; either.
&gt;
&gt; &lt;quote&gt;
&gt; this code cannot simply be copied and put under another distrubution
&gt; license [including the GNU Public License.]
&gt; &lt;/quote&gt;
&gt;
&gt; AFAIK, this means that the code cannot simply be put into the crypto-
&gt; API without permission. Do you think it's possible to get the
&gt; necessary permission to insert the the libdes 3DES implementation into
&gt; the kernel.

In those cases, its often smart to offer the compiling user the option of
linking against it and creating your own library to do it thats slower as
well.  ./configure --with-lib3des ... they'll have to acquire lib3des on
their own.  This is done with lots of other large packages.


Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001005230837</emailId><senderName>Gisle S{lensminde</senderName><senderEmail>gisle@ii.uib.no</senderEmail><timestampReceived>2000-10-05 23:08:37-0400</timestampReceived><subject>Re: linux-ipsec: freeswan .... using OpenSSL ?</subject><body>

On Thu, 5 Oct 2000, Michael T. Babcock wrote:

&gt; &gt; Marc has told what things that is found in kerneli. Now Freeswan/ipsec
&gt; &gt; uses Eric Young's libdes, which both has a fast C implementation and
&gt; &gt; a fast x86 implementation. Unfortunatly it is specially stated in the
&gt; &gt; library source that the code is not GPL, and cannot be changed to GPL
&gt; &gt; either.
&gt; &gt;
&gt; &gt; &lt;quote&gt;
&gt; &gt; this code cannot simply be copied and put under another distrubution
&gt; &gt; license [including the GNU Public License.]
&gt; &gt; &lt;/quote&gt;
&gt; &gt;
&gt; &gt; AFAIK, this means that the code cannot simply be put into the crypto-
&gt; &gt; API without permission. Do you think it's possible to get the
&gt; &gt; necessary permission to insert the the libdes 3DES implementation into
&gt; &gt; the kernel.
&gt; 
&gt; In those cases, its often smart to offer the compiling user the option of
&gt; linking against it and creating your own library to do it thats slower as
&gt; well.  ./configure --with-lib3des ... they'll have to acquire lib3des on
&gt; their own.  This is done with lots of other large packages.

The code wil be put inside the kernel, and 3DES is already there. 
The point is to get a faster version in. I don't think the idea relying
on people puting there own libraries into the kernel is a particularly
good idea. 

The best idea would probably be to ask Eric Young for permission for
insering the relevant parts of his library into the linux crypto API.
Does anyone have his email adress, or know what he thinks about 
such usage. (other than the licence text)

--
Gisle Sælensminde ( gisle@ii.uib.no )   

With sufficient thrust, pigs fly just fine. However, this is not
necessarily a good idea. It is hard to be sure where they are going
to land, and it could be dangerous sitting under them as they fly
overhead. (from RFC 1925)


Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001006004008</emailId><senderName>Richard Guy Briggs</senderName><senderEmail>rgb@conscoop.ottawa.on.ca</senderEmail><timestampReceived>2000-10-06 00:40:08-0400</timestampReceived><subject>Re: linux-ipsec: freeswan .... using OpenSSL ?</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----

On Fri, Oct 06, 2000 at 01:08:37AM +0200, Gisle wrote:
&gt; On Thu, 5 Oct 2000, Michael T. Babcock wrote:
&gt; &gt; In those cases, its often smart to offer the compiling user the option of
&gt; &gt; linking against it and creating your own library to do it thats slower as
&gt; &gt; well.  ./configure --with-lib3des ... they'll have to acquire lib3des on
&gt; &gt; their own.  This is done with lots of other large packages.
&gt; 
&gt; The code wil be put inside the kernel, and 3DES is already there. 

Eventually, but that does not help us for 2.0, 2.2 and 2.4 kernels, so
it would be easier to include it with the distribution of FreeS/WAN
and only use the built-in one if it exists.  Eventually, we can ditch
it when we stop supporting 2.0, 2.2 and 2.4.

&gt; The point is to get a faster version in. I don't think the idea relying
&gt; on people puting there own libraries into the kernel is a particularly
&gt; good idea. 

Agreed.

&gt; Gisle

	slainte mhath, RGB
- -- 
Richard Guy Briggs -- PGP key available            Auto-Free Ottawa! Canada
&lt;www.conscoop.ottawa.on.ca/rgb/&gt;                       &lt;www.flora.org/afo/&gt;
Prevent Internet Wiretapping!        --        FreeS/WAN:&lt;www.freeswan.org&gt;
Thanks for voting Green! -- &lt;green.ca&gt;      Marillion:&lt;www.marillion.co.uk&gt;

-----BEGIN PGP SIGNATURE-----
Version: 2.6.3i
Charset: noconv

iQCVAwUBOd0fZt+sBuIhFagtAQGeYgQAkjK1gnWBLr6BHWhW6kuTo1OdWtwDpiXt
okAt/gJtfhwTIZqyFDh9olt+/XyBkflHF9XHZwzM1yFCRMy5VpJefcapk/JYxQcJ
OfNyr9Uw+RFC1h3i5fNjMp9WJG+/4hR+9Wk53jg8mK1/9sw3ZSiebY2QU5aAFlmE
KnGJn270Uso=
=dcyI
-----END PGP SIGNATURE-----

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001006033750</emailId><senderName>"Michael T. Babcock"</senderName><senderEmail>mbabcock@fibrespeed.net</senderEmail><timestampReceived>2000-10-06 03:37:50-0400</timestampReceived><subject>Re: linux-ipsec: freeswan .... using OpenSSL ?</subject><body>

&gt; On Fri, Oct 06, 2000 at 01:08:37AM +0200, Gisle wrote:
&gt; &gt; On Thu, 5 Oct 2000, Michael T. Babcock wrote:
&gt; &gt; &gt; In those cases, its often smart to offer the compiling user the option
of
&gt; &gt; &gt; linking against it and creating your own library to do it thats slower
as
&gt; &gt; &gt; well.  ./configure --with-lib3des ... they'll have to acquire lib3des
on
&gt; &gt; &gt; their own.  This is done with lots of other large packages.
&gt; &gt;
&gt; &gt; The point is to get a faster version in. I don't think the idea relying
&gt; &gt; on people puting there own libraries into the kernel is a particularly
&gt; &gt; good idea.
&gt;
&gt; Agreed.

My comment was to have the option available sooner than later to use
external 3DES, etc. libraries that are known to be more optimised.  This can
be replaced down the road with built-in libraries.  That said, installing
FreeS/WAN currently requires patching the kernel, etc. so why would you be
hesitant about someone who wanted to use another library for better 3DES
support?


Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001006084136</emailId><senderName>Alexander S A Kjeldaas</senderName><senderEmail>alexander.kjeldaas@fast.no</senderEmail><timestampReceived>2000-10-06 08:41:36-0400</timestampReceived><subject>Re: linux-ipsec: freeswan .... using OpenSSL ?</subject><body>

On Thu, Oct 05, 2000 at 01:06:01PM -0400, Sandy Harris wrote:
&gt; Marc Mutz wrote:
&gt; &gt; I thought that Pk encryption was only used for key exchange. That could
&gt; &gt; happily live in userspace.
&gt; 
&gt; Yes, for IPSEC. But if you want the kernel to authenticate binaries before
&gt; loading them, then you may need public key stuff in the kernel.
&gt; 

Until someone can show that this is needed, I do not see the point in
having the kernel authenticate binaries.  We have a file-system, and
if we accept that the file-system is secure, we can put the public-key
crypto in the tools that are given the privilege of introducing a new
executable program in the file-system.

If you say that we can not trust the file-system, then I say that you
can encrypt the file-system.  Then you are back to the point where you
have a user-level tool that does the public-key crypto when you mount
the file-system.

Even if you want to authenticate binaries, you can register
"authorities" with the kernel so that the kernel only authenticates
binaries with a HMAC.  You can _still_ have a user-level tool that
introduces those authorities into the kernel and does the necessary
public-key crypto.  I have a hard time imagining a system where:

 - There is _a lot_ of users able to introduce new binaries in the
   system so that registering them all in the kernel is awkward.
    
 - For some weird reason, you can not trust the filesystem.

 - There is no user-land workaround.

All in all, I still do not understand why public-key crypto should be
used in the kernel.  I do not see a place for it until there comes an
application where there are big _performance_ advantages of having it
there.  Few such applications exists because one generally tries to
keep public-key crypto out of performance-critical areas.

astor

-- 
Alexander Kjeldaas                Mail:  astor@fast.no
finger astor@master.kernel.org for OpenPGP key.

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001004143632</emailId><senderName>Alexander S A Kjeldaas</senderName><senderEmail>alexander.kjeldaas@fast.no</senderEmail><timestampReceived>2000-10-04 14:36:32-0400</timestampReceived><subject>Re: Using kerneli w/o compiling a kernel?</subject><body>

On Mon, Oct 02, 2000 at 03:05:29PM +0000, Marc Mutz wrote:
&gt; Hi!
&gt; 
&gt; I've run into the problem of explaining how to make an encrypted folder
&gt; with kerneli to someone who merely survived a linux install. I kow that
&gt; the answer to the following is NO, but does someone out there know of
&gt; RPMs for the major dirtributions of both the kernel modules and the
&gt; patched mount and losetup? Is anyone willing to do this or tell me how
&gt; to? This would greatly simplify my task.
&gt; 
&gt; However if - as is expected - the answer to the above question is NO, is
&gt; there a way to completely module out the kerneli parts so that there is
&gt; no need to recompile the kernel. I know that everything can be compiled
&gt; as modules, but when I try this, I don't get a cryptoapi.o module. I've
&gt; selected it as being a module, but is is compiled into the kernel
&gt; nevertheless:
&gt; 

Could you try 2.2.17.8.pre1 available from
ftp.*.kernel.org:/pub/linux/kernel/people/astor/v2.2/.  It includes
quite a few other changes as well.  For example, DEFINE_CIPHER et.al
is gone.

astor

-- 
Alexander Kjeldaas                Mail:  astor@fast.no
finger astor@master.kernel.org for OpenPGP key.

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001004185408</emailId><senderName>Marc Mutz</senderName><senderEmail>marc@mutz.com</senderEmail><timestampReceived>2000-10-04 18:54:08-0400</timestampReceived><subject>Re: Using kerneli w/o compiling a kernel?</subject><body>

Alexander S A Kjeldaas wrote:
&gt; 
&lt;snip&gt;
&gt; Could you try 2.2.17.8.pre1 available from
&gt; ftp.*.kernel.org:/pub/linux/kernel/people/astor/v2.2/.  It includes
&gt; quite a few other changes as well.  For example, DEFINE_CIPHER et.al
&gt; is gone.
&lt;snip&gt;

This change breaks my blowfish crypted fs. &lt;angst&gt;
Initially, I thought it was due to the restriction of blowfish to 128
192 and 256 bits, but after adding 160, which is what losetup uses,
things stayed broken. I also tried loading blowish.o from i7, but that
had unresolved dependencies on depmod -a.
I havn't looked further into this as blowfish.c and there seems to be
nothing unusual there.

Also, when loading blowfish (or rijndael), they don't show up in
/proc/cipher/. However, the directory is there.

The issues might well be in cryptoapi.c

Marc

PS: Now that I need a devel machine, 50% of your laptops are broken :-(

-- 
Marc Mutz &lt;Marc@Mutz.com&gt;     http://EncryptionHOWTO.sourceforge.net/
University of Bielefeld, Dep. of Mathematics / Dep. of Physics

PGP-keyID's:   0xd46ce9ab (RSA), 0x7ae55b9e (DSS/DH)


Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001004200138</emailId><senderName>Alexander S A Kjeldaas</senderName><senderEmail>alexander.kjeldaas@fast.no</senderEmail><timestampReceived>2000-10-04 20:01:38-0400</timestampReceived><subject>Re: Using kerneli w/o compiling a kernel?</subject><body>

On Wed, Oct 04, 2000 at 06:54:08PM +0000, Marc Mutz wrote:
&gt; 
&gt; This change breaks my blowfish crypted fs. &lt;angst&gt;
&gt; Initially, I thought it was due to the restriction of blowfish to 128
&gt; 192 and 256 bits, but after adding 160, which is what losetup uses,
&gt; things stayed broken. I also tried loading blowish.o from i7, but that
&gt; had unresolved dependencies on depmod -a.
&gt; I havn't looked further into this as blowfish.c and there seems to be
&gt; nothing unusual there.
&gt; 
&gt; Also, when loading blowfish (or rijndael), they don't show up in
&gt; /proc/cipher/. However, the directory is there.
&gt; 
&gt; The issues might well be in cryptoapi.c
&gt; 

Expect some blow-ups from a pre-patch ;-).  I'll look at it
tomorrow. cryptoapi.c was pretty much rewritten, so yes, it is most
probably buggy.  Did the ciphers register on bootup/insmod?

astor

-- 
Alexander Kjeldaas                Mail:  astor@fast.no
finger astor@master.kernel.org for OpenPGP key.

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001004210626</emailId><senderName>Marc Mutz</senderName><senderEmail>marc@mutz.com</senderEmail><timestampReceived>2000-10-04 21:06:26-0400</timestampReceived><subject>Re: Using kerneli w/o compiling a kernel?</subject><body>

Alexander S A Kjeldaas wrote:
&gt; 
&lt;snip&gt;
&gt; Did the ciphers register on bootup/insmod?
&gt; 

Yes.

Marc

-- 
Marc Mutz &lt;Marc@Mutz.com&gt;     http://EncryptionHOWTO.sourceforge.net/
University of Bielefeld, Dep. of Mathematics / Dep. of Physics

PGP-keyID's:   0xd46ce9ab (RSA), 0x7ae55b9e (DSS/DH)


Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001005084555</emailId><senderName>Alexander S A Kjeldaas</senderName><senderEmail>alexander.kjeldaas@fast.no</senderEmail><timestampReceived>2000-10-05 08:45:55-0400</timestampReceived><subject>Re: Using kerneli w/o compiling a kernel?</subject><body>

On Wed, Oct 04, 2000 at 09:06:26PM +0000, Marc Mutz wrote:
&gt; Alexander S A Kjeldaas wrote:
&gt; &gt; 
&gt; &lt;snip&gt;
&gt; &gt; Did the ciphers register on bootup/insmod?
&gt; &gt; 
&gt; 
&gt; Yes.
&gt; 

Try 2.2.17.8.pre2.  The /proc/cipher and /proc/digest entries were
switched.

astor

-- 
Alexander Kjeldaas                Mail:  astor@fast.no
finger astor@master.kernel.org for OpenPGP key.

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001001125624</emailId><senderName>Gisle S{lensminde</senderName><senderEmail>gisle@ii.uib.no</senderEmail><timestampReceived>2000-10-01 12:56:24-0400</timestampReceived><subject>Re: [experimantal patch] show allowed keylengths in /proc/cipher/*</subject><body>

On Sun, 1 Oct 2000, Alexander S A Kjeldaas wrote:

&gt; On Fri, Sep 29, 2000 at 03:13:27PM +0000, Marc Mutz wrote:
&gt; &gt; Hi out there!
&gt; &gt; 
&gt; &gt; This little patch allows /proc/cipher/* to show a bitmask of allowed
&gt; &gt; keysizes. Simple as it may ssem, it breaks the current jungle of
&gt; &gt; #define's quite thoroughly. Ciphers that want to take advantage of this
&gt; &gt; patch and actually _provide_ more than one keylength per cipher
&gt; &gt; implementation (and most ciphers could), will not be able to use the
&gt; &gt; DEFINE_CIPHER construct any more.
&gt; &gt; 
&gt; 
&gt; Why not just let all ciphers accept any key-length up to a maximum key
&gt; length, and have the cipher internally treat shorter keys as a
&gt; possible optimization opportunities.  For example, the rijndael cipher
&gt; could exploit that kind of stuff to select the correct number of
&gt; rounds.  So the user wouldn't really care about which intermediate
&gt; keylengths a cipher was designed for, just the maximum keylength it
&gt; was designed for.

For some ciphers this may introduce security traps. The best example
is 3DES. Now we accept 8, 16 or 24 bit keys and reject all other
key lengths. This corresponds to DES compatibility, 2 key 3DES and
3 key 3DES respectivly. The parity bits are ignored. The problem
is what we are going to do in the case where we have keylengths that
don't fit into this. If we pad the key up to the nearest defined
keylength we will get the possibility for meet-in-the-middle attacks
against the cipher, which will reduce the complexity of an attack
to around 2^56 work.

If we on the other hand throw away bits to fit into a smaller key,
we can also get in touble. The best example is when someone tries
to use a keylength 14 or 15 bytes. then the security will be 2^56,
since the lower key length is 56 bits. This will give the users a
false imression of security. The worst case is maybe 14 bytes, since
many people thinks that 14 bytes = 112 bits keylength, but miss
the parity bits. They will belive they use a 112 bits key, while
they only use a 56 bit key.  

Both of the strategies will introduce potential traps, and a more
advanced scheme will give surprises to the users, since we must 
introduce such modes. This will not be compatible with anything
else either. IMO here should be possible to restrict some ciphers to
predefined keylengths.

--
Gisle Sælensminde ( gisle@ii.uib.no )   

With sufficient thrust, pigs fly just fine. However, this is not
necessarily a good idea. It is hard to be sure where they are going
to land, and it could be dangerous sitting under them as they fly
overhead. (from RFC 1925)


Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001002133333</emailId><senderName>Alexander S A Kjeldaas</senderName><senderEmail>alexander.kjeldaas@fast.no</senderEmail><timestampReceived>2000-10-02 13:33:33-0400</timestampReceived><subject>Re: [experimantal patch] show allowed keylengths in /proc/cipher/*</subject><body>

On Sun, Oct 01, 2000 at 02:56:24PM +0200, Gisle S{lensminde wrote:
&gt; On Sun, 1 Oct 2000, Alexander S A Kjeldaas wrote:
&gt; &gt;
&gt; &gt; Why not just let all ciphers accept any key-length up to a maximum key
&gt; &gt; length, and have the cipher internally treat shorter keys as a
&gt; &gt; possible optimization opportunities.  For example, the rijndael cipher
&gt; &gt; could exploit that kind of stuff to select the correct number of
&gt; &gt; rounds.  So the user wouldn't really care about which intermediate
&gt; &gt; keylengths a cipher was designed for, just the maximum keylength it
&gt; &gt; was designed for.
&gt; 
&gt; For some ciphers this may introduce security traps. The best example
&gt; is 3DES. Now we accept 8, 16 or 24 bit keys and reject all other
&gt; key lengths. This corresponds to DES compatibility, 2 key 3DES and
&gt; 3 key 3DES respectivly. The parity bits are ignored. The problem
&gt; is what we are going to do in the case where we have keylengths that
&gt; don't fit into this. If we pad the key up to the nearest defined
&gt; keylength we will get the possibility for meet-in-the-middle attacks
&gt; against the cipher, which will reduce the complexity of an attack
&gt; to around 2^56 work.
&gt; 
&gt; If we on the other hand throw away bits to fit into a smaller key,
&gt; we can also get in touble. The best example is when someone tries
&gt; to use a keylength 14 or 15 bytes. then the security will be 2^56,
&gt; since the lower key length is 56 bits. This will give the users a
&gt; false imression of security. The worst case is maybe 14 bytes, since
&gt; many people thinks that 14 bytes = 112 bits keylength, but miss
&gt; the parity bits. They will belive they use a 112 bits key, while
&gt; they only use a 56 bit key.  
&gt; 

Third strategy.  You don't need a "global" strategy for how you deal
with keys.  For 3DES you could remove bits from the three keys in a
round-robin fashion so that none of the three keys are weaker than the
others by more than 1 bit.

I buy your argument that the very act of accepting a 112 bit key is a
potential trap, since you might very well be looking at a software
bug, and that returning an error would be a lot better.

But what if the user of the library actually _has_ 80 random bits that
he wants to use as a key.  How should he be able to use 3DES?  He
queries the interface and finds out that he can give 3DES a key with
56, 112, or 168 random bits (if we ignore parity bits). What should
the user do? The "obvious" tricks are dangerous to use for 3DES, as
you demonstrate above, while a 3DES-specific function could help him
get a key with as high security as possible from his 80 random bits.

&gt; Both of the strategies will introduce potential traps, and a more
&gt; advanced scheme will give surprises to the users, since we must 
&gt; introduce such modes. This will not be compatible with anything
&gt; else either. 

If we construct a 3DES-specific key-munging algorithm, it will be
"incompatible" with other software to a certain extent, and that's a
bad thing.  I'm just trying to show/make sure that all ciphers _can_
handle a keys of variable length, so that the user of a crypto library
doesn't need to care about these issues.  If the user doesn't need to
care about these issues, the interface doesn't have to be more
complex.  I am no cryptographer so there might well be more traps with
such an approach though, so do not expect something like this to
appear right away.

&gt; IMO here should be possible to restrict some ciphers to
&gt; predefined keylengths.

astor

-- 
Alexander Kjeldaas                Mail:  astor@fast.no
finger astor@master.kernel.org for OpenPGP key.

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001002152041</emailId><senderName>Marc Mutz</senderName><senderEmail>marc@mutz.com</senderEmail><timestampReceived>2000-10-02 15:20:41-0400</timestampReceived><subject>Re: [experimantal patch] show allowed keylengths in /proc/cipher/*</subject><body>

Alexander S A Kjeldaas wrote:
&gt; 
&lt;snip&gt;
&gt; 
&gt; Third strategy.  You don't need a "global" strategy for how you deal
&gt; with keys.  For 3DES you could remove bits from the three keys in a
&gt; round-robin fashion so that none of the three keys are weaker than the
&gt; others by more than 1 bit.
&gt; 
&gt; I buy your argument that the very act of accepting a 112 bit key is a
&gt; potential trap, since you might very well be looking at a software
&gt; bug, and that returning an error would be a lot better.
&gt; 
&gt; But what if the user of the library actually _has_ 80 random bits that
&gt; he wants to use as a key.  How should he be able to use 3DES?

Hashing it or just using a cipher that can.

&gt; He
&gt; queries the interface and finds out that he can give 3DES a key with
&gt; 56, 112, or 168 random bits (if we ignore parity bits). What should
&gt; the user do? The "obvious" tricks are dangerous to use for 3DES, as
&gt; you demonstrate above, while a 3DES-specific function could help him
&gt; get a key with as high security as possible from his 80 random bits.
&gt; 
&lt;snip&gt;
&gt; 
&gt; If we construct a 3DES-specific key-munging algorithm, it will be
&gt; "incompatible" with other software to a certain extent, and that's a
&gt; bad thing.  I'm just trying to show/make sure that all ciphers _can_
&gt; handle a keys of variable length, so that the user of a crypto library
&gt; doesn't need to care about these issues.  If the user doesn't need to
&gt; care about these issues, the interface doesn't have to be more
&gt; complex.  I am no cryptographer so there might well be more traps with
&gt; such an approach though, so do not expect something like this to
&gt; appear right away.
&gt; 
&lt;snip&gt;

I'm sure there can be nasty consequences if you use a cipher that has a
defined key length with another. It is true that most recently developed
ciphers do in fact accept arbitrary length keys (up to a certain
maximum), but they are _designed_ to do this. They have a matching key
schedule algorithm that can cope with that. Blowfish accepts key lengths
of up to 448 bits (being a _symmetric_ cipher) and Twofish up to 256.
But doing some nasty things with the key bits before they are given to
the key schedule will probably open the door for related-key attacks.
It's the old tale: Use a cipher different than it was designed and you
get into all sorts of troubles. Look at DES's S-Boxes. Change them in
any way and you make DES weaker and sometimes trivial to break. Ciphers
are fragile objects that should only be used "according to the book".

Alex gave another reason: DES is a standard. You can't go and say.
"Well, I have here these extra bits of entropy, lets throw them in
somehow." How should this interoperate with other implementations.
That's the way MS is using standards. Sorry.

The main reason for the proposal of a keylength list in /proc/cipher/
was the need to have it in order for losetup to look it up. Currently
there is no inexpensive way to gather allowed keysizes to present them
in /proc/cipher/. losetup should be able to search that directoy and
find the key length there.

Marc

-- 
Marc Mutz &lt;Marc@Mutz.com&gt;        http://marc.mutz.com/Encryption-HOWTO/
University of Bielefeld, Dep. of Mathematics / Dep. of Physics

PGP-keyID's:   0xd46ce9ab (RSA), 0x7ae55b9e (DSS/DH)



Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001003163927</emailId><senderName>Alexander S A Kjeldaas</senderName><senderEmail>alexander.kjeldaas@fast.no</senderEmail><timestampReceived>2000-10-03 16:39:27-0400</timestampReceived><subject>Re: [experimantal patch] show allowed keylengths in /proc/cipher/*</subject><body>

On Mon, Oct 02, 2000 at 03:20:41PM +0000, Marc Mutz wrote:
[...]

I buy the arguments.  Having ciphers accept all kinds of keysizes will
inevitably cause problems.

astor

-- 
Alexander Kjeldaas                Mail:  astor@fast.no
finger astor@master.kernel.org for OpenPGP key.

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001004192819</emailId><senderName>"Michael T. Babcock"</senderName><senderEmail>mbabcock@fibrespeed.net</senderEmail><timestampReceived>2000-10-04 19:28:19-0400</timestampReceived><subject>Re: [experimantal patch] show allowed keylengths in /proc/cipher/*</subject><body>

&gt; If we construct a 3DES-specific key-munging algorithm, it will be
&gt; "incompatible" with other software to a certain extent, and that's a
&gt; bad thing.  I'm just trying to show/make sure that all ciphers _can_
&gt; handle a keys of variable length, so that the user of a crypto library
&gt; doesn't need to care about these issues.  If the user doesn't need to
&gt; care about these issues, the interface doesn't have to be more
&gt; complex.  I am no cryptographer so there might well be more traps with
&gt; such an approach though, so do not expect something like this to
&gt; appear right away.

I think it would be most beneficial here to definately consult with a real
cryptographer if 'we' want to know how to handle this correctly.  There may
or may not be a paper written somewhere on the issue too.


Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001004140155</emailId><senderName>Marc Mutz</senderName><senderEmail>marc@mutz.com</senderEmail><timestampReceived>2000-10-04 14:01:55-0400</timestampReceived><subject>[PATCH] Configure.help updates for AES.</subject><body>

Hi!

Subject says it all. Please check and consider applying.

Marc

-- 
Marc Mutz &lt;Marc@Mutz.com&gt;     http://EncryptionHOWTO.sourceforge.net/
University of Bielefeld, Dep. of Mathematics / Dep. of Physics

PGP-keyID's:   0xd46ce9ab (RSA), 0x7ae55b9e (DSS/DH)

["Configure.help-2.2.17.7.patch;" (text/plain)]

--- Configure.help~	Tue Oct  3 20:03:06 2000
+++ Configure.help	Wed Oct  4 15:28:53 2000
@@ -365,6 +365,54 @@
 
   If unsure, say 'N'.
 
+AES cipher (EXPERIMENTAL - Read Help)
+CONFIG_CIPHER_AES
+  [2000-10-04]
+  DESCRIPTION:
+  AES (Advanced Encryption Standard) is a proposed Federal Information
+  Processing Standard (FIPS) of the USA. Nevertheless, it was
+  conceived by Joan Daemon and Vincent Rijmen, two Belgians, under the
+  name Rijndael and submitted to the AES selection process in 1997
+  (http://www.nist.gov/aes). On Oct 2, 2000 it was announced as being
+  the selected algorithm for the AES.
+
+  Rijndael is a variable-round iterated block cipher that supports
+  block and key sizes each ranging from 128 to 256 bits, in steps of
+  64. The number of rounds is dependant on the block and key sizes and
+  varies from 10 for 128/128 to 14 for 256/256 block/key sizes.
+  
+  SPPED: N/A
+
+  PATENTS and LICENSING:
+  Rijndeal/AES is free of patents. As beign AES, NIST will ensure that
+  this will stay so.
+
+  KNOWN ATTACKS:
+  None of the following attacks is able to undermine the security of
+  AES, when used with the round numbers specified by the authors.
+
+  The original Rijndael specification contains a truncated
+  differential attack on 4,5 resp. 6 round versions ("Square attack")
+  requiring 2^9, 2^11 resp. 2^32 plaintexts and 2^9, 2^40 resp. 2^72
+  work. There is another truncated differential attack that leads to a
+  collision attack on 7 round 192 and 256 bit keysize Rijndael
+  requiring 2^32 plaintext encryptions and 2^140 work. Other authors
+  extend the original Square attack to 7 rounds of 192 and 256 bit
+  keysize, both with more that 2^184 work. Further improvements of
+  these techniques result in attacks against 7 and 8 round
+  variants. But the latter require almost all of the codebook. At
+  last, there is a related key attack against 9 round, 256 bit keysize
+  Rijndael that requires 2^77 chosen plaintexts and 2^224 work.
+
+AES available under the Rijndael name
+CONFIG_CIPHER_RIJNDAEL
+  If you say 'Y' here, AES will be also accessible through its
+  original name Rijndael. This is mostly for backwards compatibilty.
+  If you use kernel modules that use Rijndael, but do not know that it
+  is now called AES, say 'Y' here.
+
+  If unsure, say 'N'.
+
 DFC encryption (EXPERIMENTAL - Read Help)
 CONFIG_CIPHER_DFC
   [2000-09-13]
@@ -390,7 +438,7 @@
 CONFIG_CIPHER_MARS
   [2000-09-13]
   DESCRIPTION:
-  MARS is IBM's candidate algorithm for the Advanded Encryption
+  MARS was IBM's candidate algorithm for the Advanded Encryption
   Standard (AES). It consists of 16 core rounds and eight pre-mixing
   as well as eight post-mixing rounds.
 
@@ -417,7 +465,7 @@
 CONFIG_CIPHER_RC6
   [2000-09-13]
   DESCRIPTION:
-  RC6 is invented by Ron Rivest and RSA Labs.  It is one of the five
+  RC6 is invented by Ron Rivest and RSA Labs.  It was one of the five
   candidates in round two for the Advanced Encryption Standard (AES).
 
   PATENTS and LICENSING:
@@ -446,7 +494,7 @@
   DESCRIPTION:
   Serpent is a 128-bit block cipher designed by Ross Anderson, Eli
   Biham and Lars Knudsen as a candidate for the Advanced Encryption
-  Standard (AES, see http://www.nist.gov/aes).  It is one of the five
+  Standard (AES, see http://www.nist.gov/aes).  It was one of the five
   finalists after round two of the AES candidate search. Serpent
   provides users with the highest practical level of assurance that no
   shortcut attack will be found.  To achieve this, the algorithm uses

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20001004141630</emailId><senderName>Marc Mutz</senderName><senderEmail>marc@mutz.com</senderEmail><timestampReceived>2000-10-04 14:16:30-0400</timestampReceived><subject>[PATCH] crypto/Config.in reorganization</subject><body>

Hi!

I've shuffled the entries in crypto/Config.in around a bit, grouping
similar ciphers together and adding section titles. We now have:

&lt; &gt; AES
--- AES Finalists:
... Twofish, RC6, Serpent, MARS
--- Other submissions to AES:
&lt; &gt; DFC
--- Other ciphers (64 bit blocksize):
... rest with DES being marked as deprecated.

Please consider applying.

Marc

-- 
Marc Mutz &lt;Marc@Mutz.com&gt;     http://EncryptionHOWTO.sourceforge.net/
University of Bielefeld, Dep. of Mathematics / Dep. of Physics

PGP-keyID's:   0xd46ce9ab (RSA), 0x7ae55b9e (DSS/DH)

["Config.in-reorg-2.2.17.7.patch;" (text/plain)]

--- i7/crypto/Config.in	Tue Oct  3 19:55:10 2000
+++ i7-raidA0-raid1rb15.B2-ext0.0.3a/crypto/Config.in	Wed Oct  4 16:10:56 2000
@@ -6,20 +6,23 @@
 bool 'Crypto support' CONFIG_CRYPTO
 dep_tristate 'Crypto ciphers' CONFIG_CIPHERS $CONFIG_CRYPTO
 if [ "$CONFIG_CIPHERS" != "n" ]; then
-	dep_tristate 'Blowfish cipher (EXPERIMENTAL)' CONFIG_CIPHER_BLOWFISH $CONFIG_CIPHERS
-	dep_tristate 'Twofish cipher (EXPERIMENTAL)' CONFIG_CIPHER_TWOFISH $CONFIG_CIPHERS
- 	dep_tristate 'DES cipher (EXPERIMENTAL)' CONFIG_CIPHER_DES $CONFIG_CIPHERS
-        dep_tristate 'DES EDE3 cipher (3DES, EXPERIMENTAL)' CONFIG_CIPHER_DES_EDE3 $CONFIG_CIPHERS
-	dep_tristate 'DFC cipher (EXPERIMENTAL)' CONFIG_CIPHER_DFC $CONFIG_CIPHERS
- 	dep_tristate 'IDEA cipher (EXPERIMENTAL)' CONFIG_CIPHER_IDEA $CONFIG_CIPHERS
-	dep_tristate 'MARS cipher (EXPERIMENTAL)' CONFIG_CIPHER_MARS $CONFIG_CIPHERS
-	dep_tristate 'RC5 cipher (EXPERIMENTAL)' CONFIG_CIPHER_RC5 $CONFIG_CIPHERS
-	dep_tristate 'RC6 cipher (EXPERIMENTAL)' CONFIG_CIPHER_RC6 $CONFIG_CIPHERS
 	dep_tristate 'AES cipher (EXPERIMENTAL)' CONFIG_CIPHER_AES $CONFIG_CIPHERS
 	if [ "$CONFIG_CIPHER_AES" != "n" ]; then
 		bool 'AES available under the Rijndael name' CONFIG_CIPHER_RIJNDAEL
         fi
+	comment 'AES Finalist Ciphers:'
+	dep_tristate 'Twofish cipher (EXPERIMENTAL)' CONFIG_CIPHER_TWOFISH $CONFIG_CIPHERS
+	dep_tristate 'MARS cipher (EXPERIMENTAL)' CONFIG_CIPHER_MARS $CONFIG_CIPHERS
+	dep_tristate 'RC6 cipher (EXPERIMENTAL)' CONFIG_CIPHER_RC6 $CONFIG_CIPHERS
 	dep_tristate 'Serpent cipher (EXPERIMENTAL)' CONFIG_CIPHER_SERPENT $CONFIG_CIPHERS
+	comment 'Other Ciphers submitted as AES Candidates:'
+	dep_tristate 'DFC cipher (EXPERIMENTAL)' CONFIG_CIPHER_DFC $CONFIG_CIPHERS
+	comment 'Other ciphers (64 bit blocksize)'
+	dep_tristate 'Blowfish cipher (EXPERIMENTAL)' CONFIG_CIPHER_BLOWFISH $CONFIG_CIPHERS
+ 	dep_tristate 'IDEA cipher (EXPERIMENTAL)' CONFIG_CIPHER_IDEA $CONFIG_CIPHERS
+	dep_tristate 'RC5 cipher (EXPERIMENTAL)' CONFIG_CIPHER_RC5 $CONFIG_CIPHERS
+ 	dep_tristate 'DES EDE3 cipher (3DES, EXPERIMENTAL)' CONFIG_CIPHER_DES_EDE3 $CONFIG_CIPHERS
+	dep_tristate 'DES cipher (DEPRECATED)' CONFIG_CIPHER_DES $CONFIG_CIPHERS
 fi
 dep_tristate 'Digest algorithms' CONFIG_DIGEST $CONFIG_CRYPTO
 if [ "$CONFIG_DIGEST" != "n" ]; then

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20001004205623</emailId><senderName>Marc Mutz</senderName><senderEmail>marc@mutz.com</senderEmail><timestampReceived>2000-10-04 20:56:23-0400</timestampReceived><subject>[Encryption-HOWTO] v0.2.2 released</subject><body>

ChangeLog:

- Small updates because of AES. 
- Encryption-HOWTO now on sourceforge.net 
- Updates to the Journalling Q. 
- Updates from Sandy Harris regarding FreeS/WAN.

Release Notes:

Maintainance version only. Needed because of the advent of AES in
kerneli-2.2.17.7.

Marc

-- 
Marc Mutz &lt;Marc@Mutz.com&gt;     http://EncryptionHOWTO.sourceforge.net/
University of Bielefeld, Dep. of Mathematics / Dep. of Physics

PGP-keyID's:   0xd46ce9ab (RSA), 0x7ae55b9e (DSS/DH)


Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001005135051</emailId><senderName>Marc Mutz</senderName><senderEmail>marc@mutz.com</senderEmail><timestampReceived>2000-10-05 13:50:51-0400</timestampReceived><subject>Re: [experimantal patch] show allowed keylengths in /proc/cipher/*</subject><body>

"Michael T. Babcock" wrote:
&gt; 
&lt;snip&gt;
&gt; 
&gt; I think it would be most beneficial here to definately consult with a real
&gt; cryptographer if 'we' want to know how to handle this correctly.  There may
&gt; or may not be a paper written somewhere on the issue too.
&gt; 
&lt;snip&gt;

You don't need a 'real' cryptographer (better. cryptanalyst or
cryptologist) to understand that Rijndael was defined for key lengths of
128 to 256 bits in steps of 32 bits. Look at it's structure and you'll
understand why. Twofish was defined for 128, 192 and 256 bits, but with
a description of how to handle key lengths that don't match the defined
ones.

The point here is that if you leave the path that the authors of the
algorithm have drawn or that is described in a standard somewhere,
you'll lose all cryptanalytic results obtained for that cipher. So you
should simply stay with the definition of the cipher.

The AES committee has refused to alter the definitions of the finalist
ciphers precisely because adding or subtracting rounds would invalidate
all or most of the cryptanalysis obtained in the review period. This was
although the common feeling after AES3 was that Rijndael should be
elected with added rounds.

Marc

-- 
Marc Mutz &lt;Marc@Mutz.com&gt;     http://EncryptionHOWTO.sourceforge.net/
University of Bielefeld, Dep. of Mathematics / Dep. of Physics

PGP-keyID's:   0xd46ce9ab (RSA), 0x7ae55b9e (DSS/DH)



Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001005161112</emailId><senderName>Marc Mutz</senderName><senderEmail>marc@mutz.com</senderEmail><timestampReceived>2000-10-05 16:11:12-0400</timestampReceived><subject>Re: Using kerneli w/o compiling a kernel?</subject><body>

Alexander S A Kjeldaas wrote:
&gt; 
&lt;snip&gt;
&gt; Try 2.2.17.8.pre2.  The /proc/cipher and /proc/digest entries were
&gt; switched.
&gt; 
&lt;snip&gt;

Now the ciphers show up in /proc/ciphers. But losetup or mount on my
blowfish fs gives me an invalid argument on the LOOP_SET_STATUS ioctl.

I wonder where this stems from. There are no changes in loop_gen.c or
loop.c that could do this, also the introduction of the keysize_mask
does not contribute because it is currently purely cosmetic.

On the other hand, the changes in cryptoapi.c are so complex that
looking at a unified diff makes one lose grip on the context, primarily
because I have not yet dug into this too deep.

LOOP_SET_STATUS can return EINVAL on:

loop.c:557:
if lo_encrypt_key_size &gt; LO_KEY_SIZE
loop.c:486:
if type &gt;= MAX_LO_CRYPT
and if xfer_funcs[type] is 0 and a module load fails.

also, if xfer-&gt;release(lo) or xfer-&gt;init(lo,i) return EINVAL.

loop_gen_release: always return 0;
loop_gen_init2: returns EINVAL if
	- find_cipher_by_id fails
	- ci-&gt;set_key() fails (i.e. does not return 0).

So I suspect the error to be in find_cipher_by_id(), which is now
defined a find_transform_by_id(id, TRANSFORM_CIPHER).

Here I don't understand why you treat tg different from the way you did
before. Prior, it was defined as a pointer to struct transform_group,
just like now. The difference being that it is now a local variable
where it was a function argument before.
Yet, you now write
Q&gt; read_lock(&amp;tg-&gt;tg_lock)
where you wrote
Q&gt; read_lock(tg-tg_lock)
before?

Marc

-- 
Marc Mutz &lt;Marc@Mutz.com&gt;     http://EncryptionHOWTO.sourceforge.net/
University of Bielefeld, Dep. of Mathematics / Dep. of Physics

PGP-keyID's:   0xd46ce9ab (RSA), 0x7ae55b9e (DSS/DH)


Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001006084807</emailId><senderName>Alexander S A Kjeldaas</senderName><senderEmail>alexander.kjeldaas@fast.no</senderEmail><timestampReceived>2000-10-06 08:48:07-0400</timestampReceived><subject>Re: fast encryption of large files with asymetric keys</subject><body>

On Thu, Oct 05, 2000 at 11:07:52PM +0200, Andreas Schuldei wrote:

&gt; Is there a program/lib/... for fast encryption of large files with
&gt; asymetric keys? gpg would do, but the minimal keylegth is 768 and
&gt; with that key it is to slow. In fact a much smaller key would
&gt; do. 60-200 Bits should be enough.
&gt; 
&gt; Is there such a beast? Where?
&gt; 
&gt; Please cc me, i am not on this list.
&gt; 

gpg encrypts your large file with a normal symetric cipher.  This
cipher is given a secret key, and this _key_ is encrypted using an
asymetric key.  So as the size of the file you encrypt with gpg
increases, the number of bits in your asymetric key becomes more and
more irrelevant, and the choice of cipher becomes your main concern.

astor

-- 
Alexander Kjeldaas                Mail:  astor@fast.no
finger astor@master.kernel.org for OpenPGP key.

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001006135215</emailId><senderName>Marc Mutz</senderName><senderEmail>marc@mutz.com</senderEmail><timestampReceived>2000-10-06 13:52:15-0400</timestampReceived><subject>Re: encrypting large files</subject><body>

Andreas Schuldei wrote:
&gt; 
&gt; I used ssh exactly in the (just now shown) insecure way: I transfered big files \
&gt; over an encrypted scp tunnel to my computer at home using cron. 
&gt; Now I need an other way to shovel my 20-30Mbyte per night over the net.
&gt; 
&lt;snip&gt;

Why not use the way that was proposed as the alternative:

ssh peer "tar cfz - files" &gt; files.tar.gz
tar tfz files.tar | grep for unusual files

if nothing is found, untar and rm the tar.gz file. Or use ssh2.

Marc

-- 
Marc Mutz &lt;Marc@Mutz.com&gt;     http://EncryptionHOWTO.sourceforge.net/
University of Bielefeld, Dep. of Mathematics / Dep. of Physics

PGP-keyID's:   0xd46ce9ab (RSA), 0x7ae55b9e (DSS/DH)


Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20001006140612</emailId><senderName>Alexander S A Kjeldaas</senderName><senderEmail>alexander.kjeldaas@fast.no</senderEmail><timestampReceived>2000-10-06 14:06:12-0400</timestampReceived><subject>Re: Q: Can in and out buffers of xxx_encrypt() be the same?</subject><body>

On Fri, Oct 06, 2000 at 01:03:41PM +0000, Marc Mutz wrote:
&gt; Hi!
&gt; 
&gt; We should clarify the issues:
&gt; 
&gt; Must cipher implementations
&gt; 
&gt; 1) expect that *in and *out may be the same buffer?

Yes I think they should.

I can think of some ciphers where being able to use the output buffer
as temporary space might be practical.  For example a bitslice
implementation of 3des which wants to transpose a 64x32 bit matrix
needs a temporary storage area.  Creating a 256 byte array on the
stack might be questionable, but the memory could also be put at the
end of the key_schedule, so this could be worked around.

&gt; 2) use no additional memory for operation after set_key() is called?
&gt; 

I think they should not.

&gt; Point (1) is not that terribly importatnt. It's just that such things
&gt; should be defined somewhere.
&gt; 

Agreed. 

&gt; ad (2): I'm particularly thinking of encrypting swap here. There was a
&gt; thread[1] about this about a year ago or so on lkml where it was said
&gt; that it was necessary that encrypt() and decrypt() don't use additional
&gt; memory for their run.

If the kernel is low on memory and wants to swap something out, the
subsystem responsible for that (including the crypto API used in the
loopback system) can not allocate memory.  I do not know of any cipher
that does, so this should not be an issue.  I think the issue of using
loopback for swap lies outside of the crypto API.

&gt; However, whether this includes local variables placed on the stack I
&gt; don't know. Maybe there is a limitation on the overall size of local
&gt; variables so that it is not neccessay to claim a new page for the stack.
&gt; 

It does not include local variables.  There is an upper bound on the
stack space that can be used in the kernel for a process, and that is
sizeof(PAGE)-sizeof(task_struct) on most architectures AFAIK.  This
memory is allocated during fork().  Exceeding that stack-space is
considered a bug in the kernel, so you have to be careful about
recursion and having large objects on the stack.


astor

-- 
Alexander Kjeldaas                Mail:  astor@fast.no
finger astor@master.kernel.org for OpenPGP key.

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001007000627</emailId><senderName>Marc Mutz</senderName><senderEmail>marc@mutz.com</senderEmail><timestampReceived>2000-10-07 00:06:27-0400</timestampReceived><subject>Re: linux-ipsec: freeswan .... using OpenSSL ?</subject><body>

Sandy Harris wrote:
&gt; 
&lt;snip&gt;
&gt; &gt; &gt;         SHA HMAC (initialise with secret key material)
&gt; &gt;
&gt; &gt; probably trivial to add.
&gt; &gt;
&lt;snip&gt;
&gt; 
&gt; Packet authentication is done with the HMAC. This is an SHA or MD5 hash of
&gt; the packet data, except with the registers in the hashing code initialised
&gt; from the HMAC key rather than from standard constants.

I've read both rfc2104 and pluto/crypto.c. Looking at crypto.c:hmac_*()
I reckon you use HMAC in the mode

           H(K XOR opad, H(K XOR ipad, text))

therefore requiring no chosen-IV for the hash, no?

So either this could be added to the CryptoAPI or implemented as it is
now inside freeswan.

Alex Kjeldaas - if I understood him correctly - has a long-term goal of
being able to combine several cryptographic primitives to new ones at
runtime. 

&gt; It therefore does
&gt; more than a simple hash would, authenticating not just that the packet data
&gt; was not changed in transit but also that the sender knew the HMAC key.
&lt;snip&gt;

Marc

-- 
Marc Mutz &lt;Marc@Mutz.com&gt;     http://EncryptionHOWTO.sourceforge.net/
University of Bielefeld, Dep. of Mathematics / Dep. of Physics

PGP-keyID's:   0xd46ce9ab (RSA), 0x7ae55b9e (DSS/DH)


Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001010104803</emailId><senderName>Terrapin Station</senderName><senderEmail>sclam@singnet.com.sg</senderEmail><timestampReceived>2000-10-10 10:48:03-0400</timestampReceived><subject>Secure File System</subject><body>

Hello everyone,

    Eh...I'm quite new to this list and towards this subject. First
question I'd like to ask is:

    Has anyone here tried out the "Secure File System" created by Michal
Svec and Vaclav Petricek? I know are quite a few file crypto system
called "SFS" but this is the one found at this website:

    http://atrey.karlin.mff.cuni.cz/~rebel/sfs/

    Any comments?

    I managed to compile and got it to run (on kernel 2.0.x). I was able
to read an encrypted file with "cat" or "less" but wasn't able to edit
it using "vi". Actually, I can't save what I have edited.

    Has anyone encountered this problem before?

Thanks




Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001013224236</emailId><senderName>Marc Mutz</senderName><senderEmail>marc@mutz.com</senderEmail><timestampReceived>2000-10-13 22:42:36-0400</timestampReceived><subject>Re: A patch to loop.c for better cryption support</subject><body>

kernel wrote:
&gt; 
&lt;snip&gt;
&gt; 
&gt; Caution is advised when depending upon crypto systems that use relative
&gt; block numbers as IV.  The security may not be a strong as hoped.
&gt; There are some who believe that "not unique" IVs (across multiple
&gt; filesystems) facilitates some methods of cryptanalysis.
&gt; 
Do you have a paper reference? I know that there are issues when using
sequence numbers as IVs for CBC, but that is an isolated problem for
CBC-like modes.

&gt; Strong security is the reason absolute block numbers were chosen at
&gt; the time I introduced loop.c cipher-block-chaining support (in
&gt; kernel 2.1.130).  This has the unfortunate side effect of preventing
&gt; filesystem relocation... leading some to claim that loop.c is now
&gt; broken.  A crypto system is only as strong as its weakest link.
&gt; 

Perhaps we should make Counter mode available for loop_gen.c. It does
not have the artifacts that CBC has when seqence numbers are used as
IVs. On the contrary: sequential IVs are an integral part of CTR mode
encryption. This mode is not only just as secure as CBC, but has also
the added bonus of only requiring encryption, something the AES would
benfit from immensely, since decryption is so much slower for Rijndael
than encryption and reads (decryption) are typically used more often in
a filesystem than writes (encryption).

&gt; Perhaps losetup can allow the user to specify a "IVseed" value
&gt; and then pass to the transfer modules IVseed + relative block.
&gt; This would also allow existing absolute block based encrypted file
&gt; systems to be relocated (IVseed = absolute # of 1st block),
&lt;interrupted&gt;

Hm, I don't get you here. If I was to use absolute block numbers as IVs
on a 1k block size ext2 filesystem, I could theoretically end up with
the following mapping of loop device blocks vs. ext2 blocks

Q&gt; loop:	0	1	2	3	4	5
Q&gt; ext2:	12	13	14	22	23	24

If I used IVseed = 12 here, the first three blocks would decrypt
correctly, yet the forth would decrypt to white noise.

&gt; satisfy
&gt; those among us who demand unique IVs, and allow those who prefer
&gt; operational convenience at the cost of weaker security to do so.
&gt; 

As CTR mode _requires_ unique IVs (CBC does not), the upper half of the
IV could be initialized from the key, whose length would thus grow by
50%. The lower half would contain the relative block number in units of
512 bytes.

&gt; Reed H. Petty
&gt; rhp@draper.net

Marc

-- 
Marc Mutz &lt;Marc@Mutz.com&gt;     http://EncryptionHOWTO.sourceforge.net/
University of Bielefeld, Dep. of Mathematics / Dep. of Physics

PGP-keyID's:   0xd46ce9ab (RSA), 0x7ae55b9e (DSS/DH)


Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001016125027</emailId><senderName>Marc Mutz</senderName><senderEmail>marc@mutz.com</senderEmail><timestampReceived>2000-10-16 12:50:27-0400</timestampReceived><subject>[Fwd: 2.2.17.8]</subject><body>

Marc Mutz wrote:
&gt; 
&gt; Alexander S A Kjeldaas wrote:
&gt; &gt;
&gt; &lt;snip&gt;
&gt; &gt; It was an unused code-path in loop_gen.c that was triggered by the
&gt; &gt; changes in 2.2.17.8.  A magic block-size of 0 no longer indicates that
&gt; &gt; a cipher supports encrypting variable-length blocks.  I think the
&gt; &gt; following patch should fix the problem:
&gt; &lt;snip&gt;
&gt; 
&gt; Yes, it did!
&gt; 
&gt; Marc
&gt; 
&gt; --
&gt; Marc Mutz &lt;Marc@Mutz.com&gt;     http://EncryptionHOWTO.sourceforge.net/
&gt; University of Bielefeld, Dep. of Mathematics / Dep. of Physics
&gt; 
&gt; PGP-keyID's:   0xd46ce9ab (RSA), 0x7ae55b9e (DSS/DH)

-- 
Marc Mutz &lt;Marc@Mutz.com&gt;     http://EncryptionHOWTO.sourceforge.net/
University of Bielefeld, Dep. of Mathematics / Dep. of Physics

PGP-keyID's:   0xd46ce9ab (RSA), 0x7ae55b9e (DSS/DH)


Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001016132139</emailId><senderName>Alexander S A Kjeldaas</senderName><senderEmail>alexander.kjeldaas@fast.no</senderEmail><timestampReceived>2000-10-16 13:21:39-0400</timestampReceived><subject>Re: 2.2.17.8</subject><body>

On Mon, Oct 16, 2000 at 03:02:35PM +0200, Gisle S{lensminde wrote:
&gt; 
&gt; When compiling the tests in the linux/crypto/testing directory, I
&gt; got a compile error for the tests. The symbol 'schedule' was missing
&gt; for several of the ciphers (maybe all), so I got a linker error.
&gt; The kernel itself on the other hand, linked fine.
&gt; 


Argh.. it is the 

if (current-&gt;need_resched)
    schedule();

in gen-cbc.h and gen-ecb.h.  Added in 2.2.17.8.  We need this to avoid
the loopback filesystem to end up on top of the latency-tests. As a
start we need a stub for schedule().  

The bad news is "current".  It is a magic variable that lies at the
start of the stack-pointer, so on i386 it is derived from %esp.  So
current-&gt;need_resched is peeking at places it shouldn't :-(.

The good news is that accessing "current" won't cause a segfault when
the stack starts on a page boundary.  And since our stub for
schedule() is a nop, it will run correctly no matter what
current-&gt;need_resched turns out to be :-)

So the following patch should fix the problem:

--- i17xx/crypto/testing/stubs.c        Mon Oct 16 15:20:25 2000
+++ i17x.nomodule/crypto/testing/stubs.c        Mon Oct 16 15:17:04 2000
@@ -36,3 +36,9 @@
        return (int) name;
 }
 
+asmlinkage void schedule(void)
+{
+}
+
+
+


astor

-- 
Alexander Kjeldaas                Mail:  astor@fast.no
finger astor@master.kernel.org for OpenPGP key.

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001018093801</emailId><senderName>Alexander S A Kjeldaas</senderName><senderEmail>alexander.kjeldaas@fast.no</senderEmail><timestampReceived>2000-10-18 09:38:01-0400</timestampReceived><subject>Re: 2.2.17.10</subject><body>

On Tue, Oct 17, 2000 at 10:37:46PM +0000, Marc Mutz wrote:
&gt; Marc Mutz wrote:
&gt; &gt; 
&gt; &lt;snip&gt;
&gt; &gt; &gt; ftp.kernel.org/pub/linux/kernel/crypto/v2.2/patch-int-2.2.17.10.gz
&gt; &gt; &gt;
&gt; &gt; &lt;snip&gt;
&gt; &gt; 
&gt; &gt; Not there a of now. Not on ftp.kernel.org, nor on ftp.de.kernel.org?
&gt; &gt; 
&gt; Sorry, the .gz is there, I've been doing ls *.bz2 and they were not
&gt; there.


They have been changing machines at kernel.org.  That might have
caused the lack of a .bz2 file.

astor

-- 
Alexander Kjeldaas                Mail:  astor@fast.no
finger astor@master.kernel.org for OpenPGP key.

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001018123108</emailId><senderName>Marc Mutz</senderName><senderEmail>marc@mutz.com</senderEmail><timestampReceived>2000-10-18 12:31:08-0400</timestampReceived><subject>[PATCH] step 2 of the config.h cleanup: context sizes,</subject><body>

Hi!

This patch is a superset of config_h-cleanup-2.2.17.8. It does:

o Remove the declarations for encrypt/decrypt/set_key routines from 
  include/linux/crypto.h. Dto. for the digest functions.
o Remove the #define'f of *_SCHEDULE_KEY_SIZE from
  include/linux/crypto.h. Used sizeof(...) where cx-&gt;keyinfo is a
  pointer to "...".
o Change CIPHER_CBC to CIPHER_MODE_CBC and fixes all occurences.
o Add CIPHER_MODE_ECB and CIPHER_MODE_CTR (the latter being not
  implemented yet). Make the implicit OR with 0x0 for ECB mode
  explicit.
o Ciphers now appear as cipher-ecb and cipher-cbc in
  /proc/crypto/cipher. Previously, "cipher-ecb" read only "cipher".
o Reserves the high-order 16 bits of cipher-id's for the mode used.
  Only affects the module request in crypto/cryptoapi.c

All of this has been tested to compile as modules and blowfish has been
tested to load, register and to not break my crypted fs.

Marc

BTW: Why don't rijndael.c and rc62.c include gen-ecb.h? I made them.
Please check these changes carefully.

-- 
Marc Mutz &lt;Marc@Mutz.com&gt;     http://EncryptionHOWTO.sourceforge.net/
University of Bielefeld, Dep. of Mathematics / Dep. of Physics

PGP-keyID's:   0xd46ce9ab (RSA), 0x7ae55b9e (DSS/DH)

["step-2-crypto_h-cleanup-2.2.17.10.patch.bz2" (application/octet-stream)]
Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20001021183753</emailId><senderName>Alexander S A Kjeldaas</senderName><senderEmail>alexander.kjeldaas@fast.no</senderEmail><timestampReceived>2000-10-21 18:37:53-0400</timestampReceived><subject>Re: [PATCH] clean up include/linux/crypto.h and [RFC] API changes</subject><body>

On Wed, Oct 18, 2000 at 01:58:18PM +0000, Marc Mutz wrote:
&gt; Alexander S A Kjeldaas wrote:
&gt; &gt; 
&gt; &lt;snip&gt; 
&gt; &gt; Although I think using separate header files is ok, I do not see an
&gt; &gt; advantage in this case.  Why optimize on an extremely remotely
&gt; &gt; probable case - that the following happens:
&gt; &gt; 
&gt; 
&gt; It's not for optimizing something, except the case of readable code.
&gt; There's a lot of redundancy in the source as is and that is bad for
&gt; maintainability. We already have a dozen ciphers and two hash functions
&gt; in the API, adding RIPEMD, Tiger and SHA-256, -384 and -512 is just a
&gt; matter of time. I just experienced what is takes to go through all
&gt; cipher files by hand and changing similar things in each of them. Ugh.
&gt; Don't want to do that for 20 ciphers and 10 digests.
&gt; 

Ok then.. let's remove the defines and wait with adding separate
headers until someone wants them.

astor

-- 
Alexander Kjeldaas                Mail:  astor@fast.no
finger astor@master.kernel.org for OpenPGP key.

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001024185302</emailId><senderName>Michael Peddemors</senderName><senderEmail>michael@linuxmagic.com</senderEmail><timestampReceived>2000-10-24 18:53:02-0400</timestampReceived><subject>Re: Problem booting kernel.</subject><body>

And although this is a litle off-topic for this channel, make sure that you 
have the correct architecture specified.. most common reason I see for that 
error.. compiling for a Pentium Pro and running it on something less...

On Tue, 24 Oct 2000, Marc Mutz wrote:
&gt; Pierre PEIFFER wrote:
&gt; &gt; Hello everybody,
&gt; &gt;
&gt; &gt;     I'm a newby and I'm trying to test encrypted loobpack file. So I
&gt; &gt; have to apply a patch to my kernel.
&gt;
&gt; &lt;snip&gt;
&gt;
&gt; &gt; "Uncompressing Linux... Ok, booting the kernel."
&gt; &gt;
&gt; &gt; But nothing else, my kernel doesn't boot. As far I'm, I've not read
&gt; &gt; something about such a problem and have no idea. So, do you see
&gt; &gt; something wrong somewhere ? It will be very great if somebody could just
&gt; &gt; help me to have a booting kernel.... Thank you very much.
&gt;
&gt; &lt;snip&gt;
&gt;
&gt; Is this the first time you compile a custom kernel?
&gt; It looks to me that you just added the options for the crypto stuff but
&gt; did not go through all the other options that need to be adjusted to fit
&gt; your box. The vanilla kernel tarball is not configured by any means. You
&gt; have to go through all menus and select what you need. Or copy a working
&gt; ..config into the main directory and run make oldconfig. See the
&gt; Kernel-HOWTO for more.
&gt;
&gt; If that is not the case and you successfully compiled kernels before,
&gt; then it might be a good idea to tell us the exact commands you used and
&gt; actions you did so we have a clue of where things could have gone wrong.
&gt;
&gt; Marc

-- 
--------------------------------------------------------
Michael Peddemors - Senior Consultant
Unix Administration - WebSite Hosting
Network Services - Programming
Wizard Internet Services http://www.wizard.ca
Linux Support Specialist - http://www.linuxmagic.com
--------------------------------------------------------
(604) 589-0037 Beautiful British Columbia, Canada
--------------------------------------------------------

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001027183148</emailId><senderName>William Ahern</senderName><senderEmail>wahern@25thandclement.com</senderEmail><timestampReceived>2000-10-27 18:31:48-0400</timestampReceived><subject>Re: Int Crypto Patch and FreeS/Wan</subject><body>

On Friday 27 October 2000 00:56, you wrote:
&gt; On Thu, 26 Oct 2000, William Ahern wrote:
&gt; &gt; I have the 2.2.17 kernel, 2.2.17.9 international kernel patch and
&gt; &gt; frees/wan 1.6. any tips on how to get it to compile? DES, MD5 and SHA1
&gt; &gt; routines seems to be conflicting. everything compiles fine until it hits
&gt; &gt; these....
&gt; &gt;
&gt; &gt; i ran the freeswan-import script.... no beans....
&gt;
&gt; Could you please tell which symboles that are conflicting. It
&gt; would make it easier to find the problem and/or fix problems
&gt; in kerneli.

I've compiled w/ freeswan and the crypto patch, seperately. freeswan won't 
patch w/ the crypto patch already in, but the crypto patch will take after 
the freeswan patch. here are the compile errors:

cc -D__KERNEL__ -I/usr/src/kernel-source-2.2.17/include -E -C -P 
-I/usr/src/kernel-source-2.2.17/include -imacros 
/usr/src/kernel-source-2.2.17/include/asm-i386/page_offset.h -Ui386 
arch/i386/vmlinux.lds.S &gt;arch/i386/vmlinux.lds
ld -m elf_i386 -T /usr/src/kernel-source-2.2.17/arch/i386/vmlinux.lds -e 
stext arch/i386/kernel/head.o arch/i386/kernel/init_task.o init/main.o 
init/version.o \        --start-group \
        arch/i386/kernel/kernel.o arch/i386/mm/mm.o kernel/kernel.o mm/mm.o 
fs/fs.o ipc/ipc.o \
        fs/filesystems.a \
        net/network.a \
        crypto/crypto.a drivers/block/block.a drivers/char/char.a 
drivers/misc/misc.a drivers/net/net.a drivers/scsi/scsi.a 
drivers/cdrom/cdrom.a drivers/sound/sound.a drivers/pci/pci.a 
drivers/pnp/pnp.a drivers/video/video.a \
        /usr/src/kernel-source-2.2.17/arch/i386/lib/lib.a 
/usr/src/kernel-source-2.2.17/lib/lib.a 
/usr/src/kernel-source-2.2.17/arch/i386/lib/lib.a \
        --end-group \
        -o vmlinux
crypto/crypto.a(des.o): In function `des_set_key':
des.o(.text+0x0): multiple definition of `des_set_key'
net/network.a(ipsec.o):/usr/src/kernel-source-2.2.17/net/ipsec/libdes/set_key.c:163: 
first defined here
ld: Warning: size of symbol `des_set_key' changed from 629 to 1184 in des.o
crypto/crypto.a(des.o): In function `des_encrypt':
des.o(.text+0x1750): multiple definition of `des_encrypt'
net/network.a(ipsec.o):/usr/src/kernel-source-2.2.17/net/ipsec/ipsec_sha1.c:165: 
first defined here
ld: Warning: size of symbol `des_encrypt' changed from 4157 to 104 in des.o
crypto/crypto.a(des.o): In function `des_ecb_encrypt':
des.o(.text+0x19d0): multiple definition of `des_ecb_encrypt'
net/network.a(ipsec.o):/usr/src/kernel-source-2.2.17/net/ipsec/libdes/ecb_enc.c:114: 
first defined here
ld: Warning: size of symbol `des_ecb_encrypt' changed from 186 to 143 in des.o
crypto/crypto.a(des_ede3.o): In function `des_ede3_cbc_encrypt':
des_ede3.o(.text+0x19f0): multiple definition of `des_ede3_cbc_encrypt'
net/network.a(ipsec.o):/usr/src/kernel-source-2.2.17/net/ipsec/ipsec_sha1.c:165: 
first defined here
ld: Warning: size of symbol `des_ede3_cbc_encrypt' changed from 480 to 226 in 
des_ede3.o
crypto/crypto.a(md5glue.o): In function `MD5Init':
md5glue.o(.text+0x0): multiple definition of `MD5Init'
net/network.a(ipsec.o):/usr/src/kernel-source-2.2.17/net/ipsec/ipsec_md5c.c:148: 
first defined here
crypto/crypto.a(md5glue.o): In function `MD5Update':
md5glue.o(.text+0x30): multiple definition of `MD5Update'
net/network.a(ipsec.o):/usr/src/kernel-source-2.2.17/net/ipsec/ipsec_md5c.c:166: 
first defined here
crypto/crypto.a(md5glue.o): In function `MD5Final':
md5glue.o(.text+0xf8): multiple definition of `MD5Final'
net/network.a(ipsec.o):/usr/src/kernel-source-2.2.17/net/ipsec/ipsec_md5c.c:208: 
first defined here
ld: Warning: size of symbol `MD5Final' changed from 120 to 122 in md5glue.o
crypto/crypto.a(sha1glue.o): In function `SHA1Transform':
sha1glue.o(.text+0x0): multiple definition of `SHA1Transform'
net/network.a(ipsec.o):/usr/src/linux/include/asm/string.h:285: first defined 
here
crypto/crypto.a(sha1glue.o): In function `SHA1Init':
sha1glue.o(.text+0x1e24): multiple definition of `SHA1Init'
net/network.a(ipsec.o):/usr/src/kernel-source-2.2.17/net/ipsec/ipsec_sha1.c:101: 
first defined here
crypto/crypto.a(sha1glue.o): In function `SHA1Update':
sha1glue.o(.text+0x1e5c): multiple definition of `SHA1Update'
net/network.a(ipsec.o):/usr/src/kernel-source-2.2.17/net/ipsec/ipsec_sha1.c:115: 
first defined here
ld: Warning: size of symbol `SHA1Update' changed from 216 to 224 in sha1glue.o
crypto/crypto.a(sha1glue.o): In function `SHA1Final':
sha1glue.o(.text+0x1f3c): multiple definition of `SHA1Final'
net/network.a(ipsec.o):/usr/src/kernel-source-2.2.17/net/ipsec/ipsec_sha1.c:143: 
first defined here
make: *** [vmlinux] Error 1

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20001031091828</emailId><senderName>Marc Mutz</senderName><senderEmail>marc@mutz.com</senderEmail><timestampReceived>2000-10-31 09:18:28-0400</timestampReceived><subject>Re: encrypting large files - revisited</subject><body>

Doug VanLeuven wrote:
&gt; 
&gt; Would someone please point me to the original thread on this?
&gt; I use tar across ssh &amp; would like to know what the problem
&gt; with this is, but I can't locate the original discussion
&gt; in the archive.
&gt; 
&lt;snip&gt;

http://lwn.net/2000/1005/security.php3#ssh

Marc

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20000928011521</emailId><senderName>Richard Guy Briggs</senderName><senderEmail>rgb@conscoop.ottawa.on.ca</senderEmail><timestampReceived>2000-09-28 01:15:21-0400</timestampReceived><subject>Re: Hardware crypto</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----

On Wed, Sep 27, 2000 at 11:25:32PM +0200, Alexander S A Kjeldaas wrote:
&gt; On Wed, Sep 27, 2000 at 12:17:17PM -0400, Richard Guy Briggs wrote:
&gt; &gt; On Wed, Sep 27, 2000 at 05:52:04PM +0200, Alexander S A Kjeldaas wrote:
&gt; &gt; &gt; I think there are some interesting issues to be solved when we want to
&gt; &gt; &gt; get hardware crypto cards running under Linux.  For one, we want to
&gt; &gt; &gt; have a queue of processing requests for the device instead of having a
&gt; &gt; &gt; synchronous interface like most crypto libraries offer.  We also
&gt; &gt; &gt; probably want to use the CPU if the queue starts to have too many
&gt; &gt; &gt; entries, or load-balance between several cards, so we need a
&gt; &gt; &gt; "crypto-provider" concept.  Also, for programmable crypto-cards we
&gt; &gt; &gt; might want to consider the cost of switching ciphers on the card when
&gt; &gt; &gt; choosing which requests should be done by which cards/CPU.  This will
&gt; &gt; &gt; be interesting to look at when the first drivers emerge.
&gt; &gt; 
&gt; &gt; I completely agree that it should be queue-based.  SMP is the other
&gt; &gt; obvious reason for a queue.
&gt; &gt; 
&gt; &gt; Alan Cox has publicly stated that he thinks this is the right way to
&gt; &gt; do things, but at the moment, asynchrony and queues for this type of
&gt; &gt; processing will be a big challenge to accomplish this in the present
&gt; &gt; Linux kernels.  
&gt; 
&gt; Could you expand on some of the issues?  Are the problems related to
&gt; where you are allowed to sleep in the tcp/ip stack?  The part of
&gt; creating the async crypto API seems doable.

I don't know, I would have to check back with Alan on this one...

&gt; astor
&gt; 
&gt; -- 
&gt; Alexander Kjeldaas                Mail:  astor@fast.no
&gt; finger astor@master.kernel.org for OpenPGP key.
&gt; 
&gt; Linux-crypto:  cryptography in and on the Linux system
&gt; Archive:       http://mail.nl.linux.org/linux-crypto/

	slainte mhath, RGB
- -- 
Richard Guy Briggs -- PGP key available            Auto-Free Ottawa! Canada
&lt;www.conscoop.ottawa.on.ca/rgb/&gt;                       &lt;www.flora.org/afo/&gt;
Prevent Internet Wiretapping!        --        FreeS/WAN:&lt;www.freeswan.org&gt;
Thanks for voting Green! -- &lt;green.ca&gt;      Marillion:&lt;www.marillion.co.uk&gt;

-----BEGIN PGP SIGNATURE-----
Version: 2.6.3i
Charset: noconv

iQCVAwUBOdKbp9+sBuIhFagtAQH+NQP/e4Kt2jpy4kEu0gTlUhryCbgtZ7srcZdY
awY4kbGSV+qUYtm8+zP3txLZq2VgFdwxyjEUC0QU4quTaJhITdoBDc3A3ECoQqJU
9KP+lI8RIhM0N8be+qvcH6nCreHHy8xiTEkF8+Cd7lSRk4+GuRM/AQqW8xUBwG3e
Mnw/8jB9MRA=
=JFUs
-----END PGP SIGNATURE-----

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20000928084110</emailId><senderName>Alexander S A Kjeldaas</senderName><senderEmail>alexander.kjeldaas@fast.no</senderEmail><timestampReceived>2000-09-28 08:41:10-0400</timestampReceived><subject>2.2.17.6</subject><body>

ChangeLog:

	* International kernel patch 2.2.17.6 released.

	* Twofish implementation added. Patch from Marc Mutz
	&lt;marc@mutz.com&gt;.

	* loop_gen.c cleanups + plugged memory leak by Marc Mutz
	&lt;marc@mutz.com&gt;.

	* Configure.help updates. Patch from Marc Mutz &lt;marc@mutz.com&gt;

	* New script crypto/testing/aes-test from Marc Mutz tests ciphers
	based on the known-answer test values in NIST format.

	* crypto/testing/speed.c used weak DES-keys for speed-testing. 
	Fixed by patch from Gisle Sælensminde &lt;gisle@ii.uib.no&gt;.


astor

-- 
Alexander Kjeldaas                Mail:  astor@fast.no
finger astor@master.kernel.org for OpenPGP key.

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20000928130305</emailId><senderName>Marc Mutz</senderName><senderEmail>marc@mutz.com</senderEmail><timestampReceived>2000-09-28 13:03:05-0400</timestampReceived><subject>Re: lista</subject><body>

David Ford wrote:
&gt; 
&gt; Netscape sent it multipart because he chose both text and html for the
&gt; message.  The message was sent as both text and html.  This allows for the
&gt; reader to choose plain or 'enriched' viewing.  This is having it both
&gt; ways.  People who gripe about enriched content can read the plain text.
&gt; People who want the markup can view it as well.
&gt; 
Have you had a look at the message? Did it include rich text formatting
and if it does, did it need to? No. It was a plain, simple message. The
vast majority of them are. And netscape contains a configuration option
to only send html mails when there actually _is_ rich content.

&gt; It's a configuration choice issue.  What you viewed was his entire
&gt; message, regardless of whether your reader displayed it in text or html.
&gt; I also use NS messenger as one of my preferred readers and I'm able to
&gt; view his message perfectly.
&lt;snip&gt;

Can you show me where this option is?

Marc

-- 
Marc Mutz &lt;Marc@Mutz.com&gt;        http://marc.mutz.com/Encryption-HOWTO/
University of Bielefeld, Dep. of Mathematics / Dep. of Physics

PGP-keyID's:   0xd46ce9ab (RSA), 0x7ae55b9e (DSS/DH)



Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20000928155613</emailId><senderName>Gisle S{lensminde</senderName><senderEmail>gisle@ii.uib.no</senderEmail><timestampReceived>2000-09-28 15:56:13-0400</timestampReceived><subject>Assembly implementation for the linux kryptoapi.</subject><body>


I'm looking a bit on the posibility to make assembly versions of
some of the cipers (3DES, the AES candidates), but before I do 
a major effort on this area, do anyone know about implementations
that is GPL-compatible, or written by people that is willing to 
realese the code as such. 

As a note, I copied the assembly implementation of blowfish from cipe into
the crypto API. To my surprise, the it showed not to be any faster than
the existion C implementation. I also tried some tricks to get it faster,
but it did not help. I have not tried the IDEA implementation.




--
Gisle Sælensminde ( gisle@ii.uib.no )   

With sufficient thrust, pigs fly just fine. However, this is not
necessarily a good idea. It is hard to be sure where they are going
to land, and it could be dangerous sitting under them as they fly
overhead. (from RFC 1925)




Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20000928220103</emailId><senderName>Marc Mutz</senderName><senderEmail>marc@mutz.com</senderEmail><timestampReceived>2000-09-28 22:01:03-0400</timestampReceived><subject>[Encryption-HOWTO] v0.2.1 released</subject><body>

ChangeLog:

Small updates all over the place (IKP 2.2.17.6 now on kernel.org,
	CIPE4Win, linux-crypto ml, remount loop bug, --passfd for
	losetup and mount, FreeS/WAN 1.5, OpenSSH instead of SSH); 
Small additions all over the place (VTUN, PPTP, Cipe+Masquerading
	miniHOWTO, Credits);
Debian issues when compiling util-linux; 
A new question for Q&amp;A: journaling filesystems (no "A" yet); 

Release Notes:
This version is a maintainance release only. It updates a bunch of small
things, nothing big, and adds another bunch. I have tried to incorporate
as many suggestions as possible without changing the document too much.
In the light of the massive publicity the Encrytion HOWTO has attracted
for the last two days, I wanted to update the discussion to the most
recent stuff. See ChangeLog for more.

Enjoy!

Marc

-- 
Marc Mutz &lt;Marc@Mutz.com&gt;        http://marc.mutz.com/Encryption-HOWTO/
University of Bielefeld, Dep. of Mathematics / Dep. of Physics

PGP-keyID's:   0xd46ce9ab (RSA), 0x7ae55b9e (DSS/DH)

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email><email><emailId>20000929151327</emailId><senderName>Marc Mutz</senderName><senderEmail>marc@mutz.com</senderEmail><timestampReceived>2000-09-29 15:13:27-0400</timestampReceived><subject>[experimantal patch] show allowed keylengths in /proc/cipher/*</subject><body>

Hi out there!

This little patch allows /proc/cipher/* to show a bitmask of allowed
keysizes. Simple as it may ssem, it breaks the current jungle of
#define's quite thoroughly. Ciphers that want to take advantage of this
patch and actually _provide_ more than one keylength per cipher
implementation (and most ciphers could), will not be able to use the
DEFINE_CIPHER construct any more.

So what now? I'd like to remove the DEFINE_CIPHER construct althogether.
It makes defining "dumb" ciphers easy, but it obfuscates the definition
of a cipher for unexperienced (w.r.t. cipherapi) coders and interested
eyes that read the source, since the meaning of the numbers and strings
appearing in DEFINE_CIPHER is not obvious. Even when you have read over
a few cipher sources you catch yourself going back to
include/linux/crypto.h to look up what each entry means.

On the opposite, having the struct cipher_implementation populated
without the help of macros goes a long way towards transparency, because
the field identifiers show up alongside their values. Or not?

Now my inexprience with C comes up again: Is there a C construct that
shows the field identifiers even in static const definitions? Like in
perl:

%an_associative_array = {
	field1 -&gt; value1,
	field2 -&gt; value2,
	 :          :
}

Is there a C reference online somewhere to install locally, e.g. in
html?

Marc

-- 
Marc Mutz &lt;Marc@Mutz.com&gt;        http://marc.mutz.com/Encryption-HOWTO/
University of Bielefeld, Dep. of Mathematics / Dep. of Physics

PGP-keyID's:   0xd46ce9ab (RSA), 0x7ae55b9e (DSS/DH)

["proc_shows_keysizes.patch;" (text/plain)]

--- i6/crypto/cryptoapi.c	Thu Sep 28 16:29:13 2000
+++ i6-raidA0-raid1rb15.B2-ext0.0.3a/crypto/cryptoapi.c	Fri Sep 29 16:11:52 2000
@@ -218,10 +218,11 @@
 	len = sprintf(page, "cipher_id:         %d\n"
 		      "cipher_name:       %s\n"
 		      "blocksize:         %d\n"
+		      "keysize_mask:      0x%08x\n"
 		      "ivsize:            %d\n"
 		      "key_schedule_size: %d\n",
 		      ci-&gt;trans.t_id, ci-&gt;trans.t_name, 
-		      ci-&gt;blocksize,
+		      ci-&gt;blocksize, ci-&gt;key_size_mask,
 		      ci-&gt;ivsize, ci-&gt;key_schedule_size);
 	*eof=1;
 
--- i6/include/linux/crypto.h	Thu Sep 28 16:29:14 2000
+++ i6-raidA0-raid1rb15.B2-ext0.0.3a/include/linux/crypto.h	Fri Sep 29 16:19:48 2000
@@ -51,6 +51,23 @@
 #define CIPHER_cbc_DFC      (CIPHER_DFC      | CIPHER_CBC)
 #define CIPHER_cbc_RIJNDAEL (CIPHER_RIJNDAEL | CIPHER_CBC)
 
+
+#define CIPHER_KEYSIZE_ANY  0xFFFFFFFF
+#define CIPHER_KEYSIZE_NONE 0x00000000
+
+#define CIPHER_KEYSIZE_40   0x00000010
+#define CIPHER_KEYSIZE_56   0x00000040
+#define CIPHER_KEYSIZE_64   0x00000080
+#define CIPHER_KEYSIZE_80   0x00000200
+#define CIPHER_KEYSIZE_96   0x00000800
+#define CIPHER_KEYSIZE_112  0x00002000
+#define CIPHER_KEYSIZE_128  0x00008000
+#define CIPHER_KEYSIZE_160  0x00080000
+#define CIPHER_KEYSIZE_168  0x00100000
+#define CIPHER_KEYSIZE_192  0x00800000
+#define CIPHER_KEYSIZE_256  0x80000000
+
+
 #define DIGEST_NONE        0
 #define DIGEST_SUM         1
 #define DIGEST_CRC_CCITT16 2
@@ -94,7 +113,7 @@
	int blocksize;         /* in bytes */
	int ivsize;            /* in bytes */
	int key_schedule_size; /* in bytes */
+	u32 key_length_list;   /* bit 0 set = 8 bit, ... , bit 31 set = 256 bit */
	int (*encrypt)(struct cipher_context *cx, 
		       const u8 *in, u8 *out, int size);
	int (*decrypt)(struct cipher_context *cx,
@@ -110,7 +130,7 @@
 
 extern struct list_head ciphers;
 
-#define MAX_KEY_SIZE 8
+#define MAX_KEY_SIZE 8               /* 256 bit */
 #define MAX_IV_SIZE  MAX_KEY_SIZE
 
 struct cipher_context {
@@ -331,6 +351,7 @@
 	blocksize,							   \
 	ivsize,								   \
 	uppername##_KEY_SCHEDULE_SIZE,					   \
+        0x0,                                                               \
 	name##_##mode##encrypt,						   \
 	name##_##mode##decrypt,						   \
 	name##_set_key,							   \

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/


</body></email><email><emailId>20000930085538</emailId><senderName>Alexander S A Kjeldaas</senderName><senderEmail>alexander.kjeldaas@fast.no</senderEmail><timestampReceived>2000-09-30 08:55:38-0400</timestampReceived><subject>Re: AES will be announced monday.</subject><body>

On Fri, Sep 29, 2000 at 06:14:43PM -0400, Bill Rugolsky Jr. wrote:
&gt; On Fri, Sep 29, 2000 at 09:52:01PM +0000, Marc Mutz wrote:
&gt; &gt; Anyone wants to bet? I'd say one of Twofish, Serpent, Rijndael. To be
&gt; &gt; precise, I'd say Serpent. Because it is fastest in HW and the most
&gt; &gt; secure. Software performance was never really high on NISTs list (see
&gt; &gt; DES). Twofish, while equally secure as Serpent is very complicated and
&gt; &gt; Rijndael can only be elected if the number of rounds is increased, which
&gt; &gt; implies a relative performance loss w.r.t. the other two.
&gt; 
&gt; While specialized hardware may be important, CPU/memory speeds may
&gt; favor software implementations that allow one to flexibly and simultaneously
&gt; do compression, encryption, checksumming, etc. with minimal data touching.
&gt; 

Agreed.  And on current CPUs that means ciphers that can be
efficiently implemented with MMX and SSE instructions, so you can use
the normal registers for compression etc.  This again favours ciphers
that don't do _random_ table lookups as they are slow when you do
vector processing.  Also it favours ciphers that don't do 32-bit
multiplication as this isn't available (yet).  The two ciphers I know
that are ideal for this kind of stuff are serpent and IDEA.

astor

-- 
Alexander Kjeldaas                Mail:  astor@fast.no
finger astor@master.kernel.org for OpenPGP key.

Linux-crypto:  cryptography in and on the Linux system
Archive:       http://mail.nl.linux.org/linux-crypto/

</body></email></emails>