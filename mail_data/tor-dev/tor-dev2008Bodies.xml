<?xml version="1.0" encoding="utf-8"?>
<emails><email><emailId>20080102155944</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-01-02 15:59:44-0400</timestampReceived><subject>Re: Topic of a diploma</subject><body>


On Mon, Dec 10, 2007 at 12:07:02PM +0100, Heiko Gro? wrote:
&gt; Hi there,
&gt; 
&gt; During the last weeks I've done research. I'm looking for a topic for my 
&gt; diploma which should be close to anomity/tor. I've read quit a few about 
&gt; cicuit-building, geoip and node-exclusion in order to build 
&gt; "Vorratsdatenspeicherungs"-proof circuits. At the beginning of my 
&gt; research I thought it would be suitable to just restrict the choice of 
&gt; the nodes by writing a special controller, but later on I became aware 
&gt; of other possible kinds of attacks such as statistic attacks on both 
&gt; ends of the communication.
&gt; Where are you guys right now at? Is there anything I can do?
&gt; I'm looking forward to find some working specially at this kind of problem.

The state of the art on resisting end-to-end statistical attacks by an
attacker who can watch both ends of a low-latency anonymity channel,
is IMO Shmatikov and Wang's "Adaptive Padding":

   http://freehaven.net/anonbib/author.html#ShWa-Timing06

The paper mentiones earlier research in the area, which is also pretty
important.  IMO none of it is useful enough yet to merit inclusion in
Tor, but it might be on the right path.

For a paper with interesting implications for path selection stuff, I
like Steven Murdoch's
    http://freehaven.net/anonbib/author.html#murdoch-pet2007
It refers to some earlier papers that are also pretty important.

You might also check out other related papers on anonbib; there's some
good research been happening in the last few years.  IMO, new defenses
are generally more interesting than new attacks, since the attacks are
already so good that new, equally good attacks aren't very impressive.

hope this helps,
-- 
Nick Mathewson
[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20080212090132</emailId><senderName>"freddyz77 () tin ! it"</senderName><senderEmail>freddyz77@tin.it</senderEmail><timestampReceived>2008-02-12 09:01:32-0400</timestampReceived><subject>Small leak patch</subject><body>

I discovered a small fd leak in src/common/compat.c:tor_mmap_file

diff 
-r -U10 tor-0.1.2.19/src/common/compat.c tor-0.1.2.19.
my/src/common/compat.c
--- tor-0.1.2.19/src/common/compat.c    2008-01-
08 05:45:55.000000000 +0100
+++ tor-0.1.2.19.my/src/common/compat.c 
2008-02-12 09:41:24.211311798 +0100
@@ -148,36 +148,35 @@
     return 
NULL;
   }

   size = filesize = (size_t) lseek(fd, 0, SEEK_END);
   
lseek(fd, 0, SEEK_SET);
   /* ensure page alignment */
   page_size = 
getpagesize();
   size += (size%page_size) ? page_size-(size%page_size) 
: 0;

   if (!size) {
+    close(fd);
     /* Zero-length file. If we 
call mmap on it, it will succeed but
      * return NULL, and bad 
things will happen. So just fail. */
     log_info(LD_FS,"File \"%s\" 
is empty. Ignoring.",filename);
     return NULL;
   }

   string = mmap
(0, size, PROT_READ, MAP_PRIVATE, fd, 0);
+  close(fd);
   if (string 
== MAP_FAILED) {
-    close(fd);
     log_warn(LD_FS,"Could not mmap 
file \"%s\": %s", filename,
              strerror(errno));
     return 
NULL;
   }

-  close(fd);
-
   res = tor_malloc_zero(sizeof
(tor_mmap_impl_t));
   res-&gt;base.data = string;
   res-&gt;base.size = 
filesize;
   res-&gt;mapping_size = size;

   return &amp;(res-&gt;base);
 }
 /** 
Release storage held for a memory mapping. */
 void
 tor_munmap_file
(tor_mmap_t *handle)


If file is zero fd was not released.

bye
  
freddy77

</body></email><email><emailId>20080316225101</emailId><senderName>Peter Palfrader</senderName><senderEmail>peter@palfrader.org</senderEmail><timestampReceived>2008-03-16 22:51:01-0400</timestampReceived><subject>openbsd malloc on alpha</subject><body>

Hi,

it turns out the problem is that the pagesize on alpha is 8k.

-#if defined(__sparc__)
+#if defined(__sparc__) || defined (__alpha__)
 #define        malloc_pageshift        13U
 #endif /* __sparc__ */

"fixes" the issue, but it's certainly not a nice fix.

We should probably be using getpagesize() to find out the page size.
I'm unsure if it's safe to use it at compile time and assume it will
work on all the subarchs that the binary will run on.

Peter
-- 
                           |  .''`.  ** Debian GNU/Linux **
      Peter Palfrader      | : :' :      The  universal
 http://www.palfrader.org/ | `. `'      Operating System
                           |   `-    http://www.debian.org/
</body></email><email><emailId>20080407190617</emailId><senderName>Camilo Viecco</senderName><senderEmail>cviecco@anml.iu.edu</senderEmail><timestampReceived>2008-04-07 19:06:17-0400</timestampReceived><subject>udp transport PoC</subject><body>

Hello Mail list

First introduction:
My name is Camilo Viecco, and I am PhD student at the CS department of
Indiana University.

I really like tor but had became disillusioned by its network
performance (or lack of). Thus,
as part of my graduate work I have designed a modification of the
transport mechanism in tor
to use tunnel tcp connections over ucp. That is, socks aware
applications open tcp streams
to a socks server running at the tor exit node. Tor does not transport
tcp streams
but transports the tcp packets (build by the os) in the form of
encapsulated autonomous circuit cells over udp.

The objectives of the redesign are to:
-Have a more fair allocation of network resources.
-Use end to end congestion control and avoidance.
-simplify the codebase.

During testing I have seen that even in high-latency, low bandwidth
circuits (US(abiline)-UK(home DSL)-US(abiline))
the latency at the application circuit is almost constant even with 
high load the  circuit (500ms  vs 10s on tor (average over 20 connections)).
Also, bandwidth is spread evenly among multiple tcp streams.

The proof of concept code for this is available at:
http://www.cs.indiana.edu/~cviecco/oscode/tdor/
(please use the latest code alway, now 0.0.3).

The network has been running since last week and seems to have no problems.
The code is linux only and one of the required libraries (libdnet)
requires a patch
since the library is broken (No response form the library developer yet).

Detailed instructions on building, installing and running can be found
in the distribution.

hope you have fun and dont hesitate to contact me if there are you have
and/or find
bugs/problems/suggestions.

Camilo H. Viecco
==============
 Key fingerprint = 0781 10A0 44CC C441 594F  E5A9 858A 173E 3EC5 EA42
==============


</body></email><email><emailId>20080502040511</emailId><senderName>Matt Edman</senderName><senderEmail>edmanm@vidalia-project.net</senderEmail><timestampReceived>2008-05-02 04:05:11-0400</timestampReceived><subject>Re: Parallelizing (some of) Tor's AES Operations</subject><body>

On Mon, Apr 21, 2008 at 12:34:04PM -0400, Nick Mathewson wrote:
&gt; On Mon, Apr 21, 2008 at 02:29:05AM -0400, Matt Edman wrote:
&gt; &gt;  1) The most straightforward approach I can think of is to launch
&gt; &gt; $NumCpus threads when Tor starts up. When aes_crypt() or
&gt; &gt; aes_crypt_inplace() get called from the main thread, the input gets
&gt; &gt; split into $length/$NumCpus chunks (or maybe fewer depending on
&gt; &gt; input length), which get farmed out to the worker threads.  The main
&gt; &gt; thread then collects the results and returns.

[...]

&gt; Right.  Personally, I don't expect that this will wind up working very
&gt; well in practice, what with the locking but if you want to benchmark
&gt; it, it might work out well after all.  Having the main thread wait
&gt; while all the subthreads are doing AES seems like a losing proposition.

Yep, this approach does indeed seem to perform quite poorly and scales even
worse when increasing the number of processors/chunks. Granted my little
benchmarking application probably left plenty of room for optimizing, but I
don't suspect much would change when you're getting near-linear _slowdown_ for
Tor's small cell sizes. On the other hand, this looks like it could be a win
if Tor ever moves to, say, 64KB cells. ;)

&gt; &gt;  4) A fourth approach would be to farm entire cells out to
&gt; &gt; threads. 

[...]

&gt; Note that there's exactly one place in the entire code where
&gt; relay_crypt() is called, marked [**] above.  To get things to
&gt; parallelize effectively, I think you'd want to replace the call to
&gt; relay_crypt, and have it instead place the cell in a work queue for
&gt; the worker threads to process.  When the worker threads were done with
&gt; one or more cell, you'd need a way for them to tell the main thread
&gt; about them, and which circuit's cell queue to put them in.

Looking through the code, it seems this is approximately what cpuworkers.c
does now for onion skins. Roughly, the work queue is simply a socket. The
workers receive tasks from the main thread over the socket, do some
processing, and then write the result back to the main thread.

A simple and straightforward implementation would be to extend the existing
CPU worker code with an additional task type for processing relay cells.  This
seems to have the same drawback as the first approach above, though, in that
you spend too much time bookkeeping and not enough doing actual work.  Not
reusing the existing CPU workers means Tor will actually launch 2*NumCpus
workers total, but that's probably not so bad.

&gt; Alternatively, you could give each circuit _two_ cell queues for each
&gt; direction: one for cells that need to be crypted, and one for cells
&gt; that are already crypted and are ready to transmit.  All you'd need to
&gt; tell the workers about is which circuits have to be processed; all
&gt; you'd need to tell the main thread about is which circuits now have
&gt; more data.  I like this approach a little better because it doesn't
&gt; require quite so much bookkeeping to tell the workers about what keys
&gt; to use to crypt what, or to tell the main thread where to put cells.

I like this approach better too. Separate cell queues definitely seems like
the way to go.

&gt; It will definitely take some thinking to figure out exactly what kind
&gt; of locking and notification mechanisms you'd want to use here.  If you
&gt; have any questions about waking the main thread, or what kind of
&gt; integrity Tor's data structures need, just ask.

In terms of locking and notification mechanisms, is it reasonable to assume a
threaded environment? I notice CPU workers are typically threads, but may be
fork()ed processes on some platforms. If TOR_IS_MULTITHREADED is not defined,
though, we don't get to use the handy locking constructs that already exist in
compat.h. Are there really many platforms that don't handle threads very well?

It also looks like compat.h already has wrappers for thread signaling, but are
just '#if 0'ed out right now. I assume that's simply because they're not
currently used anywhere in Tor though (rather than because it's broken).

&gt; This sounds like a really fun project in any case, and one I'd very
&gt; much like to include in the next Tor release.  What timeframe will you
&gt; be doing this on?

No particular rush, but I'm still shooting for a fairly short timeframe on
this.

--Matt

</body></email><email><emailId>20080612202841</emailId><senderName>Peter Palfrader</senderName><senderEmail>peter@palfrader.org</senderEmail><timestampReceived>2008-06-12 20:28:41-0400</timestampReceived><subject>Proposal: remove down routers from consensus</subject><body>

This is a pretty low hanging fruit and part of the job to make tor
bootstrap faster even if your bandwidth is really small.


Filename: xxx-remove-down-routers-from-consensus
Title: Remove routers that are not Running from consensus documents
Version: $Revision$
Last-Modified: $Date$
Author: Peter Palfrader
Created: 11-Jun-2008
Status: Open

1. Overview.

  Tor directory authorities hourly vote and agree on a consensus document
  which lists all the routers on the network together with some of their
  basic properties, like if a router is an exit node, whether it is
  stable or whether it is a version 2 directory mirror.

  One of the properties given with each router is the 'Running' flag.
  Clients do not use routers that are not listed as running.

  This proposal suggests that routers without the Running flag are not
  listed at all.

2. Current status

  At a typical bootstrap a client downloads a 140KB consensus, about
  10KB of certificates to verify that consensus, and about 1.6MB of
  server descriptors, about half of which it requires before it will
  start building circuits.

  Another proposal deals with how to get that huge 1.6MB fraction to
  effectively zero (by downloading only individual descriptors, on
  demand).  Should that get successfully implemented that will leave the
  140KB compressed consensus as a large fraction of what a client needs
  to get in order to work.

  About one third of the routers listed in a consensus are not running
  and will therefor never be used by clients who use this consensus.
  Not listing those routers will safe about 30% to 40% in size.

3. Proposed change

  Authority directory servers produce vote documents that include all
  the servers they know about, running or not, like they currently
  do.  In addition these vote documents also state that the authority
  supports a new consensus forming method (method number 4).

  If more than two thirds of votes that an authority has received claim
  they support method 4 then this new method will be used:  The
  consensus document is formed like before but a new last step removes
  all routers from the listing that are not marked as Running.

</body></email><email><emailId>20080702191850</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-07-02 19:18:50-0400</timestampReceived><subject>Proposal 147: Eliminate the need for v2 directories in generating v3 directories</subject><body>

Filename: 147-prevoting-opinions.txt
Title: Eliminate the need for v2 directories in generating v3 directories
Version: $Revision: 15607 $
Last-Modified: $Date: 2008-07-02 15:17:51 -0400 (Wed, 02 Jul 2008) $
Author: Nick Mathewson
Created: 2-Jul-2008
Status: Open

Overview

  We propose a new v3 vote document type to replace the role of v2
  networkstatus information in generating v3 consensuses.

Motivation

  When authorities vote on which descriptors are to be listed in the
  next consensus, it helps if they all know about the same descriptors
  as one another.  But a hostile, confused, or out-of-date server may
  upload a descriptor to only some authorities.  In the current v3
  directory design, the authorities don't have a good way to tell one
  another about the new descriptor until they exchange votes... but by
  the time this happens, they are already committed to their votes,
  and they can't add anybody they learn about from other authorities
  until the next voting cycle.  That's no good!

  The current Tor implementation avoids this problem by having
  authorities also look at v2 networkstatus documents, but we'd like
  in the long term to eliminate these, once 0.1.2.x is obsolete.

Design:

  We add a new value for vote-status in v3 consensus documents in
  addition to "consensus" and "vote": "opinion".  Authorities generate
  and sign an opinion document as if they were generating a vote,
  except that they send it to one another earlier than they send
  votes.

  Authorities don't need to generate more than one opinion document
  per voting interval, but may.  They should send it to the other
  authorities they know about, at the regular vote upload URL, before
  the authorities begin voting, so that enough time remains for the
  authorities to fetch new descriptors.

  Upon receiving an opinion document, authorities scan it for any
  descriptors that:
     - They might accept.
     - Are for routers they don't know about, or are published more
       recently than any descriptor they have for that router.
  Authorities then begin downloading such descriptors from authorities
  that claim to have them.

  Authorities MAY cache opinion documents, but don't need to.


</body></email><email><emailId>20080806135210</emailId><senderName>Karsten Loesing</senderName><senderEmail>karsten.loesing@gmx.net</senderEmail><timestampReceived>2008-08-06 13:52:10-0400</timestampReceived><subject>First patch for proposal 121</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Hi Nick,

as discussed on IRC I have started splitting up the implementation of
proposal 121 into smaller patches. I've come to the conclusion that four
main patches would be a good trade-off between patch size and number in
this case. There might be further, smaller patches afterwards, but these
four patches cover roughly everything to make proposal 121 work.

1. This is the first patch that includes configuration of client
authorization on hidden-service side, but without actually using that
data when advertising hidden services.

2. The second patch will use client authorization data to advertise
hidden services and restrict access to authorized clients only.

3. The third patch will enable users to configure authorization data for
hidden services on client side.

4. Finally, the fourth patch uses authorization data to access a hidden
service.

Let me know what parts of this first patch I should improve (or if you
want more/smaller or less/larger patches in the future).

Thanks!
- --Karsten
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFImayI0M+WPffBEmURAh1ZAKDN7JD41LzQSEfRO4Fi3r/7yG5oOwCfQp3G
L84XuhLl4wbaGVbmMWqmXXE=
=tbfV
-----END PGP SIGNATURE-----

["patch-121-1.txt" (text/plain)]

Index: /home/karsten/tor/tor-trunk/src/common/crypto.c
===================================================================
--- /home/karsten/tor/tor-trunk/src/common/crypto.c	(revision 16440)
+++ /home/karsten/tor/tor-trunk/src/common/crypto.c	(working copy)
@@ -515,6 +515,47 @@
   return 0;
 }
 
+/** PEM-encode the private key portion of &lt;b&gt;env&lt;/b&gt; and write it to a
+ * newly allocated string.  On success, set *&lt;b&gt;dest&lt;/b&gt; to the new
+ * string, *&lt;b&gt;len&lt;/b&gt; to the string's length, and return 0.  On
+ * failure, return -1.
+ */
+int
+crypto_pk_write_private_key_to_string(crypto_pk_env_t *env, char **dest,
+                                     size_t *len)
+{
+  BUF_MEM *buf;
+  BIO *b;
+
+  tor_assert(env);
+  tor_assert(env-&gt;key);
+  tor_assert(dest);
+
+  b = BIO_new(BIO_s_mem()); /* Create a memory BIO */
+
+  /* Now you can treat b as if it were a file.  Just use the
+   * PEM_*_bio_* functions instead of the non-bio variants.
+   */
+  if (!PEM_write_bio_RSAPrivateKey(b, env-&gt;key, NULL,NULL,0,NULL,NULL)) {
+    crypto_log_errors(LOG_WARN, "writing private key to string");
+    BIO_free(b);
+    return -1;
+  }
+
+  BIO_get_mem_ptr(b, &amp;buf);
+  (void)BIO_set_close(b, BIO_NOCLOSE); /* so BIO_free doesn't free buf */
+  BIO_free(b);
+
+  tor_assert(buf-&gt;length &gt;= 0);
+  *dest = tor_malloc(buf-&gt;length+1);
+  memcpy(*dest, buf-&gt;data, buf-&gt;length);
+  (*dest)[buf-&gt;length] = 0; /* nul terminate it */
+  *len = buf-&gt;length;
+  BUF_MEM_free(buf);
+
+  return 0;
+}
+
 /** Read a PEM-encoded public key from the first &lt;b&gt;len&lt;/b&gt; characters of
  * &lt;b&gt;src&lt;/b&gt;, and store the result in &lt;b&gt;env&lt;/b&gt;.  Return 0 on success, -1 on
  * failure.
Index: /home/karsten/tor/tor-trunk/src/common/crypto.h
===================================================================
--- /home/karsten/tor/tor-trunk/src/common/crypto.h	(revision 16440)
+++ /home/karsten/tor/tor-trunk/src/common/crypto.h	(working copy)
@@ -79,8 +79,12 @@
                                              const char *keyfile);
 int crypto_pk_write_public_key_to_string(crypto_pk_env_t *env,
                                          char **dest, size_t *len);
+int crypto_pk_write_private_key_to_string(crypto_pk_env_t *env,
+                                          char **dest, size_t *len);
 int crypto_pk_read_public_key_from_string(crypto_pk_env_t *env,
                                           const char *src, size_t len);
+int crypto_pk_read_private_key_from_string(crypto_pk_env_t *env,
+                                           const char *s);
 int crypto_pk_write_private_key_to_filename(crypto_pk_env_t *env,
                                             const char *fname);
 
@@ -206,8 +210,6 @@
                                                 int private);
 struct dh_st *_crypto_dh_env_get_dh(crypto_dh_env_t *dh);
 /* Prototypes for private functions only used by crypto.c and test.c*/
-int crypto_pk_read_private_key_from_string(crypto_pk_env_t *env,
-                                           const char *s);
 void add_spaces_to_fp(char *out, size_t outlen, const char *in);
 #endif
 
Index: /home/karsten/tor/tor-trunk/src/or/config.c
===================================================================
--- /home/karsten/tor/tor-trunk/src/or/config.c	(revision 16440)
+++ /home/karsten/tor/tor-trunk/src/or/config.c	(working copy)
@@ -226,6 +226,7 @@
   VAR("HiddenServiceOptions",LINELIST_V, RendConfigLines,    NULL),
   VAR("HiddenServicePort",   LINELIST_S, RendConfigLines,    NULL),
   VAR("HiddenServiceVersion",LINELIST_S, RendConfigLines,    NULL),
+  VAR("HiddenServiceAuthorizeClient",LINELIST_S,RendConfigLines, NULL),
   V(HSAuthoritativeDir,          BOOL,     "0"),
   V(HSAuthorityRecordStats,      BOOL,     "0"),
   V(HttpProxy,                   STRING,   NULL),
Index: /home/karsten/tor/tor-trunk/src/or/or.h
===================================================================
--- /home/karsten/tor/tor-trunk/src/or/or.h	(revision 16440)
+++ /home/karsten/tor/tor-trunk/src/or/or.h	(working copy)
@@ -640,6 +640,19 @@
  * identity key. */
 #define REND_INTRO_POINT_ID_LEN_BASE32 32
 
+/** Length of the descriptor cookie that is used for client authorization
+ * to hidden services. */
+#define REND_DESC_COOKIE_LEN 16
+
+/** Length of the base64-encoded descriptor cookie that is used for
+ * exchanging client authorization between hidden service and client. */
+#define REND_DESC_COOKIE_LEN_BASE64 22
+
+/** Legal characters for use in authorized client names for a hidden
+ * service. */
+#define REND_LEGAL_CLIENTNAME_CHARACTERS \
+  "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+-_"
+
 #define CELL_DIRECTION_IN 1
 #define CELL_DIRECTION_OUT 2
 
@@ -3788,6 +3801,13 @@
 
 /********************************* rendcommon.c ***************************/
 
+/** Hidden-service side configuration of client authorization. */
+typedef struct rend_authorized_client_t {
+  char *client_name;
+  char descriptor_cookie[REND_DESC_COOKIE_LEN];
+  crypto_pk_env_t *client_key;
+} rend_authorized_client_t;
+
 /** ASCII-encoded v2 hidden service descriptor. */
 typedef struct rend_encoded_v2_service_descriptor_t {
   char desc_id[DIGEST_LEN]; /**&lt; Descriptor ID. */
@@ -4247,6 +4267,7 @@
                                      const char *descriptor_cookie,
                                      const char *intro_content,
                                      size_t intro_size);
+int rend_parse_client_keys(strmap_t *parsed_clients, const char *str);
 
 #endif
 
Index: /home/karsten/tor/tor-trunk/src/or/rendservice.c
===================================================================
--- /home/karsten/tor/tor-trunk/src/or/rendservice.c	(revision 16440)
+++ /home/karsten/tor/tor-trunk/src/or/rendservice.c	(working copy)
@@ -47,6 +47,10 @@
   smartlist_t *ports; /**&lt; List of rend_service_port_config_t */
   int descriptor_version; /**&lt; Rendezvous descriptor version that will be
                            * published. */
+  int auth_type; /**&lt; Client authorization type or 0 if no client
+                  * authorization is performed. */
+  smartlist_t *clients; /**&lt; List of rend_authorized_client_t's of
+                         * clients that may access our service. */
   /* Other fields */
   crypto_pk_env_t *private_key; /**&lt; Permanent hidden-service key. */
   char service_id[REND_SERVICE_ID_LEN_BASE32+1]; /**&lt; Onion address without
@@ -79,6 +83,18 @@
   return smartlist_len(rend_service_list);
 }
 
+/** Helper: free storage held by a single service authorized client entry. */
+static void
+rend_authorized_client_free(void *authorized_client)
+{
+  rend_authorized_client_t *client = authorized_client;
+  if (!authorized_client) return;
+  if (client-&gt;client_key)
+    crypto_free_pk_env(client-&gt;client_key);
+  tor_free(client-&gt;client_name);
+  tor_free(client);
+}
+
 /** Release the storage held by &lt;b&gt;service&lt;/b&gt;.
  */
 static void
@@ -97,6 +113,11 @@
   }
   if (service-&gt;desc)
     rend_service_descriptor_free(service-&gt;desc);
+  if (service-&gt;clients) {
+    SMARTLIST_FOREACH(service-&gt;clients, rend_authorized_client_t *, c,
+      rend_authorized_client_free(c););
+    smartlist_free(service-&gt;clients);
+  }
   tor_free(service);
 }
 
@@ -125,20 +146,24 @@
   service-&gt;intro_nodes = smartlist_create();
 
   /* If the service is configured to publish unversioned (v0) and versioned
-   * descriptors (v2 or higher), split it up into two separate services. */
+   * descriptors (v2 or higher), split it up into two separate services
+   * (unless it is configured to perform client authorization). */
   if (service-&gt;descriptor_version == -1) {
-    rend_service_t *v0_service = tor_malloc_zero(sizeof(rend_service_t));
-    v0_service-&gt;directory = tor_strdup(service-&gt;directory);
-    v0_service-&gt;ports = smartlist_create();
-    SMARTLIST_FOREACH(service-&gt;ports, rend_service_port_config_t *, p, {
-      rend_service_port_config_t *copy =
-        tor_malloc_zero(sizeof(rend_service_port_config_t));
-      memcpy(copy, p, sizeof(rend_service_port_config_t));
-      smartlist_add(v0_service-&gt;ports, copy);
-    });
-    v0_service-&gt;intro_period_started = service-&gt;intro_period_started;
-    v0_service-&gt;descriptor_version = 0; /* Unversioned descriptor. */
-    rend_add_service(v0_service);
+    if (!service-&gt;auth_type) {
+      rend_service_t *v0_service = tor_malloc_zero(sizeof(rend_service_t));
+      v0_service-&gt;directory = tor_strdup(service-&gt;directory);
+      v0_service-&gt;ports = smartlist_create();
+      SMARTLIST_FOREACH(service-&gt;ports, rend_service_port_config_t *, p, {
+        rend_service_port_config_t *copy =
+          tor_malloc_zero(sizeof(rend_service_port_config_t));
+        memcpy(copy, p, sizeof(rend_service_port_config_t));
+        smartlist_add(v0_service-&gt;ports, copy);
+      });
+      v0_service-&gt;intro_period_started = service-&gt;intro_period_started;
+      v0_service-&gt;descriptor_version = 0; /* Unversioned descriptor. */
+      v0_service-&gt;auth_type = 0;
+      rend_add_service(v0_service);
+    }
 
     service-&gt;descriptor_version = 2; /* Versioned descriptor. */
   }
@@ -143,6 +168,20 @@
     service-&gt;descriptor_version = 2; /* Versioned descriptor. */
   }
 
+  if (service-&gt;auth_type &amp;&amp; !service-&gt;descriptor_version) {
+    log_warn(LD_CONFIG, "Hidden service with client authorization and "
+                        "version 0 descriptors configured; ignoring.");
+    rend_service_free(service);
+    return;
+  }
+
+  if (service-&gt;auth_type &amp;&amp; smartlist_len(service-&gt;clients) == 0) {
+    log_warn(LD_CONFIG, "Hidden service with client authorization but no "
+                        "clients; ignoring.");
+    rend_service_free(service);
+    return;
+  }
+
   if (!smartlist_len(service-&gt;ports)) {
     log_warn(LD_CONFIG, "Hidden service with no ports configured; ignoring.");
     rend_service_free(service);
@@ -271,6 +310,124 @@
         return -1;
       }
       smartlist_add(service-&gt;ports, portcfg);
+    } else if (!strcasecmp(line-&gt;key, "HiddenServiceAuthorizeClient")) {
+      /* Parse auth type and comma-separated list of client names and add a
+       * rend_authorized_client_t for each client to the service's list
+       * of authorized clients. */
+      smartlist_t *type_names_split, *clients;
+      if (service-&gt;auth_type) {
+        log_warn(LD_CONFIG, "Got multiple HiddenServiceAuthorizeClient "
+                 "lines for a single service.");
+        rend_service_free(service);
+        return -1;
+      }
+      type_names_split = smartlist_create();
+      smartlist_split_string(type_names_split, line-&gt;value, " ", 0, 0);
+      if (smartlist_len(type_names_split) &lt; 1) {
+        log_warn(LD_BUG, "HiddenServiceAuthorizeClient has no value. This "
+                         "should have been prevented when parsing the "
+                         "configuration.");
+        smartlist_free(type_names_split);
+        rend_service_free(service);
+        return -1;
+      }
+      service-&gt;auth_type = (int) tor_parse_long(
+                 smartlist_get(type_names_split, 0), 10, 1, 2, NULL, NULL);
+      if (!service-&gt;auth_type) {
+        log_warn(LD_CONFIG, "HiddenServiceAuthorizeClient contains "
+                 "unrecognized auth-type '%s'. Only 1 or 2 are recognized.",
+                 (char *) smartlist_get(type_names_split, 0));
+        SMARTLIST_FOREACH(type_names_split, char *, cp, tor_free(cp));
+        smartlist_free(type_names_split);
+        rend_service_free(service);
+        return -1;
+      }
+      service-&gt;clients = smartlist_create();
+      if (smartlist_len(type_names_split) &lt; 2) {
+        log_warn(LD_CONFIG, "HiddenServiceAuthorizeClient contains "
+                            "authorization type %d, but no client names.",
+                 service-&gt;auth_type);
+        SMARTLIST_FOREACH(type_names_split, char *, cp, tor_free(cp));
+        smartlist_free(type_names_split);
+        continue;
+      }
+      if (smartlist_len(type_names_split) &gt; 2) {
+        log_warn(LD_CONFIG, "HiddenServiceAuthorizeClient contains "
+                            "illegal value '%s'. Must be formatted "
+                            "as 'HiddenServiceAuthorizeClient auth-type "
+                            "client-name,client-name,...' (without "
+                            "additional spaces in comma-separated client "
+                            "list).",
+                 line-&gt;value);
+        SMARTLIST_FOREACH(type_names_split, char *, cp, tor_free(cp));
+        smartlist_free(type_names_split);
+        rend_service_free(service);
+        return -1;
+      }
+      clients = smartlist_create();
+      smartlist_split_string(clients, smartlist_get(type_names_split, 1),
+                             ",", 0, 0);
+      SMARTLIST_FOREACH(type_names_split, char *, cp, tor_free(cp));
+      smartlist_free(type_names_split);
+      SMARTLIST_FOREACH_BEGIN(clients, char *, client_name)
+      {
+        rend_authorized_client_t *client;
+        size_t len = strlen(client_name);
+        int found_duplicate = 0;
+        if (len &lt; 1 || len &gt; 19) {
+          log_warn(LD_CONFIG, "HiddenServiceAuthorizeClient contains an "
+                              "illegal client name: '%s'. Length must be "
+                              "between 1 and 19 characters.",
+                   client_name);
+          SMARTLIST_FOREACH(clients, char *, cp, tor_free(cp));
+          smartlist_free(clients);
+          rend_service_free(service);
+          return -1;
+        }
+        if (strspn(client_name, REND_LEGAL_CLIENTNAME_CHARACTERS) != len) {
+          log_warn(LD_CONFIG, "HiddenServiceAuthorizeClient contains an "
+                              "illegal client name: '%s'. Valid "
+                              "characters are [A-Za-z0-9+-_].",
+                   client_name);
+          SMARTLIST_FOREACH(clients, char *, cp, tor_free(cp));
+          smartlist_free(clients);
+          rend_service_free(service);
+          return -1;
+        }
+        /* Check if client name is duplicate. */
+        SMARTLIST_FOREACH(service-&gt;clients, rend_authorized_client_t *, c, {
+          if (!strcmp(c-&gt;client_name, client_name)) {
+            log_warn(LD_CONFIG, "HiddenServiceAuthorizeClient contains a "
+                     "duplicate client name: '%s'; ignoring.", client_name);
+            found_duplicate = 1;
+            break;
+          }
+        });
+        if (found_duplicate)
+          continue;
+        client = tor_malloc_zero(sizeof(rend_authorized_client_t));
+        client-&gt;client_name = strdup(client_name);
+        smartlist_add(service-&gt;clients, client);
+        log_debug(LD_REND, "Adding client name '%s'", client_name);
+      }
+      SMARTLIST_FOREACH_END(client_name);
+      SMARTLIST_FOREACH(clients, char *, cp, tor_free(cp));
+      smartlist_free(clients);
+      /* Ensure maximum number of clients. */
+      if ((service-&gt;auth_type == 1 &amp;&amp;
+            smartlist_len(service-&gt;clients) &gt; 512) ||
+          (service-&gt;auth_type == 2 &amp;&amp;
+            smartlist_len(service-&gt;clients) &gt; 16)) {
+        log_warn(LD_CONFIG, "HiddenServiceAuthorizeClient contains %d "
+                            "client authorization entries, but only a "
+                            "maximum of %d entries is allowed for "
+                            "authorization type %d.",
+                 smartlist_len(service-&gt;clients),
+                 service-&gt;auth_type == 1 ? 512 : 16,
+                 service-&gt;auth_type);
+        rend_service_free(service);
+        return -1;
+      }
     } else {
       smartlist_t *versions;
       char *version_str;
@@ -351,8 +508,9 @@
   }
 }
 
-/** Load and/or generate private keys for all hidden services.  Return 0 on
- * success, -1 on failure.
+/** Load and/or generate private keys for all hidden services, possibly
+ * including keys for client authorization.  Return 0 on success, -1 on
+ * failure.
  */
 int
 rend_service_load_keys(void)
@@ -360,7 +518,7 @@
   int i;
   rend_service_t *s;
   char fname[512];
-  char buf[128];
+  char buf[1500];
 
   for (i=0; i &lt; smartlist_len(rend_service_list); ++i) {
     s = smartlist_get(rend_service_list,i);
@@ -402,8 +560,157 @@
       return -1;
     }
     tor_snprintf(buf, sizeof(buf),"%s.onion\n", s-&gt;service_id);
-    if (write_str_to_file(fname,buf,0)&lt;0)
+    if (write_str_to_file(fname,buf,0)&lt;0) {
+      log_warn(LD_CONFIG, "Could not write onion address to hostname file.");
       return -1;
+    }
+
+    /* If client authorization is configured, load or generate keys. */
+    if (s-&gt;auth_type) {
+      char *client_keys_str;
+      strmap_t *parsed_clients = strmap_new();
+      char cfname[512];
+
+      /* Load client keys and descriptor cookies, if available. */
+      if (strlcpy(cfname,s-&gt;directory,sizeof(cfname)) &gt;= sizeof(cfname) ||
+          strlcat(cfname,PATH_SEPARATOR"client_keys",sizeof(cfname))
+                                                      &gt;= sizeof(cfname)) {
+        log_warn(LD_CONFIG, "Directory name too long to store client keys "
+                 "file: \"%s\".", s-&gt;directory);
+        strmap_free(parsed_clients, rend_authorized_client_free);
+        return -1;
+      }
+      client_keys_str = read_file_to_str(cfname, RFTS_IGNORE_MISSING, NULL);
+      if (client_keys_str) {
+        if (rend_parse_client_keys(parsed_clients, client_keys_str) &lt; 0) {
+          log_warn(LD_CONFIG, "Previously stored client_keys file could not "
+                              "be parsed.");
+          tor_free(client_keys_str);
+          strmap_free(parsed_clients, rend_authorized_client_free);
+          return -1;
+        } else {
+          log_info(LD_CONFIG, "Parsed %d previously stored client entries.",
+                   strmap_size(parsed_clients));
+          tor_free(client_keys_str);
+        }
+      }
+
+      /* Prepare client_keys and hostname files. */
+      if (write_str_to_file(cfname, "", 0) &lt; 0) {
+        log_warn(LD_CONFIG, "Could not clear client_keys file.");
+        strmap_free(parsed_clients, rend_authorized_client_free);
+        return -1;
+      }
+      if (write_str_to_file(fname, "", 0) &lt; 0) {
+        log_warn(LD_CONFIG, "Could not clear hostname file.");
+        strmap_free(parsed_clients, rend_authorized_client_free);
+        return -1;
+      }
+
+      /* Either use loaded keys for configured clients or generate new
+       * ones if a client is new. */
+      SMARTLIST_FOREACH_BEGIN(s-&gt;clients, rend_authorized_client_t *, client)
+      {
+        char desc_cook_out[3*REND_DESC_COOKIE_LEN_BASE64+1];
+        char service_id[16+1];
+        rend_authorized_client_t *parsed =
+            strmap_get(parsed_clients, client-&gt;client_name);
+        int written;
+        size_t len;
+        /* Copy descriptor cookie from parsed entry or create new one. */
+        if (parsed) {
+          memcpy(client-&gt;descriptor_cookie, parsed-&gt;descriptor_cookie,
+                 REND_DESC_COOKIE_LEN);
+        } else {
+          crypto_rand(client-&gt;descriptor_cookie, REND_DESC_COOKIE_LEN);
+        }
+        if (base64_encode(desc_cook_out, 3*REND_DESC_COOKIE_LEN_BASE64+1,
+                          client-&gt;descriptor_cookie,
+                          REND_DESC_COOKIE_LEN) &lt; 0) {
+          log_warn(LD_BUG, "Could not base64-encode descriptor cookie.");
+          strmap_free(parsed_clients, rend_authorized_client_free);
+          return -1;
+        }
+        /* Copy client key from parsed entry or create new one if required. */
+        if (parsed &amp;&amp; parsed-&gt;client_key) {
+          client-&gt;client_key = crypto_pk_dup_key(parsed-&gt;client_key);
+        } else if (s-&gt;auth_type == 2) {
+          /* Create private key for client. */
+          crypto_pk_env_t *prkey = NULL;
+          if (!(prkey = crypto_new_pk_env())) {
+            log_warn(LD_BUG,"Error constructing client key");
+            strmap_free(parsed_clients, rend_authorized_client_free);
+            return -1;
+          }
+          if (crypto_pk_generate_key(prkey)) {
+            log_warn(LD_BUG,"Error generating client key");
+            strmap_free(parsed_clients, rend_authorized_client_free);
+            return -1;
+          }
+          if (crypto_pk_check_key(prkey) &lt;= 0) {
+            log_warn(LD_BUG,"Generated client key seems invalid");
+            crypto_free_pk_env(prkey);
+            strmap_free(parsed_clients, rend_authorized_client_free);
+            return -1;
+          }
+          client-&gt;client_key = prkey;
+        }
+        /* Add entry to client_keys file. */
+        desc_cook_out[strlen(desc_cook_out)-1] = '\0'; /* Remove newline. */
+        written = tor_snprintf(buf, sizeof(buf),
+                               "client-name %s\ndescriptor-cookie %s\n",
+                               client-&gt;client_name, desc_cook_out);
+        if (written &lt; 0) {
+          log_warn(LD_BUG, "Could not write client entry.");
+          strmap_free(parsed_clients, rend_authorized_client_free);
+          return -1;
+        }
+        if (client-&gt;client_key) {
+          char *client_key_out;
+          crypto_pk_write_private_key_to_string(client-&gt;client_key,
+                                                &amp;client_key_out, &amp;len);
+          if (rend_get_service_id(client-&gt;client_key, service_id)&lt;0) {
+            log_warn(LD_BUG, "Internal error: couldn't encode service ID.");
+            strmap_free(parsed_clients, rend_authorized_client_free);
+            return -1;
+          }
+          written = tor_snprintf(buf + written, sizeof(buf) - written,
+                                 "client-key\n%s", client_key_out);
+          if (written &lt; 0) {
+            log_warn(LD_BUG, "Could not write client entry.");
+            strmap_free(parsed_clients, rend_authorized_client_free);
+            return -1;
+          }
+        }
+        append_bytes_to_file(cfname, buf, strlen(buf), 0);
+        /* Add line to hostname file. */
+        if (s-&gt;auth_type == 1) {
+          /* Remove == signs (newline has been removed above). */
+          desc_cook_out[strlen(desc_cook_out)-2] = '\0';
+          tor_snprintf(buf, sizeof(buf),"%s.onion %s # client: %s\n",
+                       s-&gt;service_id, desc_cook_out, client-&gt;client_name);
+        } else {
+          char extended_desc_cookie[REND_DESC_COOKIE_LEN+1];
+          memcpy(extended_desc_cookie, client-&gt;descriptor_cookie,
+                 REND_DESC_COOKIE_LEN);
+          extended_desc_cookie[REND_DESC_COOKIE_LEN] = (s-&gt;auth_type - 1) &lt;&lt; 4;
+          if (base64_encode(desc_cook_out, 3*REND_DESC_COOKIE_LEN_BASE64+1,
+                            extended_desc_cookie,
+                            REND_DESC_COOKIE_LEN+1) &lt; 0) {
+            log_warn(LD_BUG, "Could not base64-encode descriptor cookie.");
+            strmap_free(parsed_clients, rend_authorized_client_free);
+            return -1;
+          }
+          desc_cook_out[strlen(desc_cook_out)-3] = '\0'; /* Remove A= and
+                                                            newline. */
+          tor_snprintf(buf, sizeof(buf),"%s.onion %s # client: %s\n",
+                       service_id, desc_cook_out, client-&gt;client_name);
+        }
+        append_bytes_to_file(fname, buf, strlen(buf), 0);
+      }
+      SMARTLIST_FOREACH_END(client);
+      strmap_free(parsed_clients, rend_authorized_client_free);
+    }
   }
   return 0;
 }
Index: /home/karsten/tor/tor-trunk/src/or/routerparse.c
===================================================================
--- /home/karsten/tor/tor-trunk/src/or/routerparse.c	(revision 16440)
+++ /home/karsten/tor/tor-trunk/src/or/routerparse.c	(working copy)
@@ -100,6 +100,10 @@
   R_IPO_ONION_KEY,
   R_IPO_SERVICE_KEY,
 
+  C_CLIENT_NAME,
+  C_DESCRIPTOR_COOKIE,
+  C_CLIENT_KEY,
+
   _UNRECOGNIZED,
   _ERR,
   _EOF,
@@ -352,6 +356,15 @@
   END_OF_TABLE
 };
 
+/** List of tokens allowed in the (possibly encrypted) list of introduction
+ * points of rendezvous service descriptors */
+static token_rule_t client_keys_token_table[] = {
+  T1_START("client-name", C_CLIENT_NAME, CONCAT_ARGS, NO_OBJ),
+  T1("descriptor-cookie", C_DESCRIPTOR_COOKIE, EQ(1), NO_OBJ),
+  T01("client-key", C_CLIENT_KEY, NO_ARGS, NEED_KEY_1024),
+  END_OF_TABLE
+};
+
 static token_rule_t networkstatus_token_table[] = {
   T1("network-status-version", K_NETWORK_STATUS_VERSION,
                                                    GE(1),       NO_OBJ ),
@@ -2948,10 +2961,14 @@
     ebuf[sizeof(ebuf)-1] = '\0';
     RET_ERR(ebuf);
   }
-  if (!strcmp(tok-&gt;object_type, "RSA PUBLIC KEY")) { /* If it's a key... */
+  if (!strcmp(tok-&gt;object_type, "RSA PUBLIC KEY")) { /* If it's a public key */
     tok-&gt;key = crypto_new_pk_env();
     if (crypto_pk_read_public_key_from_string(tok-&gt;key, obstart, eol-obstart))
       RET_ERR("Couldn't parse public key.");
+  } else if (!strcmp(tok-&gt;object_type, "RSA PRIVATE KEY")) { /* private key */
+    tok-&gt;key = crypto_new_pk_env();
+    if (crypto_pk_read_private_key_from_string(tok-&gt;key, obstart))
+      RET_ERR("Couldn't parse private key.");
   } else { /* If it's something else, try to base64-decode it */
     int r;
     tok-&gt;object_body = ALLOC(next-*s); /* really, this is too much RAM. */
@@ -3668,3 +3685,115 @@
   return result;
 }
 
+/** Parse the content of a client_key file in &lt;b&gt;ckstr&lt;/b&gt; and add
+ * rend_authorized_client_t's for each parsed client to
+ * &lt;b&gt;parsed_clients&lt;/b&gt;. Return the number of parsed clients as result
+ * or -1 for failure. */
+int
+rend_parse_client_keys(strmap_t *parsed_clients, const char *ckstr)
+{
+  int result = -1;
+  smartlist_t *tokens;
+  directory_token_t *tok;
+  const char *current_entry = NULL;
+  memarea_t *area = NULL;
+  if (!ckstr || strlen(ckstr) == 0)
+    return -1;
+  tokens = smartlist_create();
+  /* Begin parsing with first entry, skipping comments or whitespace at the
+   * beginning. */
+  area = memarea_new(4096);
+  current_entry = strstr(ckstr, "client-name ");
+  while (!strcmpstart(current_entry, "client-name ")) {
+    rend_authorized_client_t *parsed_entry;
+    size_t len;
+    char descriptor_cookie_base64[REND_DESC_COOKIE_LEN_BASE64+2+1];
+    char descriptor_cookie_tmp[REND_DESC_COOKIE_LEN+2];
+    /* Determine end of string. */
+    const char *eos = strstr(current_entry, "\nclient-name ");
+    if (!eos)
+      eos = current_entry + strlen(current_entry);
+    else
+      eos = eos + 1;
+    /* Free tokens and clear token list. */
+    SMARTLIST_FOREACH(tokens, directory_token_t *, t, token_free(t));
+    smartlist_clear(tokens);
+    memarea_clear(area);
+    /* Tokenize string. */
+    if (tokenize_string(area, current_entry, eos, tokens,
+                        client_keys_token_table, 0)) {
+      log_warn(LD_REND, "Error tokenizing client keys file.");
+      goto err;
+    }
+    /* Advance to next entry, if available. */
+    current_entry = eos;
+    /* Check minimum allowed length of token list. */
+    if (smartlist_len(tokens) &lt; 2) {
+      log_warn(LD_REND, "Impossibly short client key entry.");
+      goto err;
+    }
+    /* Parse client name. */
+    tok = find_first_by_keyword(tokens, C_CLIENT_NAME);
+    tor_assert(tok);
+    tor_assert(tok == smartlist_get(tokens, 0));
+    tor_assert(tok-&gt;n_args == 1);
+
+    len = strlen(tok-&gt;args[0]);
+    if (len &lt; 1 || len &gt; 19 ||
+      strspn(tok-&gt;args[0], REND_LEGAL_CLIENTNAME_CHARACTERS) != len) {
+      log_warn(LD_CONFIG, "Illegal client name: %s. (Length must be "
+               "between 1 and 19, and valid characters are "
+               "[A-Za-z0-9+-_].)", tok-&gt;args[0]);
+      goto err;
+    }
+    /* Check if client name is duplicate. */
+    if (strmap_get(parsed_clients, tok-&gt;args[0])) {
+      log_warn(LD_CONFIG, "HiddenServiceAuthorizeClient contains a "
+               "duplicate client name: '%s'. Ignoring.", tok-&gt;args[0]);
+      goto err;
+    }
+    parsed_entry = tor_malloc_zero(sizeof(rend_authorized_client_t));
+    parsed_entry-&gt;client_name = strdup(tok-&gt;args[0]);
+    strmap_set(parsed_clients, parsed_entry-&gt;client_name, parsed_entry);
+    /* Parse client key. */
+    tok = find_first_by_keyword(tokens, C_CLIENT_KEY);
+    if (tok) {
+      parsed_entry-&gt;client_key = tok-&gt;key;
+      tok-&gt;key = NULL; /* Prevent free */
+    }
+
+    /* Parse descriptor cookie. */
+    tok = find_first_by_keyword(tokens, C_DESCRIPTOR_COOKIE);
+    tor_assert(tok);
+    tor_assert(tok-&gt;n_args == 1);
+    if (strlen(tok-&gt;args[0]) != REND_DESC_COOKIE_LEN_BASE64 + 2) {
+      log_warn(LD_REND, "Descriptor cookie has illegal length: %s",
+               tok-&gt;args[0]);
+      goto err;
+    }
+    /* The size of descriptor_cookie_tmp needs to be REND_DESC_COOKIE_LEN+2,
+     * because a base64 encoding of length 24 does not fit into 16 bytes in all
+     * cases. */
+    if ((base64_decode(descriptor_cookie_tmp, REND_DESC_COOKIE_LEN+2,
+                       tok-&gt;args[0], REND_DESC_COOKIE_LEN_BASE64+2+1)
+           != REND_DESC_COOKIE_LEN)) {
+      log_warn(LD_REND, "Descriptor cookie contains illegal characters: "
+                        "%s", descriptor_cookie_base64);
+      goto err;
+    }
+    memcpy(parsed_entry-&gt;descriptor_cookie, descriptor_cookie_tmp,
+           REND_DESC_COOKIE_LEN);
+  }
+  result = strmap_size(parsed_clients);
+  goto done;
+ err:
+  result = -1;
+ done:
+  /* Free tokens and clear token list. */
+  SMARTLIST_FOREACH(tokens, directory_token_t *, t, token_free(t));
+  smartlist_free(tokens);
+  if (area)
+    memarea_drop_all(area);
+  return result;
+}
+


["patch-121-1.txt.sig" (application/octet-stream)]

</body></email><email><emailId>20080911215711</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-09-11 21:57:11-0400</timestampReceived><subject>Glider: Automatic updates for Tor bundles</subject><body>

This one is in the repository now, at updater/trunk/spec/glider-spec.txt.

Please check it out and let me know what you think.  It build on ideas
from earlier specs from Jake and Matt.

				- = -

             Glider: Automatic updates for Tor bundles

0. Preliminaries

0.0. Scope

   This document describes a system for distributing Tor binary bundle
   updates.

0.1. Proposed code name

   Since "auto-update" is so generic, I've been thinking about going with
   "glider", based on the sugar glider you get when you search for "handy
   pocket creature".  I haven't yet done a search to find out whether
   somebody else is using the name, so we shouldn't get too attached to it
   before we see if it's taken.

0.2. Non-goals

   This is not meant to replace any existing download mechanism for
   users who prefer that mechanism.  For example, just downloading
   source will still work fine.

   Similarly, we're not trying to force users who do not want to use
   downloaded binaries to use them, or to force users who do not want
   automatic updates to get them.  {This should be obvious, but enough
   people have asked that I'm putting it in the document.}

   This is not a general-purpose package manager like yum or apt: it
   assumes that users will want to have one or more of a set of
   "bundles", not an arbitrary selection of packages dependant on one
   another.  (Rationale: these systems do what they do pretty well.)

   This is also not a general-purpose package format.  It assumes the
   existence of an external package format that can handle install,
   update, remove, and version query.

0.3. Goals

   Once Tor was a single executable that you could just run.  Then it
   required Privoxy.  Now, thanks to the Tor Browser Bundle and related
   projects, a full installation can contain Tor, Privoxy, Torbutton,
   Firefox, and more.

   We need to keep this software updated.  When we make security fixes,
   quick uptake helps narrow the window in which attackers can exploit
   them.

   We need updates to be easy.  Each additional step a user must take to
   get updated means that more users will stay with older insecure
   versions.

   We need updates to be secure.  We're supposed to be good at crypto;
   let's act like it.  There is no good reason in this day and age to
   subject users to rollback attacks or unsigned packages or whatever.

   We need administration to be simple.  Tor doesn't have a release
   engineering team, so we can't add too many hard steps to putting out
   a new release.

   The system should be easy to implement; we may need to do multiple
   implementations on the client side at least.

0.3.1. Goals for package formats and PKIs

   It should be possible to mirror a repository using only rsync and
   cron.

   Separate keys should be used for different people and different
   roles.

   Only a minimal set of keys should have to be kept online to keep
   the system running.

   The system should handle any single computer or system or person
   being unavailable.

   The formats and protocols should be pretty future-proof.

1. System overview

   The basic unit of updatability is a "bundle".  A bundle is a set of
   software components, or "packages", plus some rules about installing
   them.  Example bundles could be "Tor Browser, stable series" or
   "Basic Tor, development series".

   When Glider has responsibility for keeping a bundle up to date, we
   say that a user has "subscribed" to that bundle.

   Conceptually, there are four parts to keeping a bundle up to date:

      Polling:
        - Periodically, Glider asks a mirror whether there is a newer
          version of some bundle that a user has subscribed to.  If so,
          Glider determines what's in the bundle.

      Fetching:
        - If the bundle contains packages that Glider hasn't installed
          or hasn't cached, it needs to download them from a mirror.
          This can happen over any protocol; v1 should support at least
          http and https-over-Tor.  V1 should also support resuming
          partial downloads, since many users have unreliable
          connections.

          Later versions could support Bittorrent, or whatever.

      Validation:
        - Throughout the process, Glider must ensure that all the
          bundles are signed correctly, all the packages are signed
          correctly, and everything is up-to-date.

          We want to specify this so that users can't be tricked about
          the contents of a bundle, can't install a malicious package,
          and can't be fooled into believing that an old bundle is
          actually the latest.

      Installation:
        - Now Glider has a set of packages to install.  The format of
          these packages will be platform-dependent: they could be pkg
          files on OSX, MSI files on Win32, RPMs or DEBs on Linux, and
          so on.  Glider should query the user for permission to start
          installing packages, then install the packages.  (All other
          steps should generally happen automatically, in the
          background, without needing user intervention.)

1.1. The repository

   Each Glider instance knows about one or more "repositories".  A
   repository is a filesystem somewhere that contains the packages in a
   set of bundles, and some associated metadata.  A repository must
   exist at one or more canonical hosts, and may have a number of full
   or partial mirrors.

   In v1, each Glider instance will know about only one repository.

1.2. The PKI

   The trust root for the whole system is, necessarily, whatever users
   download when they first download a copy of Glider.  We need to make
   sure that the first download happens from a site we trust, using
   HTTPS.

   Glider ships with root keys, which in turn are used to verify the
   keys for all the other roles.  There are a few root keys, operated by
   trusted admins for the system.  If root keys ever need to be changed,
   we can just ship an update of Glider: it's supposed to be
   self-updating anyway.

   The root keys are only used to sign a 'key list' of all the other
   keys and their roles.  A key list is valid if it has been signed by a
   threshold of root keys.

   Each package is signed with the key of its authorized builder.  For
   example, one volunteer may be authorized to build the mac versions of
   several packages, and another may be authorized to build the windows
   version of just one.

   Each bundle is signed with the key of its maintainer.  It's assumed
   that the bundle maintainer might be the package maintainer for some
   but not all of the packages.

   The list of mirrors is also signed.  If the mirror list is
   automatically updated, this key must be kept online; otherwise, it
   can be offline.

   To prevent an adversary from replaying an out-of-date signed
   document, an automated process periodically signs a timestamped
   statement containing the hashes of the mirror list, the latest
   bundles, and the key list, using yet another special-purpose key.
   This key must be kept online.

1.3. Threat Model And Analysis

   We assume an adversary who can operate compromised mirrors, and who
   can possibly compromise the main repository.  At worst, such an
   adversary can DOS users in a way that they can detect.

   We're assuming for the moment an OSX/Win32-like execution model,
   where all packages will run equal privilege, but occasionally
   installation will require higher privilege.  This means that once a
   hostile package is installed, it can basically do whatever it
   wants.  As rootkit writers demonstrate, compromise is really
   tenuous: any attacker who can induce a user to install a hostile
   piece of code has, in effect, permanently compromised that user
   until they reinstall.

   Thus, if an adversary compromises enough keys to sign a compromised
   package, or tricks a packager into signing a compromised package,
   and manages to get that package into a signed bundle, the best we
   can do is to limit the number of users who are affected.  We do
   this by compartmentalizing signing keys so that only the package
   and bundle in question are at risk.

   (If we had replicated build processes and a bit-by-bit reliable
   build process, we could have multiple packagers test that a binary
   was built properly, and multiply sign it.  This would be effective
   against an adversary compromising a single packaging key, but not
   against one compromising a source repository.)

2. The repository layout

   The filesystem layout in the repository is used for two purposes:
     - To give mirrors an easy way to mirror only some of the repository.
     - To specify which parts of the repository a given key has the
       authority to sign.

   The following files exist in all repositories and mirrors:

    /meta/keys.txt

         Signed by the root keys; indicates keys and roles.
         [???? I'm using the txt extension here.  Is that smart?]

    /meta/mirrors.txt

         Signed by the mirror key; indicates which parts of the
         repository are mirrored at what mirrors.

    /meta/timestamp.txt

         Signed by the timestamp key; indicates hashes and timestamps
         for the latest versions of keys.txt and mirrors.txt.  Also
         indicates the latest version of each bundle for each os/arch.

         This is the only file that needs to be downloaded for polling.

    /bundleinfo/bundlename/os-arch/bundlename-os-arch-bundleversion.txt

         Signed by the appropriate bundle key.  Describes what
         packages make up a bundle, and what order to install,
         uninstall, and upgrade them in.

    /pkginfo/packagename/os-arch/version/packagename-os-arch-packageversion.txt

         Signed by the appropriate package key.  Tells the name of the
         file that makes up a package, its hash, and what procedure
         is used to install it.

    /packages/packagename/os-arch/version/(some filename)

         The actual package file.  Its naming convention will depend
         on the underlying packaging system.

3. Document formats

3.1. Metaformat

   All documents use Rivest's SEXP meta-format as documented at
     http://people.csail.mit.edu/rivest/sexp.html
   with the restriction that no "display hint" fields are to be used,
   and the base64 transit encoding isn't used either.

   (We use SEXP because it's really easy to parse, really portable,
   and unlike most other tagged data formats, has a
   trivially-specified canonical format suitable for hashing.)

   In descriptions of syntax below, we use regex-style qualifiers, so
   that in
        (sofa slipcover? occupant* leg+)
   the sofa will have an optional slipcover, zero or more occupants,
   and one or more legs.  This pattern matches (sofa leg) and (sofa
   slipcover occupant occupant leg leg leg leg) but not (sofa leg
   slipcover).

   We also use a braces notation to indicate elements that can occur
   in any order.  For example,
        (bread {flour+ eggs? yeast})
   matches a list starting with "bread", and then containing one or
   more  of flours, zero or one occurrences of eggs, and one
   occurrence of yeast, in any order.  This pattern matches (bread eggs
   yeast flour) but not (bread yeast) or (bread flour eggs yeast
   macadamias).

3.2. File formats: general principles

   We use tagged lists (lists whose first element is a string) to
   indicate typed objects.  Tags are generally lower-case, with
   hyphens used for separation.  Think Lispy.

   We use attrlists [lists of (key value) lists] to indicate a
   multimap from keys to values.  Clients MUST accept unrecognized
   keys in these attrlists.  The syntax for an attrlist with two
   recognized and required keys is typically given as ({(key1 val1)
   (key2 val2) (ATTR VAL)*}), indicating that the keys can occur in
   any order, intermixed with other attributes.

   Timestamp files will be downloaded very frequently; all other files
   will be much smaller in size than package files.  Thus,
   size-optimization for timestamp files makes sense and most other
   other space optimizations don't.

   Versions are represented as lists of the form (v I1 I2 I3 I4 ...)
   where each item is a number or alphanumeric version component.  For
   example, the version "0.2.1.5-alpha" is represented as (v 0 2 1 5
   alpha).

   All signed files are of the format:

       (signed
          X
          (signature ({(keyid K) (method M) (ATTR VAL)*}) SIG)+
       )

   where: X is a list whose first element describes the signed object.
          K is the identifier of a key signing the document
          M is the method to be used to make the signature
          (ATTR VAL) is an arbitrary list whose first element is a
             string.
          SIG is a signature of the canonical encoding of X using the
          identified key.

   We define two signing methods at present:
       sha256-oaep : A signature of the SHA256 hash of the canonical
         encoding of X, using OAEP+ padding. [XXXX say more about mgf]

   All times are given as strings of the format "YYYY-MM-DD HH:MM:SS",
   in UTC.

   All keys are of the format:
      (pubkey ({(type TYPE) (ATTR VAL)*}) KEYVAL)
   where TYPE is a string describing the type of the key and how it's
   used to sign documents.  The type determines the interpretation of
   KEYVAL.

   The ID of a key is the type field concatenated with the SHA-256
   hash of the canonical encoding of the KEYVAL field.

   We define one keytype at present: 'rsa'.  The KEYVAL in this case
   is a 2-element list of (e n), with both values given in big-endian
   binary format.  [This makes keys 45-60% more compact than using
   decimal integers.]

   All RSA keys must be at least 2048 bits long.


   Every role in the system is associated with a key.  Replacing
   anything but a root key is supposed to be relatively easy.

   Root-keys sign other keys, and certify them as belonging to roles.
   Clients are configured to know the root keys.

   Bundle keys certify the contents of a bundle.

   Package keys certify packages for a given program or set of
   programs.

   Mirror keys certify a list of mirrors.  We expect this to be an
   automated process.

   Timestamp keys certify that given versions of other metadata
   documents are up-to-date.  They are the only keys that absolutely
   need to be kept online.  (If they are not, timestamps won't be
   generated.)

3.3. File formats: key list

   The key list file is signed by multiple root keys.  It indicates
   which keys are authorized to sign which parts of the repository.

   (keylist
     (ts TIME)
     (keys
       ((key ({(roles (ROLE PATH)+) (ATTR VAL)*}) KEY)*)
     ...
   )

   The "ts" line describes when the keys file was updated.  Clients
   MUST NOT replace a file with an older one, and SHOULD NOT accept a
   file too far in the future.

   A ROLE is one of "timestamp" "mirrors" "bundle" or "package".

   PATH is a path relative to the top of the directory hierarchy.  It
   may contain "*" elements to indicate "any file", and may end with a
   "/**" element to indicate all files under a given point.

3.4. File formats: mirror list

   The mirror list is signed by a mirror key.  It indicates which
   mirrors are active and believed to be mirroring which parts of the
   repository.

   (mirrorlist
     (ts TIME)
     (mirrors
       ( (mirror ({(name N) (urlbase U) (contents PATH+) (weight W)
                   (official)?  (ATTR VAL)})) * )
     ...
  )

  Every mirror is a copy of some or all of the directory hierarchy
  containing at least the /meta, /bundles/, and /pkginfo directories.

  N is a descriptive name for the mirror; U is the URL of the mirror's
  base (i.e., the parent of the "meta" directory); and the PATH
  elements are the components describing how much of the packages
  directory is mirrored.  Their format is as in the keylist file.

  W is an integer used to weight mirrors when picking at random;
  mirrors with more bandwidth should have higher weigths.   The
  "official" element should only be present if the mirror is (one of
  the) official repositories operated by the Tor Project.

3.5. File formats: timestamp files

  The timestamp file is signed by a timestamp key.  It indicates the
  latest versions of other files, and contains a regularly updated
  timestamp to prevent rollback attacks.

  (ts
    ({(at TIME)
      (m TIME MIRRORLISTHASH)
      (k TIME KEYLISTHASH)
      (b NAME VERSION TIME PATH HASH)*})
  )

  TIME is when the timestamp was signed.  MIRRORLISTHASH is the digest
  of the mirror-list file; KEYLISTHASH is the digest of the key list
  file; and the 'b' entries are a list of the latest version of each
  bundles and their locations and hashes.

3.6. File formats: bundle files

  (bundle
    (at TIME)
    (os OS)
    [(arch ARCH)]
    (version V)
    (packages
      (NAME VERSION PATH HASH ({(order INST UPDATE REMOVE)
                                (optional)?
                                (gloss LANG TEXT)*
                                (longloss LANG TEXT)*
                                 (ATTR VAL)*})? )* )
  )

  Most elements are self-explanatory; the INST, UPDATE, and REMOVE
  elements of the order element are numbers defining the order in
  which the packages are installed, updated, and removed respectively.
  The "optional" element is present if the package is optional.
  "Gloss" is a short utf-8 human-readable string explaining what the
  package provides for the bundle; "longloss" is a longer such
  utf-8 string.

  (Note that the gloss strings are meant, not to describe the package,
  but to describe what the package provides for the bundle.  For
  example, "The Anonymous Email Bundle needs the Python Runtime to run
  Mixminion.")

  Multiple gloss strings are allowed; each should have a different
  language. The UI should display the must appropriate language to the
  user.

3.7. File formats: package files

  (package
    ({(name NAME)
     (version VERSION)
     (format FMT ((ATTR VAL)*)? )
     (path PATH)
     (ts TIME)
     (digest HASH)
     (shortdesc LANG TEXT)*
     (longdesc LANG TEXT)*
     (ATTR VAL)* })
  )

  Most elements are self-explanatory.  The "FMT" element describes the
  file format of the package, which should give enough information
  about how to install it.

  No two package files in the same repository should have the same
  name and version.  If a package needs to be changed, the version
  MUST be incremented.

  Descriptions are tagged with languages in the same way as glosses.

4. Detailed Workflows

4.1. The client application

  Periodically, the client updater fetches a timestamp file from a
  mirror.  If the timestamp in the file is up-to-date, the client
  first checks to see whether the keys file listed is one that the
  client has.  If not, the client fetches it, makes sure the hash of
  the keys file matches the hash in the timestamp file, makes sure its
  date is more recent than any keys file they have but not too far in
  the future, and that it is signed by enough root keys that the
  client recognizes.

       [If the timestamp file is not up-to-date, the client tries a
       few mirrors until it finds one with a good timestamp.]

       [If the keys file from a mirror does not match the timestamp
       file, the client tries a new mirror for both.]

       [If the keys file is not signed by enough root keys, the client
       warns the user and tries another mirror for both the timestamp
       file and the keys file.]

  Once the client has an up-to-date keys file, the client checks the
  signature on the timestamp file.  Assuming it checks out, the client
  refreshes the mirror list as needed, and refreshes any bundle files
  to which the user is subscribed if the client does not have
  the latest version of those files.  The client checks signatures on
  these files, and fetches package metadata for any packages listed in
  the bundle file that the client does not have, checks signatures on
  these, and fetches binaries for packages that might need to be
  installed or updated.  As the packages arrive, clients check their
  hashes.

  Once the client has gotten enough packages, it informs the user that
  new packages have arrived, and asks them if they want to update.

  Clients SHOULD cache at least the latest versions they have received
  of all files.

4.1.1. Download preferences

  Users should be able to specify that packages must be only
  downloaded over Tor, or must only be downloaded over encrypted
  protocols, or both.  Users should also be able to express preference
  for Tor vs non-Tor and encrypted vs non-encrypted, even if they
  allow both.

4.2. Mirrors

  Periodically, mirrors do an rsync or equivalent to fetch the latest
  version of whatever parts of the repository have changed since the
  version they currently hold.  Mirrors SHOULD replace older versions
  of the repository idempotently, so that clients are less likely to
  see inconsistent state.  Mirrors SHOULD validate the information
  they receive, and not serve partial or inconsistent files.

4.3. Workflow: Packagers

  When a new binary package is done, the person making the package
  runs a tool to generate and sign a package file, and sends both the
  package and the package file to a repository admin.  Typically, the
  base package file will be generated by inserting a version into a
  template.

  Packages MAY have as part of their build process a script to
  generate the appropriately versioned package file.  This script
  should at a minimum demand a build version, or use a timestamp in
  place of a build version, to prevent two packages with the same
  version from being created.

4.4. Workflow: bundlers

  When the packages in a bundle are done, the bundler runs a tool on
  the package files to generate and sign a bundle file.  Typically,
  this tool uses a template bundle file.

4.5. Workflow: repository administrators

  Repository administrators use a tool to validate signed files into the
  repository.  The repository should not be altered manually.

  This tool acts as follows:
     - Package files may be added, but never replaced.
     - Bundle files may be added, but never replaced.
     - No file may be added unless it is syntactically valid and
       signed by a key in the keys file authorized to sign files of
       this type in this file's location location.

     - A package file may not be added unless all of its binary
       packages match their hashes.

     - A bundle file may not be added unless all of its package files
       are present and match their hashes.

     - When adding a new keylist, bundle, or mirrors list, the
       timestamp file must be regenerated immediately.

5. Parameter setting and corner cases.

5.1. Timing

  The timestamp file SHOULD be regenerated every 15 minutes.  Mirrors
  SHOULD attempt to update every hour.  Clients SHOULD accept a
  timestamp file up to 6 hours old.

5.2. Format versioning and forward-compatibility:

  All of the above formats include the ability to add more
  attribute-value fields for backwards-compatible format changes.  If
  we need to make a backwards incompatible format change, we create a
  new filename for the new format.

5.3. Key management and migration:

  Root keys should be kept offline.  All keys except timestamp and
  mirror keys should be stored encrypted.

  All the formats above allow for multiple keys to sign a single
  document.  To replace a compromised root key, it suffices to sign
  keylist documents with both the compromised key and its replacement
  until all clients have updated to a new version of the autoupdater.

  To replace another key, it suffices to authorize the new key in the
  keylist.  Note that a new package or bundle key must re-sign and
  issue new versions of all packages or bundles it has generated.



F. Future directions and open questions

F.1. Package decomposition

  It would be neat to decouple existing packages.  Right now, we'd
  never want a windows user to have to fetch an openssl dll and Tor
  separately.  But if they're using an auto-update tool, it'd be
  pretty keen to have them not need to fetch a new openssl every time
  Tor has a bugfix.

F.2. Caching at Tor servers.

  See Tor Proposal number 127.

F.3. Support for more download methods

  Ozymandns, chunked downloads, and bittorrent would all be neat
  ideas.

F.4. Support for bogus clocks.

  Glider should have a user configurable "no, my clock is _supposed_
  to be wrong" mode, since lots of users seem to _like_ having their
  clocks in 1970 forever.

R. Ideas I'm rejecting for the moment

R.1. Considering recommended versions from Tor consensus directory documents

  This requires a working Tor to update Tor; that's not necessarily a
  great idea.

R.2. Integration with existing GPG signatures

  The OpenPGP signature and key format is so complicated that you'd
  have to be mad to touch it.


</body></email><email><emailId>20080808143405</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-08-08 14:34:05-0400</timestampReceived><subject>Re: First patch for proposal 121</subject><body>

On Wed, Aug 06, 2008 at 03:52:10PM +0200, Karsten Loesing wrote:
&gt; -----BEGIN PGP SIGNED MESSAGE-----
&gt; Hash: SHA1
&gt; 
&gt; Hi Nick,
&gt; 
&gt; as discussed on IRC I have started splitting up the implementation of
&gt; proposal 121 into smaller patches. I've come to the conclusion that four
&gt; main patches would be a good trade-off between patch size and number in
&gt; this case. There might be further, smaller patches afterwards, but these
&gt; four patches cover roughly everything to make proposal 121 work.
&gt; 
&gt; 1. This is the first patch that includes configuration of client
&gt; authorization on hidden-service side, but without actually using that
&gt; data when advertising hidden services.

Hi, Karsten!  I'm checking this in with some modifications and
questions, as noted below.  Please compare my patch to yours, and let
me know about anything I screwed up.

&gt; Index: /home/karsten/tor/tor-trunk/src/common/crypto.c
&gt; ===================================================================
&gt; --- /home/karsten/tor/tor-trunk/src/common/crypto.c	(revision 16440)
&gt; +++ /home/karsten/tor/tor-trunk/src/common/crypto.c	(working copy)
&gt; @@ -515,6 +515,47 @@
&gt;    return 0;
&gt;  }
&gt;  
&gt; +/** PEM-encode the private key portion of &lt;b&gt;env&lt;/b&gt; and write it to a
&gt; + * newly allocated string.  On success, set *&lt;b&gt;dest&lt;/b&gt; to the new
&gt; + * string, *&lt;b&gt;len&lt;/b&gt; to the string's length, and return 0.  On
&gt; + * failure, return -1.
&gt; + */
&gt; +int
&gt; +crypto_pk_write_private_key_to_string(crypto_pk_env_t *env, char **dest,
&gt; +                                     size_t *len)

This is mostly duplicate code with crypto_pk_write_public_key_to_string:
only one line is different between the two.  I've extracted the code
into a new static function that takes a flag, and replaced both
functions with calls to it.

Copy-and-paste coding like this is usually to be avoided, for several
reasons.  The most significant is that if there is a bug in the code,
or a feature we need to add to it, there are now two places that need
to be changed.


&gt; Index: /home/karsten/tor/tor-trunk/src/or/rendservice.c
&gt; ===================================================================
&gt; --- /home/karsten/tor/tor-trunk/src/or/rendservice.c	(revision 16440)
&gt; +++ /home/karsten/tor/tor-trunk/src/or/rendservice.c	(working copy)
&gt; @@ -47,6 +47,10 @@
&gt;    smartlist_t *ports; /**&lt; List of rend_service_port_config_t */
&gt;    int descriptor_version; /**&lt; Rendezvous descriptor version that will be
&gt;                             * published. */
&gt; +  int auth_type; /**&lt; Client authorization type or 0 if no client
&gt; +                  * authorization is performed. */

This should be an enumeration.  Using "0" to mean no authentication
and "1" to mean "key-based authentication" is a fine way for computers
to communicate, but it will make our code insane.

&gt; +  smartlist_t *clients; /**&lt; List of rend_authorized_client_t's of
&gt; +                         * clients that may access our service. */

Am I right in thinking this can be NULL?  If so, the doxygen comment
should probably mention that.

&gt;    /* Other fields */
&gt;    crypto_pk_env_t *private_key; /**&lt; Permanent hidden-service key. */
&gt;    char service_id[REND_SERVICE_ID_LEN_BASE32+1]; /**&lt; Onion address without
&gt; @@ -79,6 +83,18 @@
&gt;    return smartlist_len(rend_service_list);
&gt;  }
&gt;  
&gt; +/** Helper: free storage held by a single service authorized client entry. */
&gt; +static void
&gt; +rend_authorized_client_free(void *authorized_client)
&gt; +{

This should not take a void*.  We use it in a few contexts, and in all
but one of them, we're passing in a rend_authorized_client_t pointer.
Let's not undermine the compiler's typechecking facilities any more
than we must.


 [...]
&gt; +      if (smartlist_len(type_names_split) &gt; 2) {
&gt; +        log_warn(LD_CONFIG, "HiddenServiceAuthorizeClient contains "
&gt; +                            "illegal value '%s'. Must be formatted "
&gt; +                            "as 'HiddenServiceAuthorizeClient auth-type "
&gt; +                            "client-name,client-name,...' (without "
&gt; +                            "additional spaces in comma-separated client "
&gt; +                            "list).",

Why this requirement?


&gt; +      SMARTLIST_FOREACH_BEGIN(clients, char *, client_name)

This should be a "const char *".

&gt; +      {
&gt; +        rend_authorized_client_t *client;
&gt; +        size_t len = strlen(client_name);
&gt; +        int found_duplicate = 0;
&gt; +        if (len &lt; 1 || len &gt; 19) {
&gt; +          log_warn(LD_CONFIG, "HiddenServiceAuthorizeClient contains an "
&gt; +                              "illegal client name: '%s'. Length must be "
&gt; +                              "between 1 and 19 characters.",
&gt; +                   client_name);

Why 19?  The reason that server nicknames top out at 19 characters is
so that we can never confuse them for hex-encoded SHA-1 digests (which
are 20 characters).  Does this also apply to client names?

[Also, this maximum should be a constant.]


 [...]
&gt; +        /* Check if client name is duplicate. */
&gt; +        SMARTLIST_FOREACH(service-&gt;clients, rend_authorized_client_t *, c, {
&gt; +          if (!strcmp(c-&gt;client_name, client_name)) {
&gt; +            log_warn(LD_CONFIG, "HiddenServiceAuthorizeClient contains a "
&gt; +                     "duplicate client name: '%s'; ignoring.", client_name);
&gt; +            found_duplicate = 1;
&gt; +            break;
&gt; +          }
&gt; +        });

Ug.  This is O(N^2).  I suppose it won't matter for a while.

&gt; +        if (found_duplicate)
&gt; +          continue;
&gt; +        client = tor_malloc_zero(sizeof(rend_authorized_client_t));
&gt; +        client-&gt;client_name = strdup(client_name);

You mean "tor_strdup(client_name)".

&gt; +    /* If client authorization is configured, load or generate keys. */
&gt; +    if (s-&gt;auth_type) {
&gt; +      char *client_keys_str;
&gt; +      strmap_t *parsed_clients = strmap_new();
&gt; +      char cfname[512];
&gt; +
&gt; +      /* Load client keys and descriptor cookies, if available. */
&gt; +      if (strlcpy(cfname,s-&gt;directory,sizeof(cfname)) &gt;= sizeof(cfname) ||
&gt; +          strlcat(cfname,PATH_SEPARATOR"client_keys",sizeof(cfname))
&gt; +                                                      &gt;= sizeof(cfname)) {

tor_snprintf is usually more readable for this kind of thing.

&gt; +      /* Prepare client_keys and hostname files. */
&gt; +      if (write_str_to_file(cfname, "", 0) &lt; 0) {
&gt; +        log_warn(LD_CONFIG, "Could not clear client_keys file.");
&gt; +        strmap_free(parsed_clients, rend_authorized_client_free);
&gt; +        return -1;
&gt; +      }
&gt; +      if (write_str_to_file(fname, "", 0) &lt; 0) {
&gt; +        log_warn(LD_CONFIG, "Could not clear hostname file.");
&gt; +        strmap_free(parsed_clients, rend_authorized_client_free);
&gt; +        return -1;
&gt; +      }

This is really bad: If there's an error or crash or anything during
this step, then you'll have erased all the old keys.  Instead, you
want to open new files, write into them, and when you're done, replace
the old files with the new files.

Fortunately, Tor already has functions for doing this: see
start_writing_to_file() and friends in util.c.

 [...]
&gt; +            strmap_free(parsed_clients, rend_authorized_client_free);
&gt; +            return -1;

This is duplicated a _whole lot_.  When you have repeated cleanup
code, consider using a "goto err" pattern.


&gt; Index: /home/karsten/tor/tor-trunk/src/or/routerparse.c
&gt; ===================================================================
 [...]
&gt; @@ -2948,10 +2961,14 @@
&gt;      ebuf[sizeof(ebuf)-1] = '\0';
&gt;      RET_ERR(ebuf);
&gt;    }
&gt; -  if (!strcmp(tok-&gt;object_type, "RSA PUBLIC KEY")) { /* If it's a key... */
&gt; +  if (!strcmp(tok-&gt;object_type, "RSA PUBLIC KEY")) { /* If it's a public key */
&gt;      tok-&gt;key = crypto_new_pk_env();
&gt;      if (crypto_pk_read_public_key_from_string(tok-&gt;key, obstart, eol-obstart))
&gt;        RET_ERR("Couldn't parse public key.");
&gt; +  } else if (!strcmp(tok-&gt;object_type, "RSA PRIVATE KEY")) { /* private key */
&gt; +    tok-&gt;key = crypto_new_pk_env();
&gt; +    if (crypto_pk_read_private_key_from_string(tok-&gt;key, obstart))
&gt; +      RET_ERR("Couldn't parse private key.");

Nice thinking, but there's a problematic aspect: We do not want
private keys accepted in existing descriptors when currently only
public keys are accepted.  I've added a new NEED_SKEY_1024 to handle
this.

 [...]
&gt; +  /* Begin parsing with first entry, skipping comments or whitespace at the
&gt; +   * beginning. */

This skips *everything*, not just comments and whitespace.  Is that
really wise?

many thanks,
-- 
Nick
</body></email><email><emailId>20080808172458</emailId><senderName>Karsten Loesing</senderName><senderEmail>karsten.loesing@gmx.net</senderEmail><timestampReceived>2008-08-08 17:24:58-0400</timestampReceived><subject>Re: First patch for proposal 121</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Hi Nick,

|&gt; +  int auth_type; /**&lt; Client authorization type or 0 if no client
|&gt; +                  * authorization is performed. */
|
| This should be an enumeration.  Using "0" to mean no authentication
| and "1" to mean "key-based authentication" is a fine way for computers
| to communicate, but it will make our code insane.

Yes, right, an enumeration is better suited here.

The question is: should comparisons of this variable always be performed
with an enumeration constant? For example, should "if
(service-&gt;auth_type)" be changed to "if (service-&gt;auth_type !=
REND_NO_AUTH)"? (I changed it that way in the attached patch.)

And, at one place you explicitly converted the enumeration value to an
int before writing it to a log statement, but at another place you
didn't. Should this conversion be performed consistently in all places?

|&gt; +      if (smartlist_len(type_names_split) &gt; 2) {
|&gt; +        log_warn(LD_CONFIG, "HiddenServiceAuthorizeClient contains "
|&gt; +                            "illegal value '%s'. Must be formatted "
|&gt; +                            "as 'HiddenServiceAuthorizeClient
auth-type "
|&gt; +                            "client-name,client-name,...' (without "
|&gt; +                            "additional spaces in comma-separated
client "
|&gt; +                            "list).",
|
| Why this requirement?

You mean the requirement that there are no additional spaces in the
list? That can be relaxed. I'll add it to the second patch.

|&gt; +        if (len &lt; 1 || len &gt; 19) {
|&gt; +          log_warn(LD_CONFIG, "HiddenServiceAuthorizeClient contains
an "
|&gt; +                              "illegal client name: '%s'. Length
must be "
|&gt; +                              "between 1 and 19 characters.",
|&gt; +                   client_name);
|
| Why 19?  The reason that server nicknames top out at 19 characters is
| so that we can never confuse them for hex-encoded SHA-1 digests (which
| are 20 characters).  Does this also apply to client names?

No, there is no such reason with SHA-1 digests here. The limit of 19
characters is more or less arbitrary. There should be _some_ limit, or
the other way round, there is no need to use names of arbitrary length.
But it does not necessarily have to be 19. Maybe the 19 are even
confusing, because people might think that there is some relation to
node nicknames. Don't know. Suggestions?

|&gt; +        /* Check if client name is duplicate. */
|&gt; +        SMARTLIST_FOREACH(service-&gt;clients, rend_authorized_client_t
*, c, {
|&gt; +          if (!strcmp(c-&gt;client_name, client_name)) {
|&gt; +            log_warn(LD_CONFIG, "HiddenServiceAuthorizeClient
contains a "
|&gt; +                     "duplicate client name: '%s'; ignoring.",
client_name);
|&gt; +            found_duplicate = 1;
|&gt; +            break;
|&gt; +          }
|&gt; +        });
|
| Ug.  This is O(N^2).  I suppose it won't matter for a while.

Right. I'll have a second look at the other data structures that are
provided in Tor and find something more efficient (like putting all
strings in a set or map that discards duplicates and read them out
afterwards. That will also be included in the second patch.

|&gt; +  /* Begin parsing with first entry, skipping comments or whitespace
at the
|&gt; +   * beginning. */
|
| This skips *everything*, not just comments and whitespace.  Is that
| really wise?

Hmm, what would you suggest? The only thing I could imagine is to check
if there are non-comment, non-whitespace characters and warn/err on
that. Heh, and the other approach would be to change the comment.


Thanks a lot for these suggestions and for even implementing most of
them! :)

See the attached patch with some minor changes.

Thanks!
- --Karsten
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFInIFj0M+WPffBEmURAkcCAJ40UFUF7ivde7TpTJg3tDq0L3+6LACfRqjr
+6gYHDVxUeDH18tRA3hR4Qg=
=DdxU
-----END PGP SIGNATURE-----

["patch-121-1a.txt" (text/plain)]

Index: /home/karsten/tor/tor-trunk-121-patches/src/or/rendservice.c
===================================================================
--- /home/karsten/tor/tor-trunk-121-patches/src/or/rendservice.c	(revision 16477)
+++ /home/karsten/tor/tor-trunk-121-patches/src/or/rendservice.c	(working copy)
@@ -57,7 +57,8 @@
   rend_auth_type_t auth_type; /**&lt; Client authorization type or 0 if no client
                                * authorization is performed. */
   smartlist_t *clients; /**&lt; List of rend_authorized_client_t's of
-                         * clients that may access our service. */
+                         * clients that may access our service. Can be NULL
+                         * if no client authorization is peformed. */
   /* Other fields */
   crypto_pk_env_t *private_key; /**&lt; Permanent hidden-service key. */
   char service_id[REND_SERVICE_ID_LEN_BASE32+1]; /**&lt; Onion address without
@@ -181,7 +182,7 @@
     service-&gt;descriptor_version = 2; /* Versioned descriptor. */
   }
 
-  if (service-&gt;auth_type &amp;&amp; !service-&gt;descriptor_version) {
+  if (service-&gt;auth_type != REND_NO_AUTH &amp;&amp; !service-&gt;descriptor_version) {
     log_warn(LD_CONFIG, "Hidden service with client authorization and "
                         "version 0 descriptors configured; ignoring.");
     rend_service_free(service);
@@ -188,7 +189,8 @@
     return;
   }
 
-  if (service-&gt;auth_type &amp;&amp; smartlist_len(service-&gt;clients) == 0) {
+  if (service-&gt;auth_type != REND_NO_AUTH &amp;&amp;
+      smartlist_len(service-&gt;clients) == 0) {
     log_warn(LD_CONFIG, "Hidden service with client authorization but no "
                         "clients; ignoring.");
     rend_service_free(service);
@@ -329,7 +331,7 @@
        * of authorized clients. */
       smartlist_t *type_names_split, *clients;
       const char *authname;
-      if (service-&gt;auth_type) {
+      if (service-&gt;auth_type != REND_NO_AUTH) {
         log_warn(LD_CONFIG, "Got multiple HiddenServiceAuthorizeClient "
                  "lines for a single service.");
         rend_service_free(service);
@@ -363,7 +365,7 @@
       if (smartlist_len(type_names_split) &lt; 2) {
         log_warn(LD_CONFIG, "HiddenServiceAuthorizeClient contains "
                             "authorization type %d, but no client names.",
-                 service-&gt;auth_type);
+                 (int)service-&gt;auth_type);
         SMARTLIST_FOREACH(type_names_split, char *, cp, tor_free(cp));
         smartlist_free(type_names_split);
         continue;
@@ -583,7 +585,7 @@
     }
 
     /* If client authorization is configured, load or generate keys. */
-    if (s-&gt;auth_type) {
+    if (s-&gt;auth_type != REND_NO_AUTH) {
       char *client_keys_str = NULL;
       strmap_t *parsed_clients = strmap_new();
       char cfname[512];
@@ -676,7 +678,6 @@
         if (written &lt; 0) {
           log_warn(LD_BUG, "Could not write client entry.");
           goto err;
-
         }
         if (client-&gt;client_key) {
           char *client_key_out;
@@ -710,7 +711,8 @@
           char extended_desc_cookie[REND_DESC_COOKIE_LEN+1];
           memcpy(extended_desc_cookie, client-&gt;descriptor_cookie,
                  REND_DESC_COOKIE_LEN);
-          extended_desc_cookie[REND_DESC_COOKIE_LEN] = (s-&gt;auth_type - 1) &lt;&lt; 4;
+          extended_desc_cookie[REND_DESC_COOKIE_LEN] =
+              ((int)s-&gt;auth_type - 1) &lt;&lt; 4;
           if (base64_encode(desc_cook_out, 3*REND_DESC_COOKIE_LEN_BASE64+1,
                             extended_desc_cookie,
                             REND_DESC_COOKIE_LEN+1) &lt; 0) {


["patch-121-1a.txt.sig" (application/octet-stream)]

</body></email><email><emailId>20080808193103</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-08-08 19:31:03-0400</timestampReceived><subject>Re: First patch for proposal 121</subject><body>

On Fri, Aug 08, 2008 at 07:24:58PM +0200, Karsten Loesing wrote:
&gt; -----BEGIN PGP SIGNED MESSAGE-----
&gt; Hash: SHA1
&gt; 
&gt; Hi Nick,
&gt; 
&gt; |&gt; +  int auth_type; /**&lt; Client authorization type or 0 if no client
&gt; |&gt; +                  * authorization is performed. */
&gt; |
&gt; | This should be an enumeration.  Using "0" to mean no authentication
&gt; | and "1" to mean "key-based authentication" is a fine way for computers
&gt; | to communicate, but it will make our code insane.
&gt; 
&gt; Yes, right, an enumeration is better suited here.
&gt; 
&gt; The question is: should comparisons of this variable always be performed
&gt; with an enumeration constant? For example, should "if
&gt; (service-&gt;auth_type)" be changed to "if (service-&gt;auth_type !=
&gt; REND_NO_AUTH)"? (I changed it that way in the attached patch.)

That's fine.  I personally think having 0 mean "NO_AUTH" is on the
okay side of good taste, but having NO_AUTH mean NO_AUTH is even
better. :)

&gt; And, at one place you explicitly converted the enumeration value to an
&gt; int before writing it to a log statement, but at another place you
&gt; didn't. Should this conversion be performed consistently in all places?

Ideally, it shouldn't be an integer, but rather converted back to a
string. for logging.

&gt; |&gt; +      if (smartlist_len(type_names_split) &gt; 2) {
&gt; |&gt; +        log_warn(LD_CONFIG, "HiddenServiceAuthorizeClient contains "
&gt; |&gt; +                            "illegal value '%s'. Must be formatted "
&gt; |&gt; +                            "as 'HiddenServiceAuthorizeClient
&gt; auth-type "
&gt; |&gt; +                            "client-name,client-name,...' (without "
&gt; |&gt; +                            "additional spaces in comma-separated
&gt; client "
&gt; |&gt; +                            "list).",
&gt; |
&gt; | Why this requirement?
&gt; 
&gt; You mean the requirement that there are no additional spaces in the
&gt; list? That can be relaxed. I'll add it to the second patch.

Great.

&gt; |&gt; +        if (len &lt; 1 || len &gt; 19) {
&gt; |&gt; +          log_warn(LD_CONFIG, "HiddenServiceAuthorizeClient contains
&gt; an "
&gt; |&gt; +                              "illegal client name: '%s'. Length
&gt; must be "
&gt; |&gt; +                              "between 1 and 19 characters.",
&gt; |&gt; +                   client_name);
&gt; |
&gt; | Why 19?  The reason that server nicknames top out at 19 characters is
&gt; | so that we can never confuse them for hex-encoded SHA-1 digests (which
&gt; | are 20 characters).  Does this also apply to client names?
&gt; 
&gt; No, there is no such reason with SHA-1 digests here. The limit of 19
&gt; characters is more or less arbitrary. There should be _some_ limit, or
&gt; the other way round, there is no need to use names of arbitrary length.
&gt; But it does not necessarily have to be 19. Maybe the 19 are even
&gt; confusing, because people might think that there is some relation to
&gt; node nicknames. Don't know. Suggestions?

Let's go with an arbitrarily chosen power of 2 (16 or 32 seem
attractive colors for a bikeshed today), and make a #define for it,
and call ourselves done.

&gt; |&gt; +        /* Check if client name is duplicate. */
&gt; |&gt; +        SMARTLIST_FOREACH(service-&gt;clients, rend_authorized_client_t
&gt; *, c, {
&gt; |&gt; +          if (!strcmp(c-&gt;client_name, client_name)) {
&gt; |&gt; +            log_warn(LD_CONFIG, "HiddenServiceAuthorizeClient
&gt; contains a "
&gt; |&gt; +                     "duplicate client name: '%s'; ignoring.",
&gt; client_name);
&gt; |&gt; +            found_duplicate = 1;
&gt; |&gt; +            break;
&gt; |&gt; +          }
&gt; |&gt; +        });
&gt; |
&gt; | Ug.  This is O(N^2).  I suppose it won't matter for a while.
&gt; 
&gt; Right. I'll have a second look at the other data structures that are
&gt; provided in Tor and find something more efficient (like putting all
&gt; strings in a set or map that discards duplicates and read them out
&gt; afterwards. That will also be included in the second patch.

Keen.
 
&gt; |&gt; +  /* Begin parsing with first entry, skipping comments or whitespace
&gt; at the
&gt; |&gt; +   * beginning. */
&gt; |
&gt; | This skips *everything*, not just comments and whitespace.  Is that
&gt; | really wise?
&gt; 
&gt; Hmm, what would you suggest? The only thing I could imagine is to check
&gt; if there are non-comment, non-whitespace characters and warn/err on
&gt; that. Heh, and the other approach would be to change the comment.

I think disallowing non-whitespace data is the best here.  It's in a
descriptor IIUC, so no comments should really be expected or allowed.

Another note on this part of the code: strstr(ckstr, "client-name ")
will match lines that have "client-name" in the *middle* of the line
too.  That is really not at all what you want.

yrs,
-- 
Nick
</body></email><email><emailId>20080612205614</emailId><senderName>Geoffrey Goodell</senderName><senderEmail>goodell@eecs.harvard.edu</senderEmail><timestampReceived>2008-06-12 20:56:14-0400</timestampReceived><subject>Re: Proposal: remove down routers from consensus</subject><body>


Suggest that instead of removing routers that are not running, we simply
remove routers for which we do not have descriptors in dir/server/all.
Does this make sense?

Geoff

On Thu, Jun 12, 2008 at 10:28:41PM +0200, Peter Palfrader wrote:
&gt; This is a pretty low hanging fruit and part of the job to make tor
&gt; bootstrap faster even if your bandwidth is really small.
&gt; 
&gt; 
&gt; Filename: xxx-remove-down-routers-from-consensus
&gt; Title: Remove routers that are not Running from consensus documents
&gt; Version: $Revision$
&gt; Last-Modified: $Date$
&gt; Author: Peter Palfrader
&gt; Created: 11-Jun-2008
&gt; Status: Open
&gt; 
&gt; 1. Overview.
&gt; 
&gt;   Tor directory authorities hourly vote and agree on a consensus document
&gt;   which lists all the routers on the network together with some of their
&gt;   basic properties, like if a router is an exit node, whether it is
&gt;   stable or whether it is a version 2 directory mirror.
&gt; 
&gt;   One of the properties given with each router is the 'Running' flag.
&gt;   Clients do not use routers that are not listed as running.
&gt; 
&gt;   This proposal suggests that routers without the Running flag are not
&gt;   listed at all.
&gt; 
&gt; 2. Current status
&gt; 
&gt;   At a typical bootstrap a client downloads a 140KB consensus, about
&gt;   10KB of certificates to verify that consensus, and about 1.6MB of
&gt;   server descriptors, about half of which it requires before it will
&gt;   start building circuits.
&gt; 
&gt;   Another proposal deals with how to get that huge 1.6MB fraction to
&gt;   effectively zero (by downloading only individual descriptors, on
&gt;   demand).  Should that get successfully implemented that will leave the
&gt;   140KB compressed consensus as a large fraction of what a client needs
&gt;   to get in order to work.
&gt; 
&gt;   About one third of the routers listed in a consensus are not running
&gt;   and will therefor never be used by clients who use this consensus.
&gt;   Not listing those routers will safe about 30% to 40% in size.
&gt; 
&gt; 3. Proposed change
&gt; 
&gt;   Authority directory servers produce vote documents that include all
&gt;   the servers they know about, running or not, like they currently
&gt;   do.  In addition these vote documents also state that the authority
&gt;   supports a new consensus forming method (method number 4).
&gt; 
&gt;   If more than two thirds of votes that an authority has received claim
&gt;   they support method 4 then this new method will be used:  The
&gt;   consensus document is formed like before but a new last step removes
&gt;   all routers from the listing that are not marked as Running.
&gt; 

["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20080906002709</emailId><senderName>Karsten Loesing</senderName><senderEmail>karsten.loesing@gmx.net</senderEmail><timestampReceived>2008-09-06 00:27:09-0400</timestampReceived><subject>Re: Fourth patch for proposal 121</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Hi Nick,

this patch 4a now contains two more changes as discussed on IRC:

1. The signatures of directory_initiate_command_routerstatus() and
directory_initiate_command() are left unchanged. Therefore there are now
two more functions especially for hidden service requests ending in _rend().

2. The various connection and circuit structs don't reserve memory for
hidden service requests any more. Now there is a new struct rend_data_t
that holds all hidden-service-specific data and that is pointed to by
those data structures. I also moved the memory for storing rendezvous
cookie and hidden service identifier on service side to that new struct.

- --Karsten
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFIwc5Z0M+WPffBEmURAgagAKDZaxqitFPpJQStmyIaiSWlaoHmsgCcDGpA
2SehaefYfaZxqbn20GyEVa0=
=ciyq
-----END PGP SIGNATURE-----

["patch-121-4a.txt" (text/plain)]

Index: /home/karsten/tor/tor-trunk-121-patches/doc/tor.1.in
===================================================================
--- /home/karsten/tor/tor-trunk-121-patches/doc/tor.1.in	(revision 16785)
+++ /home/karsten/tor/tor-trunk-121-patches/doc/tor.1.in	(working copy)
@@ -472,6 +472,15 @@
 ReachableAddresses instead. (Default: 80, 443)
 .LP
 .TP
+\fBHidServAuth \fR\fIonion-address\fR \fIauth-cookie\fP \fIservice-name\fR 
+Client authorization for a hidden service. Valid onion addresses contain 16
+characters in a-z2-7 plus ".onion", and valid auth cookies contain 22
+characters in A-Za-z0-9+/. The service name is only used for internal
+purposes, e.g., for Tor controllers. This option may be used multiple times
+for different hidden services. If a hidden service uses authorization and
+this option is not set, the hidden service is not accessible.
+.LP
+.TP
 \fBReachableAddresses \fR\fIADDR\fP[\fB/\fP\fIMASK\fP][:\fIPORT\fP]...\fP
 A comma-separated list of IP addresses and ports that your firewall allows you
 to connect to. The format is as
@@ -1268,6 +1277,18 @@
 service. Possible version numbers are 0 and 2. (Default: 0, 2)
 .LP
 .TP
+\fBHiddenServiceAuthorizeClient \fR\fIauth-type\fR \fR\fIclient-name\fR,\fIclient-name\fR,\fI...\fP
+If configured, the hidden service is accessible for authorized clients
+only. The auth-type can either be 'basic' for a general-purpose
+authorization protocol or 'stealth' for a less scalable protocol that also
+hides service activity from unauthorized clients. Only clients that are
+listed here are authorized to access the hidden service. Valid client names
+are 1 to 19 characters long and only use characters in A-Za-z0-9+-_
+(no spaces). If this option is set, the hidden service is not accessible
+for clients without authorization any more. Generated authorization data
+can be found in the hostname file.
+.LP
+.TP
 \fBRendPostPeriod \fR\fIN\fR \fBseconds\fR|\fBminutes\fR|\fBhours\fR|\fBdays\fR|\fBweeks\fP
 Every time the specified period elapses, Tor uploads any rendezvous
 service descriptors to the directory servers.  This information is also
@@ -1452,6 +1473,8 @@
 .TP
 .B \fIHiddenServiceDirectory\fP/hostname 
 The &lt;base32-encoded-fingerprint&gt;.onion domain name for this hidden service.
+If the hidden service is restricted to authorized clients only, this file
+also contains authorization data for all clients.
 .LP
 .TP
 .B \fIHiddenServiceDirectory\fP/private_key 
@@ -1456,6 +1479,11 @@
 .TP
 .B \fIHiddenServiceDirectory\fP/private_key 
 The private key for this hidden service.
+.LP
+.TP
+.B \fIHiddenServiceDirectory\fP/client_keys 
+Authorization data for a hidden service that is only accessible by authorized
+clients.
 .SH SEE ALSO
 .BR privoxy (1),
 .BR tsocks (1),
Index: /home/karsten/tor/tor-trunk-121-patches/src/or/circuitlist.c
===================================================================
--- /home/karsten/tor/tor-trunk-121-patches/src/or/circuitlist.c	(revision 16785)
+++ /home/karsten/tor/tor-trunk-121-patches/src/or/circuitlist.c	(working copy)
@@ -401,6 +401,7 @@
     circuit_free_cpath(ocirc-&gt;cpath);
     if (ocirc-&gt;intro_key)
       crypto_free_pk_env(ocirc-&gt;intro_key);
+    tor_free(ocirc-&gt;rend_data);
 
   } else {
     or_circuit_t *ocirc = TO_OR_CIRCUIT(circ);
@@ -720,7 +721,7 @@
 }
 
 /** Return a circ such that:
- *  - circ-\&gt;rend_query is equal to &lt;b&gt;rend_query&lt;/b&gt;, and
+ *  - circ-\&gt;rend_data-\&gt;query is equal to &lt;b&gt;rend_query&lt;/b&gt;, and
  *  - circ-\&gt;purpose is equal to &lt;b&gt;purpose&lt;/b&gt;.
  *
  * Return NULL if no such circuit exists.
@@ -735,7 +736,9 @@
   for (circ = global_circuitlist; circ; circ = circ-&gt;next) {
     if (!circ-&gt;marked_for_close &amp;&amp;
         circ-&gt;purpose == purpose &amp;&amp;
-        !rend_cmp_service_ids(rend_query, TO_ORIGIN_CIRCUIT(circ)-&gt;rend_query))
+        TO_ORIGIN_CIRCUIT(circ)-&gt;rend_data &amp;&amp;
+        !rend_cmp_service_ids(rend_query,
+                    TO_ORIGIN_CIRCUIT(circ)-&gt;rend_data-&gt;onion_address))
       return TO_ORIGIN_CIRCUIT(circ);
   }
   return NULL;
@@ -764,7 +767,8 @@
       continue;
     if (!digest)
       return TO_ORIGIN_CIRCUIT(circ);
-    else if (!memcmp(TO_ORIGIN_CIRCUIT(circ)-&gt;rend_pk_digest,
+    else if (TO_ORIGIN_CIRCUIT(circ)-&gt;rend_data &amp;&amp;
+             !memcmp(TO_ORIGIN_CIRCUIT(circ)-&gt;rend_data-&gt;rend_pk_digest,
                      digest, DIGEST_LEN))
       return TO_ORIGIN_CIRCUIT(circ);
   }
@@ -1020,13 +1024,14 @@
     origin_circuit_t *ocirc = TO_ORIGIN_CIRCUIT(circ);
     tor_assert(circ-&gt;state == CIRCUIT_STATE_OPEN);
     tor_assert(ocirc-&gt;build_state-&gt;chosen_exit);
+    tor_assert(ocirc-&gt;rend_data);
     /* treat this like getting a nack from it */
     log_info(LD_REND, "Failed intro circ %s to %s (awaiting ack). "
              "Removing from descriptor.",
-             safe_str(ocirc-&gt;rend_query),
+             safe_str(ocirc-&gt;rend_data-&gt;onion_address),
              safe_str(build_state_get_exit_nickname(ocirc-&gt;build_state)));
     rend_client_remove_intro_point(ocirc-&gt;build_state-&gt;chosen_exit,
-                                   ocirc-&gt;rend_query);
+                                   ocirc-&gt;rend_data);
   }
   if (circ-&gt;n_conn)
     connection_or_send_destroy(circ-&gt;n_circ_id, circ-&gt;n_conn, reason);
Index: /home/karsten/tor/tor-trunk-121-patches/src/or/circuituse.c
===================================================================
--- /home/karsten/tor/tor-trunk-121-patches/src/or/circuituse.c	(revision 16785)
+++ /home/karsten/tor/tor-trunk-121-patches/src/or/circuituse.c	(working copy)
@@ -121,8 +121,11 @@
       return 0;
     }
   } else { /* not general */
-    if (rend_cmp_service_ids(conn-&gt;rend_query,
-                             TO_ORIGIN_CIRCUIT(circ)-&gt;rend_query)) {
+    if ((conn-&gt;rend_data &amp;&amp; !TO_ORIGIN_CIRCUIT(circ)-&gt;rend_data) ||
+        (!conn-&gt;rend_data &amp;&amp; TO_ORIGIN_CIRCUIT(circ)-&gt;rend_data) ||
+        (conn-&gt;rend_data &amp;&amp; TO_ORIGIN_CIRCUIT(circ)-&gt;rend_data &amp;&amp;
+         rend_cmp_service_ids(conn-&gt;rend_data-&gt;onion_address,
+             TO_ORIGIN_CIRCUIT(circ)-&gt;rend_data-&gt;onion_address))) {
       /* this circ is not for this conn */
       return 0;
     }
@@ -272,7 +275,7 @@
           /* c_rend_ready circs measure age since timestamp_dirty,
            * because that's set when they switch purposes
            */
-          if (TO_ORIGIN_CIRCUIT(victim)-&gt;rend_query[0] ||
+          if (TO_ORIGIN_CIRCUIT(victim)-&gt;rend_data ||
               victim-&gt;timestamp_dirty &gt; cutoff)
             continue;
           break;
@@ -1051,13 +1054,18 @@
 
     if (desired_circuit_purpose == CIRCUIT_PURPOSE_C_INTRODUCE_ACK_WAIT) {
       /* need to pick an intro point */
-      extend_info = rend_client_get_random_intro(conn-&gt;rend_query);
+      tor_assert(conn-&gt;rend_data);
+      extend_info = rend_client_get_random_intro(conn-&gt;rend_data);
       if (!extend_info) {
         log_info(LD_REND,
                  "No intro points for '%s': refetching service descriptor.",
-                 safe_str(conn-&gt;rend_query));
-        rend_client_refetch_renddesc(conn-&gt;rend_query);
-        rend_client_refetch_v2_renddesc(conn-&gt;rend_query);
+                 safe_str(conn-&gt;rend_data-&gt;onion_address));
+        /* Fetch both, v0 and v2 rend descriptors in parallel. Use whichever
+         * arrives first. Exception: When using client authorization, only
+         * fetch v2 descriptors.*/
+        rend_client_refetch_v2_renddesc(conn-&gt;rend_data);
+        if (conn-&gt;rend_data-&gt;auth_type == REND_NO_AUTH)
+          rend_client_refetch_renddesc(conn-&gt;rend_data-&gt;onion_address);
         conn-&gt;_base.state = AP_CONN_STATE_RENDDESC_WAIT;
         return 0;
       }
@@ -1062,7 +1070,8 @@
         return 0;
       }
       log_info(LD_REND,"Chose '%s' as intro point for '%s'.",
-               extend_info-&gt;nickname, safe_str(conn-&gt;rend_query));
+               extend_info-&gt;nickname,
+               safe_str(conn-&gt;rend_data-&gt;onion_address));
     }
 
     /* If we have specified a particular exit node for our
@@ -1138,7 +1147,7 @@
       rep_hist_note_used_internal(time(NULL), need_uptime, 1);
       if (circ) {
         /* write the service_id into circ */
-        strlcpy(circ-&gt;rend_query, conn-&gt;rend_query, sizeof(circ-&gt;rend_query));
+        circ-&gt;rend_data = rend_data_dup(conn-&gt;rend_data);
         if (circ-&gt;_base.purpose == CIRCUIT_PURPOSE_C_ESTABLISH_REND &amp;&amp;
             circ-&gt;_base.state == CIRCUIT_STATE_OPEN)
           rend_client_rendcirc_has_opened(circ);
Index: /home/karsten/tor/tor-trunk-121-patches/src/or/connection.c
===================================================================
--- /home/karsten/tor/tor-trunk-121-patches/src/or/connection.c	(revision 16785)
+++ /home/karsten/tor/tor-trunk-121-patches/src/or/connection.c	(working copy)
@@ -384,6 +384,7 @@
       memset(edge_conn-&gt;socks_request, 0xcc, sizeof(socks_request_t));
       tor_free(edge_conn-&gt;socks_request);
     }
+    tor_free(edge_conn-&gt;rend_data);
   }
   if (conn-&gt;type == CONN_TYPE_CONTROL) {
     control_connection_t *control_conn = TO_CONTROL_CONN(conn);
@@ -404,6 +405,7 @@
     }
     if (dir_conn-&gt;cached_dir)
       cached_dir_decref(dir_conn-&gt;cached_dir);
+    tor_free(dir_conn-&gt;rend_data);
   }
 
   if (conn-&gt;s &gt;= 0) {
@@ -522,8 +524,9 @@
          * failed: forget about this router, and maybe try again. */
         connection_dir_request_failed(dir_conn);
       }
-      if (conn-&gt;purpose == DIR_PURPOSE_FETCH_RENDDESC)
-        rend_client_desc_here(dir_conn-&gt;rend_query); /* give it a try */
+      if (conn-&gt;purpose == DIR_PURPOSE_FETCH_RENDDESC &amp;&amp; dir_conn-&gt;rend_data)
+        /* give it a try */
+        rend_client_desc_here(dir_conn-&gt;rend_data-&gt;onion_address);
       /* If we were trying to fetch a v2 rend desc and did not succeed,
        * retry as needed. (If a fetch is successful, the connection state
        * is changed to DIR_PURPOSE_HAS_FETCHED_RENDDESC to mark that
@@ -528,10 +531,11 @@
        * retry as needed. (If a fetch is successful, the connection state
        * is changed to DIR_PURPOSE_HAS_FETCHED_RENDDESC to mark that
        * refetching is unnecessary.) */
-       if (conn-&gt;purpose == DIR_PURPOSE_FETCH_RENDDESC_V2 &amp;&amp;
-           dir_conn-&gt;rend_query &amp;&amp;
-           strlen(dir_conn-&gt;rend_query) == REND_SERVICE_ID_LEN_BASE32)
-        rend_client_refetch_v2_renddesc(dir_conn-&gt;rend_query);
+      if (conn-&gt;purpose == DIR_PURPOSE_FETCH_RENDDESC_V2 &amp;&amp;
+          dir_conn-&gt;rend_data &amp;&amp; dir_conn-&gt;rend_data-&gt;onion_address &amp;&amp;
+          strlen(dir_conn-&gt;rend_data-&gt;onion_address) ==
+              REND_SERVICE_ID_LEN_BASE32)
+        rend_client_refetch_v2_renddesc(dir_conn-&gt;rend_data);
       break;
     case CONN_TYPE_OR:
       or_conn = TO_OR_CONN(conn);
@@ -2558,6 +2562,7 @@
 
   tor_assert(type == CONN_TYPE_DIR ||
              type == CONN_TYPE_AP || type == CONN_TYPE_EXIT);
+  tor_assert(rendquery);
 
   SMARTLIST_FOREACH(conns, connection_t *, conn,
   {
@@ -2565,12 +2570,16 @@
         !conn-&gt;marked_for_close &amp;&amp;
         (!state || state == conn-&gt;state)) {
       if (type == CONN_TYPE_DIR &amp;&amp;
+          TO_DIR_CONN(conn)-&gt;rend_data &amp;&amp;
           (rendversion &lt; 0 ||
-           rendversion == TO_DIR_CONN(conn)-&gt;rend_version) &amp;&amp;
-          !rend_cmp_service_ids(rendquery, TO_DIR_CONN(conn)-&gt;rend_query))
+           rendversion == TO_DIR_CONN(conn)-&gt;rend_data-&gt;rend_desc_version) &amp;&amp;
+          !rend_cmp_service_ids(rendquery,
+                    TO_DIR_CONN(conn)-&gt;rend_data-&gt;onion_address))
         return conn;
       else if (CONN_IS_EDGE(conn) &amp;&amp;
-              !rend_cmp_service_ids(rendquery, TO_EDGE_CONN(conn)-&gt;rend_query))
+               TO_DIR_CONN(conn)-&gt;rend_data &amp;&amp;
+              !rend_cmp_service_ids(rendquery,
+                        TO_EDGE_CONN(conn)-&gt;rend_data-&gt;onion_address))
         return conn;
     }
   });
Index: /home/karsten/tor/tor-trunk-121-patches/src/or/connection_edge.c
===================================================================
--- /home/karsten/tor/tor-trunk-121-patches/src/or/connection_edge.c	(revision 16785)
+++ /home/karsten/tor/tor-trunk-121-patches/src/or/connection_edge.c	(working copy)
@@ -1587,6 +1587,7 @@
     /* it's a hidden-service request */
     rend_cache_entry_t *entry;
     int r;
+    rend_service_authorization_t *client_auth;
     tor_assert(!automap);
     if (SOCKS_COMMAND_IS_RESOLVE(socks-&gt;command)) {
       /* if it's a resolve request, fail it right now, rather than
@@ -1608,14 +1609,16 @@
       return -1;
     }
 
-    strlcpy(conn-&gt;rend_query, socks-&gt;address, sizeof(conn-&gt;rend_query));
+    conn-&gt;rend_data = tor_malloc_zero(sizeof(rend_data_t));
+    strlcpy(conn-&gt;rend_data-&gt;onion_address, socks-&gt;address,
+            sizeof(conn-&gt;rend_data-&gt;onion_address));
     log_info(LD_REND,"Got a hidden service request for ID '%s'",
-             safe_str(conn-&gt;rend_query));
+             safe_str(conn-&gt;rend_data-&gt;onion_address));
     /* see if we already have it cached */
-    r = rend_cache_lookup_entry(conn-&gt;rend_query, -1, &amp;entry);
+    r = rend_cache_lookup_entry(conn-&gt;rend_data-&gt;onion_address, -1, &amp;entry);
     if (r&lt;0) {
       log_warn(LD_BUG,"Invalid service name '%s'",
-               safe_str(conn-&gt;rend_query));
+               safe_str(socks-&gt;address));
       connection_mark_unattached_ap(conn, END_STREAM_REASON_TORPROTOCOL);
       return -1;
     }
@@ -1624,14 +1627,26 @@
      * a stable circuit yet, but we know we'll need *something*. */
     rep_hist_note_used_internal(now, 0, 1);
 
+    /* Look up if we have client authorization for it. */
+    client_auth = rend_client_lookup_service_authorization(
+                                          conn-&gt;rend_data-&gt;onion_address);
+    if (client_auth) {
+      log_info(LD_REND, "Using previously configured client authorization "
+                        "for hidden service request.");
+      memcpy(conn-&gt;rend_data-&gt;descriptor_cookie,
+             client_auth-&gt;descriptor_cookie, REND_DESC_COOKIE_LEN);
+      conn-&gt;rend_data-&gt;auth_type = client_auth-&gt;auth_type;
+    }
     if (r==0) {
       conn-&gt;_base.state = AP_CONN_STATE_RENDDESC_WAIT;
       log_info(LD_REND, "Unknown descriptor %s. Fetching.",
-               safe_str(conn-&gt;rend_query));
+               safe_str(conn-&gt;rend_data-&gt;onion_address));
       /* Fetch both, v0 and v2 rend descriptors in parallel. Use whichever
-       * arrives first. */
-      rend_client_refetch_v2_renddesc(conn-&gt;rend_query);
-      rend_client_refetch_renddesc(conn-&gt;rend_query);
+       * arrives first. Exception: When using client authorization, only
+       * fetch v2 descriptors.*/
+      rend_client_refetch_v2_renddesc(conn-&gt;rend_data);
+      if (conn-&gt;rend_data-&gt;auth_type == REND_NO_AUTH)
+        rend_client_refetch_renddesc(conn-&gt;rend_data-&gt;onion_address);
     } else { /* r &gt; 0 */
 /** How long after we receive a hidden service descriptor do we consider
  * it valid? */
@@ -1647,11 +1662,13 @@
       } else {
         conn-&gt;_base.state = AP_CONN_STATE_RENDDESC_WAIT;
         log_info(LD_REND, "Stale descriptor %s. Refetching.",
-                 safe_str(conn-&gt;rend_query));
+                 safe_str(conn-&gt;rend_data-&gt;onion_address));
         /* Fetch both, v0 and v2 rend descriptors in parallel. Use whichever
-         * arrives first. */
-        rend_client_refetch_v2_renddesc(conn-&gt;rend_query);
-        rend_client_refetch_renddesc(conn-&gt;rend_query);
+         * arrives first. Exception: When using client authorization, only
+         * fetch v2 descriptors.*/
+        rend_client_refetch_v2_renddesc(conn-&gt;rend_data);
+        if (conn-&gt;rend_data-&gt;auth_type == REND_NO_AUTH)
+          rend_client_refetch_renddesc(conn-&gt;rend_data-&gt;onion_address);
       }
     }
     return 0;
@@ -2531,8 +2548,7 @@
     log_info(LD_REND,"begin is for rendezvous. configuring stream.");
     n_stream-&gt;_base.address = tor_strdup("(rendezvous)");
     n_stream-&gt;_base.state = EXIT_CONN_STATE_CONNECTING;
-    strlcpy(n_stream-&gt;rend_query, origin_circ-&gt;rend_query,
-            sizeof(n_stream-&gt;rend_query));
+    n_stream-&gt;rend_data = rend_data_dup(origin_circ-&gt;rend_data);
     tor_assert(connection_edge_is_rendezvous_stream(n_stream));
     assert_circuit_ok(circ);
     if (rend_service_set_connection_addr_port(n_stream, origin_circ) &lt; 0) {
@@ -2815,7 +2831,7 @@
 connection_edge_is_rendezvous_stream(edge_connection_t *conn)
 {
   tor_assert(conn);
-  if (*conn-&gt;rend_query) /* XXX */ /* XXXX Why is this XXX? -NM */
+  if (conn-&gt;rend_data) /* XXX */ /* XXXX Why is this XXX? -NM */
     return 1;
   return 0;
 }
Index: /home/karsten/tor/tor-trunk-121-patches/src/or/directory.c
===================================================================
--- /home/karsten/tor/tor-trunk-121-patches/src/or/directory.c	(revision 16785)
+++ /home/karsten/tor/tor-trunk-121-patches/src/or/directory.c	(working copy)
@@ -60,6 +60,22 @@
 static void note_client_request(int purpose, int compressed, size_t bytes);
 static int client_likes_consensus(networkstatus_t *v, const char *want_url);
 
+static void directory_initiate_command_rend(const char *address,
+                                            const tor_addr_t *addr,
+                                            uint16_t or_port,
+                                            uint16_t dir_port,
+                                            int supports_conditional_consensus,
+                                            int supports_begindir,
+                                            const char *digest,
+                                            uint8_t dir_purpose,
+                                            uint8_t router_purpose,
+                                            int anonymized_connection,
+                                            const char *resource,
+                                            const char *payload,
+                                            size_t payload_len,
+                                            time_t if_modified_since,
+                                            rend_data_t *rend_query);
+
 /********* START VARIABLES **********/
 
 /** How far in the future do we allow a directory server to tell us it is
@@ -434,6 +450,43 @@
     });
 }
 
+/** Same as directory_initiate_command_routerstatus(), but accepts
+ * rendezvous data to fetch a hidden service descriptor. */
+void
+directory_initiate_command_routerstatus_rend(routerstatus_t *status,
+                                             uint8_t dir_purpose,
+                                             uint8_t router_purpose,
+                                             int anonymized_connection,
+                                             const char *resource,
+                                             const char *payload,
+                                             size_t payload_len,
+                                             time_t if_modified_since,
+                                             rend_data_t *rend_query)
+{
+  routerinfo_t *router;
+  char address_buf[INET_NTOA_BUF_LEN+1];
+  struct in_addr in;
+  const char *address;
+  tor_addr_t addr;
+  if ((router = router_get_by_digest(status-&gt;identity_digest))) {
+    address = router-&gt;address;
+  } else {
+    in.s_addr = htonl(status-&gt;addr);
+    tor_inet_ntoa(&amp;in, address_buf, sizeof(address_buf));
+    address = address_buf;
+  }
+  tor_addr_from_ipv4h(&amp;addr, status-&gt;addr);
+  directory_initiate_command_rend(address, &amp;addr,
+                             status-&gt;or_port, status-&gt;dir_port,
+                             status-&gt;version_supports_conditional_consensus,
+                             status-&gt;version_supports_begindir,
+                             status-&gt;identity_digest,
+                             dir_purpose, router_purpose,
+                             anonymized_connection, resource,
+                             payload, payload_len, if_modified_since,
+                             rend_query);
+}
+
 /** Launch a new connection to the directory server &lt;b&gt;status&lt;/b&gt; to
  * upload or download a server or rendezvous
  * descriptor. &lt;b&gt;dir_purpose&lt;/b&gt; determines what
@@ -446,8 +499,7 @@
  * of the HTTP post.  Otherwise, &lt;b&gt;payload&lt;/b&gt; should be NULL.
  *
  * When fetching a rendezvous descriptor, &lt;b&gt;resource&lt;/b&gt; is the service ID we
- * want to fetch.
- */
+ * want to fetch. */
 void
 directory_initiate_command_routerstatus(routerstatus_t *status,
                                         uint8_t dir_purpose,
@@ -458,27 +510,11 @@
                                         size_t payload_len,
                                         time_t if_modified_since)
 {
-  routerinfo_t *router;
-  char address_buf[INET_NTOA_BUF_LEN+1];
-  struct in_addr in;
-  const char *address;
-  tor_addr_t addr;
-  if ((router = router_get_by_digest(status-&gt;identity_digest))) {
-    address = router-&gt;address;
-  } else {
-    in.s_addr = htonl(status-&gt;addr);
-    tor_inet_ntoa(&amp;in, address_buf, sizeof(address_buf));
-    address = address_buf;
-  }
-  tor_addr_from_ipv4h(&amp;addr, status-&gt;addr);
-  directory_initiate_command(address, &amp;addr,
-                             status-&gt;or_port, status-&gt;dir_port,
-                             status-&gt;version_supports_conditional_consensus,
-                             status-&gt;version_supports_begindir,
-                             status-&gt;identity_digest,
-                             dir_purpose, router_purpose,
-                             anonymized_connection, resource,
-                             payload, payload_len, if_modified_since);
+  directory_initiate_command_routerstatus_rend(status, dir_purpose,
+                                          router_purpose,
+                                          anonymized_connection, resource,
+                                          payload, payload_len,
+                                          if_modified_since, NULL);
 }
 
 /** Return true iff &lt;b&gt;conn&lt;/b&gt; is the client side of a directory connection
@@ -663,6 +699,28 @@
                            const char *payload, size_t payload_len,
                            time_t if_modified_since)
 {
+  directory_initiate_command_rend(address, _addr, or_port, dir_port,
+                             supports_conditional_consensus,
+                             supports_begindir, digest, dir_purpose,
+                             router_purpose, anonymized_connection,
+                             resource, payload, payload_len,
+                             if_modified_since, NULL);
+}
+
+/** Same as directory_initiate_command(), but accepts rendezvous data to
+ * fetch a hidden service descriptor. */
+static void
+directory_initiate_command_rend(const char *address, const tor_addr_t *_addr,
+                                uint16_t or_port, uint16_t dir_port,
+                                int supports_conditional_consensus,
+                                int supports_begindir, const char *digest,
+                                uint8_t dir_purpose, uint8_t router_purpose,
+                                int anonymized_connection,
+                                const char *resource,
+                                const char *payload, size_t payload_len,
+                                time_t if_modified_since,
+                                rend_data_t *rend_query)
+{
   dir_connection_t *conn;
   or_options_t *options = get_options();
   int socket_error = 0;
@@ -700,6 +758,10 @@
   /* decide whether we can learn our IP address from this conn */
   conn-&gt;dirconn_direct = !anonymized_connection;
 
+  /* copy rendezvous data, if any */
+  if (rend_query)
+    conn-&gt;rend_data = rend_data_dup(rend_query);
+
   if (!anonymized_connection &amp;&amp; !use_begindir) {
     /* then we want to connect to dirport directly */
 
@@ -1001,8 +1063,10 @@
       /* this must be true or we wouldn't be doing the lookup */
       tor_assert(strlen(resource) &lt;= REND_SERVICE_ID_LEN_BASE32);
       /* This breaks the function abstraction. */
-      strlcpy(conn-&gt;rend_query, resource, sizeof(conn-&gt;rend_query));
-      conn-&gt;rend_version = 0;
+      conn-&gt;rend_data = tor_malloc_zero(sizeof(rend_data_t));
+      strlcpy(conn-&gt;rend_data-&gt;onion_address, resource,
+              sizeof(conn-&gt;rend_data-&gt;onion_address));
+      conn-&gt;rend_data-&gt;rend_desc_version = 0;
 
       httpcommand = "GET";
       /* Request the most recent versioned descriptor. */
@@ -1015,10 +1079,8 @@
     case DIR_PURPOSE_FETCH_RENDDESC_V2:
       tor_assert(resource);
       tor_assert(strlen(resource) &lt;= REND_DESC_ID_V2_LEN_BASE32);
-      /* Remember the query to refer to it when a response arrives. */
-      strlcpy(conn-&gt;rend_query, payload, sizeof(conn-&gt;rend_query));
-      conn-&gt;rend_version = 2;
-      payload = NULL;
+      tor_assert(!payload);
+      conn-&gt;rend_data-&gt;rend_desc_version = 2;
       httpcommand = "GET";
       len = strlen(resource) + 32;
       url = tor_malloc(len);
@@ -1873,6 +1935,7 @@
   }
 
   if (conn-&gt;_base.purpose == DIR_PURPOSE_FETCH_RENDDESC) {
+    tor_assert(conn-&gt;rend_data);
     log_info(LD_REND,"Received rendezvous descriptor (size %d, status %d "
              "(%s))",
              (int)body_len, status_code, escaped(reason));
@@ -1888,7 +1951,7 @@
         } else {
           /* success. notify pending connections about this. */
           conn-&gt;_base.purpose = DIR_PURPOSE_HAS_FETCHED_RENDDESC;
-          rend_client_desc_here(conn-&gt;rend_query);
+          rend_client_desc_here(conn-&gt;rend_data-&gt;onion_address);
         }
         break;
       case 404:
@@ -1910,6 +1973,7 @@
   }
 
   if (conn-&gt;_base.purpose == DIR_PURPOSE_FETCH_RENDDESC_V2) {
+    tor_assert(conn-&gt;rend_data);
     log_info(LD_REND,"Received rendezvous descriptor (size %d, status %d "
              "(%s))",
              (int)body_len, status_code, escaped(reason));
@@ -1915,7 +1979,7 @@
              (int)body_len, status_code, escaped(reason));
     switch (status_code) {
       case 200:
-        switch (rend_cache_store_v2_desc_as_client(body, NULL)) {
+        switch (rend_cache_store_v2_desc_as_client(body, conn-&gt;rend_data)) {
           case -2:
             log_warn(LD_REND,"Fetching v2 rendezvous descriptor failed. "
                      "Retrying at another directory.");
@@ -1934,7 +1998,7 @@
             log_info(LD_REND, "Successfully fetched v2 rendezvous "
                      "descriptor.");
             conn-&gt;_base.purpose = DIR_PURPOSE_HAS_FETCHED_RENDDESC;
-            rend_client_desc_here(conn-&gt;rend_query);
+            rend_client_desc_here(conn-&gt;rend_data-&gt;onion_address);
             break;
         }
         break;
Index: /home/karsten/tor/tor-trunk-121-patches/src/or/or.h
===================================================================
--- /home/karsten/tor/tor-trunk-121-patches/src/or/or.h	(revision 16785)
+++ /home/karsten/tor/tor-trunk-121-patches/src/or/or.h	(working copy)
@@ -676,6 +676,55 @@
 /** Maximum length of authorized client names for a hidden service. */
 #define REND_CLIENTNAME_MAX_LEN 16
 
+/** Length of the rendezvous cookie that is used to connect circuits at the
+ * rendezvous point. */
+#define REND_COOKIE_LEN DIGEST_LEN
+
+/** Client authorization type that a hidden service performs. */
+typedef enum rend_auth_type_t {
+  REND_NO_AUTH      = 0,
+  REND_BASIC_AUTH   = 1,
+  REND_STEALTH_AUTH = 2,
+} rend_auth_type_t;
+
+/** Client-side configuration of authorization for a hidden service. */
+typedef struct rend_service_authorization_t {
+  char descriptor_cookie[REND_DESC_COOKIE_LEN];
+  char onion_address[REND_SERVICE_ADDRESS_LEN+1];
+  rend_auth_type_t auth_type;
+} rend_service_authorization_t;
+
+/** Client- and server-side data that is used for hidden service connection
+ * establishment. Not all fields contain data depending on where this struct
+ * is used. */
+typedef struct rend_data_t {
+  /** Onion address (without the .onion part) that a client requests. */
+  char onion_address[REND_SERVICE_ID_LEN_BASE32+1];
+
+  /** (Optional) descriptor cookie that is used by a client. */
+  char descriptor_cookie[REND_DESC_COOKIE_LEN];
+
+  /** Authorization type for accessing a service used by a client. */
+  rend_auth_type_t auth_type;
+
+  /** Hash of the hidden service's PK used by a service. */
+  char rend_pk_digest[DIGEST_LEN];
+
+  /** Rendezvous cookie used by both, client and service. */
+  char rend_cookie[REND_COOKIE_LEN];
+
+  /** Rendezvous descriptor version that is used by a service. Used to
+   * distinguish introduction and rendezvous points belonging to the same
+   * rendezvous service ID, but different descriptor versions.
+   */
+  uint8_t rend_desc_version;
+} rend_data_t;
+
+/** Time interval for tracking possible replays of INTRODUCE2 cells.
+ * Incoming cells with timestamps half of this interval in the past or
+ * future are dropped immediately. */
+#define REND_REPLAY_TIME_INTERVAL (60 * 60)
+
 #define CELL_DIRECTION_IN 1
 #define CELL_DIRECTION_OUT 2
 
@@ -1028,7 +1077,7 @@
   uint32_t n_written;
 
   /** What rendezvous service are we querying for? (AP only) */
-  char rend_query[REND_SERVICE_ID_LEN_BASE32+1];
+  rend_data_t *rend_data;
 
   /** Number of times we've reassigned this application connection to
    * a new circuit. We keep track because the timeout is longer if we've
@@ -1081,11 +1130,8 @@
   /** The zlib object doing on-the-fly compression for spooled data. */
   tor_zlib_state_t *zlib_state;
 
-  /** What hidden service descriptor are we fetching, if any? */
-  int rend_version;
-
   /** What rendezvous service are we querying for? */
-  char rend_query[REND_SERVICE_ID_LEN_BASE32+1];
+  rend_data_t *rend_data;
 
   char identity_digest[DIGEST_LEN]; /**&lt; Hash of the public RSA key for
                                      * the directory server's signing key. */
@@ -1750,7 +1796,6 @@
                                  CIPHER_KEY_LEN+\
                                  DH_KEY_LEN)
 #define ONIONSKIN_REPLY_LEN (DH_KEY_LEN+DIGEST_LEN)
-#define REND_COOKIE_LEN DIGEST_LEN
 
 /** Information used to build a circuit. */
 typedef struct {
@@ -1886,28 +1931,8 @@
    */
   crypt_path_t *cpath;
 
-  /** The rend_pk_digest field holds a hash of location-hidden service's
-   * PK if purpose is S_ESTABLISH_INTRO or S_RENDEZVOUSING.
-   */
-  char rend_pk_digest[DIGEST_LEN];
-
-  /** Holds rendezvous cookie if purpose is C_ESTABLISH_REND. Filled with
-   * zeroes otherwise.
-   */
-  char rend_cookie[REND_COOKIE_LEN];
-
-  /**
-   * The rend_query field holds the y portion of y.onion (nul-terminated)
-   * if purpose is C_INTRODUCING or C_ESTABLISH_REND, or is a C_GENERAL
-   * for a hidden service, or is S_*.
-   */
-  char rend_query[REND_SERVICE_ID_LEN_BASE32+1];
-
-  /** Stores the rendezvous descriptor version if purpose is S_*. Used to
-   * distinguish introduction and rendezvous points belonging to the same
-   * rendezvous service ID, but different descriptor versions.
-   */
-  uint8_t rend_desc_version;
+  /** Holds all rendezvous data on either client or service side. */
+  rend_data_t *rend_data;
 
   /** How many more relay_early cells can we send on this circuit, according
    * to the specification? */
@@ -3177,6 +3202,15 @@
                                              const char *payload,
                                              size_t payload_len,
                                              time_t if_modified_since);
+void directory_initiate_command_routerstatus_rend(routerstatus_t *status,
+                                                  uint8_t dir_purpose,
+                                                  uint8_t router_purpose,
+                                                  int anonymized_connection,
+                                                  const char *resource,
+                                                  const char *payload,
+                                                  size_t payload_len,
+                                                  time_t if_modified_since,
+                                                  rend_data_t *rend_query);
 
 int parse_http_response(const char *headers, int *code, time_t *date,
                         compress_method_t *compression, char **response);
@@ -3833,9 +3867,9 @@
 int rend_client_introduction_acked(origin_circuit_t *circ, const char *request,
                                    size_t request_len);
 void rend_client_refetch_renddesc(const char *query);
-void rend_client_refetch_v2_renddesc(const char *query);
+void rend_client_refetch_v2_renddesc(rend_data_t *rend_query);
 int rend_client_remove_intro_point(extend_info_t *failed_intro,
-                                   const char *query);
+                                   rend_data_t *rend_query);
 int rend_client_rendezvous_acked(origin_circuit_t *circ, const char *request,
                                  size_t request_len);
 int rend_client_receive_rendezvous(origin_circuit_t *circ, const char *request,
@@ -3842,25 +3876,10 @@
                                    size_t request_len);
 void rend_client_desc_here(const char *query);
 
-extend_info_t *rend_client_get_random_intro(const char *query);
+extend_info_t *rend_client_get_random_intro(rend_data_t *rend_query);
 
 int rend_client_send_introduction(origin_circuit_t *introcirc,
                                   origin_circuit_t *rendcirc);
-
-/** Client authorization type that a hidden service performs. */
-typedef enum rend_auth_type_t {
-  REND_NO_AUTH      = 0,
-  REND_BASIC_AUTH   = 1,
-  REND_STEALTH_AUTH = 2,
-} rend_auth_type_t;
-
-/** Client-side configuration of authorization for a hidden service. */
-typedef struct rend_service_authorization_t {
-  char descriptor_cookie[REND_DESC_COOKIE_LEN];
-  char onion_address[REND_SERVICE_ADDRESS_LEN+1];
-  rend_auth_type_t auth_type;
-} rend_service_authorization_t;
-
 int rend_parse_service_authorization(or_options_t *options,
                                      int validate_only);
 rend_service_authorization_t *rend_client_lookup_service_authorization(
@@ -3866,6 +3885,7 @@
 rend_service_authorization_t *rend_client_lookup_service_authorization(
                                                 const char *onion_address);
 void rend_service_authorization_free_all(void);
+rend_data_t *rend_data_dup(rend_data_t *request);
 
 /********************************* rendcommon.c ***************************/
 
@@ -3938,7 +3958,7 @@
 int rend_cache_lookup_v2_desc_as_dir(const char *query, const char **desc);
 int rend_cache_store(const char *desc, size_t desc_len, int published);
 int rend_cache_store_v2_desc_as_client(const char *desc,
-                               const char *descriptor_cookie);
+                                       rend_data_t *rend_query);
 int rend_cache_store_v2_desc_as_dir(const char *desc);
 int rend_cache_size(void);
 int rend_encode_v2_descriptors(smartlist_t *descs_out,
Index: /home/karsten/tor/tor-trunk-121-patches/src/or/rendclient.c
===================================================================
--- /home/karsten/tor/tor-trunk-121-patches/src/or/rendclient.c	(revision 16785)
+++ /home/karsten/tor/tor-trunk-121-patches/src/or/rendclient.c	(working copy)
@@ -31,9 +31,10 @@
 rend_client_send_establish_rendezvous(origin_circuit_t *circ)
 {
   tor_assert(circ-&gt;_base.purpose == CIRCUIT_PURPOSE_C_ESTABLISH_REND);
+  tor_assert(circ-&gt;rend_data);
   log_info(LD_REND, "Sending an ESTABLISH_RENDEZVOUS cell");
 
-  if (crypto_rand(circ-&gt;rend_cookie, REND_COOKIE_LEN) &lt; 0) {
+  if (crypto_rand(circ-&gt;rend_data-&gt;rend_cookie, REND_COOKIE_LEN) &lt; 0) {
     log_warn(LD_BUG, "Internal error: Couldn't produce random cookie.");
     circuit_mark_for_close(TO_CIRCUIT(circ), END_CIRC_REASON_INTERNAL);
     return -1;
@@ -40,7 +41,8 @@
   }
   if (relay_send_command_from_edge(0, TO_CIRCUIT(circ),
                                    RELAY_COMMAND_ESTABLISH_RENDEZVOUS,
-                                   circ-&gt;rend_cookie, REND_COOKIE_LEN,
+                                   circ-&gt;rend_data-&gt;rend_cookie,
+                                   REND_COOKIE_LEN,
                                    circ-&gt;cpath-&gt;prev)&lt;0) {
     /* circ is already marked for close */
     log_warn(LD_GENERAL, "Couldn't send ESTABLISH_RENDEZVOUS cell");
@@ -58,7 +60,7 @@
                               origin_circuit_t *rendcirc)
 {
   size_t payload_len;
-  int r;
+  int r, v3_shift = 0;
   char payload[RELAY_PAYLOAD_SIZE];
   char tmp[RELAY_PAYLOAD_SIZE];
   rend_cache_entry_t *entry;
@@ -68,13 +70,16 @@
 
   tor_assert(introcirc-&gt;_base.purpose == CIRCUIT_PURPOSE_C_INTRODUCING);
   tor_assert(rendcirc-&gt;_base.purpose == CIRCUIT_PURPOSE_C_REND_READY);
-  tor_assert(!rend_cmp_service_ids(introcirc-&gt;rend_query,
-                                   rendcirc-&gt;rend_query));
+  tor_assert(introcirc-&gt;rend_data);
+  tor_assert(rendcirc-&gt;rend_data);
+  tor_assert(!rend_cmp_service_ids(introcirc-&gt;rend_data-&gt;onion_address,
+                                   rendcirc-&gt;rend_data-&gt;onion_address));
 
-  if (rend_cache_lookup_entry(introcirc-&gt;rend_query, -1, &amp;entry) &lt; 1) {
+  if (rend_cache_lookup_entry(introcirc-&gt;rend_data-&gt;onion_address, -1,
+                              &amp;entry) &lt; 1) {
     log_warn(LD_REND,
              "query %s didn't have valid rend desc in cache. Failing.",
-             escaped_safe_str(introcirc-&gt;rend_query));
+             escaped_safe_str(introcirc-&gt;rend_data-&gt;onion_address));
     goto err;
   }
 
@@ -117,22 +122,40 @@
     }
   }
 
+  /* If version is 3, write (optional) auth data and timestamp. */
+  if (entry-&gt;parsed-&gt;protocols &amp; (1&lt;&lt;3)) {
+    tmp[0] = 3; /* version 3 of the cell format */
+    tmp[1] = (uint8_t)introcirc-&gt;rend_data-&gt;auth_type; /* auth type, if any */
+    v3_shift = 1;
+    if (introcirc-&gt;rend_data-&gt;auth_type != REND_NO_AUTH) {
+      set_uint16(tmp+2, htons(REND_DESC_COOKIE_LEN));
+      memcpy(tmp+4, introcirc-&gt;rend_data-&gt;descriptor_cookie,
+             REND_DESC_COOKIE_LEN);
+      v3_shift += 2+REND_DESC_COOKIE_LEN;
+    }
+    set_uint32(tmp+v3_shift+1, htonl(time(NULL)));
+    v3_shift += 4;
+  } /* if version 2 only write version number */
+  else if (entry-&gt;parsed-&gt;protocols &amp; (1&lt;&lt;2)) {
+    tmp[0] = 2; /* version 2 of the cell format */
+  }
+
   /* write the remaining items into tmp */
-  if (entry-&gt;parsed-&gt;protocols &amp; (1&lt;&lt;2)) {
+  if (entry-&gt;parsed-&gt;protocols &amp; (1&lt;&lt;3) || entry-&gt;parsed-&gt;protocols &amp; (1&lt;&lt;2)) {
     /* version 2 format */
     extend_info_t *extend_info = rendcirc-&gt;build_state-&gt;chosen_exit;
     int klen;
-    tmp[0] = 2; /* version 2 of the cell format */
     /* nul pads */
-    set_uint32(tmp+1, tor_addr_to_ipv4h(&amp;extend_info-&gt;addr));
-    set_uint16(tmp+5, htons(extend_info-&gt;port));
-    memcpy(tmp+7, extend_info-&gt;identity_digest, DIGEST_LEN);
-    klen = crypto_pk_asn1_encode(extend_info-&gt;onion_key, tmp+7+DIGEST_LEN+2,
-                                 sizeof(tmp)-(7+DIGEST_LEN+2));
-    set_uint16(tmp+7+DIGEST_LEN, htons(klen));
-    memcpy(tmp+7+DIGEST_LEN+2+klen, rendcirc-&gt;rend_cookie,
+    set_uint32(tmp+v3_shift+1, tor_addr_to_ipv4h(&amp;extend_info-&gt;addr));
+    set_uint16(tmp+v3_shift+5, htons(extend_info-&gt;port));
+    memcpy(tmp+v3_shift+7, extend_info-&gt;identity_digest, DIGEST_LEN);
+    klen = crypto_pk_asn1_encode(extend_info-&gt;onion_key,
+                                 tmp+v3_shift+7+DIGEST_LEN+2,
+                                 sizeof(tmp)-(v3_shift+7+DIGEST_LEN+2));
+    set_uint16(tmp+v3_shift+7+DIGEST_LEN, htons(klen));
+    memcpy(tmp+v3_shift+7+DIGEST_LEN+2+klen, rendcirc-&gt;rend_data-&gt;rend_cookie,
            REND_COOKIE_LEN);
-    dh_offset = 7+DIGEST_LEN+2+klen+REND_COOKIE_LEN;
+    dh_offset = v3_shift+7+DIGEST_LEN+2+klen+REND_COOKIE_LEN;
   } else {
     /* Version 0. */
     strncpy(tmp, rendcirc-&gt;build_state-&gt;chosen_exit-&gt;nickname,
@@ -137,7 +160,7 @@
     /* Version 0. */
     strncpy(tmp, rendcirc-&gt;build_state-&gt;chosen_exit-&gt;nickname,
             (MAX_NICKNAME_LEN+1)); /* nul pads */
-    memcpy(tmp+MAX_NICKNAME_LEN+1, rendcirc-&gt;rend_cookie,
+    memcpy(tmp+MAX_NICKNAME_LEN+1, rendcirc-&gt;rend_data-&gt;rend_cookie,
            REND_COOKIE_LEN);
     dh_offset = MAX_NICKNAME_LEN+1+REND_COOKIE_LEN;
   }
@@ -216,6 +239,7 @@
   }
 
   tor_assert(circ-&gt;build_state-&gt;chosen_exit);
+  tor_assert(circ-&gt;rend_data);
 
   if (request_len == 0) {
     /* It's an ACK; the introduction point relayed our introduction request. */
@@ -224,7 +248,7 @@
      */
     log_info(LD_REND,"Received ack. Telling rend circ...");
     rendcirc = circuit_get_by_rend_query_and_purpose(
-               circ-&gt;rend_query, CIRCUIT_PURPOSE_C_REND_READY);
+               circ-&gt;rend_data-&gt;onion_address, CIRCUIT_PURPOSE_C_REND_READY);
     if (rendcirc) { /* remember the ack */
       rendcirc-&gt;_base.purpose = CIRCUIT_PURPOSE_C_REND_READY_INTRO_ACKED;
     } else {
@@ -241,7 +265,7 @@
      * If none remain, refetch the service descriptor.
      */
     if (rend_client_remove_intro_point(circ-&gt;build_state-&gt;chosen_exit,
-                                       circ-&gt;rend_query) &gt; 0) {
+                                       circ-&gt;rend_data) &gt; 0) {
       /* There are introduction points left. Re-extend the circuit to
        * another intro point and try again. */
       extend_info_t *extend_info;
@@ -246,10 +270,10 @@
        * another intro point and try again. */
       extend_info_t *extend_info;
       int result;
-      extend_info = rend_client_get_random_intro(circ-&gt;rend_query);
+      extend_info = rend_client_get_random_intro(circ-&gt;rend_data);
       if (!extend_info) {
         log_warn(LD_REND, "No introduction points left for %s. Closing.",
-                 escaped_safe_str(circ-&gt;rend_query));
+                 escaped_safe_str(circ-&gt;rend_data-&gt;onion_address));
         circuit_mark_for_close(TO_CIRCUIT(circ), END_CIRC_REASON_INTERNAL);
         return -1;
       }
@@ -256,7 +280,7 @@
       log_info(LD_REND,
                "Got nack for %s from %s. Re-extending circ %d, "
                "this time to %s.",
-               escaped_safe_str(circ-&gt;rend_query),
+               escaped_safe_str(circ-&gt;rend_data-&gt;onion_address),
                circ-&gt;build_state-&gt;chosen_exit-&gt;nickname, circ-&gt;_base.n_circ_id,
                extend_info-&gt;nickname);
       result = circuit_extend_to_new_exit(circ, extend_info);
@@ -337,7 +361,7 @@
  * descriptor, return 0, and in case of a failure -1. &lt;b&gt;query&lt;/b&gt; is only
  * passed for pretty log statements. */
 static int
-directory_get_from_hs_dir(const char *desc_id, const char *query)
+directory_get_from_hs_dir(const char *desc_id, rend_data_t *rend_query)
 {
   smartlist_t *responsible_dirs = smartlist_create();
   routerstatus_t *hs_dir;
@@ -343,9 +367,9 @@
   routerstatus_t *hs_dir;
   char desc_id_base32[REND_DESC_ID_V2_LEN_BASE32 + 1];
   time_t now = time(NULL);
+  char descriptor_cookie_base64[3*REND_DESC_COOKIE_LEN_BASE64];
   tor_assert(desc_id);
-  tor_assert(query);
-  tor_assert(strlen(query) == REND_SERVICE_ID_LEN_BASE32);
+  tor_assert(rend_query);
   /* Determine responsible dirs. Even if we can't get all we want,
    * work with the ones we have. If it's empty, we'll notice below. */
   (int) hid_serv_get_responsible_directories(responsible_dirs, desc_id);
@@ -376,17 +400,33 @@
    * directory now. */
   lookup_last_hid_serv_request(hs_dir, desc_id_base32, now, 1);
 
-  /* Send fetch request. (Pass query as payload to write it to the directory
-   * connection so that it can be referred to when the response arrives.) */
-  directory_initiate_command_routerstatus(hs_dir,
+  /* Encode descriptor cookie for logging purposes. */
+  if (rend_query-&gt;auth_type != REND_NO_AUTH &amp;&amp;
+      base64_encode(descriptor_cookie_base64, 3*REND_DESC_COOKIE_LEN_BASE64,
+                    rend_query-&gt;descriptor_cookie, REND_DESC_COOKIE_LEN) &lt; 0) {
+    log_warn(LD_BUG, "Could not base64-encode descriptor cookie.");
+    return 0;
+  }
+  /* Remove == signs and newline. */
+  descriptor_cookie_base64[strlen(descriptor_cookie_base64)-3] = '\0';
+
+  /* Send fetch request. (Pass query and possibly descriptor cookie so that
+   * they can be written to the directory connection and be referred to when
+   * the response arrives. */
+  directory_initiate_command_routerstatus_rend(hs_dir,
                                           DIR_PURPOSE_FETCH_RENDDESC_V2,
                                           ROUTER_PURPOSE_GENERAL,
-                                          1, desc_id_base32, query, 0, 0);
+                                          1, desc_id_base32, NULL, 0, 0,
+                                          rend_query);
   log_info(LD_REND, "Sending fetch request for v2 descriptor for "
-                    "service '%s' with descriptor ID '%s' to hidden "
-                    "service directory '%s' on port %d.",
-           safe_str(query), safe_str(desc_id_base32), hs_dir-&gt;nickname,
-           hs_dir-&gt;dir_port);
+                    "service '%s' with descriptor ID '%s', auth type %d, "
+                    "and descriptor cookie '%s' to hidden service "
+                    "directory '%s' on port %d.",
+           rend_query-&gt;onion_address, desc_id_base32,
+           rend_query-&gt;auth_type,
+           (rend_query-&gt;auth_type == REND_NO_AUTH ? "NULL" :
+           escaped_safe_str(descriptor_cookie_base64)),
+           hs_dir-&gt;nickname, hs_dir-&gt;dir_port);
   return 1;
 }
 
@@ -416,7 +456,7 @@
  * &lt;b&gt;query&lt;/b&gt;.
  */
 void
-rend_client_refetch_v2_renddesc(const char *query)
+rend_client_refetch_v2_renddesc(rend_data_t *rend_query)
 {
   char descriptor_id[DIGEST_LEN];
   int replicas_left_to_try[REND_NUMBER_OF_NON_CONSECUTIVE_REPLICAS];
@@ -422,8 +462,7 @@
   int replicas_left_to_try[REND_NUMBER_OF_NON_CONSECUTIVE_REPLICAS];
   int i, tries_left;
   rend_cache_entry_t *e = NULL;
-  tor_assert(query);
-  tor_assert(strlen(query) == REND_SERVICE_ID_LEN_BASE32);
+  tor_assert(rend_query);
   /* Are we configured to fetch descriptors? */
   if (!get_options()-&gt;FetchHidServDescriptors) {
     log_warn(LD_REND, "We received an onion address for a v2 rendezvous "
@@ -431,7 +470,7 @@
     return;
   }
   /* Before fetching, check if we already have the descriptor here. */
-  if (rend_cache_lookup_entry(query, -1, &amp;e) &gt; 0) {
+  if (rend_cache_lookup_entry(rend_query-&gt;onion_address, -1, &amp;e) &gt; 0) {
     log_info(LD_REND, "We would fetch a v2 rendezvous descriptor, but we "
                       "already have that descriptor here. Not fetching.");
     return;
@@ -437,7 +476,7 @@
     return;
   }
   log_debug(LD_REND, "Fetching v2 rendezvous descriptor for service %s",
-            safe_str(query));
+            safe_str(rend_query-&gt;onion_address));
   /* Randomly iterate over the replicas until a descriptor can be fetched
    * from one of the consecutive nodes, or no options are left. */
   tries_left = REND_NUMBER_OF_NON_CONSECUTIVE_REPLICAS;
@@ -448,8 +487,10 @@
     int chosen_replica = replicas_left_to_try[rand];
     replicas_left_to_try[rand] = replicas_left_to_try[--tries_left];
 
-    if (rend_compute_v2_desc_id(descriptor_id, query, NULL, time(NULL),
-                                chosen_replica) &lt; 0) {
+    if (rend_compute_v2_desc_id(descriptor_id, rend_query-&gt;onion_address,
+                                rend_query-&gt;auth_type == REND_STEALTH_AUTH ?
+                                    rend_query-&gt;descriptor_cookie : NULL,
+                                time(NULL), chosen_replica) &lt; 0) {
       log_warn(LD_REND, "Internal error: Computing v2 rendezvous "
                         "descriptor ID did not succeed.");
       return;
@@ -454,7 +495,7 @@
                         "descriptor ID did not succeed.");
       return;
     }
-    if (directory_get_from_hs_dir(descriptor_id, query) != 0)
+    if (directory_get_from_hs_dir(descriptor_id, rend_query) != 0)
       return; /* either success or failure, but we're done */
   }
   /* If we come here, there are no hidden service directories left. */
@@ -471,7 +512,8 @@
  * unrecognized, 1 if recognized and some intro points remain.
  */
 int
-rend_client_remove_intro_point(extend_info_t *failed_intro, const char *query)
+rend_client_remove_intro_point(extend_info_t *failed_intro,
+                               rend_data_t *rend_query)
 {
   int i, r;
   rend_cache_entry_t *ent;
@@ -477,9 +519,10 @@
   rend_cache_entry_t *ent;
   connection_t *conn;
 
-  r = rend_cache_lookup_entry(query, -1, &amp;ent);
+  r = rend_cache_lookup_entry(rend_query-&gt;onion_address, -1, &amp;ent);
   if (r&lt;0) {
-    log_warn(LD_BUG, "Malformed service ID %s.", escaped_safe_str(query));
+    log_warn(LD_BUG, "Malformed service ID %s.",
+             escaped_safe_str(rend_query-&gt;onion_address));
     return -1;
   }
   if (r==0) {
@@ -484,11 +527,13 @@
   }
   if (r==0) {
     log_info(LD_REND, "Unknown service %s. Re-fetching descriptor.",
-             escaped_safe_str(query));
+             escaped_safe_str(rend_query-&gt;onion_address));
     /* Fetch both, v0 and v2 rend descriptors in parallel. Use whichever
-     * arrives first. */
-    rend_client_refetch_v2_renddesc(query);
-    rend_client_refetch_renddesc(query);
+     * arrives first. Exception: When using client authorization, only
+     * fetch v2 descriptors.*/
+    rend_client_refetch_v2_renddesc(rend_query);
+    if (rend_query-&gt;auth_type == REND_NO_AUTH)
+      rend_client_refetch_renddesc(rend_query-&gt;onion_address);
     return 0;
   }
 
@@ -505,15 +550,18 @@
   if (smartlist_len(ent-&gt;parsed-&gt;intro_nodes) == 0) {
     log_info(LD_REND,
              "No more intro points remain for %s. Re-fetching descriptor.",
-             escaped_safe_str(query));
+             escaped_safe_str(rend_query-&gt;onion_address));
     /* Fetch both, v0 and v2 rend descriptors in parallel. Use whichever
-     * arrives first. */
-    rend_client_refetch_v2_renddesc(query);
-    rend_client_refetch_renddesc(query);
+     * arrives first. Exception: When using client authorization, only
+     * fetch v2 descriptors.*/
+    rend_client_refetch_v2_renddesc(rend_query);
+    if (rend_query-&gt;auth_type == REND_NO_AUTH)
+      rend_client_refetch_renddesc(rend_query-&gt;onion_address);
 
     /* move all pending streams back to renddesc_wait */
     while ((conn = connection_get_by_type_state_rendquery(CONN_TYPE_AP,
-                                   AP_CONN_STATE_CIRCUIT_WAIT, query, -1))) {
+                                   AP_CONN_STATE_CIRCUIT_WAIT,
+                                   rend_query-&gt;onion_address, -1))) {
       conn-&gt;state = AP_CONN_STATE_RENDDESC_WAIT;
     }
 
@@ -520,7 +568,8 @@
     return 0;
   }
   log_info(LD_REND,"%d options left for %s.",
-           smartlist_len(ent-&gt;parsed-&gt;intro_nodes), escaped_safe_str(query));
+           smartlist_len(ent-&gt;parsed-&gt;intro_nodes),
+           escaped_safe_str(rend_query-&gt;onion_address));
   return 1;
 }
 
@@ -642,10 +691,13 @@
         _conn-&gt;marked_for_close)
       continue;
     conn = TO_EDGE_CONN(_conn);
-    if (rend_cmp_service_ids(query, conn-&gt;rend_query))
+    if (!conn-&gt;rend_data)
+      continue;
+    if (rend_cmp_service_ids(query, conn-&gt;rend_data-&gt;onion_address))
       continue;
     assert_connection_ok(TO_CONN(conn), now);
-    if (rend_cache_lookup_entry(conn-&gt;rend_query, -1, &amp;entry) == 1 &amp;&amp;
+    if (rend_cache_lookup_entry(conn-&gt;rend_data-&gt;onion_address, -1,
+                                &amp;entry) == 1 &amp;&amp;
         smartlist_len(entry-&gt;parsed-&gt;intro_nodes) &gt; 0) {
       /* either this fetch worked, or it failed but there was a
        * valid entry from before which we should reuse */
@@ -677,7 +729,7 @@
  * have been tried and failed.
  */
 extend_info_t *
-rend_client_get_random_intro(const char *query)
+rend_client_get_random_intro(rend_data_t *rend_query)
 {
   int i;
   rend_cache_entry_t *entry;
@@ -684,10 +736,10 @@
   rend_intro_point_t *intro;
   routerinfo_t *router;
 
-  if (rend_cache_lookup_entry(query, -1, &amp;entry) &lt; 1) {
+  if (rend_cache_lookup_entry(rend_query-&gt;onion_address, -1, &amp;entry) &lt; 1) {
     log_warn(LD_REND,
              "Query '%s' didn't have valid rend desc in cache. Failing.",
-             safe_str(query));
+             safe_str(rend_query-&gt;onion_address));
     return NULL;
   }
 
Index: /home/karsten/tor/tor-trunk-121-patches/src/or/rendcommon.c
===================================================================
--- /home/karsten/tor/tor-trunk-121-patches/src/or/rendcommon.c	(revision 16785)
+++ /home/karsten/tor/tor-trunk-121-patches/src/or/rendcommon.c	(working copy)
@@ -1236,8 +1236,7 @@
  * than one we've already got; return 1 if it's novel.
  */
 int
-rend_cache_store_v2_desc_as_client(const char *desc,
-                                   const char *descriptor_cookie)
+rend_cache_store_v2_desc_as_client(const char *desc, rend_data_t *rend_query)
 {
   /*XXXX this seems to have a bit of duplicate code with
    * rend_cache_store_v2_desc_as_dir().  Fix that. */
@@ -1266,7 +1265,6 @@
   rend_cache_entry_t *e;
   tor_assert(rend_cache);
   tor_assert(desc);
-  (void) descriptor_cookie; /* We don't use it, yet. */
   /* Parse the descriptor. */
   if (rend_parse_v2_service_descriptor(&amp;parsed, desc_id, &amp;intro_content,
                                        &amp;intro_size, &amp;encoded_size,
@@ -1285,10 +1283,32 @@
   }
   /* Decode/decrypt introduction points. */
   if (intro_content) {
+    if (rend_query-&gt;auth_type != REND_NO_AUTH &amp;&amp;
+        rend_query-&gt;descriptor_cookie) {
+      char *ipos_decrypted;
+      size_t ipos_decrypted_size;
+      if (rend_decrypt_introduction_points(&amp;ipos_decrypted,
+                                           &amp;ipos_decrypted_size,
+                                           rend_query-&gt;descriptor_cookie,
+                                           intro_content,
+                                           intro_size) &lt; 0) {
+        log_warn(LD_REND, "Failed to decrypt introduction points. We are "
+                 "probably unable to parse the encoded introduction points.");
+      } else {
+        /* Replace encrypted with decrypted introduction points. */
+        log_info(LD_REND, "Successfully decrypted introduction points.");
+        tor_free(intro_content);
+        intro_content = ipos_decrypted;
+        intro_size = ipos_decrypted_size;
+      }
+    }
     if (rend_parse_introduction_points(parsed, intro_content,
-                                       intro_size) &lt; 0) {
-      log_warn(LD_PROTOCOL,"Couldn't decode/decrypt introduction points.");
-      rend_service_descriptor_free(parsed);
+                                       intro_size) &lt;= 0) {
+      log_warn(LD_REND, "Failed to parse introduction points. Either the "
+               "service has published a corrupt descriptor or you have "
+               "provided invalid authorization data.");
+      if (parsed)
+        rend_service_descriptor_free(parsed);
       tor_free(intro_content);
       return -2;
     }
@@ -1293,6 +1313,7 @@
       return -2;
     }
   } else {
+    log_info(LD_REND, "Descriptor does not contain any introduction points.");
     parsed-&gt;intro_nodes = smartlist_create();
   }
   /* We don't need the encoded/encrypted introduction points any longer. */
@@ -1420,3 +1441,15 @@
   return strmap_size(rend_cache);
 }
 
+/** Allocate and return a new rend_data_t with the same
+ * contents as &lt;b&gt;query&lt;/b&gt;. */
+rend_data_t *
+rend_data_dup(rend_data_t *data)
+{
+  rend_data_t *newdata;
+  tor_assert(data);
+  newdata = tor_malloc_zero(sizeof(rend_data_t));
+  memcpy(newdata, data, sizeof(rend_data_t));
+  return newdata;
+}
+
Index: /home/karsten/tor/tor-trunk-121-patches/src/or/rendservice.c
===================================================================
--- /home/karsten/tor/tor-trunk-121-patches/src/or/rendservice.c	(revision 16785)
+++ /home/karsten/tor/tor-trunk-121-patches/src/or/rendservice.c	(working copy)
@@ -69,8 +69,16 @@
                          * up-to-date. */
   time_t next_upload_time; /**&lt; Scheduled next hidden service descriptor
                             * upload time. */
+  smartlist_t *accepted_intros; /**&lt; List of client_access_event_t's for
+                                 * accepted and answered INTRODUCE2 cells. */
 } rend_service_t;
 
+/** The event of a client accessing our hidden service. */
+typedef struct client_access_event_t {
+  time_t access_time;
+  char diffie_hellman_hash[DIGEST_LEN];
+} client_access_event_t;
+
 /** A list of rend_service_t's for services run on this OP.
  */
 static smartlist_t *rend_service_list = NULL;
@@ -360,7 +368,7 @@
       if (smartlist_len(type_names_split) &lt; 2) {
         log_warn(LD_CONFIG, "HiddenServiceAuthorizeClient contains "
                             "auth-type '%s', but no client names.",
-                 service-&gt;auth_type == 1 ? "basic" : "stealth");
+                 service-&gt;auth_type == REND_BASIC_AUTH ? "basic" : "stealth");
         SMARTLIST_FOREACH(type_names_split, char *, cp, tor_free(cp));
         smartlist_free(type_names_split);
         continue;
@@ -423,7 +431,7 @@
                             "authorization type '%s'.",
                  smartlist_len(service-&gt;clients),
                  service-&gt;auth_type == REND_BASIC_AUTH ? 512 : 16,
-                 service-&gt;auth_type == 1 ? "basic" : "stealth");
+                 service-&gt;auth_type == REND_BASIC_AUTH ? "basic" : "stealth");
         rend_service_free(service);
         return -1;
       }
@@ -720,8 +728,10 @@
       tor_free(client_keys_str);
       strmap_free(parsed_clients, rend_authorized_client_strmap_item_free);
       if (r&lt;0) {
-        abort_writing_to_file(open_cfile);
-        abort_writing_to_file(open_hfile);
+        if (open_cfile)
+          abort_writing_to_file(open_cfile);
+        if (open_hfile)
+          abort_writing_to_file(open_hfile);
         return r;
       } else {
         finish_writing_to_file(open_cfile);
@@ -764,6 +774,45 @@
   return 0;
 }
 
+/** Check client authorization of a given &lt;b&gt;descriptor_cookie&lt;/b&gt; for
+ * &lt;b&gt;service&lt;/b&gt;. Return 1 for success and 0 for failure. */
+static int
+rend_check_authorization(rend_service_t *service,
+                         const char *descriptor_cookie)
+{
+  rend_authorized_client_t *auth_client = NULL;
+  tor_assert(service);
+  tor_assert(descriptor_cookie);
+  if (!service-&gt;clients) {
+    log_warn(LD_BUG, "Can't check authorization for a service that has no "
+                     "authorized clients configured.");
+    return 0;
+  }
+
+  /* Look up client authorization by descriptor cookie. */
+  SMARTLIST_FOREACH(service-&gt;clients, rend_authorized_client_t *, client, {
+    if (!memcmp(client-&gt;descriptor_cookie, descriptor_cookie,
+                REND_DESC_COOKIE_LEN)) {
+      auth_client = client;
+      break;
+    }
+  });
+  if (!auth_client) {
+    char descriptor_cookie_base64[3*REND_DESC_COOKIE_LEN_BASE64];
+    base64_encode(descriptor_cookie_base64, sizeof(descriptor_cookie_base64),
+                  descriptor_cookie, REND_DESC_COOKIE_LEN);
+    log_info(LD_REND, "No authorization found for descriptor cookie '%s'! "
+                      "Dropping cell!",
+             descriptor_cookie_base64);
+    return 0;
+  }
+
+  /* Allow the request. */
+  log_info(LD_REND, "Client %s could be identified for service %s.",
+           auth_client-&gt;client_name, service-&gt;service_id);
+  return 1;
+}
+
 /******
  * Handle cells
  ******/
@@ -780,7 +829,7 @@
   char buf[RELAY_PAYLOAD_SIZE];
   char keys[DIGEST_LEN+CPATH_KEY_MATERIAL_LEN]; /* Holds KH, Df, Db, Kf, Kb */
   rend_service_t *service;
-  int r, i;
+  int r, i, v3_shift = 0;
   size_t len, keylen;
   crypto_dh_env_t *dh = NULL;
   origin_circuit_t *launched = NULL;
@@ -791,9 +840,17 @@
   int reason = END_CIRC_REASON_TORPROTOCOL;
   crypto_pk_env_t *intro_key;
   char intro_key_digest[DIGEST_LEN];
+  int auth_type;
+  size_t auth_len = 0;
+  char auth_data[REND_DESC_COOKIE_LEN];
+  crypto_digest_env_t *digest = NULL;
+  time_t now = time(NULL);
+  char diffie_hellman_hash[DIGEST_LEN];
+  client_access_event_t *event = NULL;
+  tor_assert(circuit-&gt;rend_data);
 
   base32_encode(serviceid, REND_SERVICE_ID_LEN_BASE32+1,
-                circuit-&gt;rend_pk_digest, REND_SERVICE_ID_LEN);
+                circuit-&gt;rend_data-&gt;rend_pk_digest, REND_SERVICE_ID_LEN);
   log_info(LD_REND, "Received INTRODUCE2 cell for service %s on circ %d.",
            escaped(serviceid), circuit-&gt;_base.n_circ_id);
 
@@ -814,7 +871,8 @@
 
   /* look up service depending on circuit. */
   service = rend_service_get_by_pk_digest_and_version(
-              circuit-&gt;rend_pk_digest, circuit-&gt;rend_desc_version);
+              circuit-&gt;rend_data-&gt;rend_pk_digest,
+              circuit-&gt;rend_data-&gt;rend_desc_version);
   if (!service) {
     log_warn(LD_REND, "Got an INTRODUCE2 cell for an unrecognized service %s.",
              escaped(serviceid));
@@ -822,7 +880,7 @@
   }
 
   /* if descriptor version is 2, use intro key instead of service key. */
-  if (circuit-&gt;rend_desc_version == 0) {
+  if (circuit-&gt;rend_data-&gt;rend_desc_version == 0) {
     intro_key = service-&gt;private_key;
   } else {
     intro_key = circuit-&gt;intro_key;
@@ -854,13 +912,49 @@
     return -1;
   }
   len = r;
-  if (*buf == 2) {
+  if (*buf == 3) {
+    /* Version 3 INTRODUCE2 cell. */
+    time_t ts = 0, now = time(NULL);
+    v3_shift = 1;
+    auth_type = buf[1];
+    switch (auth_type) {
+      case REND_BASIC_AUTH:
+        /* fall through */
+      case REND_STEALTH_AUTH:
+        auth_len = ntohs(get_uint16(buf+2));
+        if (auth_len != REND_DESC_COOKIE_LEN) {
+          log_info(LD_REND, "Wrong auth data size %d, should be %d.",
+                   (int)auth_len, REND_DESC_COOKIE_LEN);
+          return -1;
+        }
+        memcpy(auth_data, buf+4, sizeof(auth_data));
+        v3_shift += 2+REND_DESC_COOKIE_LEN;
+        break;
+      case REND_NO_AUTH:
+        break;
+      default:
+        log_info(LD_REND, "Unknown authorization type '%d'", auth_type);
+    }
+
+    /* Check timestamp. */
+    memcpy((char*)&amp;ts, buf+1+v3_shift, sizeof(uint32_t));
+    v3_shift += 4;
+    ts = ntohl(ts);
+    if ((now - ts) &lt; -1 * REND_REPLAY_TIME_INTERVAL / 2 ||
+        (now - ts) &gt; REND_REPLAY_TIME_INTERVAL / 2) {
+      log_warn(LD_REND, "INTRODUCE2 cell is too %s. Discarding.",
+          (now - ts) &lt; 0 ? "old" : "new");
+      return -1;
+    }
+  }
+  if (*buf == 2 || *buf == 3) {
     /* Version 2 INTRODUCE2 cell. */
     int klen;
     extend_info = tor_malloc_zero(sizeof(extend_info_t));
-    tor_addr_from_ipv4n(&amp;extend_info-&gt;addr, get_uint32(buf+1));
-    extend_info-&gt;port = ntohs(get_uint16(buf+5));
-    memcpy(extend_info-&gt;identity_digest, buf+7, DIGEST_LEN);
+    tor_addr_from_ipv4n(&amp;extend_info-&gt;addr, get_uint32(buf+v3_shift+1));
+    extend_info-&gt;port = ntohs(get_uint16(buf+v3_shift+5));
+    memcpy(extend_info-&gt;identity_digest, buf+v3_shift+7,
+           DIGEST_LEN);
     extend_info-&gt;nickname[0] = '$';
     base16_encode(extend_info-&gt;nickname+1, sizeof(extend_info-&gt;nickname)-1,
                   extend_info-&gt;identity_digest, DIGEST_LEN);
@@ -865,22 +959,23 @@
     base16_encode(extend_info-&gt;nickname+1, sizeof(extend_info-&gt;nickname)-1,
                   extend_info-&gt;identity_digest, DIGEST_LEN);
 
-    klen = ntohs(get_uint16(buf+7+DIGEST_LEN));
-    if ((int)len != 7+DIGEST_LEN+2+klen+20+128) {
-      log_warn(LD_PROTOCOL, "Bad length %u for version 2 INTRODUCE2 cell.",
-               (int)len);
+    klen = ntohs(get_uint16(buf+v3_shift+7+DIGEST_LEN));
+    if ((int)len != v3_shift+7+DIGEST_LEN+2+klen+20+128) {
+      log_warn(LD_PROTOCOL, "Bad length %u for version %d INTRODUCE2 cell.",
+               (int)len, *buf);
       reason = END_CIRC_REASON_TORPROTOCOL;
       goto err;
     }
-    extend_info-&gt;onion_key = crypto_pk_asn1_decode(buf+7+DIGEST_LEN+2, klen);
+    extend_info-&gt;onion_key =
+        crypto_pk_asn1_decode(buf+v3_shift+7+DIGEST_LEN+2, klen);
     if (!extend_info-&gt;onion_key) {
-      log_warn(LD_PROTOCOL,
-               "Error decoding onion key in version 2 INTRODUCE2 cell.");
+      log_warn(LD_PROTOCOL, "Error decoding onion key in version %d "
+                            "INTRODUCE2 cell.", *buf);
       reason = END_CIRC_REASON_TORPROTOCOL;
       goto err;
     }
-    ptr = buf+7+DIGEST_LEN+2+klen;
-    len -= 7+DIGEST_LEN+2+klen;
+    ptr = buf+v3_shift+7+DIGEST_LEN+2+klen;
+    len -= v3_shift+7+DIGEST_LEN+2+klen;
   } else {
     char *rp_nickname;
     size_t nickname_field_len;
@@ -932,6 +1027,58 @@
   r_cookie = ptr;
   base16_encode(hexcookie,9,r_cookie,4);
 
+  /* Determine hash of Diffie-Hellman, part 1 to detect replays. */
+  digest = crypto_new_digest_env();
+  crypto_digest_add_bytes(digest, ptr+REND_COOKIE_LEN, DH_KEY_LEN);
+  crypto_digest_get_digest(digest, diffie_hellman_hash, DIGEST_LEN);
+  crypto_free_digest_env(digest);
+
+  /* Iterate over past requests, remove those which are older than one hour,
+   * and check whether there is one with same Diffie-Hellman, part 1. */
+  if (!service-&gt;accepted_intros)
+    service-&gt;accepted_intros = smartlist_create();
+  SMARTLIST_FOREACH(service-&gt;accepted_intros, client_access_event_t *,
+                    access, {
+    if (access-&gt;access_time + REND_REPLAY_TIME_INTERVAL &lt; now) {
+      tor_free(access);
+      SMARTLIST_DEL_CURRENT(service-&gt;accepted_intros, access);
+    } else if (!memcmp(access-&gt;diffie_hellman_hash, diffie_hellman_hash,
+                       DIGEST_LEN)) {
+      log_warn(LD_REND, "Possible replay detected! We received an "
+                        "INTRODUCE2 cell with same first part of "
+                        "Diffie-Hellman handshake %d seconds ago. Dropping "
+                        "cell.",
+               (uint32_t) (now - access-&gt;access_time));
+      return 0;
+    }
+  });
+
+  /* Add request to access history, including time and hash of
+   * Diffie-Hellman, part 1. */
+  event = tor_malloc_zero(sizeof(client_access_event_t));
+  event-&gt;access_time = now;
+  memcpy(event-&gt;diffie_hellman_hash, diffie_hellman_hash, DIGEST_LEN);
+  smartlist_add(service-&gt;accepted_intros, event);
+
+  /* If the service performs client authorization, check included auth data. */
+  if (service-&gt;clients) {
+    if (auth_len &gt; 0) {
+      if (rend_check_authorization(service, auth_data)) {
+        log_info(LD_REND, "Authorization data in INTRODUCE2 cell are valid.");
+      } else {
+        log_info(LD_REND, "The authorization data that are contained in "
+                 "the INTRODUCE2 cell are invalid. Dropping cell.");
+        reason = END_CIRC_REASON_CONNECTFAILED;
+        goto err;
+      }
+    } else {
+      log_info(LD_REND, "INTRODUCE2 cell does not contain authentication "
+               "data, but we require client authorization. Dropping cell.");
+      reason = END_CIRC_REASON_CONNECTFAILED;
+      goto err;
+    }
+  }
+
   /* Try DH handshake... */
   dh = crypto_dh_new();
   if (!dh || crypto_dh_generate_public(dh)&lt;0) {
@@ -976,12 +1123,14 @@
            escaped_safe_str(extend_info-&gt;nickname), hexcookie, serviceid);
   tor_assert(launched-&gt;build_state);
   /* Fill in the circuit's state. */
-  memcpy(launched-&gt;rend_pk_digest, circuit-&gt;rend_pk_digest,
+  launched-&gt;rend_data = tor_malloc_zero(sizeof(rend_data_t));
+  memcpy(launched-&gt;rend_data-&gt;rend_pk_digest,
+         circuit-&gt;rend_data-&gt;rend_pk_digest,
          DIGEST_LEN);
-  memcpy(launched-&gt;rend_cookie, r_cookie, REND_COOKIE_LEN);
-  strlcpy(launched-&gt;rend_query, service-&gt;service_id,
-          sizeof(launched-&gt;rend_query));
-  launched-&gt;rend_desc_version = service-&gt;descriptor_version;
+  memcpy(launched-&gt;rend_data-&gt;rend_cookie, r_cookie, REND_COOKIE_LEN);
+  strlcpy(launched-&gt;rend_data-&gt;onion_address, service-&gt;service_id,
+          sizeof(launched-&gt;rend_data-&gt;onion_address));
+  launched-&gt;rend_data-&gt;rend_desc_version = service-&gt;descriptor_version;
   launched-&gt;build_state-&gt;pending_final_cpath = cpath =
     tor_malloc_zero(sizeof(crypt_path_t));
   cpath-&gt;magic = CRYPT_PATH_MAGIC;
@@ -1053,13 +1202,7 @@
   newstate-&gt;pending_final_cpath = oldstate-&gt;pending_final_cpath;
   oldstate-&gt;pending_final_cpath = NULL;
 
-  memcpy(newcirc-&gt;rend_query, oldcirc-&gt;rend_query,
-         REND_SERVICE_ID_LEN_BASE32+1);
-  memcpy(newcirc-&gt;rend_pk_digest, oldcirc-&gt;rend_pk_digest,
-         DIGEST_LEN);
-  memcpy(newcirc-&gt;rend_cookie, oldcirc-&gt;rend_cookie,
-         REND_COOKIE_LEN);
-  newcirc-&gt;rend_desc_version = oldcirc-&gt;rend_desc_version;
+  newcirc-&gt;rend_data = rend_data_dup(oldcirc-&gt;rend_data);
 }
 
 /** Launch a circuit to serve as an introduction point for the service
@@ -1105,10 +1248,11 @@
     intro-&gt;extend_info = extend_info_dup(launched-&gt;build_state-&gt;chosen_exit);
   }
 
-  strlcpy(launched-&gt;rend_query, service-&gt;service_id,
-          sizeof(launched-&gt;rend_query));
-  memcpy(launched-&gt;rend_pk_digest, service-&gt;pk_digest, DIGEST_LEN);
-  launched-&gt;rend_desc_version = service-&gt;descriptor_version;
+  launched-&gt;rend_data = tor_malloc_zero(sizeof(rend_data_t));
+  strlcpy(launched-&gt;rend_data-&gt;onion_address, service-&gt;service_id,
+          sizeof(launched-&gt;rend_data-&gt;onion_address));
+  memcpy(launched-&gt;rend_data-&gt;rend_pk_digest, service-&gt;pk_digest, DIGEST_LEN);
+  launched-&gt;rend_data-&gt;rend_desc_version = service-&gt;descriptor_version;
   if (service-&gt;descriptor_version == 2)
     launched-&gt;intro_key = crypto_pk_dup_key(intro-&gt;intro_key);
   if (launched-&gt;_base.state == CIRCUIT_STATE_OPEN)
@@ -1133,12 +1277,14 @@
 
   tor_assert(circuit-&gt;_base.purpose == CIRCUIT_PURPOSE_S_ESTABLISH_INTRO);
   tor_assert(circuit-&gt;cpath);
+  tor_assert(circuit-&gt;rend_data);
 
   base32_encode(serviceid, REND_SERVICE_ID_LEN_BASE32+1,
-                circuit-&gt;rend_pk_digest, REND_SERVICE_ID_LEN);
+                circuit-&gt;rend_data-&gt;rend_pk_digest, REND_SERVICE_ID_LEN);
 
   service = rend_service_get_by_pk_digest_and_version(
-              circuit-&gt;rend_pk_digest, circuit-&gt;rend_desc_version);
+              circuit-&gt;rend_data-&gt;rend_pk_digest,
+              circuit-&gt;rend_data-&gt;rend_desc_version);
   if (!service) {
     log_warn(LD_REND, "Unrecognized service ID %s on introduction circuit %d.",
              serviceid, circuit-&gt;_base.n_circ_id);
@@ -1214,8 +1360,10 @@
              "received INTRO_ESTABLISHED cell on non-intro circuit.");
     goto err;
   }
+  tor_assert(circuit-&gt;rend_data);
   service = rend_service_get_by_pk_digest_and_version(
-              circuit-&gt;rend_pk_digest, circuit-&gt;rend_desc_version);
+              circuit-&gt;rend_data-&gt;rend_pk_digest,
+              circuit-&gt;rend_data-&gt;rend_desc_version);
   if (!service) {
     log_warn(LD_REND, "Unknown service on introduction circuit %d.",
              circuit-&gt;_base.n_circ_id);
@@ -1225,7 +1373,7 @@
   circuit-&gt;_base.purpose = CIRCUIT_PURPOSE_S_INTRO;
 
   base32_encode(serviceid, REND_SERVICE_ID_LEN_BASE32 + 1,
-                circuit-&gt;rend_pk_digest, REND_SERVICE_ID_LEN);
+                circuit-&gt;rend_data-&gt;rend_pk_digest, REND_SERVICE_ID_LEN);
   log_info(LD_REND,
            "Received INTRO_ESTABLISHED cell on circuit %d for service %s",
            circuit-&gt;_base.n_circ_id, serviceid);
@@ -1252,12 +1400,13 @@
   tor_assert(circuit-&gt;_base.purpose == CIRCUIT_PURPOSE_S_CONNECT_REND);
   tor_assert(circuit-&gt;cpath);
   tor_assert(circuit-&gt;build_state);
+  tor_assert(circuit-&gt;rend_data);
   hop = circuit-&gt;build_state-&gt;pending_final_cpath;
   tor_assert(hop);
 
-  base16_encode(hexcookie,9,circuit-&gt;rend_cookie,4);
+  base16_encode(hexcookie,9,circuit-&gt;rend_data-&gt;rend_cookie,4);
   base32_encode(serviceid, REND_SERVICE_ID_LEN_BASE32+1,
-                circuit-&gt;rend_pk_digest, REND_SERVICE_ID_LEN);
+                circuit-&gt;rend_data-&gt;rend_pk_digest, REND_SERVICE_ID_LEN);
 
   log_info(LD_REND,
            "Done building circuit %d to rendezvous with "
@@ -1265,7 +1414,8 @@
            circuit-&gt;_base.n_circ_id, hexcookie, serviceid);
 
   service = rend_service_get_by_pk_digest_and_version(
-              circuit-&gt;rend_pk_digest, circuit-&gt;rend_desc_version);
+              circuit-&gt;rend_data-&gt;rend_pk_digest,
+              circuit-&gt;rend_data-&gt;rend_desc_version);
   if (!service) {
     log_warn(LD_GENERAL, "Internal error: unrecognized service ID on "
              "introduction circuit.");
@@ -1274,7 +1424,7 @@
   }
 
   /* All we need to do is send a RELAY_RENDEZVOUS1 cell... */
-  memcpy(buf, circuit-&gt;rend_cookie, REND_COOKIE_LEN);
+  memcpy(buf, circuit-&gt;rend_data-&gt;rend_cookie, REND_COOKIE_LEN);
   if (crypto_dh_get_public(hop-&gt;dh_handshake_state,
                            buf+REND_COOKIE_LEN, DH_KEY_LEN)&lt;0) {
     log_warn(LD_GENERAL,"Couldn't get DH public key.");
@@ -1336,7 +1486,8 @@
                                                   CIRCUIT_PURPOSE_S_INTRO))) {
     if (!memcmp(circ-&gt;build_state-&gt;chosen_exit-&gt;identity_digest,
                 intro-&gt;extend_info-&gt;identity_digest, DIGEST_LEN) &amp;&amp;
-        circ-&gt;rend_desc_version == desc_version) {
+        circ-&gt;rend_data &amp;&amp;
+        circ-&gt;rend_data-&gt;rend_desc_version == desc_version) {
       return circ;
     }
   }
@@ -1346,7 +1497,8 @@
                                         CIRCUIT_PURPOSE_S_ESTABLISH_INTRO))) {
     if (!memcmp(circ-&gt;build_state-&gt;chosen_exit-&gt;identity_digest,
                 intro-&gt;extend_info-&gt;identity_digest, DIGEST_LEN) &amp;&amp;
-        circ-&gt;rend_desc_version == desc_version) {
+        circ-&gt;rend_data &amp;&amp;
+        circ-&gt;rend_data-&gt;rend_desc_version == desc_version) {
       return circ;
     }
   }
@@ -1748,11 +1900,13 @@
   rend_service_port_config_t *chosen_port;
 
   tor_assert(circ-&gt;_base.purpose == CIRCUIT_PURPOSE_S_REND_JOINED);
+  tor_assert(circ-&gt;rend_data);
   log_debug(LD_REND,"beginning to hunt for addr/port");
   base32_encode(serviceid, REND_SERVICE_ID_LEN_BASE32+1,
-                circ-&gt;rend_pk_digest, REND_SERVICE_ID_LEN);
-  service = rend_service_get_by_pk_digest_and_version(circ-&gt;rend_pk_digest,
-                                                      circ-&gt;rend_desc_version);
+                circ-&gt;rend_data-&gt;rend_pk_digest, REND_SERVICE_ID_LEN);
+  service = rend_service_get_by_pk_digest_and_version(
+                circ-&gt;rend_data-&gt;rend_pk_digest,
+                circ-&gt;rend_data-&gt;rend_desc_version);
   if (!service) {
     log_warn(LD_REND, "Couldn't find any service associated with pk %s on "
              "rendezvous circuit %d; closing.",


["patch-121-4a.txt.sig" (application/octet-stream)]

</body></email><email><emailId>20080923201529</emailId><senderName>Karsten Loesing</senderName><senderEmail>karsten.loesing@gmx.net</senderEmail><timestampReceived>2008-09-23 20:15:29-0400</timestampReceived><subject>Re: Fourth patch for proposal 121</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Same patch, updated to be compatible with current trunk.


Karsten Loesing wrote:
&gt; Hi Nick,
&gt; 
&gt; this patch 4a now contains two more changes as discussed on IRC:
&gt; 
&gt; 1. The signatures of directory_initiate_command_routerstatus() and
&gt; directory_initiate_command() are left unchanged. Therefore there are now
&gt; two more functions especially for hidden service requests ending in _rend().
&gt; 
&gt; 2. The various connection and circuit structs don't reserve memory for
&gt; hidden service requests any more. Now there is a new struct rend_data_t
&gt; that holds all hidden-service-specific data and that is pointed to by
&gt; those data structures. I also moved the memory for storing rendezvous
&gt; cookie and hidden service identifier on service side to that new struct.
&gt; 
&gt; --Karsten
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFI2U5f0M+WPffBEmURAvE5AJ9qUaIp7sTzAII+pGwUnT58wqcM0QCfUi5N
BHDouj6sDHfVyu3bl1gU0AY=
=CvOg
-----END PGP SIGNATURE-----

["patch-121-4b.txt" (text/plain)]

Index: /home/karsten/tor/tor-trunk-121-patches/doc/tor.1.in
===================================================================
--- /home/karsten/tor/tor-trunk-121-patches/doc/tor.1.in	(revision 16941)
+++ /home/karsten/tor/tor-trunk-121-patches/doc/tor.1.in	(working copy)
@@ -472,6 +472,15 @@
 ReachableAddresses instead. (Default: 80, 443)
 .LP
 .TP
+\fBHidServAuth \fR\fIonion-address\fR \fIauth-cookie\fP \fIservice-name\fR 
+Client authorization for a hidden service. Valid onion addresses contain 16
+characters in a-z2-7 plus ".onion", and valid auth cookies contain 22
+characters in A-Za-z0-9+/. The service name is only used for internal
+purposes, e.g., for Tor controllers. This option may be used multiple times
+for different hidden services. If a hidden service uses authorization and
+this option is not set, the hidden service is not accessible.
+.LP
+.TP
 \fBReachableAddresses \fR\fIADDR\fP[\fB/\fP\fIMASK\fP][:\fIPORT\fP]...\fP
 A comma-separated list of IP addresses and ports that your firewall allows you
 to connect to. The format is as
@@ -1266,6 +1275,18 @@
 service. Possible version numbers are 0 and 2. (Default: 0, 2)
 .LP
 .TP
+\fBHiddenServiceAuthorizeClient \fR\fIauth-type\fR \fR\fIclient-name\fR,\fIclient-name\fR,\fI...\fP
+If configured, the hidden service is accessible for authorized clients
+only. The auth-type can either be 'basic' for a general-purpose
+authorization protocol or 'stealth' for a less scalable protocol that also
+hides service activity from unauthorized clients. Only clients that are
+listed here are authorized to access the hidden service. Valid client names
+are 1 to 19 characters long and only use characters in A-Za-z0-9+-_
+(no spaces). If this option is set, the hidden service is not accessible
+for clients without authorization any more. Generated authorization data
+can be found in the hostname file.
+.LP
+.TP
 \fBRendPostPeriod \fR\fIN\fR \fBseconds\fR|\fBminutes\fR|\fBhours\fR|\fBdays\fR|\fBweeks\fP
 Every time the specified period elapses, Tor uploads any rendezvous
 service descriptors to the directory servers.  This information is also
@@ -1450,6 +1471,8 @@
 .TP
 .B \fIHiddenServiceDirectory\fP/hostname 
 The &lt;base32-encoded-fingerprint&gt;.onion domain name for this hidden service.
+If the hidden service is restricted to authorized clients only, this file
+also contains authorization data for all clients.
 .LP
 .TP
 .B \fIHiddenServiceDirectory\fP/private_key 
@@ -1454,6 +1477,11 @@
 .TP
 .B \fIHiddenServiceDirectory\fP/private_key 
 The private key for this hidden service.
+.LP
+.TP
+.B \fIHiddenServiceDirectory\fP/client_keys 
+Authorization data for a hidden service that is only accessible by authorized
+clients.
 .SH SEE ALSO
 .BR privoxy (1),
 .BR tsocks (1),
Index: /home/karsten/tor/tor-trunk-121-patches/src/or/circuitlist.c
===================================================================
--- /home/karsten/tor/tor-trunk-121-patches/src/or/circuitlist.c	(revision 16941)
+++ /home/karsten/tor/tor-trunk-121-patches/src/or/circuitlist.c	(working copy)
@@ -401,6 +401,7 @@
     circuit_free_cpath(ocirc-&gt;cpath);
     if (ocirc-&gt;intro_key)
       crypto_free_pk_env(ocirc-&gt;intro_key);
+    tor_free(ocirc-&gt;rend_data);
 
   } else {
     or_circuit_t *ocirc = TO_OR_CIRCUIT(circ);
@@ -720,7 +721,7 @@
 }
 
 /** Return a circ such that:
- *  - circ-\&gt;rend_query is equal to &lt;b&gt;rend_query&lt;/b&gt;, and
+ *  - circ-\&gt;rend_data-\&gt;query is equal to &lt;b&gt;rend_query&lt;/b&gt;, and
  *  - circ-\&gt;purpose is equal to &lt;b&gt;purpose&lt;/b&gt;.
  *
  * Return NULL if no such circuit exists.
@@ -735,7 +736,9 @@
   for (circ = global_circuitlist; circ; circ = circ-&gt;next) {
     if (!circ-&gt;marked_for_close &amp;&amp;
         circ-&gt;purpose == purpose &amp;&amp;
-        !rend_cmp_service_ids(rend_query, TO_ORIGIN_CIRCUIT(circ)-&gt;rend_query))
+        TO_ORIGIN_CIRCUIT(circ)-&gt;rend_data &amp;&amp;
+        !rend_cmp_service_ids(rend_query,
+                    TO_ORIGIN_CIRCUIT(circ)-&gt;rend_data-&gt;onion_address))
       return TO_ORIGIN_CIRCUIT(circ);
   }
   return NULL;
@@ -764,7 +767,8 @@
       continue;
     if (!digest)
       return TO_ORIGIN_CIRCUIT(circ);
-    else if (!memcmp(TO_ORIGIN_CIRCUIT(circ)-&gt;rend_pk_digest,
+    else if (TO_ORIGIN_CIRCUIT(circ)-&gt;rend_data &amp;&amp;
+             !memcmp(TO_ORIGIN_CIRCUIT(circ)-&gt;rend_data-&gt;rend_pk_digest,
                      digest, DIGEST_LEN))
       return TO_ORIGIN_CIRCUIT(circ);
   }
@@ -1020,13 +1024,14 @@
     origin_circuit_t *ocirc = TO_ORIGIN_CIRCUIT(circ);
     tor_assert(circ-&gt;state == CIRCUIT_STATE_OPEN);
     tor_assert(ocirc-&gt;build_state-&gt;chosen_exit);
+    tor_assert(ocirc-&gt;rend_data);
     /* treat this like getting a nack from it */
     log_info(LD_REND, "Failed intro circ %s to %s (awaiting ack). "
              "Removing from descriptor.",
-             safe_str(ocirc-&gt;rend_query),
+             safe_str(ocirc-&gt;rend_data-&gt;onion_address),
              safe_str(build_state_get_exit_nickname(ocirc-&gt;build_state)));
     rend_client_remove_intro_point(ocirc-&gt;build_state-&gt;chosen_exit,
-                                   ocirc-&gt;rend_query);
+                                   ocirc-&gt;rend_data);
   }
   if (circ-&gt;n_conn)
     connection_or_send_destroy(circ-&gt;n_circ_id, circ-&gt;n_conn, reason);
Index: /home/karsten/tor/tor-trunk-121-patches/src/or/circuituse.c
===================================================================
--- /home/karsten/tor/tor-trunk-121-patches/src/or/circuituse.c	(revision 16941)
+++ /home/karsten/tor/tor-trunk-121-patches/src/or/circuituse.c	(working copy)
@@ -121,8 +121,11 @@
       return 0;
     }
   } else { /* not general */
-    if (rend_cmp_service_ids(conn-&gt;rend_query,
-                             TO_ORIGIN_CIRCUIT(circ)-&gt;rend_query)) {
+    if ((conn-&gt;rend_data &amp;&amp; !TO_ORIGIN_CIRCUIT(circ)-&gt;rend_data) ||
+        (!conn-&gt;rend_data &amp;&amp; TO_ORIGIN_CIRCUIT(circ)-&gt;rend_data) ||
+        (conn-&gt;rend_data &amp;&amp; TO_ORIGIN_CIRCUIT(circ)-&gt;rend_data &amp;&amp;
+         rend_cmp_service_ids(conn-&gt;rend_data-&gt;onion_address,
+             TO_ORIGIN_CIRCUIT(circ)-&gt;rend_data-&gt;onion_address))) {
       /* this circ is not for this conn */
       return 0;
     }
@@ -300,7 +303,7 @@
           /* c_rend_ready circs measure age since timestamp_dirty,
            * because that's set when they switch purposes
            */
-          if (TO_ORIGIN_CIRCUIT(victim)-&gt;rend_query[0] ||
+          if (TO_ORIGIN_CIRCUIT(victim)-&gt;rend_data ||
               victim-&gt;timestamp_dirty &gt; cutoff)
             continue;
           break;
@@ -1076,13 +1079,18 @@
 
     if (desired_circuit_purpose == CIRCUIT_PURPOSE_C_INTRODUCE_ACK_WAIT) {
       /* need to pick an intro point */
-      extend_info = rend_client_get_random_intro(conn-&gt;rend_query);
+      tor_assert(conn-&gt;rend_data);
+      extend_info = rend_client_get_random_intro(conn-&gt;rend_data);
       if (!extend_info) {
         log_info(LD_REND,
                  "No intro points for '%s': refetching service descriptor.",
-                 safe_str(conn-&gt;rend_query));
-        rend_client_refetch_renddesc(conn-&gt;rend_query);
-        rend_client_refetch_v2_renddesc(conn-&gt;rend_query);
+                 safe_str(conn-&gt;rend_data-&gt;onion_address));
+        /* Fetch both, v0 and v2 rend descriptors in parallel. Use whichever
+         * arrives first. Exception: When using client authorization, only
+         * fetch v2 descriptors.*/
+        rend_client_refetch_v2_renddesc(conn-&gt;rend_data);
+        if (conn-&gt;rend_data-&gt;auth_type == REND_NO_AUTH)
+          rend_client_refetch_renddesc(conn-&gt;rend_data-&gt;onion_address);
         conn-&gt;_base.state = AP_CONN_STATE_RENDDESC_WAIT;
         return 0;
       }
@@ -1087,7 +1095,8 @@
         return 0;
       }
       log_info(LD_REND,"Chose '%s' as intro point for '%s'.",
-               extend_info-&gt;nickname, safe_str(conn-&gt;rend_query));
+               extend_info-&gt;nickname,
+               safe_str(conn-&gt;rend_data-&gt;onion_address));
     }
 
     /* If we have specified a particular exit node for our
@@ -1163,7 +1172,7 @@
       rep_hist_note_used_internal(time(NULL), need_uptime, 1);
       if (circ) {
         /* write the service_id into circ */
-        strlcpy(circ-&gt;rend_query, conn-&gt;rend_query, sizeof(circ-&gt;rend_query));
+        circ-&gt;rend_data = rend_data_dup(conn-&gt;rend_data);
         if (circ-&gt;_base.purpose == CIRCUIT_PURPOSE_C_ESTABLISH_REND &amp;&amp;
             circ-&gt;_base.state == CIRCUIT_STATE_OPEN)
           rend_client_rendcirc_has_opened(circ);
Index: /home/karsten/tor/tor-trunk-121-patches/src/or/connection.c
===================================================================
--- /home/karsten/tor/tor-trunk-121-patches/src/or/connection.c	(revision 16941)
+++ /home/karsten/tor/tor-trunk-121-patches/src/or/connection.c	(working copy)
@@ -385,6 +385,7 @@
       memset(edge_conn-&gt;socks_request, 0xcc, sizeof(socks_request_t));
       tor_free(edge_conn-&gt;socks_request);
     }
+    tor_free(edge_conn-&gt;rend_data);
   }
   if (conn-&gt;type == CONN_TYPE_CONTROL) {
     control_connection_t *control_conn = TO_CONTROL_CONN(conn);
@@ -405,6 +406,7 @@
     }
     if (dir_conn-&gt;cached_dir)
       cached_dir_decref(dir_conn-&gt;cached_dir);
+    tor_free(dir_conn-&gt;rend_data);
   }
 
   if (conn-&gt;s &gt;= 0) {
@@ -523,7 +525,7 @@
          * failed: forget about this router, and maybe try again. */
         connection_dir_request_failed(dir_conn);
       }
-      if (conn-&gt;purpose == DIR_PURPOSE_FETCH_RENDDESC) {
+      if (conn-&gt;purpose == DIR_PURPOSE_FETCH_RENDDESC &amp;&amp; dir_conn-&gt;rend_data) {
         /* Give it a try. However, there is no re-fetching for v0 rend
          * descriptors; if the response is empty or the descriptor is
          * unusable, close pending connections (unless a v2 request is
@@ -528,7 +530,7 @@
          * descriptors; if the response is empty or the descriptor is
          * unusable, close pending connections (unless a v2 request is
          * still in progress). */
-        rend_client_desc_trynow(dir_conn-&gt;rend_query, 0);
+        rend_client_desc_trynow(dir_conn-&gt;rend_data-&gt;onion_address, 0);
       }
       /* If we were trying to fetch a v2 rend desc and did not succeed,
        * retry as needed. (If a fetch is successful, the connection state
@@ -535,9 +537,10 @@
        * is changed to DIR_PURPOSE_HAS_FETCHED_RENDDESC to mark that
        * refetching is unnecessary.) */
       if (conn-&gt;purpose == DIR_PURPOSE_FETCH_RENDDESC_V2 &amp;&amp;
-          dir_conn-&gt;rend_query &amp;&amp;
-          strlen(dir_conn-&gt;rend_query) == REND_SERVICE_ID_LEN_BASE32)
-        rend_client_refetch_v2_renddesc(dir_conn-&gt;rend_query);
+          dir_conn-&gt;rend_data &amp;&amp; dir_conn-&gt;rend_data-&gt;onion_address &amp;&amp;
+          strlen(dir_conn-&gt;rend_data-&gt;onion_address) ==
+              REND_SERVICE_ID_LEN_BASE32)
+        rend_client_refetch_v2_renddesc(dir_conn-&gt;rend_data);
       break;
     case CONN_TYPE_OR:
       or_conn = TO_OR_CONN(conn);
@@ -2565,6 +2568,7 @@
 
   tor_assert(type == CONN_TYPE_DIR ||
              type == CONN_TYPE_AP || type == CONN_TYPE_EXIT);
+  tor_assert(rendquery);
 
   SMARTLIST_FOREACH(conns, connection_t *, conn,
   {
@@ -2572,12 +2576,16 @@
         !conn-&gt;marked_for_close &amp;&amp;
         (!state || state == conn-&gt;state)) {
       if (type == CONN_TYPE_DIR &amp;&amp;
+          TO_DIR_CONN(conn)-&gt;rend_data &amp;&amp;
           (rendversion &lt; 0 ||
-           rendversion == TO_DIR_CONN(conn)-&gt;rend_version) &amp;&amp;
-          !rend_cmp_service_ids(rendquery, TO_DIR_CONN(conn)-&gt;rend_query))
+           rendversion == TO_DIR_CONN(conn)-&gt;rend_data-&gt;rend_desc_version) &amp;&amp;
+          !rend_cmp_service_ids(rendquery,
+                    TO_DIR_CONN(conn)-&gt;rend_data-&gt;onion_address))
         return conn;
       else if (CONN_IS_EDGE(conn) &amp;&amp;
-              !rend_cmp_service_ids(rendquery, TO_EDGE_CONN(conn)-&gt;rend_query))
+               TO_DIR_CONN(conn)-&gt;rend_data &amp;&amp;
+              !rend_cmp_service_ids(rendquery,
+                        TO_EDGE_CONN(conn)-&gt;rend_data-&gt;onion_address))
         return conn;
     }
   });
Index: /home/karsten/tor/tor-trunk-121-patches/src/or/connection_edge.c
===================================================================
--- /home/karsten/tor/tor-trunk-121-patches/src/or/connection_edge.c	(revision 16941)
+++ /home/karsten/tor/tor-trunk-121-patches/src/or/connection_edge.c	(working copy)
@@ -1587,6 +1587,7 @@
     /* it's a hidden-service request */
     rend_cache_entry_t *entry;
     int r;
+    rend_service_authorization_t *client_auth;
     tor_assert(!automap);
     if (SOCKS_COMMAND_IS_RESOLVE(socks-&gt;command)) {
       /* if it's a resolve request, fail it right now, rather than
@@ -1608,14 +1609,16 @@
       return -1;
     }
 
-    strlcpy(conn-&gt;rend_query, socks-&gt;address, sizeof(conn-&gt;rend_query));
+    conn-&gt;rend_data = tor_malloc_zero(sizeof(rend_data_t));
+    strlcpy(conn-&gt;rend_data-&gt;onion_address, socks-&gt;address,
+            sizeof(conn-&gt;rend_data-&gt;onion_address));
     log_info(LD_REND,"Got a hidden service request for ID '%s'",
-             safe_str(conn-&gt;rend_query));
+             safe_str(conn-&gt;rend_data-&gt;onion_address));
     /* see if we already have it cached */
-    r = rend_cache_lookup_entry(conn-&gt;rend_query, -1, &amp;entry);
+    r = rend_cache_lookup_entry(conn-&gt;rend_data-&gt;onion_address, -1, &amp;entry);
     if (r&lt;0) {
       log_warn(LD_BUG,"Invalid service name '%s'",
-               safe_str(conn-&gt;rend_query));
+               safe_str(conn-&gt;rend_data-&gt;onion_address));
       connection_mark_unattached_ap(conn, END_STREAM_REASON_TORPROTOCOL);
       return -1;
     }
@@ -1624,14 +1627,26 @@
      * a stable circuit yet, but we know we'll need *something*. */
     rep_hist_note_used_internal(now, 0, 1);
 
+    /* Look up if we have client authorization for it. */
+    client_auth = rend_client_lookup_service_authorization(
+                                          conn-&gt;rend_data-&gt;onion_address);
+    if (client_auth) {
+      log_info(LD_REND, "Using previously configured client authorization "
+                        "for hidden service request.");
+      memcpy(conn-&gt;rend_data-&gt;descriptor_cookie,
+             client_auth-&gt;descriptor_cookie, REND_DESC_COOKIE_LEN);
+      conn-&gt;rend_data-&gt;auth_type = client_auth-&gt;auth_type;
+    }
     if (r==0) {
       conn-&gt;_base.state = AP_CONN_STATE_RENDDESC_WAIT;
       log_info(LD_REND, "Unknown descriptor %s. Fetching.",
-               safe_str(conn-&gt;rend_query));
+               safe_str(conn-&gt;rend_data-&gt;onion_address));
       /* Fetch both, v0 and v2 rend descriptors in parallel. Use whichever
-       * arrives first. */
-      rend_client_refetch_v2_renddesc(conn-&gt;rend_query);
-      rend_client_refetch_renddesc(conn-&gt;rend_query);
+       * arrives first. Exception: When using client authorization, only
+       * fetch v2 descriptors.*/
+      rend_client_refetch_v2_renddesc(conn-&gt;rend_data);
+      if (conn-&gt;rend_data-&gt;auth_type == REND_NO_AUTH)
+        rend_client_refetch_renddesc(conn-&gt;rend_data-&gt;onion_address);
     } else { /* r &gt; 0 */
 /** How long after we receive a hidden service descriptor do we consider
  * it valid? */
@@ -1647,11 +1662,13 @@
       } else {
         conn-&gt;_base.state = AP_CONN_STATE_RENDDESC_WAIT;
         log_info(LD_REND, "Stale descriptor %s. Refetching.",
-                 safe_str(conn-&gt;rend_query));
+                 safe_str(conn-&gt;rend_data-&gt;onion_address));
         /* Fetch both, v0 and v2 rend descriptors in parallel. Use whichever
-         * arrives first. */
-        rend_client_refetch_v2_renddesc(conn-&gt;rend_query);
-        rend_client_refetch_renddesc(conn-&gt;rend_query);
+         * arrives first. Exception: When using client authorization, only
+         * fetch v2 descriptors.*/
+        rend_client_refetch_v2_renddesc(conn-&gt;rend_data);
+        if (conn-&gt;rend_data-&gt;auth_type == REND_NO_AUTH)
+          rend_client_refetch_renddesc(conn-&gt;rend_data-&gt;onion_address);
       }
     }
     return 0;
@@ -2531,8 +2548,7 @@
     log_info(LD_REND,"begin is for rendezvous. configuring stream.");
     n_stream-&gt;_base.address = tor_strdup("(rendezvous)");
     n_stream-&gt;_base.state = EXIT_CONN_STATE_CONNECTING;
-    strlcpy(n_stream-&gt;rend_query, origin_circ-&gt;rend_query,
-            sizeof(n_stream-&gt;rend_query));
+    n_stream-&gt;rend_data = rend_data_dup(origin_circ-&gt;rend_data);
     tor_assert(connection_edge_is_rendezvous_stream(n_stream));
     assert_circuit_ok(circ);
     if (rend_service_set_connection_addr_port(n_stream, origin_circ) &lt; 0) {
@@ -2815,7 +2831,7 @@
 connection_edge_is_rendezvous_stream(edge_connection_t *conn)
 {
   tor_assert(conn);
-  if (*conn-&gt;rend_query) /* XXX */ /* XXXX Why is this XXX? -NM */
+  if (conn-&gt;rend_data) /* XXX */ /* XXXX Why is this XXX? -NM */
     return 1;
   return 0;
 }
Index: /home/karsten/tor/tor-trunk-121-patches/src/or/directory.c
===================================================================
--- /home/karsten/tor/tor-trunk-121-patches/src/or/directory.c	(revision 16941)
+++ /home/karsten/tor/tor-trunk-121-patches/src/or/directory.c	(working copy)
@@ -60,6 +60,22 @@
 static void note_client_request(int purpose, int compressed, size_t bytes);
 static int client_likes_consensus(networkstatus_t *v, const char *want_url);
 
+static void directory_initiate_command_rend(const char *address,
+                                            const tor_addr_t *addr,
+                                            uint16_t or_port,
+                                            uint16_t dir_port,
+                                            int supports_conditional_consensus,
+                                            int supports_begindir,
+                                            const char *digest,
+                                            uint8_t dir_purpose,
+                                            uint8_t router_purpose,
+                                            int anonymized_connection,
+                                            const char *resource,
+                                            const char *payload,
+                                            size_t payload_len,
+                                            time_t if_modified_since,
+                                            rend_data_t *rend_query);
+
 /********* START VARIABLES **********/
 
 /** How far in the future do we allow a directory server to tell us it is
@@ -434,29 +450,18 @@
     });
 }
 
-/** Launch a new connection to the directory server &lt;b&gt;status&lt;/b&gt; to
- * upload or download a server or rendezvous
- * descriptor. &lt;b&gt;dir_purpose&lt;/b&gt; determines what
- * kind of directory connection we're launching, and must be one of
- * DIR_PURPOSE_{FETCH|UPLOAD}_{DIR|RENDDESC|RENDDESC_V2}. &lt;b&gt;router_purpose&lt;/b&gt;
- * specifies the descriptor purposes we have in mind (currently only
- * used for FETCH_DIR).
- *
- * When uploading, &lt;b&gt;payload&lt;/b&gt; and &lt;b&gt;payload_len&lt;/b&gt; determine the content
- * of the HTTP post.  Otherwise, &lt;b&gt;payload&lt;/b&gt; should be NULL.
- *
- * When fetching a rendezvous descriptor, &lt;b&gt;resource&lt;/b&gt; is the service ID we
- * want to fetch.
- */
+/** Same as directory_initiate_command_routerstatus(), but accepts
+ * rendezvous data to fetch a hidden service descriptor. */
 void
-directory_initiate_command_routerstatus(routerstatus_t *status,
-                                        uint8_t dir_purpose,
-                                        uint8_t router_purpose,
-                                        int anonymized_connection,
-                                        const char *resource,
-                                        const char *payload,
-                                        size_t payload_len,
-                                        time_t if_modified_since)
+directory_initiate_command_routerstatus_rend(routerstatus_t *status,
+                                             uint8_t dir_purpose,
+                                             uint8_t router_purpose,
+                                             int anonymized_connection,
+                                             const char *resource,
+                                             const char *payload,
+                                             size_t payload_len,
+                                             time_t if_modified_since,
+                                             rend_data_t *rend_query)
 {
   routerinfo_t *router;
   char address_buf[INET_NTOA_BUF_LEN+1];
@@ -476,7 +481,7 @@
     address = address_buf;
   }
   tor_addr_from_ipv4h(&amp;addr, status-&gt;addr);
-  directory_initiate_command(address, &amp;addr,
+  directory_initiate_command_rend(address, &amp;addr,
                              status-&gt;or_port, status-&gt;dir_port,
                              status-&gt;version_supports_conditional_consensus,
                              status-&gt;version_supports_begindir,
@@ -483,7 +488,39 @@
                              status-&gt;identity_digest,
                              dir_purpose, router_purpose,
                              anonymized_connection, resource,
-                             payload, payload_len, if_modified_since);
+                             payload, payload_len, if_modified_since,
+                             rend_query);
+}
+
+/** Launch a new connection to the directory server &lt;b&gt;status&lt;/b&gt; to
+ * upload or download a server or rendezvous
+ * descriptor. &lt;b&gt;dir_purpose&lt;/b&gt; determines what
+ * kind of directory connection we're launching, and must be one of
+ * DIR_PURPOSE_{FETCH|UPLOAD}_{DIR|RENDDESC|RENDDESC_V2}. &lt;b&gt;router_purpose&lt;/b&gt;
+ * specifies the descriptor purposes we have in mind (currently only
+ * used for FETCH_DIR).
+ *
+ * When uploading, &lt;b&gt;payload&lt;/b&gt; and &lt;b&gt;payload_len&lt;/b&gt; determine the content
+ * of the HTTP post.  Otherwise, &lt;b&gt;payload&lt;/b&gt; should be NULL.
+ *
+ * When fetching a rendezvous descriptor, &lt;b&gt;resource&lt;/b&gt; is the service ID we
+ * want to fetch.
+ */
+void
+directory_initiate_command_routerstatus(routerstatus_t *status,
+                                        uint8_t dir_purpose,
+                                        uint8_t router_purpose,
+                                        int anonymized_connection,
+                                        const char *resource,
+                                        const char *payload,
+                                        size_t payload_len,
+                                        time_t if_modified_since)
+{
+  directory_initiate_command_routerstatus_rend(status, dir_purpose,
+                                          router_purpose,
+                                          anonymized_connection, resource,
+                                          payload, payload_len,
+                                          if_modified_since, NULL);
 }
 
 /** Return true iff &lt;b&gt;conn&lt;/b&gt; is the client side of a directory connection
@@ -668,6 +705,28 @@
                            const char *payload, size_t payload_len,
                            time_t if_modified_since)
 {
+  directory_initiate_command_rend(address, _addr, or_port, dir_port,
+                             supports_conditional_consensus,
+                             supports_begindir, digest, dir_purpose,
+                             router_purpose, anonymized_connection,
+                             resource, payload, payload_len,
+                             if_modified_since, NULL);
+}
+
+/** Same as directory_initiate_command(), but accepts rendezvous data to
+ * fetch a hidden service descriptor. */
+static void
+directory_initiate_command_rend(const char *address, const tor_addr_t *_addr,
+                                uint16_t or_port, uint16_t dir_port,
+                                int supports_conditional_consensus,
+                                int supports_begindir, const char *digest,
+                                uint8_t dir_purpose, uint8_t router_purpose,
+                                int anonymized_connection,
+                                const char *resource,
+                                const char *payload, size_t payload_len,
+                                time_t if_modified_since,
+                                rend_data_t *rend_query)
+{
   dir_connection_t *conn;
   or_options_t *options = get_options();
   int socket_error = 0;
@@ -705,6 +764,10 @@
   /* decide whether we can learn our IP address from this conn */
   conn-&gt;dirconn_direct = !anonymized_connection;
 
+  /* copy rendezvous data, if any */
+  if (rend_query)
+    conn-&gt;rend_data = rend_data_dup(rend_query);
+
   if (!anonymized_connection &amp;&amp; !use_begindir) {
     /* then we want to connect to dirport directly */
 
@@ -1005,8 +1068,10 @@
       /* this must be true or we wouldn't be doing the lookup */
       tor_assert(strlen(resource) &lt;= REND_SERVICE_ID_LEN_BASE32);
       /* This breaks the function abstraction. */
-      strlcpy(conn-&gt;rend_query, resource, sizeof(conn-&gt;rend_query));
-      conn-&gt;rend_version = 0;
+      conn-&gt;rend_data = tor_malloc_zero(sizeof(rend_data_t));
+      strlcpy(conn-&gt;rend_data-&gt;onion_address, resource,
+              sizeof(conn-&gt;rend_data-&gt;onion_address));
+      conn-&gt;rend_data-&gt;rend_desc_version = 0;
 
       httpcommand = "GET";
       /* Request the most recent versioned descriptor. */
@@ -1019,10 +1084,8 @@
     case DIR_PURPOSE_FETCH_RENDDESC_V2:
       tor_assert(resource);
       tor_assert(strlen(resource) &lt;= REND_DESC_ID_V2_LEN_BASE32);
-      /* Remember the query to refer to it when a response arrives. */
-      strlcpy(conn-&gt;rend_query, payload, sizeof(conn-&gt;rend_query));
-      conn-&gt;rend_version = 2;
-      payload = NULL;
+      tor_assert(!payload);
+      conn-&gt;rend_data-&gt;rend_desc_version = 2;
       httpcommand = "GET";
       len = strlen(resource) + 32;
       url = tor_malloc(len);
@@ -1877,6 +1940,7 @@
   }
 
   if (conn-&gt;_base.purpose == DIR_PURPOSE_FETCH_RENDDESC) {
+    tor_assert(conn-&gt;rend_data);
     log_info(LD_REND,"Received rendezvous descriptor (size %d, status %d "
              "(%s))",
              (int)body_len, status_code, escaped(reason));
@@ -1892,7 +1956,7 @@
         } else {
           /* success. notify pending connections about this. */
           conn-&gt;_base.purpose = DIR_PURPOSE_HAS_FETCHED_RENDDESC;
-          rend_client_desc_trynow(conn-&gt;rend_query, -1);
+          rend_client_desc_trynow(conn-&gt;rend_data-&gt;onion_address, -1);
         }
         break;
       case 404:
@@ -1914,6 +1978,7 @@
   }
 
   if (conn-&gt;_base.purpose == DIR_PURPOSE_FETCH_RENDDESC_V2) {
+    tor_assert(conn-&gt;rend_data);
     log_info(LD_REND,"Received rendezvous descriptor (size %d, status %d "
              "(%s))",
              (int)body_len, status_code, escaped(reason));
@@ -1919,7 +1984,7 @@
              (int)body_len, status_code, escaped(reason));
     switch (status_code) {
       case 200:
-        switch (rend_cache_store_v2_desc_as_client(body, NULL)) {
+        switch (rend_cache_store_v2_desc_as_client(body, conn-&gt;rend_data)) {
           case -2:
             log_warn(LD_REND,"Fetching v2 rendezvous descriptor failed. "
                      "Retrying at another directory.");
@@ -1938,7 +2003,7 @@
             log_info(LD_REND, "Successfully fetched v2 rendezvous "
                      "descriptor.");
             conn-&gt;_base.purpose = DIR_PURPOSE_HAS_FETCHED_RENDDESC;
-            rend_client_desc_trynow(conn-&gt;rend_query, -1);
+            rend_client_desc_trynow(conn-&gt;rend_data-&gt;onion_address, -1);
             break;
         }
         break;
Index: /home/karsten/tor/tor-trunk-121-patches/src/or/or.h
===================================================================
--- /home/karsten/tor/tor-trunk-121-patches/src/or/or.h	(revision 16941)
+++ /home/karsten/tor/tor-trunk-121-patches/src/or/or.h	(working copy)
@@ -676,6 +676,55 @@
 /** Maximum length of authorized client names for a hidden service. */
 #define REND_CLIENTNAME_MAX_LEN 16
 
+/** Length of the rendezvous cookie that is used to connect circuits at the
+ * rendezvous point. */
+#define REND_COOKIE_LEN DIGEST_LEN
+
+/** Client authorization type that a hidden service performs. */
+typedef enum rend_auth_type_t {
+  REND_NO_AUTH      = 0,
+  REND_BASIC_AUTH   = 1,
+  REND_STEALTH_AUTH = 2,
+} rend_auth_type_t;
+
+/** Client-side configuration of authorization for a hidden service. */
+typedef struct rend_service_authorization_t {
+  char descriptor_cookie[REND_DESC_COOKIE_LEN];
+  char onion_address[REND_SERVICE_ADDRESS_LEN+1];
+  rend_auth_type_t auth_type;
+} rend_service_authorization_t;
+
+/** Client- and server-side data that is used for hidden service connection
+ * establishment. Not all fields contain data depending on where this struct
+ * is used. */
+typedef struct rend_data_t {
+  /** Onion address (without the .onion part) that a client requests. */
+  char onion_address[REND_SERVICE_ID_LEN_BASE32+1];
+
+  /** (Optional) descriptor cookie that is used by a client. */
+  char descriptor_cookie[REND_DESC_COOKIE_LEN];
+
+  /** Authorization type for accessing a service used by a client. */
+  rend_auth_type_t auth_type;
+
+  /** Hash of the hidden service's PK used by a service. */
+  char rend_pk_digest[DIGEST_LEN];
+
+  /** Rendezvous cookie used by both, client and service. */
+  char rend_cookie[REND_COOKIE_LEN];
+
+  /** Rendezvous descriptor version that is used by a service. Used to
+   * distinguish introduction and rendezvous points belonging to the same
+   * rendezvous service ID, but different descriptor versions.
+   */
+  uint8_t rend_desc_version;
+} rend_data_t;
+
+/** Time interval for tracking possible replays of INTRODUCE2 cells.
+ * Incoming cells with timestamps half of this interval in the past or
+ * future are dropped immediately. */
+#define REND_REPLAY_TIME_INTERVAL (60 * 60)
+
 #define CELL_DIRECTION_IN 1
 #define CELL_DIRECTION_OUT 2
 
@@ -1025,7 +1074,7 @@
   uint32_t n_written;
 
   /** What rendezvous service are we querying for? (AP only) */
-  char rend_query[REND_SERVICE_ID_LEN_BASE32+1];
+  rend_data_t *rend_data;
 
   /** Number of times we've reassigned this application connection to
    * a new circuit. We keep track because the timeout is longer if we've
@@ -1078,11 +1127,8 @@
   /** The zlib object doing on-the-fly compression for spooled data. */
   tor_zlib_state_t *zlib_state;
 
-  /** What hidden service descriptor are we fetching, if any? */
-  int rend_version;
-
   /** What rendezvous service are we querying for? */
-  char rend_query[REND_SERVICE_ID_LEN_BASE32+1];
+  rend_data_t *rend_data;
 
   char identity_digest[DIGEST_LEN]; /**&lt; Hash of the public RSA key for
                                      * the directory server's signing key. */
@@ -1747,7 +1793,6 @@
                                  CIPHER_KEY_LEN+\
                                  DH_KEY_LEN)
 #define ONIONSKIN_REPLY_LEN (DH_KEY_LEN+DIGEST_LEN)
-#define REND_COOKIE_LEN DIGEST_LEN
 
 /** Information used to build a circuit. */
 typedef struct {
@@ -1883,28 +1928,8 @@
    */
   crypt_path_t *cpath;
 
-  /** The rend_pk_digest field holds a hash of location-hidden service's
-   * PK if purpose is S_ESTABLISH_INTRO or S_RENDEZVOUSING.
-   */
-  char rend_pk_digest[DIGEST_LEN];
-
-  /** Holds rendezvous cookie if purpose is C_ESTABLISH_REND. Filled with
-   * zeroes otherwise.
-   */
-  char rend_cookie[REND_COOKIE_LEN];
-
-  /**
-   * The rend_query field holds the y portion of y.onion (nul-terminated)
-   * if purpose is C_INTRODUCING or C_ESTABLISH_REND, or is a C_GENERAL
-   * for a hidden service, or is S_*.
-   */
-  char rend_query[REND_SERVICE_ID_LEN_BASE32+1];
-
-  /** Stores the rendezvous descriptor version if purpose is S_*. Used to
-   * distinguish introduction and rendezvous points belonging to the same
-   * rendezvous service ID, but different descriptor versions.
-   */
-  uint8_t rend_desc_version;
+  /** Holds all rendezvous data on either client or service side. */
+  rend_data_t *rend_data;
 
   /** How many more relay_early cells can we send on this circuit, according
    * to the specification? */
@@ -3179,6 +3204,15 @@
                                              const char *payload,
                                              size_t payload_len,
                                              time_t if_modified_since);
+void directory_initiate_command_routerstatus_rend(routerstatus_t *status,
+                                                  uint8_t dir_purpose,
+                                                  uint8_t router_purpose,
+                                                  int anonymized_connection,
+                                                  const char *resource,
+                                                  const char *payload,
+                                                  size_t payload_len,
+                                                  time_t if_modified_since,
+                                                  rend_data_t *rend_query);
 
 int parse_http_response(const char *headers, int *code, time_t *date,
                         compress_method_t *compression, char **response);
@@ -3835,9 +3869,9 @@
 int rend_client_introduction_acked(origin_circuit_t *circ, const char *request,
                                    size_t request_len);
 void rend_client_refetch_renddesc(const char *query);
-void rend_client_refetch_v2_renddesc(const char *query);
+void rend_client_refetch_v2_renddesc(rend_data_t *rend_query);
 int rend_client_remove_intro_point(extend_info_t *failed_intro,
-                                   const char *query);
+                                   rend_data_t *rend_query);
 int rend_client_rendezvous_acked(origin_circuit_t *circ, const char *request,
                                  size_t request_len);
 int rend_client_receive_rendezvous(origin_circuit_t *circ, const char *request,
@@ -3844,25 +3878,10 @@
                                    size_t request_len);
 void rend_client_desc_trynow(const char *query, int rend_version);
 
-extend_info_t *rend_client_get_random_intro(const char *query);
+extend_info_t *rend_client_get_random_intro(rend_data_t *rend_query);
 
 int rend_client_send_introduction(origin_circuit_t *introcirc,
                                   origin_circuit_t *rendcirc);
-
-/** Client authorization type that a hidden service performs. */
-typedef enum rend_auth_type_t {
-  REND_NO_AUTH      = 0,
-  REND_BASIC_AUTH   = 1,
-  REND_STEALTH_AUTH = 2,
-} rend_auth_type_t;
-
-/** Client-side configuration of authorization for a hidden service. */
-typedef struct rend_service_authorization_t {
-  char descriptor_cookie[REND_DESC_COOKIE_LEN];
-  char onion_address[REND_SERVICE_ADDRESS_LEN+1];
-  rend_auth_type_t auth_type;
-} rend_service_authorization_t;
-
 int rend_parse_service_authorization(or_options_t *options,
                                      int validate_only);
 rend_service_authorization_t *rend_client_lookup_service_authorization(
@@ -3868,6 +3887,7 @@
 rend_service_authorization_t *rend_client_lookup_service_authorization(
                                                 const char *onion_address);
 void rend_service_authorization_free_all(void);
+rend_data_t *rend_data_dup(rend_data_t *request);
 
 /********************************* rendcommon.c ***************************/
 
@@ -3947,7 +3967,7 @@
 int rend_cache_lookup_v2_desc_as_dir(const char *query, const char **desc);
 int rend_cache_store(const char *desc, size_t desc_len, int published);
 int rend_cache_store_v2_desc_as_client(const char *desc,
-                               const char *descriptor_cookie);
+                                       rend_data_t *rend_query);
 int rend_cache_store_v2_desc_as_dir(const char *desc);
 int rend_cache_size(void);
 int rend_encode_v2_descriptors(smartlist_t *descs_out,
Index: /home/karsten/tor/tor-trunk-121-patches/src/or/rendclient.c
===================================================================
--- /home/karsten/tor/tor-trunk-121-patches/src/or/rendclient.c	(revision 16941)
+++ /home/karsten/tor/tor-trunk-121-patches/src/or/rendclient.c	(working copy)
@@ -31,9 +31,10 @@
 rend_client_send_establish_rendezvous(origin_circuit_t *circ)
 {
   tor_assert(circ-&gt;_base.purpose == CIRCUIT_PURPOSE_C_ESTABLISH_REND);
+  tor_assert(circ-&gt;rend_data);
   log_info(LD_REND, "Sending an ESTABLISH_RENDEZVOUS cell");
 
-  if (crypto_rand(circ-&gt;rend_cookie, REND_COOKIE_LEN) &lt; 0) {
+  if (crypto_rand(circ-&gt;rend_data-&gt;rend_cookie, REND_COOKIE_LEN) &lt; 0) {
     log_warn(LD_BUG, "Internal error: Couldn't produce random cookie.");
     circuit_mark_for_close(TO_CIRCUIT(circ), END_CIRC_REASON_INTERNAL);
     return -1;
@@ -40,7 +41,8 @@
   }
   if (relay_send_command_from_edge(0, TO_CIRCUIT(circ),
                                    RELAY_COMMAND_ESTABLISH_RENDEZVOUS,
-                                   circ-&gt;rend_cookie, REND_COOKIE_LEN,
+                                   circ-&gt;rend_data-&gt;rend_cookie,
+                                   REND_COOKIE_LEN,
                                    circ-&gt;cpath-&gt;prev)&lt;0) {
     /* circ is already marked for close */
     log_warn(LD_GENERAL, "Couldn't send ESTABLISH_RENDEZVOUS cell");
@@ -58,7 +60,7 @@
                               origin_circuit_t *rendcirc)
 {
   size_t payload_len;
-  int r;
+  int r, v3_shift = 0;
   char payload[RELAY_PAYLOAD_SIZE];
   char tmp[RELAY_PAYLOAD_SIZE];
   rend_cache_entry_t *entry;
@@ -68,13 +70,16 @@
 
   tor_assert(introcirc-&gt;_base.purpose == CIRCUIT_PURPOSE_C_INTRODUCING);
   tor_assert(rendcirc-&gt;_base.purpose == CIRCUIT_PURPOSE_C_REND_READY);
-  tor_assert(!rend_cmp_service_ids(introcirc-&gt;rend_query,
-                                   rendcirc-&gt;rend_query));
+  tor_assert(introcirc-&gt;rend_data);
+  tor_assert(rendcirc-&gt;rend_data);
+  tor_assert(!rend_cmp_service_ids(introcirc-&gt;rend_data-&gt;onion_address,
+                                   rendcirc-&gt;rend_data-&gt;onion_address));
 
-  if (rend_cache_lookup_entry(introcirc-&gt;rend_query, -1, &amp;entry) &lt; 1) {
+  if (rend_cache_lookup_entry(introcirc-&gt;rend_data-&gt;onion_address, -1,
+                              &amp;entry) &lt; 1) {
     log_warn(LD_REND,
              "query %s didn't have valid rend desc in cache. Failing.",
-             escaped_safe_str(introcirc-&gt;rend_query));
+             escaped_safe_str(introcirc-&gt;rend_data-&gt;onion_address));
     goto err;
   }
 
@@ -117,22 +122,40 @@
     }
   }
 
+  /* If version is 3, write (optional) auth data and timestamp. */
+  if (entry-&gt;parsed-&gt;protocols &amp; (1&lt;&lt;3)) {
+    tmp[0] = 3; /* version 3 of the cell format */
+    tmp[1] = (uint8_t)introcirc-&gt;rend_data-&gt;auth_type; /* auth type, if any */
+    v3_shift = 1;
+    if (introcirc-&gt;rend_data-&gt;auth_type != REND_NO_AUTH) {
+      set_uint16(tmp+2, htons(REND_DESC_COOKIE_LEN));
+      memcpy(tmp+4, introcirc-&gt;rend_data-&gt;descriptor_cookie,
+             REND_DESC_COOKIE_LEN);
+      v3_shift += 2+REND_DESC_COOKIE_LEN;
+    }
+    set_uint32(tmp+v3_shift+1, htonl(time(NULL)));
+    v3_shift += 4;
+  } /* if version 2 only write version number */
+  else if (entry-&gt;parsed-&gt;protocols &amp; (1&lt;&lt;2)) {
+    tmp[0] = 2; /* version 2 of the cell format */
+  }
+
   /* write the remaining items into tmp */
-  if (entry-&gt;parsed-&gt;protocols &amp; (1&lt;&lt;2)) {
+  if (entry-&gt;parsed-&gt;protocols &amp; (1&lt;&lt;3) || entry-&gt;parsed-&gt;protocols &amp; (1&lt;&lt;2)) {
     /* version 2 format */
     extend_info_t *extend_info = rendcirc-&gt;build_state-&gt;chosen_exit;
     int klen;
-    tmp[0] = 2; /* version 2 of the cell format */
     /* nul pads */
-    set_uint32(tmp+1, tor_addr_to_ipv4h(&amp;extend_info-&gt;addr));
-    set_uint16(tmp+5, htons(extend_info-&gt;port));
-    memcpy(tmp+7, extend_info-&gt;identity_digest, DIGEST_LEN);
-    klen = crypto_pk_asn1_encode(extend_info-&gt;onion_key, tmp+7+DIGEST_LEN+2,
-                                 sizeof(tmp)-(7+DIGEST_LEN+2));
-    set_uint16(tmp+7+DIGEST_LEN, htons(klen));
-    memcpy(tmp+7+DIGEST_LEN+2+klen, rendcirc-&gt;rend_cookie,
+    set_uint32(tmp+v3_shift+1, tor_addr_to_ipv4h(&amp;extend_info-&gt;addr));
+    set_uint16(tmp+v3_shift+5, htons(extend_info-&gt;port));
+    memcpy(tmp+v3_shift+7, extend_info-&gt;identity_digest, DIGEST_LEN);
+    klen = crypto_pk_asn1_encode(extend_info-&gt;onion_key,
+                                 tmp+v3_shift+7+DIGEST_LEN+2,
+                                 sizeof(tmp)-(v3_shift+7+DIGEST_LEN+2));
+    set_uint16(tmp+v3_shift+7+DIGEST_LEN, htons(klen));
+    memcpy(tmp+v3_shift+7+DIGEST_LEN+2+klen, rendcirc-&gt;rend_data-&gt;rend_cookie,
            REND_COOKIE_LEN);
-    dh_offset = 7+DIGEST_LEN+2+klen+REND_COOKIE_LEN;
+    dh_offset = v3_shift+7+DIGEST_LEN+2+klen+REND_COOKIE_LEN;
   } else {
     /* Version 0. */
     strncpy(tmp, rendcirc-&gt;build_state-&gt;chosen_exit-&gt;nickname,
@@ -137,7 +160,7 @@
     /* Version 0. */
     strncpy(tmp, rendcirc-&gt;build_state-&gt;chosen_exit-&gt;nickname,
             (MAX_NICKNAME_LEN+1)); /* nul pads */
-    memcpy(tmp+MAX_NICKNAME_LEN+1, rendcirc-&gt;rend_cookie,
+    memcpy(tmp+MAX_NICKNAME_LEN+1, rendcirc-&gt;rend_data-&gt;rend_cookie,
            REND_COOKIE_LEN);
     dh_offset = MAX_NICKNAME_LEN+1+REND_COOKIE_LEN;
   }
@@ -216,6 +239,7 @@
   }
 
   tor_assert(circ-&gt;build_state-&gt;chosen_exit);
+  tor_assert(circ-&gt;rend_data);
 
   if (request_len == 0) {
     /* It's an ACK; the introduction point relayed our introduction request. */
@@ -224,7 +248,7 @@
      */
     log_info(LD_REND,"Received ack. Telling rend circ...");
     rendcirc = circuit_get_by_rend_query_and_purpose(
-               circ-&gt;rend_query, CIRCUIT_PURPOSE_C_REND_READY);
+               circ-&gt;rend_data-&gt;onion_address, CIRCUIT_PURPOSE_C_REND_READY);
     if (rendcirc) { /* remember the ack */
       rendcirc-&gt;_base.purpose = CIRCUIT_PURPOSE_C_REND_READY_INTRO_ACKED;
     } else {
@@ -241,7 +265,7 @@
      * If none remain, refetch the service descriptor.
      */
     if (rend_client_remove_intro_point(circ-&gt;build_state-&gt;chosen_exit,
-                                       circ-&gt;rend_query) &gt; 0) {
+                                       circ-&gt;rend_data) &gt; 0) {
       /* There are introduction points left. Re-extend the circuit to
        * another intro point and try again. */
       extend_info_t *extend_info;
@@ -246,10 +270,10 @@
        * another intro point and try again. */
       extend_info_t *extend_info;
       int result;
-      extend_info = rend_client_get_random_intro(circ-&gt;rend_query);
+      extend_info = rend_client_get_random_intro(circ-&gt;rend_data);
       if (!extend_info) {
         log_warn(LD_REND, "No introduction points left for %s. Closing.",
-                 escaped_safe_str(circ-&gt;rend_query));
+                 escaped_safe_str(circ-&gt;rend_data-&gt;onion_address));
         circuit_mark_for_close(TO_CIRCUIT(circ), END_CIRC_REASON_INTERNAL);
         return -1;
       }
@@ -256,7 +280,7 @@
       log_info(LD_REND,
                "Got nack for %s from %s. Re-extending circ %d, "
                "this time to %s.",
-               escaped_safe_str(circ-&gt;rend_query),
+               escaped_safe_str(circ-&gt;rend_data-&gt;onion_address),
                circ-&gt;build_state-&gt;chosen_exit-&gt;nickname, circ-&gt;_base.n_circ_id,
                extend_info-&gt;nickname);
       result = circuit_extend_to_new_exit(circ, extend_info);
@@ -337,7 +361,7 @@
  * descriptor, return 0, and in case of a failure -1. &lt;b&gt;query&lt;/b&gt; is only
  * passed for pretty log statements. */
 static int
-directory_get_from_hs_dir(const char *desc_id, const char *query)
+directory_get_from_hs_dir(const char *desc_id, rend_data_t *rend_query)
 {
   smartlist_t *responsible_dirs = smartlist_create();
   routerstatus_t *hs_dir;
@@ -343,9 +367,9 @@
   routerstatus_t *hs_dir;
   char desc_id_base32[REND_DESC_ID_V2_LEN_BASE32 + 1];
   time_t now = time(NULL);
+  char descriptor_cookie_base64[3*REND_DESC_COOKIE_LEN_BASE64];
   tor_assert(desc_id);
-  tor_assert(query);
-  tor_assert(strlen(query) == REND_SERVICE_ID_LEN_BASE32);
+  tor_assert(rend_query);
   /* Determine responsible dirs. Even if we can't get all we want,
    * work with the ones we have. If it's empty, we'll notice below. */
   (int) hid_serv_get_responsible_directories(responsible_dirs, desc_id);
@@ -377,17 +401,33 @@
    * directory now. */
   lookup_last_hid_serv_request(hs_dir, desc_id_base32, now, 1);
 
-  /* Send fetch request. (Pass query as payload to write it to the directory
-   * connection so that it can be referred to when the response arrives.) */
-  directory_initiate_command_routerstatus(hs_dir,
+  /* Encode descriptor cookie for logging purposes. */
+  if (rend_query-&gt;auth_type != REND_NO_AUTH &amp;&amp;
+      base64_encode(descriptor_cookie_base64, 3*REND_DESC_COOKIE_LEN_BASE64,
+                    rend_query-&gt;descriptor_cookie, REND_DESC_COOKIE_LEN) &lt; 0) {
+    log_warn(LD_BUG, "Could not base64-encode descriptor cookie.");
+    return 0;
+  }
+  /* Remove == signs and newline. */
+  descriptor_cookie_base64[strlen(descriptor_cookie_base64)-3] = '\0';
+
+  /* Send fetch request. (Pass query and possibly descriptor cookie so that
+   * they can be written to the directory connection and be referred to when
+   * the response arrives. */
+  directory_initiate_command_routerstatus_rend(hs_dir,
                                           DIR_PURPOSE_FETCH_RENDDESC_V2,
                                           ROUTER_PURPOSE_GENERAL,
-                                          1, desc_id_base32, query, 0, 0);
+                                          1, desc_id_base32, NULL, 0, 0,
+                                          rend_query);
   log_info(LD_REND, "Sending fetch request for v2 descriptor for "
-                    "service '%s' with descriptor ID '%s' to hidden "
-                    "service directory '%s' on port %d.",
-           safe_str(query), safe_str(desc_id_base32), hs_dir-&gt;nickname,
-           hs_dir-&gt;dir_port);
+                    "service '%s' with descriptor ID '%s', auth type %d, "
+                    "and descriptor cookie '%s' to hidden service "
+                    "directory '%s' on port %d.",
+           rend_query-&gt;onion_address, desc_id_base32,
+           rend_query-&gt;auth_type,
+           (rend_query-&gt;auth_type == REND_NO_AUTH ? "NULL" :
+           escaped_safe_str(descriptor_cookie_base64)),
+           hs_dir-&gt;nickname, hs_dir-&gt;dir_port);
   return 1;
 }
 
@@ -417,7 +457,7 @@
  * &lt;b&gt;query&lt;/b&gt;.
  */
 void
-rend_client_refetch_v2_renddesc(const char *query)
+rend_client_refetch_v2_renddesc(rend_data_t *rend_query)
 {
   char descriptor_id[DIGEST_LEN];
   int replicas_left_to_try[REND_NUMBER_OF_NON_CONSECUTIVE_REPLICAS];
@@ -423,8 +463,7 @@
   int replicas_left_to_try[REND_NUMBER_OF_NON_CONSECUTIVE_REPLICAS];
   int i, tries_left;
   rend_cache_entry_t *e = NULL;
-  tor_assert(query);
-  tor_assert(strlen(query) == REND_SERVICE_ID_LEN_BASE32);
+  tor_assert(rend_query);
   /* Are we configured to fetch descriptors? */
   if (!get_options()-&gt;FetchHidServDescriptors) {
     log_warn(LD_REND, "We received an onion address for a v2 rendezvous "
@@ -432,7 +471,7 @@
     return;
   }
   /* Before fetching, check if we already have the descriptor here. */
-  if (rend_cache_lookup_entry(query, -1, &amp;e) &gt; 0) {
+  if (rend_cache_lookup_entry(rend_query-&gt;onion_address, -1, &amp;e) &gt; 0) {
     log_info(LD_REND, "We would fetch a v2 rendezvous descriptor, but we "
                       "already have that descriptor here. Not fetching.");
     return;
@@ -438,7 +477,7 @@
     return;
   }
   log_debug(LD_REND, "Fetching v2 rendezvous descriptor for service %s",
-            safe_str(query));
+            safe_str(rend_query-&gt;onion_address));
   /* Randomly iterate over the replicas until a descriptor can be fetched
    * from one of the consecutive nodes, or no options are left. */
   tries_left = REND_NUMBER_OF_NON_CONSECUTIVE_REPLICAS;
@@ -449,8 +488,10 @@
     int chosen_replica = replicas_left_to_try[rand];
     replicas_left_to_try[rand] = replicas_left_to_try[--tries_left];
 
-    if (rend_compute_v2_desc_id(descriptor_id, query, NULL, time(NULL),
-                                chosen_replica) &lt; 0) {
+    if (rend_compute_v2_desc_id(descriptor_id, rend_query-&gt;onion_address,
+                                rend_query-&gt;auth_type == REND_STEALTH_AUTH ?
+                                    rend_query-&gt;descriptor_cookie : NULL,
+                                time(NULL), chosen_replica) &lt; 0) {
       log_warn(LD_REND, "Internal error: Computing v2 rendezvous "
                         "descriptor ID did not succeed.");
       return;
@@ -455,7 +496,7 @@
                         "descriptor ID did not succeed.");
       return;
     }
-    if (directory_get_from_hs_dir(descriptor_id, query) != 0)
+    if (directory_get_from_hs_dir(descriptor_id, rend_query) != 0)
       return; /* either success or failure, but we're done */
   }
   /* If we come here, there are no hidden service directories left. */
@@ -463,7 +504,7 @@
                     "service directories to fetch descriptors, because "
                     "we already tried them all unsuccessfully.");
   /* Close pending connections (unless a v0 request is still going on). */
-  rend_client_desc_trynow(query, 2);
+  rend_client_desc_trynow(rend_query-&gt;onion_address, 2);
   return;
 }
 
@@ -474,7 +515,8 @@
  * unrecognized, 1 if recognized and some intro points remain.
  */
 int
-rend_client_remove_intro_point(extend_info_t *failed_intro, const char *query)
+rend_client_remove_intro_point(extend_info_t *failed_intro,
+                               rend_data_t *rend_query)
 {
   int i, r;
   rend_cache_entry_t *ent;
@@ -480,9 +522,10 @@
   rend_cache_entry_t *ent;
   connection_t *conn;
 
-  r = rend_cache_lookup_entry(query, -1, &amp;ent);
+  r = rend_cache_lookup_entry(rend_query-&gt;onion_address, -1, &amp;ent);
   if (r&lt;0) {
-    log_warn(LD_BUG, "Malformed service ID %s.", escaped_safe_str(query));
+    log_warn(LD_BUG, "Malformed service ID %s.",
+             escaped_safe_str(rend_query-&gt;onion_address));
     return -1;
   }
   if (r==0) {
@@ -487,11 +530,13 @@
   }
   if (r==0) {
     log_info(LD_REND, "Unknown service %s. Re-fetching descriptor.",
-             escaped_safe_str(query));
+             escaped_safe_str(rend_query-&gt;onion_address));
     /* Fetch both, v0 and v2 rend descriptors in parallel. Use whichever
-     * arrives first. */
-    rend_client_refetch_v2_renddesc(query);
-    rend_client_refetch_renddesc(query);
+     * arrives first. Exception: When using client authorization, only
+     * fetch v2 descriptors.*/
+    rend_client_refetch_v2_renddesc(rend_query);
+    if (rend_query-&gt;auth_type == REND_NO_AUTH)
+      rend_client_refetch_renddesc(rend_query-&gt;onion_address);
     return 0;
   }
 
@@ -508,15 +553,18 @@
   if (smartlist_len(ent-&gt;parsed-&gt;intro_nodes) == 0) {
     log_info(LD_REND,
              "No more intro points remain for %s. Re-fetching descriptor.",
-             escaped_safe_str(query));
+             escaped_safe_str(rend_query-&gt;onion_address));
     /* Fetch both, v0 and v2 rend descriptors in parallel. Use whichever
-     * arrives first. */
-    rend_client_refetch_v2_renddesc(query);
-    rend_client_refetch_renddesc(query);
+     * arrives first. Exception: When using client authorization, only
+     * fetch v2 descriptors.*/
+    rend_client_refetch_v2_renddesc(rend_query);
+    if (rend_query-&gt;auth_type == REND_NO_AUTH)
+      rend_client_refetch_renddesc(rend_query-&gt;onion_address);
 
     /* move all pending streams back to renddesc_wait */
     while ((conn = connection_get_by_type_state_rendquery(CONN_TYPE_AP,
-                                   AP_CONN_STATE_CIRCUIT_WAIT, query, -1))) {
+                                   AP_CONN_STATE_CIRCUIT_WAIT,
+                                   rend_query-&gt;onion_address, -1))) {
       conn-&gt;state = AP_CONN_STATE_RENDDESC_WAIT;
     }
 
@@ -523,7 +571,8 @@
     return 0;
   }
   log_info(LD_REND,"%d options left for %s.",
-           smartlist_len(ent-&gt;parsed-&gt;intro_nodes), escaped_safe_str(query));
+           smartlist_len(ent-&gt;parsed-&gt;intro_nodes),
+           escaped_safe_str(rend_query-&gt;onion_address));
   return 1;
 }
 
@@ -648,10 +697,13 @@
         _conn-&gt;marked_for_close)
       continue;
     conn = TO_EDGE_CONN(_conn);
-    if (rend_cmp_service_ids(query, conn-&gt;rend_query))
+    if (!conn-&gt;rend_data)
+      continue;
+    if (rend_cmp_service_ids(query, conn-&gt;rend_data-&gt;onion_address))
       continue;
     assert_connection_ok(TO_CONN(conn), now);
-    if (rend_cache_lookup_entry(conn-&gt;rend_query, -1, &amp;entry) == 1 &amp;&amp;
+    if (rend_cache_lookup_entry(conn-&gt;rend_data-&gt;onion_address, -1,
+                                &amp;entry) == 1 &amp;&amp;
         smartlist_len(entry-&gt;parsed-&gt;intro_nodes) &gt; 0) {
       /* either this fetch worked, or it failed but there was a
        * valid entry from before which we should reuse */
@@ -689,7 +741,7 @@
  * have been tried and failed.
  */
 extend_info_t *
-rend_client_get_random_intro(const char *query)
+rend_client_get_random_intro(rend_data_t *rend_query)
 {
   int i;
   rend_cache_entry_t *entry;
@@ -696,10 +748,10 @@
   rend_intro_point_t *intro;
   routerinfo_t *router;
 
-  if (rend_cache_lookup_entry(query, -1, &amp;entry) &lt; 1) {
+  if (rend_cache_lookup_entry(rend_query-&gt;onion_address, -1, &amp;entry) &lt; 1) {
     log_warn(LD_REND,
              "Query '%s' didn't have valid rend desc in cache. Failing.",
-             safe_str(query));
+             safe_str(rend_query-&gt;onion_address));
     return NULL;
   }
 
Index: /home/karsten/tor/tor-trunk-121-patches/src/or/rendcommon.c
===================================================================
--- /home/karsten/tor/tor-trunk-121-patches/src/or/rendcommon.c	(revision 16941)
+++ /home/karsten/tor/tor-trunk-121-patches/src/or/rendcommon.c	(working copy)
@@ -1242,8 +1242,7 @@
  * than one we've already got; return 1 if it's novel.
  */
 int
-rend_cache_store_v2_desc_as_client(const char *desc,
-                                   const char *descriptor_cookie)
+rend_cache_store_v2_desc_as_client(const char *desc, rend_data_t *rend_query)
 {
   /*XXXX this seems to have a bit of duplicate code with
    * rend_cache_store_v2_desc_as_dir().  Fix that. */
@@ -1272,7 +1271,6 @@
   rend_cache_entry_t *e;
   tor_assert(rend_cache);
   tor_assert(desc);
-  (void) descriptor_cookie; /* We don't use it, yet. */
   /* Parse the descriptor. */
   if (rend_parse_v2_service_descriptor(&amp;parsed, desc_id, &amp;intro_content,
                                        &amp;intro_size, &amp;encoded_size,
@@ -1291,10 +1289,32 @@
   }
   /* Decode/decrypt introduction points. */
   if (intro_content) {
+    if (rend_query-&gt;auth_type != REND_NO_AUTH &amp;&amp;
+        rend_query-&gt;descriptor_cookie) {
+      char *ipos_decrypted;
+      size_t ipos_decrypted_size;
+      if (rend_decrypt_introduction_points(&amp;ipos_decrypted,
+                                           &amp;ipos_decrypted_size,
+                                           rend_query-&gt;descriptor_cookie,
+                                           intro_content,
+                                           intro_size) &lt; 0) {
+        log_warn(LD_REND, "Failed to decrypt introduction points. We are "
+                 "probably unable to parse the encoded introduction points.");
+      } else {
+        /* Replace encrypted with decrypted introduction points. */
+        log_info(LD_REND, "Successfully decrypted introduction points.");
+        tor_free(intro_content);
+        intro_content = ipos_decrypted;
+        intro_size = ipos_decrypted_size;
+      }
+    }
     if (rend_parse_introduction_points(parsed, intro_content,
-                                       intro_size) &lt; 0) {
-      log_warn(LD_PROTOCOL,"Couldn't decode/decrypt introduction points.");
-      rend_service_descriptor_free(parsed);
+                                       intro_size) &lt;= 0) {
+      log_warn(LD_REND, "Failed to parse introduction points. Either the "
+               "service has published a corrupt descriptor or you have "
+               "provided invalid authorization data.");
+      if (parsed)
+        rend_service_descriptor_free(parsed);
       tor_free(intro_content);
       return -2;
     }
@@ -1299,6 +1319,7 @@
       return -2;
     }
   } else {
+    log_info(LD_REND, "Descriptor does not contain any introduction points.");
     parsed-&gt;intro_nodes = smartlist_create();
   }
   /* We don't need the encoded/encrypted introduction points any longer. */
@@ -1426,3 +1447,15 @@
   return strmap_size(rend_cache);
 }
 
+/** Allocate and return a new rend_data_t with the same
+ * contents as &lt;b&gt;query&lt;/b&gt;. */
+rend_data_t *
+rend_data_dup(rend_data_t *data)
+{
+  rend_data_t *newdata;
+  tor_assert(data);
+  newdata = tor_malloc_zero(sizeof(rend_data_t));
+  memcpy(newdata, data, sizeof(rend_data_t));
+  return newdata;
+}
+
Index: /home/karsten/tor/tor-trunk-121-patches/src/or/rendservice.c
===================================================================
--- /home/karsten/tor/tor-trunk-121-patches/src/or/rendservice.c	(revision 16941)
+++ /home/karsten/tor/tor-trunk-121-patches/src/or/rendservice.c	(working copy)
@@ -69,8 +69,16 @@
                          * up-to-date. */
   time_t next_upload_time; /**&lt; Scheduled next hidden service descriptor
                             * upload time. */
+  smartlist_t *accepted_intros; /**&lt; List of client_access_event_t's for
+                                 * accepted and answered INTRODUCE2 cells. */
 } rend_service_t;
 
+/** The event of a client accessing our hidden service. */
+typedef struct client_access_event_t {
+  time_t access_time;
+  char diffie_hellman_hash[DIGEST_LEN];
+} client_access_event_t;
+
 /** A list of rend_service_t's for services run on this OP.
  */
 static smartlist_t *rend_service_list = NULL;
@@ -360,7 +368,7 @@
       if (smartlist_len(type_names_split) &lt; 2) {
         log_warn(LD_CONFIG, "HiddenServiceAuthorizeClient contains "
                             "auth-type '%s', but no client names.",
-                 service-&gt;auth_type == 1 ? "basic" : "stealth");
+                 service-&gt;auth_type == REND_BASIC_AUTH ? "basic" : "stealth");
         SMARTLIST_FOREACH(type_names_split, char *, cp, tor_free(cp));
         smartlist_free(type_names_split);
         continue;
@@ -423,7 +431,7 @@
                             "authorization type '%s'.",
                  smartlist_len(service-&gt;clients),
                  service-&gt;auth_type == REND_BASIC_AUTH ? 512 : 16,
-                 service-&gt;auth_type == 1 ? "basic" : "stealth");
+                 service-&gt;auth_type == REND_BASIC_AUTH ? "basic" : "stealth");
         rend_service_free(service);
         return -1;
       }
@@ -720,8 +728,10 @@
       tor_free(client_keys_str);
       strmap_free(parsed_clients, rend_authorized_client_strmap_item_free);
       if (r&lt;0) {
-        abort_writing_to_file(open_cfile);
-        abort_writing_to_file(open_hfile);
+        if (open_cfile)
+          abort_writing_to_file(open_cfile);
+        if (open_hfile)
+          abort_writing_to_file(open_hfile);
         return r;
       } else {
         finish_writing_to_file(open_cfile);
@@ -764,6 +774,45 @@
   return 0;
 }
 
+/** Check client authorization of a given &lt;b&gt;descriptor_cookie&lt;/b&gt; for
+ * &lt;b&gt;service&lt;/b&gt;. Return 1 for success and 0 for failure. */
+static int
+rend_check_authorization(rend_service_t *service,
+                         const char *descriptor_cookie)
+{
+  rend_authorized_client_t *auth_client = NULL;
+  tor_assert(service);
+  tor_assert(descriptor_cookie);
+  if (!service-&gt;clients) {
+    log_warn(LD_BUG, "Can't check authorization for a service that has no "
+                     "authorized clients configured.");
+    return 0;
+  }
+
+  /* Look up client authorization by descriptor cookie. */
+  SMARTLIST_FOREACH(service-&gt;clients, rend_authorized_client_t *, client, {
+    if (!memcmp(client-&gt;descriptor_cookie, descriptor_cookie,
+                REND_DESC_COOKIE_LEN)) {
+      auth_client = client;
+      break;
+    }
+  });
+  if (!auth_client) {
+    char descriptor_cookie_base64[3*REND_DESC_COOKIE_LEN_BASE64];
+    base64_encode(descriptor_cookie_base64, sizeof(descriptor_cookie_base64),
+                  descriptor_cookie, REND_DESC_COOKIE_LEN);
+    log_info(LD_REND, "No authorization found for descriptor cookie '%s'! "
+                      "Dropping cell!",
+             descriptor_cookie_base64);
+    return 0;
+  }
+
+  /* Allow the request. */
+  log_info(LD_REND, "Client %s could be identified for service %s.",
+           auth_client-&gt;client_name, service-&gt;service_id);
+  return 1;
+}
+
 /******
  * Handle cells
  ******/
@@ -780,7 +829,7 @@
   char buf[RELAY_PAYLOAD_SIZE];
   char keys[DIGEST_LEN+CPATH_KEY_MATERIAL_LEN]; /* Holds KH, Df, Db, Kf, Kb */
   rend_service_t *service;
-  int r, i;
+  int r, i, v3_shift = 0;
   size_t len, keylen;
   crypto_dh_env_t *dh = NULL;
   origin_circuit_t *launched = NULL;
@@ -791,9 +840,17 @@
   int reason = END_CIRC_REASON_TORPROTOCOL;
   crypto_pk_env_t *intro_key;
   char intro_key_digest[DIGEST_LEN];
+  int auth_type;
+  size_t auth_len = 0;
+  char auth_data[REND_DESC_COOKIE_LEN];
+  crypto_digest_env_t *digest = NULL;
+  time_t now = time(NULL);
+  char diffie_hellman_hash[DIGEST_LEN];
+  client_access_event_t *event = NULL;
+  tor_assert(circuit-&gt;rend_data);
 
   base32_encode(serviceid, REND_SERVICE_ID_LEN_BASE32+1,
-                circuit-&gt;rend_pk_digest, REND_SERVICE_ID_LEN);
+                circuit-&gt;rend_data-&gt;rend_pk_digest, REND_SERVICE_ID_LEN);
   log_info(LD_REND, "Received INTRODUCE2 cell for service %s on circ %d.",
            escaped(serviceid), circuit-&gt;_base.n_circ_id);
 
@@ -814,7 +871,8 @@
 
   /* look up service depending on circuit. */
   service = rend_service_get_by_pk_digest_and_version(
-              circuit-&gt;rend_pk_digest, circuit-&gt;rend_desc_version);
+              circuit-&gt;rend_data-&gt;rend_pk_digest,
+              circuit-&gt;rend_data-&gt;rend_desc_version);
   if (!service) {
     log_warn(LD_REND, "Got an INTRODUCE2 cell for an unrecognized service %s.",
              escaped(serviceid));
@@ -822,7 +880,7 @@
   }
 
   /* if descriptor version is 2, use intro key instead of service key. */
-  if (circuit-&gt;rend_desc_version == 0) {
+  if (circuit-&gt;rend_data-&gt;rend_desc_version == 0) {
     intro_key = service-&gt;private_key;
   } else {
     intro_key = circuit-&gt;intro_key;
@@ -854,13 +912,49 @@
     return -1;
   }
   len = r;
-  if (*buf == 2) {
+  if (*buf == 3) {
+    /* Version 3 INTRODUCE2 cell. */
+    time_t ts = 0, now = time(NULL);
+    v3_shift = 1;
+    auth_type = buf[1];
+    switch (auth_type) {
+      case REND_BASIC_AUTH:
+        /* fall through */
+      case REND_STEALTH_AUTH:
+        auth_len = ntohs(get_uint16(buf+2));
+        if (auth_len != REND_DESC_COOKIE_LEN) {
+          log_info(LD_REND, "Wrong auth data size %d, should be %d.",
+                   (int)auth_len, REND_DESC_COOKIE_LEN);
+          return -1;
+        }
+        memcpy(auth_data, buf+4, sizeof(auth_data));
+        v3_shift += 2+REND_DESC_COOKIE_LEN;
+        break;
+      case REND_NO_AUTH:
+        break;
+      default:
+        log_info(LD_REND, "Unknown authorization type '%d'", auth_type);
+    }
+
+    /* Check timestamp. */
+    memcpy((char*)&amp;ts, buf+1+v3_shift, sizeof(uint32_t));
+    v3_shift += 4;
+    ts = ntohl(ts);
+    if ((now - ts) &lt; -1 * REND_REPLAY_TIME_INTERVAL / 2 ||
+        (now - ts) &gt; REND_REPLAY_TIME_INTERVAL / 2) {
+      log_warn(LD_REND, "INTRODUCE2 cell is too %s. Discarding.",
+          (now - ts) &lt; 0 ? "old" : "new");
+      return -1;
+    }
+  }
+  if (*buf == 2 || *buf == 3) {
     /* Version 2 INTRODUCE2 cell. */
     int klen;
     extend_info = tor_malloc_zero(sizeof(extend_info_t));
-    tor_addr_from_ipv4n(&amp;extend_info-&gt;addr, get_uint32(buf+1));
-    extend_info-&gt;port = ntohs(get_uint16(buf+5));
-    memcpy(extend_info-&gt;identity_digest, buf+7, DIGEST_LEN);
+    tor_addr_from_ipv4n(&amp;extend_info-&gt;addr, get_uint32(buf+v3_shift+1));
+    extend_info-&gt;port = ntohs(get_uint16(buf+v3_shift+5));
+    memcpy(extend_info-&gt;identity_digest, buf+v3_shift+7,
+           DIGEST_LEN);
     extend_info-&gt;nickname[0] = '$';
     base16_encode(extend_info-&gt;nickname+1, sizeof(extend_info-&gt;nickname)-1,
                   extend_info-&gt;identity_digest, DIGEST_LEN);
@@ -865,22 +959,23 @@
     base16_encode(extend_info-&gt;nickname+1, sizeof(extend_info-&gt;nickname)-1,
                   extend_info-&gt;identity_digest, DIGEST_LEN);
 
-    klen = ntohs(get_uint16(buf+7+DIGEST_LEN));
-    if ((int)len != 7+DIGEST_LEN+2+klen+20+128) {
-      log_warn(LD_PROTOCOL, "Bad length %u for version 2 INTRODUCE2 cell.",
-               (int)len);
+    klen = ntohs(get_uint16(buf+v3_shift+7+DIGEST_LEN));
+    if ((int)len != v3_shift+7+DIGEST_LEN+2+klen+20+128) {
+      log_warn(LD_PROTOCOL, "Bad length %u for version %d INTRODUCE2 cell.",
+               (int)len, *buf);
       reason = END_CIRC_REASON_TORPROTOCOL;
       goto err;
     }
-    extend_info-&gt;onion_key = crypto_pk_asn1_decode(buf+7+DIGEST_LEN+2, klen);
+    extend_info-&gt;onion_key =
+        crypto_pk_asn1_decode(buf+v3_shift+7+DIGEST_LEN+2, klen);
     if (!extend_info-&gt;onion_key) {
-      log_warn(LD_PROTOCOL,
-               "Error decoding onion key in version 2 INTRODUCE2 cell.");
+      log_warn(LD_PROTOCOL, "Error decoding onion key in version %d "
+                            "INTRODUCE2 cell.", *buf);
       reason = END_CIRC_REASON_TORPROTOCOL;
       goto err;
     }
-    ptr = buf+7+DIGEST_LEN+2+klen;
-    len -= 7+DIGEST_LEN+2+klen;
+    ptr = buf+v3_shift+7+DIGEST_LEN+2+klen;
+    len -= v3_shift+7+DIGEST_LEN+2+klen;
   } else {
     char *rp_nickname;
     size_t nickname_field_len;
@@ -932,6 +1027,58 @@
   r_cookie = ptr;
   base16_encode(hexcookie,9,r_cookie,4);
 
+  /* Determine hash of Diffie-Hellman, part 1 to detect replays. */
+  digest = crypto_new_digest_env();
+  crypto_digest_add_bytes(digest, ptr+REND_COOKIE_LEN, DH_KEY_LEN);
+  crypto_digest_get_digest(digest, diffie_hellman_hash, DIGEST_LEN);
+  crypto_free_digest_env(digest);
+
+  /* Iterate over past requests, remove those which are older than one hour,
+   * and check whether there is one with same Diffie-Hellman, part 1. */
+  if (!service-&gt;accepted_intros)
+    service-&gt;accepted_intros = smartlist_create();
+  SMARTLIST_FOREACH(service-&gt;accepted_intros, client_access_event_t *,
+                    access, {
+    if (access-&gt;access_time + REND_REPLAY_TIME_INTERVAL &lt; now) {
+      tor_free(access);
+      SMARTLIST_DEL_CURRENT(service-&gt;accepted_intros, access);
+    } else if (!memcmp(access-&gt;diffie_hellman_hash, diffie_hellman_hash,
+                       DIGEST_LEN)) {
+      log_warn(LD_REND, "Possible replay detected! We received an "
+                        "INTRODUCE2 cell with same first part of "
+                        "Diffie-Hellman handshake %d seconds ago. Dropping "
+                        "cell.",
+               (uint32_t) (now - access-&gt;access_time));
+      return 0;
+    }
+  });
+
+  /* Add request to access history, including time and hash of
+   * Diffie-Hellman, part 1. */
+  event = tor_malloc_zero(sizeof(client_access_event_t));
+  event-&gt;access_time = now;
+  memcpy(event-&gt;diffie_hellman_hash, diffie_hellman_hash, DIGEST_LEN);
+  smartlist_add(service-&gt;accepted_intros, event);
+
+  /* If the service performs client authorization, check included auth data. */
+  if (service-&gt;clients) {
+    if (auth_len &gt; 0) {
+      if (rend_check_authorization(service, auth_data)) {
+        log_info(LD_REND, "Authorization data in INTRODUCE2 cell are valid.");
+      } else {
+        log_info(LD_REND, "The authorization data that are contained in "
+                 "the INTRODUCE2 cell are invalid. Dropping cell.");
+        reason = END_CIRC_REASON_CONNECTFAILED;
+        goto err;
+      }
+    } else {
+      log_info(LD_REND, "INTRODUCE2 cell does not contain authentication "
+               "data, but we require client authorization. Dropping cell.");
+      reason = END_CIRC_REASON_CONNECTFAILED;
+      goto err;
+    }
+  }
+
   /* Try DH handshake... */
   dh = crypto_dh_new();
   if (!dh || crypto_dh_generate_public(dh)&lt;0) {
@@ -976,12 +1123,14 @@
            escaped_safe_str(extend_info-&gt;nickname), hexcookie, serviceid);
   tor_assert(launched-&gt;build_state);
   /* Fill in the circuit's state. */
-  memcpy(launched-&gt;rend_pk_digest, circuit-&gt;rend_pk_digest,
+  launched-&gt;rend_data = tor_malloc_zero(sizeof(rend_data_t));
+  memcpy(launched-&gt;rend_data-&gt;rend_pk_digest,
+         circuit-&gt;rend_data-&gt;rend_pk_digest,
          DIGEST_LEN);
-  memcpy(launched-&gt;rend_cookie, r_cookie, REND_COOKIE_LEN);
-  strlcpy(launched-&gt;rend_query, service-&gt;service_id,
-          sizeof(launched-&gt;rend_query));
-  launched-&gt;rend_desc_version = service-&gt;descriptor_version;
+  memcpy(launched-&gt;rend_data-&gt;rend_cookie, r_cookie, REND_COOKIE_LEN);
+  strlcpy(launched-&gt;rend_data-&gt;onion_address, service-&gt;service_id,
+          sizeof(launched-&gt;rend_data-&gt;onion_address));
+  launched-&gt;rend_data-&gt;rend_desc_version = service-&gt;descriptor_version;
   launched-&gt;build_state-&gt;pending_final_cpath = cpath =
     tor_malloc_zero(sizeof(crypt_path_t));
   cpath-&gt;magic = CRYPT_PATH_MAGIC;
@@ -1053,13 +1202,7 @@
   newstate-&gt;pending_final_cpath = oldstate-&gt;pending_final_cpath;
   oldstate-&gt;pending_final_cpath = NULL;
 
-  memcpy(newcirc-&gt;rend_query, oldcirc-&gt;rend_query,
-         REND_SERVICE_ID_LEN_BASE32+1);
-  memcpy(newcirc-&gt;rend_pk_digest, oldcirc-&gt;rend_pk_digest,
-         DIGEST_LEN);
-  memcpy(newcirc-&gt;rend_cookie, oldcirc-&gt;rend_cookie,
-         REND_COOKIE_LEN);
-  newcirc-&gt;rend_desc_version = oldcirc-&gt;rend_desc_version;
+  newcirc-&gt;rend_data = rend_data_dup(oldcirc-&gt;rend_data);
 }
 
 /** Launch a circuit to serve as an introduction point for the service
@@ -1105,10 +1248,11 @@
     intro-&gt;extend_info = extend_info_dup(launched-&gt;build_state-&gt;chosen_exit);
   }
 
-  strlcpy(launched-&gt;rend_query, service-&gt;service_id,
-          sizeof(launched-&gt;rend_query));
-  memcpy(launched-&gt;rend_pk_digest, service-&gt;pk_digest, DIGEST_LEN);
-  launched-&gt;rend_desc_version = service-&gt;descriptor_version;
+  launched-&gt;rend_data = tor_malloc_zero(sizeof(rend_data_t));
+  strlcpy(launched-&gt;rend_data-&gt;onion_address, service-&gt;service_id,
+          sizeof(launched-&gt;rend_data-&gt;onion_address));
+  memcpy(launched-&gt;rend_data-&gt;rend_pk_digest, service-&gt;pk_digest, DIGEST_LEN);
+  launched-&gt;rend_data-&gt;rend_desc_version = service-&gt;descriptor_version;
   if (service-&gt;descriptor_version == 2)
     launched-&gt;intro_key = crypto_pk_dup_key(intro-&gt;intro_key);
   if (launched-&gt;_base.state == CIRCUIT_STATE_OPEN)
@@ -1133,12 +1277,14 @@
 
   tor_assert(circuit-&gt;_base.purpose == CIRCUIT_PURPOSE_S_ESTABLISH_INTRO);
   tor_assert(circuit-&gt;cpath);
+  tor_assert(circuit-&gt;rend_data);
 
   base32_encode(serviceid, REND_SERVICE_ID_LEN_BASE32+1,
-                circuit-&gt;rend_pk_digest, REND_SERVICE_ID_LEN);
+                circuit-&gt;rend_data-&gt;rend_pk_digest, REND_SERVICE_ID_LEN);
 
   service = rend_service_get_by_pk_digest_and_version(
-              circuit-&gt;rend_pk_digest, circuit-&gt;rend_desc_version);
+              circuit-&gt;rend_data-&gt;rend_pk_digest,
+              circuit-&gt;rend_data-&gt;rend_desc_version);
   if (!service) {
     log_warn(LD_REND, "Unrecognized service ID %s on introduction circuit %d.",
              serviceid, circuit-&gt;_base.n_circ_id);
@@ -1214,8 +1360,10 @@
              "received INTRO_ESTABLISHED cell on non-intro circuit.");
     goto err;
   }
+  tor_assert(circuit-&gt;rend_data);
   service = rend_service_get_by_pk_digest_and_version(
-              circuit-&gt;rend_pk_digest, circuit-&gt;rend_desc_version);
+              circuit-&gt;rend_data-&gt;rend_pk_digest,
+              circuit-&gt;rend_data-&gt;rend_desc_version);
   if (!service) {
     log_warn(LD_REND, "Unknown service on introduction circuit %d.",
              circuit-&gt;_base.n_circ_id);
@@ -1225,7 +1373,7 @@
   circuit-&gt;_base.purpose = CIRCUIT_PURPOSE_S_INTRO;
 
   base32_encode(serviceid, REND_SERVICE_ID_LEN_BASE32 + 1,
-                circuit-&gt;rend_pk_digest, REND_SERVICE_ID_LEN);
+                circuit-&gt;rend_data-&gt;rend_pk_digest, REND_SERVICE_ID_LEN);
   log_info(LD_REND,
            "Received INTRO_ESTABLISHED cell on circuit %d for service %s",
            circuit-&gt;_base.n_circ_id, serviceid);
@@ -1252,12 +1400,13 @@
   tor_assert(circuit-&gt;_base.purpose == CIRCUIT_PURPOSE_S_CONNECT_REND);
   tor_assert(circuit-&gt;cpath);
   tor_assert(circuit-&gt;build_state);
+  tor_assert(circuit-&gt;rend_data);
   hop = circuit-&gt;build_state-&gt;pending_final_cpath;
   tor_assert(hop);
 
-  base16_encode(hexcookie,9,circuit-&gt;rend_cookie,4);
+  base16_encode(hexcookie,9,circuit-&gt;rend_data-&gt;rend_cookie,4);
   base32_encode(serviceid, REND_SERVICE_ID_LEN_BASE32+1,
-                circuit-&gt;rend_pk_digest, REND_SERVICE_ID_LEN);
+                circuit-&gt;rend_data-&gt;rend_pk_digest, REND_SERVICE_ID_LEN);
 
   log_info(LD_REND,
            "Done building circuit %d to rendezvous with "
@@ -1265,7 +1414,8 @@
            circuit-&gt;_base.n_circ_id, hexcookie, serviceid);
 
   service = rend_service_get_by_pk_digest_and_version(
-              circuit-&gt;rend_pk_digest, circuit-&gt;rend_desc_version);
+              circuit-&gt;rend_data-&gt;rend_pk_digest,
+              circuit-&gt;rend_data-&gt;rend_desc_version);
   if (!service) {
     log_warn(LD_GENERAL, "Internal error: unrecognized service ID on "
              "introduction circuit.");
@@ -1274,7 +1424,7 @@
   }
 
   /* All we need to do is send a RELAY_RENDEZVOUS1 cell... */
-  memcpy(buf, circuit-&gt;rend_cookie, REND_COOKIE_LEN);
+  memcpy(buf, circuit-&gt;rend_data-&gt;rend_cookie, REND_COOKIE_LEN);
   if (crypto_dh_get_public(hop-&gt;dh_handshake_state,
                            buf+REND_COOKIE_LEN, DH_KEY_LEN)&lt;0) {
     log_warn(LD_GENERAL,"Couldn't get DH public key.");
@@ -1336,7 +1486,8 @@
                                                   CIRCUIT_PURPOSE_S_INTRO))) {
     if (!memcmp(circ-&gt;build_state-&gt;chosen_exit-&gt;identity_digest,
                 intro-&gt;extend_info-&gt;identity_digest, DIGEST_LEN) &amp;&amp;
-        circ-&gt;rend_desc_version == desc_version) {
+        circ-&gt;rend_data &amp;&amp;
+        circ-&gt;rend_data-&gt;rend_desc_version == desc_version) {
       return circ;
     }
   }
@@ -1346,7 +1497,8 @@
                                         CIRCUIT_PURPOSE_S_ESTABLISH_INTRO))) {
     if (!memcmp(circ-&gt;build_state-&gt;chosen_exit-&gt;identity_digest,
                 intro-&gt;extend_info-&gt;identity_digest, DIGEST_LEN) &amp;&amp;
-        circ-&gt;rend_desc_version == desc_version) {
+        circ-&gt;rend_data &amp;&amp;
+        circ-&gt;rend_data-&gt;rend_desc_version == desc_version) {
       return circ;
     }
   }
@@ -1827,11 +1979,13 @@
   rend_service_port_config_t *chosen_port;
 
   tor_assert(circ-&gt;_base.purpose == CIRCUIT_PURPOSE_S_REND_JOINED);
+  tor_assert(circ-&gt;rend_data);
   log_debug(LD_REND,"beginning to hunt for addr/port");
   base32_encode(serviceid, REND_SERVICE_ID_LEN_BASE32+1,
-                circ-&gt;rend_pk_digest, REND_SERVICE_ID_LEN);
-  service = rend_service_get_by_pk_digest_and_version(circ-&gt;rend_pk_digest,
-                                                      circ-&gt;rend_desc_version);
+                circ-&gt;rend_data-&gt;rend_pk_digest, REND_SERVICE_ID_LEN);
+  service = rend_service_get_by_pk_digest_and_version(
+                circ-&gt;rend_data-&gt;rend_pk_digest,
+                circ-&gt;rend_data-&gt;rend_desc_version);
   if (!service) {
     log_warn(LD_REND, "Couldn't find any service associated with pk %s on "
              "rendezvous circuit %d; closing.",


["patch-121-4b.txt.sig" (application/octet-stream)]

</body></email><email><emailId>20080612205805</emailId><senderName>Peter Palfrader</senderName><senderEmail>peter@palfrader.org</senderEmail><timestampReceived>2008-06-12 20:58:05-0400</timestampReceived><subject>Re: Proposal: remove down routers from consensus</subject><body>

On Thu, 12 Jun 2008, Geoffrey Goodell wrote:

&gt; Suggest that instead of removing routers that are not running, we simply
&gt; remove routers for which we do not have descriptors in dir/server/all.
&gt; Does this make sense?

No, what good would that do?  The goal here is to make the consensus
document smaller.

</body></email><email><emailId>20080612210151</emailId><senderName>Geoffrey Goodell</senderName><senderEmail>goodell@eecs.harvard.edu</senderEmail><timestampReceived>2008-06-12 21:01:51-0400</timestampReceived><subject>Re: Proposal: remove down routers from consensus</subject><body>


On Thu, Jun 12, 2008 at 10:58:05PM +0200, Peter Palfrader wrote:
&gt; On Thu, 12 Jun 2008, Geoffrey Goodell wrote:
&gt; 
&gt; &gt; Suggest that instead of removing routers that are not running, we simply
&gt; &gt; remove routers for which we do not have descriptors in dir/server/all.
&gt; &gt; Does this make sense?
&gt; 
&gt; No, what good would that do?  The goal here is to make the consensus
&gt; document smaller.

This would make the consensus document smaller -- I am not sure why the
consensus document includes routers that are not in dir/server/all, but
last I checked it did.  This fact bothers me more than the fact that
some of the routers are not Running.


["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20080612210732</emailId><senderName>Peter Palfrader</senderName><senderEmail>peter@palfrader.org</senderEmail><timestampReceived>2008-06-12 21:07:32-0400</timestampReceived><subject>Re: Proposal: remove down routers from consensus</subject><body>

On Thu, 12 Jun 2008, Geoffrey Goodell wrote:

&gt; This would make the consensus document smaller -- I am not sure why the
&gt; consensus document includes routers that are not in dir/server/all, but
&gt; last I checked it did.  This fact bothers me more than the fact that
&gt; some of the routers are not Running.

Sorry for being a bit dense here, but what's your point?  Who uses
dir/server/all anyway?  And is there anything you have to say about this
idea of making the consensus smaller?
</body></email><email><emailId>20080612213314</emailId><senderName>Geoffrey Goodell</senderName><senderEmail>goodell@eecs.harvard.edu</senderEmail><timestampReceived>2008-06-12 21:33:14-0400</timestampReceived><subject>Re: Proposal: remove down routers from consensus</subject><body>


On Thu, Jun 12, 2008 at 11:07:32PM +0200, Peter Palfrader wrote:
&gt; On Thu, 12 Jun 2008, Geoffrey Goodell wrote:
&gt; 
&gt; &gt; This would make the consensus document smaller -- I am not sure why the
&gt; &gt; consensus document includes routers that are not in dir/server/all, but
&gt; &gt; last I checked it did.  This fact bothers me more than the fact that
&gt; &gt; some of the routers are not Running.
&gt; 
&gt; Sorry for being a bit dense here, but what's your point?  Who uses
&gt; dir/server/all anyway?  And is there anything you have to say about this
&gt; idea of making the consensus smaller?

Just that there is an inconsistency... if nobody uses dir/server/all,
then we ought to deprecate it because of the inconsistency.

Making consensus smaller seems like a fine idea in the abstract, though
I am not convinced that the size of this document is causing substantial Tor
bootstrapping delay or substantial traffic to Tor nodes.

It would also be interesting to know the extent to which routers are
down just intermittently... why not include them if they are going to be
back up in a minute?

Geoff


["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20080613010856</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-06-13 01:08:56-0400</timestampReceived><subject>Re: Proposal: remove down routers from consensus</subject><body>

On Thu, Jun 12, 2008 at 10:28:41PM +0200, Peter Palfrader wrote:
&gt; This is a pretty low hanging fruit and part of the job to make tor
&gt; bootstrap faster even if your bandwidth is really small.
&gt; 
&gt; 
&gt; Filename: xxx-remove-down-routers-from-consensus

Added as proposal 138.

This proposal looks simple enough and right enough to me.  I lean
towards accepting.  Any objections?

&gt; 2. Current status
&gt; 
&gt;   At a typical bootstrap a client downloads a 140KB consensus, about
&gt;   10KB of certificates to verify that consensus, and about 1.6MB of
&gt;   server descriptors, about half of which it requires before it will
&gt;   start building circuits.
&gt; 
&gt;   Another proposal deals with how to get that huge 1.6MB fraction to
&gt;   effectively zero (by downloading only individual descriptors, on
&gt;   demand).  Should that get successfully implemented that will leave the
&gt;   140KB compressed consensus as a large fraction of what a client needs
&gt;   to get in order to work.
&gt; 
&gt;   About one third of the routers listed in a consensus are not running
&gt;   and will therefor never be used by clients who use this consensus.
&gt;   Not listing those routers will safe about 30% to 40% in size.

Two related proposals I'd like to see:
  - It would be perhaps be good if clients could download "diffs" for
    consensuses to get only the parts that change from cycle to cycle.
    Of course, the data would need to be signed, and there are issues when 
    a client skips a cycle.  Are you still interested in writing a proposal
    for this? 

  - It's dumb how v3 the v3 directory protocol still depends on the
    existence of v2 directories.  We should fix that.

yrs,
-- 
Nick
</body></email><email><emailId>20080613015922</emailId><senderName>Geoffrey Goodell</senderName><senderEmail>goodell@eecs.harvard.edu</senderEmail><timestampReceived>2008-06-13 01:59:22-0400</timestampReceived><subject>Re: Proposal: remove down routers from consensus</subject><body>


On Thu, Jun 12, 2008 at 09:08:56PM -0400, Nick Mathewson wrote:
&gt; On Thu, Jun 12, 2008 at 10:28:41PM +0200, Peter Palfrader wrote:
&gt; &gt; This is a pretty low hanging fruit and part of the job to make tor
&gt; &gt; bootstrap faster even if your bandwidth is really small.
&gt; &gt; 
&gt; &gt; 
&gt; &gt; Filename: xxx-remove-down-routers-from-consensus
&gt; 
&gt; Added as proposal 138.
&gt; 
&gt; This proposal looks simple enough and right enough to me.  I lean
&gt; towards accepting.  Any objections?

for the record, I like the proposal.


["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20080613081102</emailId><senderName>Peter Palfrader</senderName><senderEmail>peter@palfrader.org</senderEmail><timestampReceived>2008-06-13 08:11:02-0400</timestampReceived><subject>Re: Proposal: remove down routers from consensus</subject><body>

On Thu, 12 Jun 2008, Nick Mathewson wrote:

&gt; Two related proposals I'd like to see:
&gt;   - It would be perhaps be good if clients could download "diffs" for
&gt;     consensuses to get only the parts that change from cycle to cycle.
&gt;     Of course, the data would need to be signed, and there are issues when 
&gt;     a client skips a cycle.  Are you still interested in writing a proposal
&gt;     for this? 

Yes, it's still in my queue.

&gt;   - It's dumb how v3 the v3 directory protocol still depends on the
&gt;     existence of v2 directories.  We should fix that.

Agreed.  I wonder if we should just use the vote documents to learn
about new servers, or if we need a new type of document.
</body></email><email><emailId>20080409010659</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-04-09 01:06:59-0400</timestampReceived><subject>Re: udp transport PoC</subject><body>

On Mon, Apr 07, 2008 at 03:06:17PM -0400, Camilo Viecco wrote:
&gt; Hello Mail list
&gt; 
&gt; First introduction:
&gt; My name is Camilo Viecco, and I am PhD student at the CS department of
&gt; Indiana University.

Hi, Camilo!  This is interesting stuff.  We definitely need to move to
a UDP transport at some point, and it's good to try out various
approaches before we can get them onto the main network.  

One question I got looking at your codebase for a few minutes: Do you
have a protocol specification for this anywhere (that is, something
like tor-spec.txt)?

&gt; I really like tor but had became disillusioned by its network
&gt; performance (or lack of). Thus,
&gt; as part of my graduate work I have designed a modification of the
&gt; transport mechanism in tor
&gt; to use tunnel tcp connections over ucp. That is, socks aware
&gt; applications open tcp streams
&gt; to a socks server running at the tor exit node.&gt; Tor does not transport
&gt; tcp streams
&gt; but transports the tcp packets (build by the os) in the form of
&gt; encapsulated autonomous circuit cells over udp.

I really worry about TCP stack fingerprinting and linking with this
approach, especially if the exit nodes have freedom what they send
back to the clients.  I guess that it doesn't matter much for a proof
of concept of the routing algorithm, but it's a problem that will need
to be solved before a solution can get deployed in Tor.

&gt; The objectives of the redesign are to:
&gt; -Have a more fair allocation of network resources.
&gt; -Use end to end congestion control and avoidance.
&gt; -simplify the codebase.
&gt; 
&gt; During testing I have seen that even in high-latency, low bandwidth
&gt; circuits (US(abiline)-UK(home DSL)-US(abiline))
&gt; the latency at the application circuit is almost constant even with 
&gt; high load the  circuit (500ms  vs 10s on tor (average over 20 connections)).
&gt; Also, bandwidth is spread evenly among multiple tcp streams.

That's pretty keen!  I had a talk with Roger today about development
directions for Tor, and I think we're pretty sure that we need to
support UDP transport within a year or two.  Work like this definitely
helps to make the case for it.

yrs,
-- 
Nick
</body></email><email><emailId>20080513205015</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-05-13 20:50:15-0400</timestampReceived><subject>Re: udp transport PoC</subject><body>

On Tue, Apr 08, 2008 at 09:06:59PM -0400, Nick Mathewson wrote:
 [...]
&gt; I really worry about TCP stack fingerprinting and linking with this
&gt; approach, especially if the exit nodes have freedom what they send
&gt; back to the clients.  I guess that it doesn't matter much for a proof
&gt; of concept of the routing algorithm, but it's a problem that will need
&gt; to be solved before a solution can get deployed in Tor.

I just had a conversation with Camilo on IRC, and I think we're closer
to agreeing about this this stuff now.  I'd like to summarize the
points I made about fingerprinting attacks and security, so that other
people can see them too.

Once you've decided to make Tor use UDP as its transport, you can
no longer rely on the transport to provide reliable in-order
delivery (as TCP did).  You basically have two choices, as far as
I can see:

   1) You can implement your own reliable in-order delivery. For
      example, you could have Tor remain as a SOCKS proxy, and use
      a free user-space TCP stack implementation to generate cell
      contents.

   2) You can take raw IP packets, relay those, and let the
      kernel's TCP stack provide reliable in-order delivery for
      you.

Spoiler: I prefer approach 1.  Here's why.

Approach 2 is way easier to implement, no question.  But it has a
flaw: the exit node can see whatever packets you send, and can
send packets back to you.  Thus, for approach 2 to work, you need
to filter what you send, and filter what you accept from the exit
node.

The list of what you need to filter in order to secure approach 2
is very broad.  You need to make sure that you don't accept
incoming connections.  You need to make sure you scrub packet
headers.  The algorithm you use to generate sequence numbers, TCP
timestamps, IP ids, source ports, etc will all need to be
scrubbed.  You'll need to figure out whether your MTU settings or
the MTU of your network can under any circumstances leak and
whether an attacker can fingerprint you as you change circuits by
luring you to a weird configuration.  Your response to patterns of
missing, misordered, and duplicate packets needs to be the same as
everybody else's.  And so on. Basically, you need to scrub
absolutely every detail of your protocol, and the attacker needs
to find one way to probe you.

Consider nmap's http://nmap.org/book/osdetect.html .  It's a big
list of how they probe for OS diferences.  What that list says to
me is not "these are the ways that TCP stacks differ; address all
of these and you're done."  Instead, that list tells me that TCP
implementations vary greatly: even when you've filtered every
stack difference you know about and plugged every mechanism you
know that an attacker could use to link streams, there are quite
likely to be remaining holes.

{Yes, I know I just mentioned nmap, and nmap does mostly active
fingerprinting.  The attacker in our model can do some active
fingerprinting on existing streams if they're the exit node,
though: he can't open new connections, but existing streams are
fair game.}

So, in summary, to be brief (ha!) the reason I favor the
generate-packets-ourself approach is that while we I can think of
ways to prevent *specific* active and passive fingerprinting
attacks on TCP stacks... I do not see any way to prevent the
general *class* of attacks sort of simply covering up the TCP
stack's weirdness and taking the generate-your-own-packets
approach.

yrs,
-- 
Nick Mathewson
</body></email><email><emailId>20080513221153</emailId><senderName>"Adam Langley"</senderName><senderEmail>agl@imperialviolet.org</senderEmail><timestampReceived>2008-05-13 22:11:53-0400</timestampReceived><subject>Re: udp transport PoC</subject><body>

On Tue, May 13, 2008 at 1:50 PM, Nick Mathewson &lt;nickm@freehaven.net&gt; wrote:
&gt;  Spoiler: I prefer approach 1.  Here's why.

For what it's worth, I suggest that you're perfectly correct here, as
unfortunate as it may be from a code complexity point of view.

Now it would appear that you have two issues to content with. Firstly,
you have a flow control issue between nodes and secondly a packet-loss
issue for an individual circuit. I'm assuming that you want to split
the problem (TCP conflates them). Not splitting them might let you
pull in a userspace TCP stack wholesale. However, splitting them will
give you better fairness to other network users (esp other flows from
the node)[1]

Your flow control should probably be based on[2]. The description in
the TCP RFC now bares no relation to reality.

Your packet loss and windowing is pretty straight forward, so long as
it can signal packet loss events to the flow control. I don't have any
specific references here, common sense is as good as the state of
practice here.

Just hoping to provide some useful pointers,


AGL

[1] http://www.cs.ucl.ac.uk/staff/bbriscoe/pubs.html#rateFairDis
[2] http://netsrv.csc.ncsu.edu/twiki/bin/view/Main/BIC

-- 
Adam Langley agl@imperialviolet.org http://www.imperialviolet.org
</body></email><email><emailId>20080514053121</emailId><senderName>coderman</senderName><senderEmail>coderman@gmail.com</senderEmail><timestampReceived>2008-05-14 05:31:21-0400</timestampReceived><subject>Re: udp transport PoC</subject><body>

On Tue, May 13, 2008 at 3:11 PM, Adam Langley &lt;agl@imperialviolet.org&gt; wrote:
&gt; ...
&gt;  Now it would appear that you have two issues to content with. Firstly,
&gt;  you have a flow control issue between nodes and secondly a packet-loss
&gt;  issue for an individual circuit.

flow control / congestion avoidance / tcp fairness will be near
impossible with userspace UDP.  splitting these functions would allow
you a bulk fraction of bandwidth for UDP payloads and a reliable
control channel (via simple DTLS timeout / re-xmit or more robust
airhook / SSCOP style control sessions for reliable datagram
transport)


&gt;  Your flow control should probably be based on[2]. The description in
&gt;  the TCP RFC now bares no relation to reality.

the problem with trying for true tcp fairness in a datagram transport
used among many peers in userspace is going to be timer resolution
(especially on win32, but still problematic in *nix).

i'd much prefer to see a robust fractional bandwidth allocation
specified for the datagram stack as a whole, than watch the poor
behavior of another attempted TCP over UDP in userspace.

(i admit a general bias against TCP fairness in userspace, so a grain
of salt with this $0.02..)


&gt;  Your packet loss and windowing is pretty straight forward, so long as
&gt;  it can signal packet loss events to the flow control. I don't have any
&gt;  specific references here, common sense is as good as the state of
&gt;  practice here.

i keep referencing airhook in these discussions, particularly because
some of the control communication changes tailored for a lossy
wireless environment map nicely to the latency / multi-hop issues Tor
DTLS will apply to reliable datagram communications between nodes.

a number of modifications would be needed, however, including the
larger windows and explicit IV management for the DTLS sessions.
(doing key schedule properly for the first DTLS implementation into
Tor would also solve the long standing thread contention issues with
SSL/TLS stream encryption/decryption across multiple CPU's in an SMP
system, for example)


aside from fingerprinting attacks, what other critical concerns exist?
</body></email><email><emailId>20080514161655</emailId><senderName>Camilo Viecco</senderName><senderEmail>cviecco@anml.iu.edu</senderEmail><timestampReceived>2008-05-14 16:16:55-0400</timestampReceived><subject>Re: udp transport PoC</subject><body>

I will resume the conversation .

For Nick: there is actually a third approach between a pure userspace
TCP-like stack
and a IP forwarding approach (like freedom).
This approach, the one the PoC takes, is to extract the transport part
of the IP packets
and only forward this section. Doing so assumes that there will be no
fragmentation
at the IP level or that fragmented packets will not be forwarded.
So yes we are using kernel build TCP/IP packets but only forwarding some
of the TCP
section. (not all TCP header fields need forwarding in our case).

This, as we agreed, can lead to an exit node (even assuming a perfect
TCP field scrubbing)
to probably identify the algorithm and/or parameters used by the a
client to adjust its advertised window and/or
handle packet loss by applying selective packet drops. Thus, while a
userspace TCP like stack
is best for anonymity, I will focus for now on packet scrubbing (the
suboptimal solution).

Adam:
Thanks for the pointers (even tough I strongly disagree in with many
parts of briscoes' paper.
He swaps the problem of link bandwidth fairness to cost fairness in a
global scale, which I think
is even harder to solve).
It is my opinion that the best we can do is to use a TCP stack because
it allows us
to build upon the research of many researchers (and copy their results).
(Further it allows us to test many TCP implementations/options without
writing one line of code.)
The 'unfairness' issue cannot be resolved with Briscoe's approach as his
solution assumes
a way to identify users in order to make them pay for their congestion
which cannot be done
in anoynmity systems.


coderman wrote:
&gt; On Tue, May 13, 2008 at 3:11 PM, Adam Langley &lt;agl@imperialviolet.org&gt; wrote:
&gt;   
&gt;&gt; ...
&gt;&gt;  Now it would appear that you have two issues to content with. Firstly,
&gt;&gt;  you have a flow control issue between nodes and secondly a packet-loss
&gt;&gt;  issue for an individual circuit.
&gt;&gt;     
&gt;
&gt; flow control / congestion avoidance / tcp fairness will be near
&gt; impossible with userspace UDP.  splitting these functions would allow
&gt; you a bulk fraction of bandwidth for UDP payloads and a reliable
&gt; control channel (via simple DTLS timeout / re-xmit or more robust
&gt; airhook / SSCOP style control sessions for reliable datagram
&gt; transport)
&gt;   
I do not agree here. The key to efficient use of a packet based network is
congestion control/avoidance. In partcular when the network characteristics
are so varied as what Tor nodes provide. I rather reuse a 'good enough
solution'
TCP that try to build a better solution. Airhook looks interesting, but
I did not
saw any congestion avoidance mechanisms in it... and that is a bad thing
(I might have overlooked that in the code, so if it does enlighten me).

&gt;&gt;  Your flow control should probably be based on[2]. The description in
&gt;&gt;  the TCP RFC now bares no relation to reality.
&gt;&gt;     
&gt;
&gt; the problem with trying for true tcp fairness in a datagram transport
&gt; used among many peers in userspace is going to be timer resolution
&gt; (especially on win32, but still problematic in *nix).
&gt;   
Dont thought of this before.  Do you know that from experience in userspace
network stacks or in some other projects?
&gt; i'd much prefer to see a robust fractional bandwidth allocation
&gt; specified for the datagram stack as a whole, than watch the poor
&gt; behavior of another attempted TCP over UDP in userspace.
&gt;
&gt;   
I dont like fractional bandwidth allocation because that implies allocation
of network resources beforehand and that could lead to DoS. However I do
like the idea of client enforced bandwidth allocation, to make all users
behave similarly (throughput wise) and to make  p2p users make a choice:
anonymity vs performance.
&gt; (i admit a general bias against TCP fairness in userspace, so a grain
&gt; of salt with this $0.02..)
&gt;   
&gt;
&gt;   
&gt;&gt;  Your packet loss and windowing is pretty straight forward, so long as
&gt;&gt;  it can signal packet loss events to the flow control. I don't have any
&gt;&gt;  specific references here, common sense is as good as the state of
&gt;&gt;  practice here.
&gt;&gt;     
&gt;
&gt; i keep referencing airhook in these discussions, particularly because
&gt; some of the control communication changes tailored for a lossy
&gt; wireless environment map nicely to the latency / multi-hop issues Tor
&gt; DTLS will apply to reliable datagram communications between nodes.
&gt;
&gt; a number of modifications would be needed, however, including the
&gt; larger windows and explicit IV management for the DTLS sessions.
&gt; (doing key schedule properly for the first DTLS implementation into
&gt; Tor would also solve the long standing thread contention issues with
&gt; SSL/TLS stream encryption/decryption across multiple CPU's in an SMP
&gt; system, for example)
&gt;
&gt;
&gt; aside from fingerprinting attacks, what other critical concerns exist?
&gt;   
I ask the same question....


Thanks all for you comments...


Camilo

</body></email><email><emailId>20080514173633</emailId><senderName>coderman</senderName><senderEmail>coderman@gmail.com</senderEmail><timestampReceived>2008-05-14 17:36:33-0400</timestampReceived><subject>Re: udp transport PoC</subject><body>

On Wed, May 14, 2008 at 9:16 AM, Camilo Viecco &lt;cviecco@anml.iu.edu&gt; wrote:
&gt; ...
&gt;  I do not agree here. The key to efficient use of a packet based network is
&gt;  congestion control/avoidance.

absolutely, i'm just saying standard TCP congestion control will not
work effectively in userspace over UDP.


&gt;  &gt; the problem with trying for true tcp fairness in a datagram transport
&gt;  &gt; used among many peers in userspace is going to be timer resolution
&gt;  &gt; (especially on win32, but still problematic in *nix).
&gt;  &gt;
&gt;  Dont thought of this before.  Do you know that from experience in userspace
&gt;  network stacks or in some other projects?

i'll try and dig up research links.  much of this is from discussion
years ago on another list (p2p-hackers).

timer resolution in win32 makes any TCP over UDP implementation
unworkable; on *nix with non blocking I/O it is at least functional.


&gt;  I dont like fractional bandwidth allocation because that implies allocation
&gt;  of network resources beforehand and that could lead to DoS. However I do
&gt;  like the idea of client enforced bandwidth allocation, to make all users
&gt;  behave similarly (throughput wise) and to make  p2p users make a choice:
&gt;  anonymity vs performance.

agreed, and the points i meant to imply about tcp fairness should not
be taken to mean no congestion control is needed; clearly that is not
true.

but rather, deal with congestion at a coarser level (the Tor DTLS
stack) and keep this larger subset of bandwidth below congestion at a
known fraction.

put another way, treat the UDP stack like a large ship, which cannot
handle the nimble TCP congestion avoidance overhead per session like a
jet ski.  it is a freighter, but you can still ensure it does not run
rough shod over all other traffic.

thanks for the responses.

best regards,
</body></email><email><emailId>20080515052545</emailId><senderName>coderman</senderName><senderEmail>coderman@gmail.com</senderEmail><timestampReceived>2008-05-15 05:25:45-0400</timestampReceived><subject>Re: udp transport PoC</subject><body>

On Wed, May 14, 2008 at 9:16 AM, Camilo Viecco &lt;cviecco@anml.iu.edu&gt; wrote:
&gt; ...
&gt; The key to efficient use of a packet based network is
&gt; congestion control/avoidance. In partcular when the network characteristics
&gt; are so varied as what Tor nodes provide. I rather reuse a 'good enough
&gt; solution'

i forgot to mention DCCP for datagram congestion control; still very
beta, if even supported on your OS, but would solve the TCP fairness /
congestion control part well.

best regards,
</body></email><email><emailId>20080316232325</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-03-16 23:23:25-0400</timestampReceived><subject>Re: openbsd malloc on alpha</subject><body>

On Sun, Mar 16, 2008 at 11:51:01PM +0100, Peter Palfrader wrote:
&gt; Hi,
&gt; 
&gt; it turns out the problem is that the pagesize on alpha is 8k.
&gt; 
&gt; -#if defined(__sparc__)
&gt; +#if defined(__sparc__) || defined (__alpha__)
&gt;  #define        malloc_pageshift        13U
&gt;  #endif /* __sparc__ */
&gt; 
&gt; "fixes" the issue, but it's certainly not a nice fix.
&gt; 
&gt; We should probably be using getpagesize() to find out the page size.
&gt; I'm unsure if it's safe to use it at compile time and assume it will
&gt; work on all the subarchs that the binary will run on.

That's quite clever.  How did you find it?  For now, I'll add an early
runtime check to make sure that runtime pagesize matches compile-time
page size when using openbsd-malloc.

(For an 0.2.1.x timeframe, it's possible we'll want to switch to
jemalloc, like Firefox is doing.)
</body></email><email><emailId>20080316233029</emailId><senderName>"Seyed Samiezadeh"</senderName><senderEmail>sami2box@yahoo.com</senderEmail><timestampReceived>2008-03-16 23:30:29-0400</timestampReceived><subject>Re: openbsd malloc on alpha</subject><body>

unsubscribe freehaven-dev

</body></email><email><emailId>20080909211317</emailId><senderName>Robert Hogan</senderName><senderEmail>robert@roberthogan.net</senderEmail><timestampReceived>2008-09-09 21:13:17-0400</timestampReceived><subject>Proposal 132 - Browser Test Service - WIP Patch</subject><body>

Hi there,

This is an update on my work so far on proposal 132. Below is the current state 
of the patch, and yes: it's a bit of a monster. (Though a major portion of the 
linecount is due to storing the two test images in const char arrays.)

The flow of the browser test procedure has evolved a little since proposal 132 
was first drafted, so I've updated and attached a new version.

Here are some videos showing the browser test in action. They show a mixture of 
successful and unsuccessful test runs. In the automated test, the browser is 
honouring a html refresh tag that redirects it to the next page in the test 
sequence.

  http://www.youtube.com/profile_videos?user=mwenge2

Areas I know that need work:
  - The text and presentation of the html pages.
  - A test image with a much lighter footprint.
  - Fold the http_ functions into those used by dirserver.c. (Not sure that this 
would save an awful lot in linecount though.)
  - A test page for javascript, plugins and the like.

Potential issues:
  - The Proxy Test uses a randomly generated IP as the 'location' of the test 
image. In theory the random IP may have a HTTP service and my be serving an 
image with a name such as /CC3B118B056F3A81.png, in which case the test would 
produce a false positive. My implementation assumes that this possibility is 
vanishingly small. I also assume that the possibility of a genuine user request 
using the randomly generated IP while the Proxy Test is in progress is also 
sufficiently remote.

For now, I just want to make sure that I haven't gone seriously awry, whether in 
concept or implementation. So any feedback on what you see in the videos or 
patch below would be greatly appreciated.

Thanks,
Robert

P.S. If you apply the patch, you can try it yourself:
telnet localhost 9051
	Trying 127.0.0.1...
	Connected to localhost.
	Escape character is '^]'.
authenticate
	250 OK
setconf testserviceport=9999
	250 OK

Then load up http://127.0.0.1:9999 in your browser.




Index: src/or/config.c
===================================================================
--- src/or/config.c	(revision 16788)
+++ src/or/config.c	(working copy)
@@ -302,6 +302,8 @@
   V(StrictEntryNodes,            BOOL,     "0"),
   V(StrictExitNodes,             BOOL,     "0"),
   OBSOLETE("SysLog"),
+  V(TestServicePort,             UINT,     "0"),
+  V(TestServiceListenAddress,    LINELIST, NULL),
   V(TestSocks,                   BOOL,     "0"),
   OBSOLETE("TestVia"),
   V(TrackHostExits,              CSV,      NULL),
@@ -2830,6 +2832,11 @@
   if (options-&gt;NatdPort == 0 &amp;&amp; options-&gt;NatdListenAddress != NULL)
     REJECT("NatdPort must be defined if NatdListenAddress is defined.");
 
+  if (options-&gt;TestServicePort == 0 &amp;&amp;
+      options-&gt;TestServiceListenAddress != NULL)
+    REJECT("TestServicePort must be defined if "
+           "TestServiceListenAddress is defined.");
+
   /* Don't gripe about SocksPort 0 with SocksListenAddress set; a standard
    * configuration does this. */
 
Index: src/or/connection_edge.c
===================================================================
--- src/or/connection_edge.c	(revision 16788)
+++ src/or/connection_edge.c	(working copy)
@@ -130,6 +130,15 @@
       }
       return 0;
     case AP_CONN_STATE_OPEN:
+      /* If this is a test request we intercept and respond ourselves */
+      if (testservice_istestrequest(TO_CONN(conn))) {
+        /* (We already sent an end cell if possible) */
+        connection_edge_end(conn, END_STREAM_REASON_INTERNAL);
+        connection_mark_for_close(TO_CONN(conn));
+        return -1;
+      }
+      if (conn-&gt;_base.purpose == TEST_PURPOSE_AP)
+        return 0;
     case EXIT_CONN_STATE_OPEN:
       if (connection_edge_package_raw_inbuf(conn, package_partial) &lt; 0) {
         /* (We already sent an end cell if possible) */
@@ -1839,6 +1848,20 @@
     return -1;
   } /* else socks handshake is done, continue processing */
 
+  if (testservice_testaddress(socks-&gt;address)) {
+    char buf[256];
+    memset(buf,0,SOCKS4_NETWORK_LEN);
+    buf[1] = SOCKS4_GRANTED;
+    /* leave version, destport, destip zero */
+    connection_write_to_buf(buf, SOCKS4_NETWORK_LEN, TO_CONN(conn));
+    conn-&gt;socks_request-&gt;has_finished = 1;
+    conn-&gt;_base.state = AP_CONN_STATE_OPEN;
+    conn-&gt;_base.purpose = TEST_PURPOSE_AP;
+    return 0;
+  }
+
+
+
   if (hostname_is_noconnect_address(socks-&gt;address))
   {
     control_event_stream_status(conn, STREAM_EVENT_NEW, 0);
Index: src/or/or.h
===================================================================
--- src/or/or.h	(revision 16788)
+++ src/or/or.h	(working copy)
@@ -207,7 +207,9 @@
 #define CONN_TYPE_AP_NATD_LISTENER 14
 /** Type for sockets listening for DNS requests. */
 #define CONN_TYPE_AP_DNS_LISTENER 15
-#define _CONN_TYPE_MAX 15
+#define CONN_TYPE_TEST_SERVICE_LISTENER 16
+#define CONN_TYPE_TEST 17
+#define _CONN_TYPE_MAX 17
 /* !!!! If _CONN_TYPE_MAX is ever over 15, we must grow the type field in
  * connection_t. */
 
@@ -305,6 +307,13 @@
 #define DIR_CONN_STATE_SERVER_WRITING 6
 #define _DIR_CONN_STATE_MAX 6
 
+#define _TEST_CONN_STATE_MIN 1
+/** State for connection at test service server: waiting for HTTP request. */
+#define TEST_CONN_STATE_SERVER_COMMAND_WAIT 1
+/** State for connection at test service server: sending HTTP response. */
+#define TEST_CONN_STATE_SERVER_WRITING 2
+#define _TEST_CONN_STATE_MAX 2
+
 /** True iff the purpose of &lt;b&gt;conn&lt;/b&gt; means that it's a server-side
  * directory connection. */
 #define DIR_CONN_IS_SERVER(conn) ((conn)-&gt;purpose == DIR_PURPOSE_SERVER)
@@ -376,6 +385,12 @@
    (p)==DIR_PURPOSE_UPLOAD_VOTE ||              \
    (p)==DIR_PURPOSE_UPLOAD_SIGNATURES)
 
+#define _TEST_PURPOSE_MIN 1
+/** Purpose for connection at a test service server. */
+#define TEST_PURPOSE_SERVER 1
+#define TEST_PURPOSE_AP 2
+#define _TEST_PURPOSE_MAX 2
+
 #define _EXIT_PURPOSE_MIN 1
 /** This exit stream wants to do an ordinary connect. */
 #define EXIT_PURPOSE_CONNECT 1
@@ -790,7 +805,8 @@
 typedef struct socks_request_t socks_request_t;
 
 /* Values for connection_t.magic: used to make sure that downcasts (casts from
-* connection_t to foo_connection_t) are safe. */
+* connection_t to foo_connection_t) are safe. These values are arbitrary. They
+  are not calculated or derived, just invented.*/
 #define BASE_CONNECTION_MAGIC 0x7C3C304Eu
 #define OR_CONNECTION_MAGIC 0x7D31FF03u
 #define EDGE_CONNECTION_MAGIC 0xF0374013u
@@ -820,7 +836,7 @@
                    * *_CONNECTION_MAGIC. */
 
   uint8_t state; /**&lt; Current state of this connection. */
-  unsigned int type:4; /**&lt; What kind of connection is this? */
+  unsigned int type:5; /**&lt; What kind of connection is this? */
   unsigned int purpose:5; /**&lt; Only used for DIR and EXIT types currently. */
 
   /* The next fields are all one-bit booleans. Some are only applicable to
@@ -2105,6 +2121,8 @@
   config_line_t *DirListenAddress;
   /** Addresses to bind for listening for control connections. */
   config_line_t *ControlListenAddress;
+  /** Addresses to bind for listening for control connections. */
+  config_line_t *TestServiceListenAddress;
   /** Local address to bind outbound sockets */
   char *OutboundBindAddress;
   /** Directory server only: which versions of
@@ -2122,6 +2140,7 @@
   int TransPort;
   int NatdPort; /**&lt; Port to listen on for transparent natd connections. */
   int ControlPort; /**&lt; Port to listen on for control connections. */
+  int TestServicePort; /**&lt; Port to listen on for control connections. */
   config_line_t *ControlSocket; /**&lt; List of Unix Domain Sockets to listen on
                                  * for control connections. */
   int DirPort; /**&lt; Port to listen on for directory connections. */
@@ -2506,7 +2525,7 @@
     state-&gt;next_write = when;
 }
 
-#define MAX_SOCKS_REPLY_LEN 1024
+#define MAX_SOCKS_REPLY_LEN 2056
 #define MAX_SOCKS_ADDR_LEN 256
 
 /** Please open a TCP connection to this addr:port. */
@@ -2572,6 +2591,7 @@
                       const char *data, size_t data_len, int done);
 int move_buf_to_buf(buf_t *buf_out, buf_t *buf_in, size_t *buf_flushlen);
 int fetch_from_buf(char *string, size_t string_len, buf_t *buf);
+int buf_startswith(buf_t *buf, char *string, size_t len);
 int fetch_var_cell_from_buf(buf_t *buf, var_cell_t **out, int linkproto);
 int fetch_from_buf_http(buf_t *buf,
                         char **headers_out, size_t max_headerlen,
@@ -4344,5 +4364,15 @@
                                    size_t intro_points_encoded_size);
 int rend_parse_client_keys(strmap_t *parsed_clients, const char *str);
 
+/********************************* testservice.c ************************/
+
+int testservice_istestrequest(connection_t *conn);
+int testservice_testaddress(const char *address);
+int testservice_handlebrowserusingtorasproxy(const char *buf,
+                                              socks_request_t *req);
+int connection_testserv_process_inbuf(connection_t *conn);
+int connection_testserv_finished_flushing(connection_t *conn);
+
 #endif
 
+
Index: src/or/buffers.c
===================================================================
--- src/or/buffers.c	(revision 16788)
+++ src/or/buffers.c	(working copy)
@@ -962,6 +962,15 @@
   }
 }
 
+int
+buf_startswith(buf_t *buf, char *string, size_t len)
+{
+  if (buf-&gt;datalen &lt; len) return 0;
+  buf_pullup(buf, len, 0);
+  if (!memcmp(buf-&gt;head-&gt;data, string, len)) return 1;
+  return 0;
+}
+
 /** Remove &lt;b&gt;string_len&lt;/b&gt; bytes from the front of &lt;b&gt;buf&lt;/b&gt;, and store
  * them into &lt;b&gt;string&lt;/b&gt;.  Return the new buffer size.  &lt;b&gt;string_len&lt;/b&gt;
  * must be \&lt;= the number of bytes on the buffer.
@@ -1574,7 +1583,8 @@
     case 'H': /* head */
     case 'P': /* put/post */
     case 'C': /* connect */
-      strlcpy(req-&gt;reply,
+      if (!testservice_handlebrowserusingtorasproxy(buf-&gt;head-&gt;data,req)) {
+        strlcpy(req-&gt;reply,
 "HTTP/1.0 501 Tor is not an HTTP Proxy\r\n"
 "Content-Type: text/html; charset=iso-8859-1\r\n\r\n"
 "&lt;html&gt;\n"
@@ -1601,6 +1611,7 @@
 "&lt;/html&gt;\n"
              , MAX_SOCKS_REPLY_LEN);
       req-&gt;replylen = strlen(req-&gt;reply)+1;
+      }
       /* fall through */
     default: /* version is not socks4 or socks5 */
       log_warn(LD_APP,
Index: src/or/connection.c
===================================================================
--- src/or/connection.c	(revision 16788)
+++ src/or/connection.c	(working copy)
@@ -54,9 +54,11 @@
       return "Transparent pf/netfilter listener";
     case CONN_TYPE_AP_NATD_LISTENER: return "Transparent natd listener";
     case CONN_TYPE_AP_DNS_LISTENER: return "DNS listener";
+    case CONN_TYPE_TEST_SERVICE_LISTENER: return "Test Service listener";
     case CONN_TYPE_AP: return "Socks";
     case CONN_TYPE_DIR_LISTENER: return "Directory listener";
     case CONN_TYPE_DIR: return "Directory";
+    case CONN_TYPE_TEST: return "Test";
     case CONN_TYPE_CPUWORKER: return "CPU worker";
     case CONN_TYPE_CONTROL_LISTENER: return "Control listener";
     case CONN_TYPE_CONTROL: return "Control";
@@ -82,6 +84,7 @@
     case CONN_TYPE_AP_NATD_LISTENER:
     case CONN_TYPE_AP_DNS_LISTENER:
     case CONN_TYPE_DIR_LISTENER:
+    case CONN_TYPE_TEST_SERVICE_LISTENER:
     case CONN_TYPE_CONTROL_LISTENER:
       if (state == LISTENER_STATE_READY)
         return "ready";
@@ -130,6 +133,12 @@
         case DIR_CONN_STATE_SERVER_WRITING: return "writing";
       }
       break;
+    case CONN_TYPE_TEST:
+      switch (state) {
+        case TEST_CONN_STATE_SERVER_COMMAND_WAIT: return "waiting for command";
+        case TEST_CONN_STATE_SERVER_WRITING: return "writing";
+      }
+      break;
     case CONN_TYPE_CPUWORKER:
       switch (state) {
         case CPUWORKER_STATE_IDLE: return "idle";
@@ -1176,6 +1185,10 @@
       conn-&gt;purpose = DIR_PURPOSE_SERVER;
       conn-&gt;state = DIR_CONN_STATE_SERVER_COMMAND_WAIT;
       break;
+    case CONN_TYPE_TEST:
+      conn-&gt;purpose = TEST_PURPOSE_SERVER;
+      conn-&gt;state = TEST_CONN_STATE_SERVER_COMMAND_WAIT;
+      break;
     case CONN_TYPE_CONTROL:
       conn-&gt;state = CONTROL_CONN_STATE_NEEDAUTH;
       break;
@@ -1482,6 +1495,12 @@
                       replaced_conns, new_conns, 0,
                       AF_INET)&lt;0)
     return -1;
+  if (retry_listeners(CONN_TYPE_TEST_SERVICE_LISTENER,
+                      options-&gt;TestServiceListenAddress,
+                      options-&gt;TestServicePort, "127.0.0.1",
+                      replaced_conns, new_conns, 0,
+                      AF_INET)&lt;0)
+    return -1;
   if (retry_listeners(CONN_TYPE_CONTROL_LISTENER,
                       options-&gt;ControlListenAddress,
                       options-&gt;ControlPort, "127.0.0.1",
@@ -1930,6 +1949,8 @@
     case CONN_TYPE_AP_TRANS_LISTENER:
     case CONN_TYPE_AP_NATD_LISTENER:
       return connection_handle_listener_read(conn, CONN_TYPE_AP);
+    case CONN_TYPE_TEST_SERVICE_LISTENER:
+      return connection_handle_listener_read(conn, CONN_TYPE_TEST);
     case CONN_TYPE_DIR_LISTENER:
       return connection_handle_listener_read(conn, CONN_TYPE_DIR);
     case CONN_TYPE_CONTROL_LISTENER:
@@ -2602,6 +2623,7 @@
       conn-&gt;type == CONN_TYPE_AP_TRANS_LISTENER ||
       conn-&gt;type == CONN_TYPE_AP_DNS_LISTENER ||
       conn-&gt;type == CONN_TYPE_AP_NATD_LISTENER ||
+      conn-&gt;type == CONN_TYPE_TEST_SERVICE_LISTENER ||
       conn-&gt;type == CONN_TYPE_DIR_LISTENER ||
       conn-&gt;type == CONN_TYPE_CONTROL_LISTENER)
     return 1;
@@ -2769,6 +2791,8 @@
     case CONN_TYPE_AP:
       return connection_edge_process_inbuf(TO_EDGE_CONN(conn),
                                            package_partial);
+    case CONN_TYPE_TEST:
+      return connection_testserv_process_inbuf(conn);
     case CONN_TYPE_DIR:
       return connection_dir_process_inbuf(TO_DIR_CONN(conn));
     case CONN_TYPE_CPUWORKER:
@@ -2822,6 +2846,8 @@
     case CONN_TYPE_AP:
     case CONN_TYPE_EXIT:
       return connection_edge_finished_flushing(TO_EDGE_CONN(conn));
+    case CONN_TYPE_TEST:
+      return connection_testserv_finished_flushing(conn);
     case CONN_TYPE_DIR:
       return connection_dir_finished_flushing(TO_DIR_CONN(conn));
     case CONN_TYPE_CPUWORKER:
@@ -3014,7 +3040,8 @@
       tor_assert(edge_conn-&gt;socks_request);
       if (conn-&gt;state == AP_CONN_STATE_OPEN) {
         tor_assert(edge_conn-&gt;socks_request-&gt;has_finished != 0);
-        if (!conn-&gt;marked_for_close) {
+        if ((!conn-&gt;marked_for_close) &amp;&amp;
+            (!conn-&gt;purpose == TEST_PURPOSE_AP)){
           tor_assert(edge_conn-&gt;cpath_layer);
           assert_cpath_layer_ok(edge_conn-&gt;cpath_layer);
         }
@@ -3025,6 +3052,7 @@
                  conn-&gt;purpose == EXIT_PURPOSE_RESOLVE);
     }
   } else if (conn-&gt;type == CONN_TYPE_DIR) {
+  } else if (conn-&gt;type == CONN_TYPE_TEST) {
   } else {
     /* Purpose is only used for dir and exit types currently */
     tor_assert(!conn-&gt;purpose);
@@ -3039,6 +3067,7 @@
     case CONN_TYPE_DIR_LISTENER:
     case CONN_TYPE_CONTROL_LISTENER:
     case CONN_TYPE_AP_DNS_LISTENER:
+    case CONN_TYPE_TEST_SERVICE_LISTENER:
       tor_assert(conn-&gt;state == LISTENER_STATE_READY);
       break;
     case CONN_TYPE_OR:
@@ -3057,6 +3086,12 @@
       tor_assert(conn-&gt;state &lt;= _AP_CONN_STATE_MAX);
       tor_assert(TO_EDGE_CONN(conn)-&gt;socks_request);
       break;
+    case CONN_TYPE_TEST:
+      tor_assert(conn-&gt;state &gt;= _TEST_CONN_STATE_MIN);
+      tor_assert(conn-&gt;state &lt;= _TEST_CONN_STATE_MAX);
+      tor_assert(conn-&gt;purpose &gt;= _TEST_PURPOSE_MIN);
+      tor_assert(conn-&gt;purpose &lt;= _TEST_PURPOSE_MAX);
+      break;
     case CONN_TYPE_DIR:
       tor_assert(conn-&gt;state &gt;= _DIR_CONN_STATE_MIN);
       tor_assert(conn-&gt;state &lt;= _DIR_CONN_STATE_MAX);
Index: src/or/testservice.c
===================================================================
--- src/or/testservice.c	(revision 0)
+++ src/or/testservice.c	(revision 0)
@@ -0,0 +1,710 @@
+/* Copyright (c) 2008, The Tor Project, Inc. */
+/* See LICENSE for licensing information */
+/* $Id: testservice.c $ */
+const char testservice_c_id[] =
+  "$Id: testservice.c $";
+
+#include "or.h"
+#include "testservice.h"
+
+/**
+ * \file testservice.c
+ * \brief Code to serve test html pages to browsers on localhost.
+ **/
+
+/* In-points to testservice.c:
+ *
+ */
+static int testservice_handle_command(connection_t *conn);
+
+/********* START VARIABLES **********/
+
+char *dnsleak_token=NULL, *proxytest_token=NULL, *connectivitytest_token=NULL;
+char *testip=NULL;
+char testpage[2056];
+uint32_t testresult;
+
+/********* END VARIABLES ************/
+char *random_token(int len);
+char *testservice_serve_page(uint32_t pagetype, int showingresult,
+                             int automated);
+int random_ip(char **ip);
+char *html_redirectheader(uint32_t pagetype, int showingresult);
+
+/** There is no reason for us to receive a resource request greater than 1K
+ * long.
+ */
+#define MAX_RESOURCE_REQUEST_SIZE (1&lt;&lt;10)
+#define LEN_TOKEN 8
+
+/** Generate a random hexadecimal token of length LEN_TOKEN * 2.
+ * The return value must be freed by the caller.
+ */
+char *
+random_token(int len)
+{
+  char *data;
+  char *output;
+  int hexlen = (len*2);
+
+  output = tor_malloc_zero(hexlen+1);
+  tor_assert(output);
+  data = tor_malloc_zero(len);
+  tor_assert(data);
+  tor_assert(!crypto_seed_rng(0));
+  crypto_rand(data, len);
+  base16_encode(output, hexlen+1, data, len);
+  tor_free(data);
+  return output;
+}
+
+/**
+ * Generate a random, non-local IP address
+ */
+
+int
+random_ip(char **ip)
+{
+  tor_addr_t addr;
+  char tmpip[INET_NTOA_BUF_LEN];
+  uint64_t a;
+
+  repeat:
+    tor_assert(!crypto_seed_rng(0));
+    a = crypto_rand_uint64(UINT64_MAX-1);
+    tor_snprintf(tmpip, sizeof(tmpip), "%d.%d.%d.%d",
+                        (int)(uint8_t)((a&gt;&gt;24)&amp;0xff),
+                        (int)(uint8_t)((a&gt;&gt;16)&amp;0xff),
+                        (int)(uint8_t)((a&gt;&gt;8 )&amp;0xff),
+                        (int)(uint8_t)((a    )&amp;0xff));
+    tor_addr_from_ipv4h(&amp;addr, a);
+
+  if (is_local_addr(&amp;addr))
+    goto repeat;
+
+  *ip = tor_malloc_zero(sizeof(tmpip));
+  strncpy(*ip,tmpip,sizeof(tmpip));
+  return 0;
+}
+
+/** Read handler for connections to the test service
+ */
+int
+connection_testserv_process_inbuf(connection_t *conn)
+{
+  tor_assert(conn);
+
+  /* Look for a command. */
+  if (conn-&gt;state == TEST_CONN_STATE_SERVER_COMMAND_WAIT) {
+    if (testservice_handle_command(conn) &lt; 0) {
+      connection_mark_for_close(conn);
+      return -1;
+    }
+    return 0;
+  }
+
+  if (buf_datalen(conn-&gt;inbuf) &gt; MAX_RESOURCE_REQUEST_SIZE) {
+    log_warn(LD_HTTP, "Too much data received from test server connection: "
+             "denial of service attempt, or you need to upgrade?");
+    connection_mark_for_close(conn);
+    return -1;
+  }
+
+  if (!conn-&gt;inbuf_reached_eof)
+    log_debug(LD_HTTP,"Got data, not eof. Leaving on inbuf.");
+  return 0;
+}
+
+/** Create an http response for the client &lt;b&gt;conn&lt;/b&gt; out of
+ * &lt;b&gt;status&lt;/b&gt; and &lt;b&gt;reason_phrase&lt;/b&gt;. Write it to &lt;b&gt;conn&lt;/b&gt;.
+ */
+static void
+write_http_status_line(connection_t *conn, int status,
+                       const char *reason_phrase)
+{
+  char buf[256];
+  if (tor_snprintf(buf, sizeof(buf), "HTTP/1.0 %d %s\r\n\r\n",
+      status, reason_phrase ? reason_phrase : "OK") &lt; 0) {
+    log_warn(LD_BUG,"status line too long.");
+    return;
+  }
+  connection_write_to_buf(buf, strlen(buf), conn);
+}
+
+/** Write the header for an HTTP/1.0 response onto &lt;b&gt;conn&lt;/b&gt;-\&gt;outbuf,
+ * with &lt;b&gt;type&lt;/b&gt; as the Content-Type.
+ *
+ * If &lt;b&gt;length&lt;/b&gt; is nonnegative, it is the Content-Length.
+ * If &lt;b&gt;encoding&lt;/b&gt; is provided, it is the Content-Encoding.
+ * If &lt;b&gt;cache_lifetime&lt;/b&gt; is greater than 0, the content may be cached for
+ * up to cache_lifetime seconds.  Otherwise, the content may not be cached. */
+static void
+write_http_response_header_impl(connection_t *conn, ssize_t length,
+                           const char *type, const char *encoding,
+                           const char *extra_headers,
+                           long cache_lifetime)
+{
+  char date[RFC1123_TIME_LEN+1];
+  char tmp[1024];
+  char *cp;
+  time_t now = time(NULL);
+
+  tor_assert(conn);
+
+  format_rfc1123_time(date, now);
+  cp = tmp;
+  tor_snprintf(cp, sizeof(tmp),
+               "HTTP/1.0 200 OK\r\nDate: %s\r\n",
+               date);
+  cp += strlen(tmp);
+  if (type) {
+    tor_snprintf(cp, sizeof(tmp)-(cp-tmp), "Content-Type: %s\r\n", type);
+    cp += strlen(cp);
+  }
+
+  if (encoding) {
+    tor_snprintf(cp, sizeof(tmp)-(cp-tmp),
+                 "Content-Encoding: %s\r\n", encoding);
+    cp += strlen(cp);
+  }
+  if (length &gt;= 0) {
+    tor_snprintf(cp, sizeof(tmp)-(cp-tmp),
+                 "Content-Length: %ld\r\n", (long)length);
+    cp += strlen(cp);
+  }
+  if (cache_lifetime &gt; 0) {
+    char expbuf[RFC1123_TIME_LEN+1];
+    format_rfc1123_time(expbuf, now + cache_lifetime);
+    /* We could say 'Cache-control: max-age=%d' here if we start doing
+     * http/1.1 */
+    tor_snprintf(cp, sizeof(tmp)-(cp-tmp),
+                 "Expires: %s\r\n", expbuf);
+    cp += strlen(cp);
+  } else if (cache_lifetime == 0) {
+    /* We could say 'Cache-control: no-cache' here if we start doing
+     * http/1.1 */
+    strlcpy(cp, "Pragma: no-cache\r\n", sizeof(tmp)-(cp-tmp));
+    cp += strlen(cp);
+  }
+  if (extra_headers)
+    strlcpy(cp, extra_headers, sizeof(tmp)-(cp-tmp));
+  if (sizeof(tmp)-(cp-tmp) &gt; 3)
+    memcpy(cp, "\r\n", 3);
+  else
+    tor_assert(0);
+
+  connection_write_to_buf(tmp, strlen(tmp), conn);
+}
+
+/** Parse an HTTP request string &lt;b&gt;headers&lt;/b&gt; of the form
+ * \verbatim
+ * "\%s [http[s]://]\%s HTTP/1..."
+ * \endverbatim
+ * If it's well-formed, strdup the second \%s into *&lt;b&gt;url&lt;/b&gt;, and
+ * nul-terminate it. Return 0.
+ * Otherwise, return -1.
+ */
+static int
+parse_http_url(const char *headers, char **url, char **stage, char **method)
+{
+  char *s, *start, *tmp;
+
+  s = (char *)eat_whitespace_no_nl(headers);
+  if (!*s) return -1;
+  s = (char *)find_whitespace(s); /* get past GET/POST */
+  if (!*s) return -1;
+  s = (char *)eat_whitespace_no_nl(s);
+  if (!*s) return -1;
+  start = s; /* this is it, assuming it's valid */
+  s = (char *)find_whitespace(start);
+  if (!*s) return -1;
+
+  /* tolerate the http[s] proxy style of putting the hostname in the url */
+  if (s-start &gt;= 4 &amp;&amp; !strcmpstart(start,"http")) {
+    tmp = start + 4;
+    if (*tmp == 's')
+      tmp++;
+    if (s-tmp &gt;= 3 &amp;&amp; !strcmpstart(tmp,"://")) {
+      tmp = strchr(tmp+3, '/');
+      if (tmp &amp;&amp; tmp &lt; s) {
+        log_debug(LD_DIR,"Skipping over 'http[s]://hostname' string");
+        start = tmp;
+      }
+    }
+  }
+
+  *url = tor_strndup(start, s-start);
+
+  /* Find the name of the next test, if present */
+  tmp = strchr(start, '?');
+  if ((tmp &amp;&amp; tmp &lt; s) &amp;&amp; !strcmpstart(tmp,"?stage=")) {
+    log_debug(LD_DIR,"Found get method.");
+    start = tmp+7;
+    *stage = tor_strndup(start, s-start);
+  }
+
+  tmp = strchr(start, '&amp;');
+  if ((tmp &amp;&amp; tmp &lt; s) &amp;&amp; !strcmpstart(tmp,"&amp;method=")) {
+    log_debug(LD_DIR,"Found get method.");
+    start = tmp+8;
+    *method = tor_strndup(start, s-start);
+  }
+
+  return 0;
+}
+
+/** As write_http_response_header_impl, but sets encoding and content-typed
+ * based on whether the response will be &lt;b&gt;compressed&lt;/b&gt; or not. */
+static void
+write_http_response_header(connection_t *conn, ssize_t length,
+                           int image, long cache_lifetime)
+{
+  write_http_response_header_impl(conn, length,
+                          image?"image/png":"text/html",
+                          "identity",
+                          NULL,
+                          cache_lifetime);
+}
+
+/**
+ * Return the html body text for the desired page.
+ */
+
+static const char *
+testservice_find_message(int type, int state, int part)
+{
+  int i;
+  for (i=0; status_messages[i].type; ++i) {
+    if ((status_messages[i].state == state) &amp;&amp;
+       (status_messages[i].type == type)) {
+      if (part == 1)
+        return status_messages[i].htmlpart1;
+      else
+        return status_messages[i].htmlpart2;
+    }
+  }
+  return " ";
+}
+
+/**
+ * Figure out the appropriate html page to serve and retrieve it's body.
+ */
+static int
+testservice_printmessage(char *htmlpart1, char *htmlpart2, size_t msglen,
+                         uint32_t type, int showingresult)
+{
+  int result=0;
+
+  switch (type) {
+    case MAIN_PAGE:
+    case END_PAGE:
+      result=TEST_COMPLETE;
+      break;
+    default:
+      if (showingresult)
+        if (testresult &amp; type)
+          result=TEST_SUCCESSFUL;
+        else
+          result=TEST_FAILED;
+      else
+        result=TEST_INPROGRESS;
+  }
+
+  strlcpy(htmlpart1, testservice_find_message(type,result,1),
+          msglen);
+  strlcpy(htmlpart2, testservice_find_message(type,result,2),
+          msglen);
+  return result;
+}
+
+
+/** Helper function: called when a test server gets a complete HTTP GET
+ * request. If the request is unrecognized, send a 400.
+ * Always return 0. */
+static int
+testservice_handle_command_get(connection_t *conn, const char *headers,
+                             const char *body, size_t body_len)
+{
+  char *url, *stage=NULL, *method=NULL;
+  int pagetoserve=0, showingresult=0, automated=0;
+  
+  /* We ignore the body of a GET request. */
+  (void)body;
+  (void)body_len;
+
+  log_debug(LD_TESTSERV,"Received GET command.");
+
+  conn-&gt;state = TEST_CONN_STATE_SERVER_WRITING;
+
+  if (parse_http_url(headers, &amp;url, &amp;stage, &amp;method) &lt; 0) {
+    write_http_status_line(conn, 400, "Bad request");
+    return 0;
+  }
+
+  if (stage)
+    showingresult = (!strncmp("check",stage,5));
+  if (method)
+    automated = (!strcmp("auto",method));
+
+  log_debug(LD_TESTSERV,"rewritten url as '%s'.", url);
+
+  if ((!strcmp(url,"/")) || (!strncmp(url,"/ind",4)))
+    pagetoserve=MAIN_PAGE;
+  else if (!strncmp(url,"/pro",4))
+    pagetoserve=PROXY_TEST;
+  else if (!strncmp(url,"/dns",4))
+    pagetoserve=DNS_TEST;
+  else if (!strncmp(url,"/tor",4))
+    pagetoserve=CONNECTIVITY_TEST;
+  else if (!strncmp(url,"/end",4))
+    pagetoserve=END_PAGE;
+
+  if (pagetoserve) {
+    char *bytes = testservice_serve_page(pagetoserve, showingresult, automated);
+    size_t len = strlen(bytes);
+    write_http_response_header(conn, len, 0, 0);
+    connection_write_to_buf(bytes, len, conn);
+    goto done;
+  }
+
+
+  /* we didn't recognize the url */
+  write_http_status_line(conn, 404, "Not found");
+
+ done:
+  control_event_client_status(LOG_NOTICE,
+                              "TESTSERVICE_REQUEST TYPE=MAIN "
+                              "RESOURCE=%s",url);
+  tor_free(url);
+  tor_free(stage);
+  tor_free(method);
+
+  return 0;
+}
+
+/** Called when a test server receives data; looks for an HTTP request.
+ * If the request is complete, remove it from the inbuf, try to process it;
+ * otherwise, leave it on the buffer.  Return a 0 on success, or -1 on error.
+ */
+static int
+testservice_handle_command(connection_t *conn)
+{
+  char *headers=NULL, *body=NULL;
+  size_t body_len=0;
+  int r;
+
+  tor_assert(conn);
+  tor_assert(conn-&gt;type == CONN_TYPE_TEST);
+
+  switch (fetch_from_buf_http(conn-&gt;inbuf,
+                              &amp;headers, MAX_HEADERS_SIZE,
+                              &amp;body, &amp;body_len, MAX_DIR_UL_SIZE, 0)) {
+    case -1: /* overflow */
+      log_warn(LD_TESTSERV,
+               "Invalid input from address '%s'. Closing.",
+               conn-&gt;address);
+      return -1;
+    case 0:
+      log_debug(LD_TESTSERV,"command not all here yet.");
+      return 0;
+    /* case 1, fall through */
+  }
+
+  if (!strncasecmp(headers,"GET",3))
+    r = testservice_handle_command_get(conn, headers, body, body_len);
+  else {
+    log_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,
+           "Got headers %s with unknown command. Closing.",
+           escaped(headers));
+    r = -1;
+  }
+
+  tor_free(headers); tor_free(body);
+  return r;
+}
+
+/** Write handler for test service connections; called when all data has
+ * been flushed.  Close the connection or wait for a response as
+ * appropriate.
+ */
+int
+connection_testserv_finished_flushing(connection_t *conn)
+{
+  tor_assert(conn);
+  tor_assert(conn-&gt;type == CONN_TYPE_TEST);
+
+  switch (conn-&gt;state) {
+    case TEST_CONN_STATE_SERVER_WRITING:
+      log_debug(LD_TESTSERV,"Finished writing server response. Closing.");
+      connection_mark_for_close(conn);
+      return 0;
+    default:
+      log_warn(LD_BUG,"called in unexpected state %d.",
+               conn-&gt;state);
+      tor_fragile_assert();
+      return -1;
+  }
+  return 0;
+}
+
+/**
+ * Return the appropriate html Refresh header, or NULL if none is required
+ */
+char *
+html_redirectheader(uint32_t pagetype, int showingresult)
+{
+  char redirecturl[24];
+  char *redirectheader=NULL,*args=NULL;
+
+  args=tor_malloc_zero(32);
+  tor_snprintf(args, 32,"?stage=%s&amp;method=auto",
+              (showingresult)?"test":"check");
+
+  /* We write a redirect header if we are not doing a manual test,
+     have not failed a test, and are not serving a static page */
+  switch (pagetype) {
+    case CONNECTIVITY_TEST:
+      tor_snprintf(redirecturl,sizeof(redirecturl),"%s",
+                  (showingresult)?"end.html":"tortest.html");
+      break;
+    case PROXY_TEST:
+      tor_snprintf(redirecturl,sizeof(redirecturl),"%s",
+                  (showingresult)?"dnstest.html":"proxy.html");
+      break;
+    case DNS_TEST:
+      tor_snprintf(redirecturl,sizeof(redirecturl),"%s",
+                   (showingresult)?"tortest.html":"dnstest.html");
+      break;
+    default:
+      return NULL;
+  }
+
+  redirectheader = tor_malloc_zero(1024);
+  tor_snprintf(redirectheader,1024,
+               "&lt;title&gt;Tor&lt;/title&gt;&lt;META HTTP-EQUIV='Refresh'"
+               " CONTENT='3; URL=%s%s'&gt;&lt;/head&gt;",
+               redirecturl,
+               (strcmp(redirecturl,"end.html"))?args:"");
+  tor_free(args);
+
+  return redirectheader;
+}
+
+/**
+ * Serve a web page
+ */
+char *
+testservice_serve_page(uint32_t pagetype, int showingresult, int automated)
+{
+  char testimage[2056];
+  char htmlpart1[2056];
+  char htmlpart2[2056];
+  int continuetesting=0;
+  char *redirectheader=NULL;
+
+  testimage[0]='\0';
+
+  /* Prepare the appropriate test image if this a test page, otherwise
+     reset the test results.*/
+  switch (pagetype) {
+    case MAIN_PAGE:
+      testresult=0;
+      break;
+    case END_PAGE:
+      if ((testresult &amp; PROXY_TEST) &amp;&amp;
+          (testresult &amp; DNS_TEST) &amp;&amp;
+          (testresult &amp; CONNECTIVITY_TEST))
+          strlcpy(testimage,
+                  "&lt;div align='center'&gt;&lt;h2&gt;Successful!&lt;/h2&gt;&lt;/div&gt;",
+                  sizeof(testimage));
+      else
+          strlcpy(testimage,
+                  "&lt;div align='center'&gt;&lt;h2&gt;A Failure!&lt;/h2&gt;&lt;/div&gt;",
+                  sizeof(testimage));
+
+      testresult=0;
+      break;
+    case PROXY_TEST:
+      random_ip(&amp;testip);
+      proxytest_token = random_token(LEN_TOKEN);
+      tor_snprintf(testimage, sizeof(testimage), "&lt;IMG src="
+                  "\"http://%s/%s.png\" "
+                  "alt=\"If this page finishes loading or takes a long time "
+                  "to load and you can still "
+                  "see this text, your browser is not "
+                  "configured to work with Tor.\" width=\"200\"  
height=\"200\" "
+                  "align=\"middle\" border=\"2\"&gt;\n",
+                  testip,proxytest_token);
+      break;
+    case DNS_TEST:
+      dnsleak_token = random_token(LEN_TOKEN);
+      tor_snprintf(testimage, sizeof(testimage), "&lt;IMG src="
+                  "\"http://%s/%s.png\""
+                  " alt=\"If this page finishes loading and you can still "
+                  "see this text, your browser's DNS requests "
+                  "are not being routed through Tor.\" width=\"200\" "
+                  "height=\"200\" align=\"middle\" border=\"2\"&gt;\n",
+                  dnsleak_token,dnsleak_token);
+      break;
+    case CONNECTIVITY_TEST:
+      connectivitytest_token = random_token(LEN_TOKEN);
+      tor_snprintf(testimage, sizeof(testimage), "&lt;IMG src="
+                  "\"http://roberthogan.net/images/%s-tortest.png\" "
+                  "alt=\"If this page finishes loading and you can still "
+                  "see this text, your Tor installation "
+                  "cannot connect to the Internet.\" width=\"200\"  "
+                  "height=\"200\" align=\"middle\" border=\"2\"&gt;\n",
+                  connectivitytest_token);
+      break;
+    default:
+      strlcpy(testpage,errorpage,sizeof(testpage));
+      return testpage;
+  }
+
+
+  /* Prepare the text for the page. If we're about to inform the user of
+     a failed test or if we're at the beginning or end of a test set,
+     then we don't want to write a redirect. */
+  continuetesting = testservice_printmessage(htmlpart1,
+                                             htmlpart2, sizeof(htmlpart2),
+                                             pagetype,
+                                             showingresult);
+
+  if ((continuetesting) &amp;&amp; (automated))
+    redirectheader = html_redirectheader(pagetype, showingresult);
+
+  tor_snprintf(testpage,sizeof(testpage),"&lt;HTML&gt;%s&lt;BODY&gt;%s%s%s&lt;/BODY&gt;&lt;/HTML&gt;",
+               (redirectheader)?redirectheader:"",
+               htmlpart1,testimage,htmlpart2);
+
+  tor_free(redirectheader);
+  return testpage;
+}
+
+/**
+ * Is the address in the SOCKS request one embedded in an image resource
+ * served by the test service?
+ */
+int
+testservice_testaddress(const char *address)
+{
+  if ((dnsleak_token) &amp;&amp; (!strcasecmp(address,dnsleak_token))) {
+      return 1;
+  }
+
+  if ((testip) &amp;&amp; (!strcasecmp(address,testip))) {
+      tor_free(testip);
+      return 1;
+  }
+
+  return 0;
+}
+
+/**
+ * If we have received a GET request on the SOCKS Port, serve a warning image.
+ * XXXXX: SOCKS doesn't like responses greater than 2056, so the image served
+ * here should not exceed that.
+ */
+int
+testservice_handlebrowserusingtorasproxy(const char *buf,socks_request_t *req)
+{
+  char proxyrequest[256];
+  char proxyresponse[MAX_SOCKS_REPLY_LEN];
+  size_t len;
+  tor_snprintf(proxyrequest, sizeof(proxyrequest),
+               "GET http://%s/%s.png",testip,proxytest_token);
+  if (!strncmp(buf,proxyrequest,strlen(proxyrequest))) {
+      tor_snprintf(proxyresponse,sizeof(proxyresponse),
+                  "HTTP/1.0 200 OK\r\n"
+                  "Content-Type: image/png\r\n"
+                  "Content-Encoding: identity\r\n"
+                  "Content-Length: %i\r\n"
+                  "Connection: close\r\n\r\n",
+                  sizeof(proxytest_image));
+      len = strlcpy(req-&gt;reply,
+              proxyresponse,
+              sizeof(proxyresponse));
+      memcpy(req-&gt;reply+len,
+             proxytest_image,
+             sizeof(proxytest_image));
+      req-&gt;replylen = ((sizeof(proxytest_image)+len+1) &gt; MAX_SOCKS_REPLY_LEN) ?
+                      MAX_SOCKS_REPLY_LEN:(sizeof(proxytest_image)+len+1);
+      return 1;
+  }
+  return 0;
+}
+
+/**
+ * Is the GET request received on Tor's SOCKSPort for a test image? If so
+ * serve it. A return code of 1 tells the caller to close the conn on the
+ * SOCKSPort.
+ */
+int
+testservice_istestrequest(connection_t *conn)
+{
+  char dnsleak_resource[256], proxytest_resource[256];
+  char connectivitytest_resource[256];
+
+  tor_assert(conn);
+  tor_assert(conn-&gt;type == CONN_TYPE_AP);
+
+  if ((!dnsleak_token) &amp;&amp;
+     (!proxytest_token) &amp;&amp;
+     (!connectivitytest_token))
+    return 0;
+
+  if (dnsleak_token) {
+    tor_snprintf(dnsleak_resource, sizeof(dnsleak_resource),
+                 "GET /%s.png",dnsleak_token);
+    if (buf_startswith(conn-&gt;inbuf,dnsleak_resource,25)) {
+      write_http_response_header(conn, sizeof(onion_image), 1, 1);
+      connection_write_to_buf(onion_image, sizeof(onion_image), conn);
+      tor_free(dnsleak_token);
+      dnsleak_token=NULL;
+      testresult = (testresult | DNS_TEST);
+      control_event_client_status(LOG_NOTICE,
+                                  "TESTSERVICE_REQUEST TYPE=DNS RESOURCE=%s",
+                                  dnsleak_resource);
+      return 1;
+    }
+  }
+
+  if (proxytest_token) {
+    tor_snprintf(proxytest_resource, sizeof(proxytest_resource),
+                 "GET /%s.png",proxytest_token);
+    if (buf_startswith(conn-&gt;inbuf,proxytest_resource,25)) {
+      write_http_response_header(conn, sizeof(onion_image), 1, 1);
+      connection_write_to_buf(onion_image, sizeof(onion_image), conn);
+      tor_free(proxytest_token);
+      proxytest_token=NULL;
+      testresult = (testresult | PROXY_TEST);
+      control_event_client_status(LOG_NOTICE,
+                                  "TESTSERVICE_REQUEST TYPE=PROXY "
+                                  "RESOURCE=%s",
+                                  proxytest_resource);
+      return 1;
+    }
+  }
+
+  // If we see the connectivitytest_token it means a circuit has been built
+  // so we send the image back and close the connection.
+  if (connectivitytest_token) {
+    tor_snprintf(connectivitytest_resource, sizeof(connectivitytest_resource),
+                 "GET /images/%s-tortest.png", connectivitytest_token);
+    if (buf_startswith(conn-&gt;inbuf,connectivitytest_resource,40)) {
+      write_http_response_header(conn, sizeof(onion_image), 1, 1);
+      connection_write_to_buf(onion_image,
+                              sizeof(onion_image), conn);
+      tor_free(connectivitytest_token);
+      connectivitytest_token=NULL;
+      testresult = (testresult | CONNECTIVITY_TEST);
+      control_event_client_status(LOG_NOTICE,
+                                  "TESTSERVICE_REQUEST TYPE=PROXY "
+                                  "RESOURCE=%s",
+                                  connectivitytest_resource);
+      return 1;
+     }
+  }
+  return 0;
+}
+
Index: src/or/testservice.h
===================================================================
--- src/or/testservice.h	(revision 0)
+++ src/or/testservice.h	(revision 0)
@@ -0,0 +1,1066 @@
+/* Copyright (c) 2008, The Tor Project, Inc. */
+/* See LICENSE for licensing information */
+/* $Id: or.h 16785 2008-09-05 22:09:44Z nickm $ */
+
+/**
+ * \file testservice.h
+ * \brief Header file for the test service.
+ **/
+#ifndef __TESTSERVICE_H
+#define __TESTSERVICE_H
+#define TESTSERVICE_H_ID "$Id: testservice.h $"
+
+/** The result of the test. */
+#define TEST_COMPLETE 0
+#define TEST_FAILED 0
+#define TEST_SUCCESSFUL 1
+#define TEST_INPROGRESS 2
+
+/** The type of test. */
+#define PROXY_TEST 1
+#define DNS_TEST 2
+#define CONNECTIVITY_TEST 4
+#define MAIN_PAGE 8
+#define END_PAGE 16
+#define SOCKSPROXY_PAGE 32
+
+/** A PNG image of a green onion! */
+const char onion_image[] = {
+ 0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00,
+0x00, 0x0d, 0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
+0x80, 0x08, 0x06, 0x00, 0x00, 0x00, 0xc3, 0x3e, 0x61, 0xcb, 0x00, 0x00, 0x00,
+0x09, 0x70, 0x48, 0x59, 0x73, 0x00, 0x00, 0x0b, 0x13, 0x00, 0x00, 0x0b, 0x13,
+0x01, 0x00, 0x9a, 0x9c, 0x18, 0x00, 0x00, 0x0a, 0x4d, 0x69, 0x43, 0x43, 0x50,
+0x50, 0x68, 0x6f, 0x74, 0x6f, 0x73, 0x68, 0x6f, 0x70, 0x20, 0x49, 0x43, 0x43,
+0x20, 0x70, 0x72, 0x6f, 0x66, 0x69, 0x6c, 0x65, 0x00, 0x00, 0x78, 0xda, 0x9d,
+0x53, 0x77, 0x58, 0x93, 0xf7, 0x16, 0x3e, 0xdf, 0xf7, 0x65, 0x0f, 0x56, 0x42,
+0xd8, 0xf0, 0xb1, 0x97, 0x6c, 0x81, 0x00, 0x22, 0x23, 0xac, 0x08, 0xc8, 0x10,
+0x59, 0xa2, 0x10, 0x92, 0x00, 0x61, 0x84, 0x10, 0x12, 0x40, 0xc5, 0x85, 0x88,
+0x0a, 0x56, 0x14, 0x15, 0x11, 0x9c, 0x48, 0x55, 0xc4, 0x82, 0xd5, 0x0a, 0x48,
+0x9d, 0x88, 0xe2, 0xa0, 0x28, 0xb8, 0x67, 0x41, 0x8a, 0x88, 0x5a, 0x8b, 0x55,
+0x5c, 0x38, 0xee, 0x1f, 0xdc, 0xa7, 0xb5, 0x7d, 0x7a, 0xef, 0xed, 0xed, 0xfb,
+0xd7, 0xfb, 0xbc, 0xe7, 0x9c, 0xe7, 0xfc, 0xce, 0x79, 0xcf, 0x0f, 0x80, 0x11,
+0x12, 0x26, 0x91, 0xe6, 0xa2, 0x6a, 0x00, 0x39, 0x52, 0x85, 0x3c, 0x3a, 0xd8,
+0x1f, 0x8f, 0x4f, 0x48, 0xc4, 0xc9, 0xbd, 0x80, 0x02, 0x15, 0x48, 0xe0, 0x04,
+0x20, 0x10, 0xe6, 0xcb, 0xc2, 0x67, 0x05, 0xc5, 0x00, 0x00, 0xf0, 0x03, 0x79,
+0x78, 0x7e, 0x74, 0xb0, 0x3f, 0xfc, 0x01, 0xaf, 0x6f, 0x00, 0x02, 0x00, 0x70,
+0xd5, 0x2e, 0x24, 0x12, 0xc7, 0xe1, 0xff, 0x83, 0xba, 0x50, 0x26, 0x57, 0x00,
+0x20, 0x91, 0x00, 0xe0, 0x22, 0x12, 0xe7, 0x0b, 0x01, 0x90, 0x52, 0x00, 0xc8,
+0x2e, 0x54, 0xc8, 0x14, 0x00, 0xc8, 0x18, 0x00, 0xb0, 0x53, 0xb3, 0x64, 0x0a,
+0x00, 0x94, 0x00, 0x00, 0x6c, 0x79, 0x7c, 0x42, 0x22, 0x00, 0xaa, 0x0d, 0x00,
+0xec, 0xf4, 0x49, 0x3e, 0x05, 0x00, 0xd8, 0xa9, 0x93, 0xdc, 0x17, 0x00, 0xd8,
+0xa2, 0x1c, 0xa9, 0x08, 0x00, 0x8d, 0x01, 0x00, 0x99, 0x28, 0x47, 0x24, 0x02,
+0x40, 0xbb, 0x00, 0x60, 0x55, 0x81, 0x52, 0x2c, 0x02, 0xc0, 0xc2, 0x00, 0xa0,
+0xac, 0x40, 0x22, 0x2e, 0x04, 0xc0, 0xae, 0x01, 0x80, 0x59, 0xb6, 0x32, 0x47,
+0x02, 0x80, 0xbd, 0x05, 0x00, 0x76, 0x8e, 0x58, 0x90, 0x0f, 0x40, 0x60, 0x00,
+0x80, 0x99, 0x42, 0x2c, 0xcc, 0x00, 0x20, 0x38, 0x02, 0x00, 0x43, 0x1e, 0x13,
+0xcd, 0x03, 0x20, 0x4c, 0x03, 0xa0, 0x30, 0xd2, 0xbf, 0xe0, 0xa9, 0x5f, 0x70,
+0x85, 0xb8, 0x48, 0x01, 0x00, 0xc0, 0xcb, 0x95, 0xcd, 0x97, 0x4b, 0xd2, 0x33,
+0x14, 0xb8, 0x95, 0xd0, 0x1a, 0x77, 0xf2, 0xf0, 0xe0, 0xe2, 0x21, 0xe2, 0xc2,
+0x6c, 0xb1, 0x42, 0x61, 0x17, 0x29, 0x10, 0x66, 0x09, 0xe4, 0x22, 0x9c, 0x97,
+0x9b, 0x23, 0x13, 0x48, 0xe7, 0x03, 0x4c, 0xce, 0x0c, 0x00, 0x00, 0x1a, 0xf9,
+0xd1, 0xc1, 0xfe, 0x38, 0x3f, 0x90, 0xe7, 0xe6, 0xe4, 0xe1, 0xe6, 0x66, 0xe7,
+0x6c, 0xef, 0xf4, 0xc5, 0xa2, 0xfe, 0x6b, 0xf0, 0x6f, 0x22, 0x3e, 0x21, 0xf1,
+0xdf, 0xfe, 0xbc, 0x8c, 0x02, 0x04, 0x00, 0x10, 0x4e, 0xcf, 0xef, 0xda, 0x5f,
+0xe5, 0xe5, 0xd6, 0x03, 0x70, 0xc7, 0x01, 0xb0, 0x75, 0xbf, 0x6b, 0xa9, 0x5b,
+0x00, 0xda, 0x56, 0x00, 0x68, 0xdf, 0xf9, 0x5d, 0x33, 0xdb, 0x09, 0xa0, 0x5a,
+0x0a, 0xd0, 0x7a, 0xf9, 0x8b, 0x79, 0x38, 0xfc, 0x40, 0x1e, 0x9e, 0xa1, 0x50,
+0xc8, 0x3c, 0x1d, 0x1c, 0x0a, 0x0b, 0x0b, 0xed, 0x25, 0x62, 0xa1, 0xbd, 0x30,
+0xe3, 0x8b, 0x3e, 0xff, 0x33, 0xe1, 0x6f, 0xe0, 0x8b, 0x7e, 0xf6, 0xfc, 0x40,
+0x1e, 0xfe, 0xdb, 0x7a, 0xf0, 0x00, 0x71, 0x9a, 0x40, 0x99, 0xad, 0xc0, 0xa3,
+0x83, 0xfd, 0x71, 0x61, 0x6e, 0x76, 0xae, 0x52, 0x8e, 0xe7, 0xcb, 0x04, 0x42,
+0x31, 0x6e, 0xf7, 0xe7, 0x23, 0xfe, 0xc7, 0x85, 0x7f, 0xfd, 0x8e, 0x29, 0xd1,
+0xe2, 0x34, 0xb1, 0x5c, 0x2c, 0x15, 0x8a, 0xf1, 0x58, 0x89, 0xb8, 0x50, 0x22,
+0x4d, 0xc7, 0x79, 0xb9, 0x52, 0x91, 0x44, 0x21, 0xc9, 0x95, 0xe2, 0x12, 0xe9,
+0x7f, 0x32, 0xf1, 0x1f, 0x96, 0xfd, 0x09, 0x93, 0x77, 0x0d, 0x00, 0xac, 0x86,
+0x4f, 0xc0, 0x4e, 0xb6, 0x07, 0xb5, 0xcb, 0x6c, 0xc0, 0x7e, 0xee, 0x01, 0x02,
+0x8b, 0x0e, 0x58, 0xd2, 0x76, 0x00, 0x40, 0x7e, 0xf3, 0x2d, 0x8c, 0x1a, 0x0b,
+0x91, 0x00, 0x10, 0x67, 0x34, 0x32, 0x79, 0xf7, 0x00, 0x00, 0x93, 0xbf, 0xf9,
+0x8f, 0x40, 0x2b, 0x01, 0x00, 0xcd, 0x97, 0xa4, 0xe3, 0x00, 0x00, 0xbc, 0xe8,
+0x18, 0x5c, 0xa8, 0x94, 0x17, 0x4c, 0xc6, 0x08, 0x00, 0x00, 0x44, 0xa0, 0x81,
+0x2a, 0xb0, 0x41, 0x07, 0x0c, 0xc1, 0x14, 0xac, 0xc0, 0x0e, 0x9c, 0xc1, 0x1d,
+0xbc, 0xc0, 0x17, 0x02, 0x61, 0x06, 0x44, 0x40, 0x0c, 0x24, 0xc0, 0x3c, 0x10,
+0x42, 0x06, 0xe4, 0x80, 0x1c, 0x0a, 0xa1, 0x18, 0x96, 0x41, 0x19, 0x54, 0xc0,
+0x3a, 0xd8, 0x04, 0xb5, 0xb0, 0x03, 0x1a, 0xa0, 0x11, 0x9a, 0xe1, 0x10, 0xb4,
+0xc1, 0x31, 0x38, 0x0d, 0xe7, 0xe0, 0x12, 0x5c, 0x81, 0xeb, 0x70, 0x17, 0x06,
+0x60, 0x18, 0x9e, 0xc2, 0x18, 0xbc, 0x86, 0x09, 0x04, 0x41, 0xc8, 0x08, 0x13,
+0x61, 0x21, 0x3a, 0x88, 0x11, 0x62, 0x8e, 0xd8, 0x22, 0xce, 0x08, 0x17, 0x99,
+0x8e, 0x04, 0x22, 0x61, 0x48, 0x34, 0x92, 0x80, 0xa4, 0x20, 0xe9, 0x88, 0x14,
+0x51, 0x22, 0xc5, 0xc8, 0x72, 0xa4, 0x02, 0xa9, 0x42, 0x6a, 0x91, 0x5d, 0x48,
+0x23, 0xf2, 0x2d, 0x72, 0x14, 0x39, 0x8d, 0x5c, 0x40, 0xfa, 0x90, 0xdb, 0xc8,
+0x20, 0x32, 0x8a, 0xfc, 0x8a, 0xbc, 0x47, 0x31, 0x94, 0x81, 0xb2, 0x51, 0x03,
+0xd4, 0x02, 0x75, 0x40, 0xb9, 0xa8, 0x1f, 0x1a, 0x8a, 0xc6, 0xa0, 0x73, 0xd1,
+0x74, 0x34, 0x0f, 0x5d, 0x80, 0x96, 0xa2, 0x6b, 0xd1, 0x1a, 0xb4, 0x1e, 0x3d,
+0x80, 0xb6, 0xa2, 0xa7, 0xd1, 0x4b, 0xe8, 0x75, 0x74, 0x00, 0x7d, 0x8a, 0x8e,
+0x63, 0x80, 0xd1, 0x31, 0x0e, 0x66, 0x8c, 0xd9, 0x61, 0x5c, 0x8c, 0x87, 0x45,
+0x60, 0x89, 0x58, 0x1a, 0x26, 0xc7, 0x16, 0x63, 0xe5, 0x58, 0x35, 0x56, 0x8f,
+0x35, 0x63, 0x1d, 0x58, 0x37, 0x76, 0x15, 0x1b, 0xc0, 0x9e, 0x61, 0xef, 0x08,
+0x24, 0x02, 0x8b, 0x80, 0x13, 0xec, 0x08, 0x5e, 0x84, 0x10, 0xc2, 0x6c, 0x82,
+0x90, 0x90, 0x47, 0x58, 0x4c, 0x58, 0x43, 0xa8, 0x25, 0xec, 0x23, 0xb4, 0x12,
+0xba, 0x08, 0x57, 0x09, 0x83, 0x84, 0x31, 0xc2, 0x27, 0x22, 0x93, 0xa8, 0x4f,
+0xb4, 0x25, 0x7a, 0x12, 0xf9, 0xc4, 0x78, 0x62, 0x3a, 0xb1, 0x90, 0x58, 0x46,
+0xac, 0x26, 0xee, 0x21, 0x1e, 0x21, 0x9e, 0x25, 0x5e, 0x27, 0x0e, 0x13, 0x5f,
+0x93, 0x48, 0x24, 0x0e, 0xc9, 0x92, 0xe4, 0x4e, 0x0a, 0x21, 0x25, 0x90, 0x32,
+0x49, 0x0b, 0x49, 0x6b, 0x48, 0xdb, 0x48, 0x2d, 0xa4, 0x53, 0xa4, 0x3e, 0xd2,
+0x10, 0x69, 0x9c, 0x4c, 0x26, 0xeb, 0x90, 0x6d, 0xc9, 0xde, 0xe4, 0x08, 0xb2,
+0x80, 0xac, 0x20, 0x97, 0x91, 0xb7, 0x90, 0x0f, 0x90, 0x4f, 0x92, 0xfb, 0xc9,
+0xc3, 0xe4, 0xb7, 0x14, 0x3a, 0xc5, 0x88, 0xe2, 0x4c, 0x09, 0xa2, 0x24, 0x52,
+0xa4, 0x94, 0x12, 0x4a, 0x35, 0x65, 0x3f, 0xe5, 0x04, 0xa5, 0x9f, 0x32, 0x42,
+0x99, 0xa0, 0xaa, 0x51, 0xcd, 0xa9, 0x9e, 0xd4, 0x08, 0xaa, 0x88, 0x3a, 0x9f,
+0x5a, 0x49, 0x6d, 0xa0, 0x76, 0x50, 0x2f, 0x53, 0x87, 0xa9, 0x13, 0x34, 0x75,
+0x9a, 0x25, 0xcd, 0x9b, 0x16, 0x43, 0xcb, 0xa4, 0x2d, 0xa3, 0xd5, 0xd0, 0x9a,
+0x69, 0x67, 0x69, 0xf7, 0x68, 0x2f, 0xe9, 0x74, 0xba, 0x09, 0xdd, 0x83, 0x1e,
+0x45, 0x97, 0xd0, 0x97, 0xd2, 0x6b, 0xe8, 0x07, 0xe9, 0xe7, 0xe9, 0x83, 0xf4,
+0x77, 0x0c, 0x0d, 0x86, 0x0d, 0x83, 0xc7, 0x48, 0x62, 0x28, 0x19, 0x6b, 0x19,
+0x7b, 0x19, 0xa7, 0x18, 0xb7, 0x19, 0x2f, 0x99, 0x4c, 0xa6, 0x05, 0xd3, 0x97,
+0x99, 0xc8, 0x54, 0x30, 0xd7, 0x32, 0x1b, 0x99, 0x67, 0x98, 0x0f, 0x98, 0x6f,
+0x55, 0x58, 0x2a, 0xf6, 0x2a, 0x7c, 0x15, 0x91, 0xca, 0x12, 0x95, 0x3a, 0x95,
+0x56, 0x95, 0x7e, 0x95, 0xe7, 0xaa, 0x54, 0x55, 0x73, 0x55, 0x3f, 0xd5, 0x79,
+0xaa, 0x0b, 0x54, 0xab, 0x55, 0x0f, 0xab, 0x5e, 0x56, 0x7d, 0xa6, 0x46, 0x55,
+0xb3, 0x50, 0xe3, 0xa9, 0x09, 0xd4, 0x16, 0xab, 0xd5, 0xa9, 0x1d, 0x55, 0xbb,
+0xa9, 0x36, 0xae, 0xce, 0x52, 0x77, 0x52, 0x8f, 0x50, 0xcf, 0x51, 0x5f, 0xa3,
+0xbe, 0x5f, 0xfd, 0x82, 0xfa, 0x63, 0x0d, 0xb2, 0x86, 0x85, 0x46, 0xa0, 0x86,
+0x48, 0xa3, 0x54, 0x63, 0xb7, 0xc6, 0x19, 0x8d, 0x21, 0x16, 0xc6, 0x32, 0x65,
+0xf1, 0x58, 0x42, 0xd6, 0x72, 0x56, 0x03, 0xeb, 0x2c, 0x6b, 0x98, 0x4d, 0x62,
+0x5b, 0xb2, 0xf9, 0xec, 0x4c, 0x76, 0x05, 0xfb, 0x1b, 0x76, 0x2f, 0x7b, 0x4c,
+0x53, 0x43, 0x73, 0xaa, 0x66, 0xac, 0x66, 0x91, 0x66, 0x9d, 0xe6, 0x71, 0xcd,
+0x01, 0x0e, 0xc6, 0xb1, 0xe0, 0xf0, 0x39, 0xd9, 0x9c, 0x4a, 0xce, 0x21, 0xce,
+0x0d, 0xce, 0x7b, 0x2d, 0x03, 0x2d, 0x3f, 0x2d, 0xb1, 0xd6, 0x6a, 0xad, 0x66,
+0xad, 0x7e, 0xad, 0x37, 0xda, 0x7a, 0xda, 0xbe, 0xda, 0x62, 0xed, 0x72, 0xed,
+0x16, 0xed, 0xeb, 0xda, 0xef, 0x75, 0x70, 0x9d, 0x40, 0x9d, 0x2c, 0x9d, 0xf5,
+0x3a, 0x6d, 0x3a, 0xf7, 0x75, 0x09, 0xba, 0x36, 0xba, 0x51, 0xba, 0x85, 0xba,
+0xdb, 0x75, 0xcf, 0xea, 0x3e, 0xd3, 0x63, 0xeb, 0x79, 0xe9, 0x09, 0xf5, 0xca,
+0xf5, 0x0e, 0xe9, 0xdd, 0xd1, 0x47, 0xf5, 0x6d, 0xf4, 0xa3, 0xf5, 0x17, 0xea,
+0xef, 0xd6, 0xef, 0xd1, 0x1f, 0x37, 0x30, 0x34, 0x08, 0x36, 0x90, 0x19, 0x6c,
+0x31, 0x38, 0x63, 0xf0, 0xcc, 0x90, 0x63, 0xe8, 0x6b, 0x98, 0x69, 0xb8, 0xd1,
+0xf0, 0x84, 0xe1, 0xa8, 0x11, 0xcb, 0x68, 0xba, 0x91, 0xc4, 0x68, 0xa3, 0xd1,
+0x49, 0xa3, 0x27, 0xb8, 0x26, 0xee, 0x87, 0x67, 0xe3, 0x35, 0x78, 0x17, 0x3e,
+0x66, 0xac, 0x6f, 0x1c, 0x62, 0xac, 0x34, 0xde, 0x65, 0xdc, 0x6b, 0x3c, 0x61,
+0x62, 0x69, 0x32, 0xdb, 0xa4, 0xc4, 0xa4, 0xc5, 0xe4, 0xbe, 0x29, 0xcd, 0x94,
+0x6b, 0x9a, 0x66, 0xba, 0xd1, 0xb4, 0xd3, 0x74, 0xcc, 0xcc, 0xc8, 0x2c, 0xdc,
+0xac, 0xd8, 0xac, 0xc9, 0xec, 0x8e, 0x39, 0xd5, 0x9c, 0x6b, 0x9e, 0x61, 0xbe,
+0xd9, 0xbc, 0xdb, 0xfc, 0x8d, 0x85, 0xa5, 0x45, 0x9c, 0xc5, 0x4a, 0x8b, 0x36,
+0x8b, 0xc7, 0x96, 0xda, 0x96, 0x7c, 0xcb, 0x05, 0x96, 0x4d, 0x96, 0xf7, 0xac,
+0x98, 0x56, 0x3e, 0x56, 0x79, 0x56, 0xf5, 0x56, 0xd7, 0xac, 0x49, 0xd6, 0x5c,
+0xeb, 0x2c, 0xeb, 0x6d, 0xd6, 0x57, 0x6c, 0x50, 0x1b, 0x57, 0x9b, 0x0c, 0x9b,
+0x3a, 0x9b, 0xcb, 0xb6, 0xa8, 0xad, 0x9b, 0xad, 0xc4, 0x76, 0x9b, 0x6d, 0xdf,
+0x14, 0xe2, 0x14, 0x8f, 0x29, 0xd2, 0x29, 0xf5, 0x53, 0x6e, 0xda, 0x31, 0xec,
+0xfc, 0xec, 0x0a, 0xec, 0x9a, 0xec, 0x06, 0xed, 0x39, 0xf6, 0x61, 0xf6, 0x25,
+0xf6, 0x6d, 0xf6, 0xcf, 0x1d, 0xcc, 0x1c, 0x12, 0x1d, 0xd6, 0x3b, 0x74, 0x3b,
+0x7c, 0x72, 0x74, 0x75, 0xcc, 0x76, 0x6c, 0x70, 0xbc, 0xeb, 0xa4, 0xe1, 0x34,
+0xc3, 0xa9, 0xc4, 0xa9, 0xc3, 0xe9, 0x57, 0x67, 0x1b, 0x67, 0xa1, 0x73, 0x9d,
+0xf3, 0x35, 0x17, 0xa6, 0x4b, 0x90, 0xcb, 0x12, 0x97, 0x76, 0x97, 0x17, 0x53,
+0x6d, 0xa7, 0x8a, 0xa7, 0x6e, 0x9f, 0x7a, 0xcb, 0x95, 0xe5, 0x1a, 0xee, 0xba,
+0xd2, 0xb5, 0xd3, 0xf5, 0xa3, 0x9b, 0xbb, 0x9b, 0xdc, 0xad, 0xd9, 0x6d, 0xd4,
+0xdd, 0xcc, 0x3d, 0xc5, 0x7d, 0xab, 0xfb, 0x4d, 0x2e, 0x9b, 0x1b, 0xc9, 0x5d,
+0xc3, 0x3d, 0xef, 0x41, 0xf4, 0xf0, 0xf7, 0x58, 0xe2, 0x71, 0xcc, 0xe3, 0x9d,
+0xa7, 0x9b, 0xa7, 0xc2, 0xf3, 0x90, 0xe7, 0x2f, 0x5e, 0x76, 0x5e, 0x59, 0x5e,
+0xfb, 0xbd, 0x1e, 0x4f, 0xb3, 0x9c, 0x26, 0x9e, 0xd6, 0x30, 0x6d, 0xc8, 0xdb,
+0xc4, 0x5b, 0xe0, 0xbd, 0xcb, 0x7b, 0x60, 0x3a, 0x3e, 0x3d, 0x65, 0xfa, 0xce,
+0xe9, 0x03, 0x3e, 0xc6, 0x3e, 0x02, 0x9f, 0x7a, 0x9f, 0x87, 0xbe, 0xa6, 0xbe,
+0x22, 0xdf, 0x3d, 0xbe, 0x23, 0x7e, 0xd6, 0x7e, 0x99, 0x7e, 0x07, 0xfc, 0x9e,
+0xfb, 0x3b, 0xfa, 0xcb, 0xfd, 0x8f, 0xf8, 0xbf, 0xe1, 0x79, 0xf2, 0x16, 0xf1,
+0x4e, 0x05, 0x60, 0x01, 0xc1, 0x01, 0xe5, 0x01, 0xbd, 0x81, 0x1a, 0x81, 0xb3,
+0x03, 0x6b, 0x03, 0x1f, 0x04, 0x99, 0x04, 0xa5, 0x07, 0x35, 0x05, 0x8d, 0x05,
+0xbb, 0x06, 0x2f, 0x0c, 0x3e, 0x15, 0x42, 0x0c, 0x09, 0x0d, 0x59, 0x1f, 0x72,
+0x93, 0x6f, 0xc0, 0x17, 0xf2, 0x1b, 0xf9, 0x63, 0x33, 0xdc, 0x67, 0x2c, 0x9a,
+0xd1, 0x15, 0xca, 0x08, 0x9d, 0x15, 0x5a, 0x1b, 0xfa, 0x30, 0xcc, 0x26, 0x4c,
+0x1e, 0xd6, 0x11, 0x8e, 0x86, 0xcf, 0x08, 0xdf, 0x10, 0x7e, 0x6f, 0xa6, 0xf9,
+0x4c, 0xe9, 0xcc, 0xb6, 0x08, 0x88, 0xe0, 0x47, 0x6c, 0x88, 0xb8, 0x1f, 0x69,
+0x19, 0x99, 0x17, 0xf9, 0x7d, 0x14, 0x29, 0x2a, 0x32, 0xaa, 0x2e, 0xea, 0x51,
+0xb4, 0x53, 0x74, 0x71, 0x74, 0xf7, 0x2c, 0xd6, 0xac, 0xe4, 0x59, 0xfb, 0x67,
+0xbd, 0x8e, 0xf1, 0x8f, 0xa9, 0x8c, 0xb9, 0x3b, 0xdb, 0x6a, 0xb6, 0x72, 0x76,
+0x67, 0xac, 0x6a, 0x6c, 0x52, 0x6c, 0x63, 0xec, 0x9b, 0xb8, 0x80, 0xb8, 0xaa,
+0xb8, 0x81, 0x78, 0x87, 0xf8, 0x45, 0xf1, 0x97, 0x12, 0x74, 0x13, 0x24, 0x09,
+0xed, 0x89, 0xe4, 0xc4, 0xd8, 0xc4, 0x3d, 0x89, 0xe3, 0x73, 0x02, 0xe7, 0x6c,
+0x9a, 0x33, 0x9c, 0xe4, 0x9a, 0x54, 0x96, 0x74, 0x63, 0xae, 0xe5, 0xdc, 0xa2,
+0xb9, 0x17, 0xe6, 0xe9, 0xce, 0xcb, 0x9e, 0x77, 0x3c, 0x59, 0x35, 0x59, 0x90,
+0x7c, 0x38, 0x85, 0x98, 0x12, 0x97, 0xb2, 0x3f, 0xe5, 0x83, 0x20, 0x42, 0x50,
+0x2f, 0x18, 0x4f, 0xe5, 0xa7, 0x6e, 0x4d, 0x1d, 0x13, 0xf2, 0x84, 0x9b, 0x85,
+0x4f, 0x45, 0xbe, 0xa2, 0x8d, 0xa2, 0x51, 0xb1, 0xb7, 0xb8, 0x4a, 0x3c, 0x92,
+0xe6, 0x9d, 0x56, 0x95, 0xf6, 0x38, 0xdd, 0x3b, 0x7d, 0x43, 0xfa, 0x68, 0x86,
+0x4f, 0x46, 0x75, 0xc6, 0x33, 0x09, 0x4f, 0x52, 0x2b, 0x79, 0x91, 0x19, 0x92,
+0xb9, 0x23, 0xf3, 0x4d, 0x56, 0x44, 0xd6, 0xde, 0xac, 0xcf, 0xd9, 0x71, 0xd9,
+0x2d, 0x39, 0x94, 0x9c, 0x94, 0x9c, 0xa3, 0x52, 0x0d, 0x69, 0x96, 0xb4, 0x2b,
+0xd7, 0x30, 0xb7, 0x28, 0xb7, 0x4f, 0x66, 0x2b, 0x2b, 0x93, 0x0d, 0xe4, 0x79,
+0xe6, 0x6d, 0xca, 0x1b, 0x93, 0x87, 0xca, 0xf7, 0xe4, 0x23, 0xf9, 0x73, 0xf3,
+0xdb, 0x15, 0x6c, 0x85, 0x4c, 0xd1, 0xa3, 0xb4, 0x52, 0xae, 0x50, 0x0e, 0x16,
+0x4c, 0x2f, 0xa8, 0x2b, 0x78, 0x5b, 0x18, 0x5b, 0x78, 0xb8, 0x48, 0xbd, 0x48,
+0x5a, 0xd4, 0x33, 0xdf, 0x66, 0xfe, 0xea, 0xf9, 0x23, 0x0b, 0x82, 0x16, 0x7c,
+0xbd, 0x90, 0xb0, 0x50, 0xb8, 0xb0, 0xb3, 0xd8, 0xb8, 0x78, 0x59, 0xf1, 0xe0,
+0x22, 0xbf, 0x45, 0xbb, 0x16, 0x23, 0x8b, 0x53, 0x17, 0x77, 0x2e, 0x31, 0x5d,
+0x52, 0xba, 0x64, 0x78, 0x69, 0xf0, 0xd2, 0x7d, 0xcb, 0x68, 0xcb, 0xb2, 0x96,
+0xfd, 0x50, 0xe2, 0x58, 0x52, 0x55, 0xf2, 0x6a, 0x79, 0xdc, 0xf2, 0x8e, 0x52,
+0x83, 0xd2, 0xa5, 0xa5, 0x43, 0x2b, 0x82, 0x57, 0x34, 0x95, 0xa9, 0x94, 0xc9,
+0xcb, 0x6e, 0xae, 0xf4, 0x5a, 0xb9, 0x63, 0x15, 0x61, 0x95, 0x64, 0x55, 0xef,
+0x6a, 0x97, 0xd5, 0x5b, 0x56, 0x7f, 0x2a, 0x17, 0x95, 0x5f, 0xac, 0x70, 0xac,
+0xa8, 0xae, 0xf8, 0xb0, 0x46, 0xb8, 0xe6, 0xe2, 0x57, 0x4e, 0x5f, 0xd5, 0x7c,
+0xf5, 0x79, 0x6d, 0xda, 0xda, 0xde, 0x4a, 0xb7, 0xca, 0xed, 0xeb, 0x48, 0xeb,
+0xa4, 0xeb, 0x6e, 0xac, 0xf7, 0x59, 0xbf, 0xaf, 0x4a, 0xbd, 0x6a, 0x41, 0xd5,
+0xd0, 0x86, 0xf0, 0x0d, 0xad, 0x1b, 0xf1, 0x8d, 0xe5, 0x1b, 0x5f, 0x6d, 0x4a,
+0xde, 0x74, 0xa1, 0x7a, 0x6a, 0xf5, 0x8e, 0xcd, 0xb4, 0xcd, 0xca, 0xcd, 0x03,
+0x35, 0x61, 0x35, 0xed, 0x5b, 0xcc, 0xb6, 0xac, 0xdb, 0xf2, 0xa1, 0x36, 0xa3,
+0xf6, 0x7a, 0x9d, 0x7f, 0x5d, 0xcb, 0x56, 0xfd, 0xad, 0xab, 0xb7, 0xbe, 0xd9,
+0x26, 0xda, 0xd6, 0xbf, 0xdd, 0x77, 0x7b, 0xf3, 0x0e, 0x83, 0x1d, 0x15, 0x3b,
+0xde, 0xef, 0x94, 0xec, 0xbc, 0xb5, 0x2b, 0x78, 0x57, 0x6b, 0xbd, 0x45, 0x7d,
+0xf5, 0x6e, 0xd2, 0xee, 0x82, 0xdd, 0x8f, 0x1a, 0x62, 0x1b, 0xba, 0xbf, 0xe6,
+0x7e, 0xdd, 0xb8, 0x47, 0x77, 0x4f, 0xc5, 0x9e, 0x8f, 0x7b, 0xa5, 0x7b, 0x07,
+0xf6, 0x45, 0xef, 0xeb, 0x6a, 0x74, 0x6f, 0x6c, 0xdc, 0xaf, 0xbf, 0xbf, 0xb2,
+0x09, 0x6d, 0x52, 0x36, 0x8d, 0x1e, 0x48, 0x3a, 0x70, 0xe5, 0x9b, 0x80, 0x6f,
+0xda, 0x9b, 0xed, 0x9a, 0x77, 0xb5, 0x70, 0x5a, 0x2a, 0x0e, 0xc2, 0x41, 0xe5,
+0xc1, 0x27, 0xdf, 0xa6, 0x7c, 0x7b, 0xe3, 0x50, 0xe8, 0xa1, 0xce, 0xc3, 0xdc,
+0xc3, 0xcd, 0xdf, 0x99, 0x7f, 0xb7, 0xf5, 0x08, 0xeb, 0x48, 0x79, 0x2b, 0xd2,
+0x3a, 0xbf, 0x75, 0xac, 0x2d, 0xa3, 0x6d, 0xa0, 0x3d, 0xa1, 0xbd, 0xef, 0xe8,
+0x8c, 0xa3, 0x9d, 0x1d, 0x5e, 0x1d, 0x47, 0xbe, 0xb7, 0xff, 0x7e, 0xef, 0x31,
+0xe3, 0x63, 0x75, 0xc7, 0x35, 0x8f, 0x57, 0x9e, 0xa0, 0x9d, 0x28, 0x3d, 0xf1,
+0xf9, 0xe4, 0x82, 0x93, 0xe3, 0xa7, 0x64, 0xa7, 0x9e, 0x9d, 0x4e, 0x3f, 0x3d,
+0xd4, 0x99, 0xdc, 0x79, 0xf7, 0x4c, 0xfc, 0x99, 0x6b, 0x5d, 0x51, 0x5d, 0xbd,
+0x67, 0x43, 0xcf, 0x9e, 0x3f, 0x17, 0x74, 0xee, 0x4c, 0xb7, 0x5f, 0xf7, 0xc9,
+0xf3, 0xde, 0xe7, 0x8f, 0x5d, 0xf0, 0xbc, 0x70, 0xf4, 0x22, 0xf7, 0x62, 0xdb,
+0x25, 0xb7, 0x4b, 0xad, 0x3d, 0xae, 0x3d, 0x47, 0x7e, 0x70, 0xfd, 0xe1, 0x48,
+0xaf, 0x5b, 0x6f, 0xeb, 0x65, 0xf7, 0xcb, 0xed, 0x57, 0x3c, 0xae, 0x74, 0xf4,
+0x4d, 0xeb, 0x3b, 0xd1, 0xef, 0xd3, 0x7f, 0xfa, 0x6a, 0xc0, 0xd5, 0x73, 0xd7,
+0xf8, 0xd7, 0x2e, 0x5d, 0x9f, 0x79, 0xbd, 0xef, 0xc6, 0xec, 0x1b, 0xb7, 0x6e,
+0x26, 0xdd, 0x1c, 0xb8, 0x25, 0xba, 0xf5, 0xf8, 0x76, 0xf6, 0xed, 0x17, 0x77,
+0x0a, 0xee, 0x4c, 0xdc, 0x5d, 0x7a, 0x8f, 0x78, 0xaf, 0xfc, 0xbe, 0xda, 0xfd,
+0xea, 0x07, 0xfa, 0x0f, 0xea, 0x7f, 0xb4, 0xfe, 0xb1, 0x65, 0xc0, 0x6d, 0xe0,
+0xf8, 0x60, 0xc0, 0x60, 0xcf, 0xc3, 0x59, 0x0f, 0xef, 0x0e, 0x09, 0x87, 0x9e,
+0xfe, 0x94, 0xff, 0xd3, 0x87, 0xe1, 0xd2, 0x47, 0xcc, 0x47, 0xd5, 0x23, 0x46,
+0x23, 0x8d, 0x8f, 0x9d, 0x1f, 0x1f, 0x1b, 0x0d, 0x1a, 0xbd, 0xf2, 0x64, 0xce,
+0x93, 0xe1, 0xa7, 0xb2, 0xa7, 0x13, 0xcf, 0xca, 0x7e, 0x56, 0xff, 0x79, 0xeb,
+0x73, 0xab, 0xe7, 0xdf, 0xfd, 0xe2, 0xfb, 0x4b, 0xcf, 0x58, 0xfc, 0xd8, 0xf0,
+0x0b, 0xf9, 0x8b, 0xcf, 0xbf, 0xae, 0x79, 0xa9, 0xf3, 0x72, 0xef, 0xab, 0xa9,
+0xaf, 0x3a, 0xc7, 0x23, 0xc7, 0x1f, 0xbc, 0xce, 0x79, 0x3d, 0xf1, 0xa6, 0xfc,
+0xad, 0xce, 0xdb, 0x7d, 0xef, 0xb8, 0xef, 0xba, 0xdf, 0xc7, 0xbd, 0x1f, 0x99,
+0x28, 0xfc, 0x40, 0xfe, 0x50, 0xf3, 0xd1, 0xfa, 0x63, 0xc7, 0xa7, 0xd0, 0x4f,
+0xf7, 0x3e, 0xe7, 0x7c, 0xfe, 0xfc, 0x2f, 0xf7, 0x84, 0xf3, 0xfb, 0x25, 0xd2,
+0x9f, 0x33, 0x00, 0x00, 0x00, 0x04, 0x67, 0x41, 0x4d, 0x41, 0x00, 0x00, 0xb1,
+0x8e, 0x7c, 0xfb, 0x51, 0x93, 0x00, 0x00, 0x00, 0x20, 0x63, 0x48, 0x52, 0x4d,
+0x00, 0x00, 0x7a, 0x25, 0x00, 0x00, 0x80, 0x83, 0x00, 0x00, 0xf9, 0xff, 0x00,
+0x00, 0x80, 0xe9, 0x00, 0x00, 0x75, 0x30, 0x00, 0x00, 0xea, 0x60, 0x00, 0x00,
+0x3a, 0x98, 0x00, 0x00, 0x17, 0x6f, 0x92, 0x5f, 0xc5, 0x46, 0x00, 0x00, 0x14,
+0x3d, 0x49, 0x44, 0x41, 0x54, 0x78, 0xda, 0xec, 0x5d, 0x4d, 0x68, 0x23, 0xe7,
+0x96, 0x3d, 0x65, 0x79, 0x64, 0xac, 0x91, 0xb0, 0xa0, 0x8c, 0x9b, 0x32, 0x32,
+0x2e, 0xc8, 0xa3, 0x84, 0x83, 0x1b, 0x6b, 0xa8, 0x95, 0x1b, 0x06, 0xd7, 0x24,
+0xd0, 0x6f, 0x23, 0xd3, 0x9a, 0x34, 0xe4, 0xe1, 0xce, 0xc2, 0xca, 0x62, 0xdc,
+0x64, 0x15, 0xe7, 0xf9, 0xad, 0x1e, 0x6f, 0xb0, 0x1a, 0x86, 0xb7, 0x7a, 0x4e,
+0x34, 0xcb, 0xee, 0x59, 0xb4, 0x7a, 0xf1, 0xdc, 0xd0, 0x90, 0xc4, 0xc1, 0xde,
+0x4c, 0xc0, 0x93, 0xf2, 0xa6, 0x0d, 0x43, 0x44, 0x64, 0x6c, 0xd2, 0xa8, 0x92,
+0x26, 0x65, 0x64, 0xa4, 0xc4, 0xa8, 0x40, 0x8d, 0x14, 0x09, 0x3b, 0xf6, 0xd4,
+0x2c, 0x54, 0x25, 0x97, 0xa4, 0xaa, 0xd2, 0x8f, 0x25, 0x59, 0x3f, 0x75, 0xc1,
+0x74, 0xb7, 0x54, 0x72, 0xdb, 0x3a, 0xe7, 0x9e, 0x7b, 0xee, 0xfd, 0xbe, 0xaf,
+0x44, 0xc8, 0xb2, 0x0c, 0x2b, 0x06, 0x37, 0x86, 0xad, 0xb7, 0xa0, 0x3d, 0xf1,
+0xea, 0xd5, 0x2b, 0x1b, 0x80, 0xff, 0x7b, 0xfb, 0xed, 0xb7, 0xab, 0x32, 0xcc,
+0x28, 0xe9, 0x08, 0x82, 0x30, 0xfd, 0x9e, 0xed, 0x48, 0xd6, 0x21, 0x0b, 0xaa,
+0xf6, 0xc4, 0xcc, 0xcc, 0xcc, 0xe5, 0xcc, 0xcc, 0x8c, 0xfc, 0xed, 0xb7, 0xdf,
+0xae, 0xcb, 0xb2, 0x0c, 0xed, 0x97, 0x19, 0xc0, 0x9d, 0x56, 0x64, 0x4b, 0x01,
+0xda, 0x14, 0xd1, 0x68, 0x74, 0x0e, 0x40, 0x04, 0x40, 0xb0, 0xd1, 0xd7, 0xca,
+0xb2, 0x5c, 0x53, 0x0d, 0x2c, 0x05, 0xe8, 0x6e, 0xf0, 0xd7, 0x01, 0xc4, 0x00,
+0x84, 0x59, 0x96, 0x3d, 0xb0, 0x3c, 0xc0, 0xe0, 0x00, 0x3f, 0x0d, 0x60, 0x0b,
+0x80, 0x0f, 0xc0, 0x2a, 0xcb, 0xb2, 0xcf, 0x9a, 0xfd, 0x5e, 0x95, 0x2a, 0xd0,
+0xae, 0xd2, 0x40, 0x58, 0x5d, 0x40, 0xcb, 0xc0, 0x5f, 0x06, 0x10, 0x06, 0xe0,
+0x06, 0x10, 0x61, 0x59, 0xf6, 0x43, 0x93, 0x6b, 0x17, 0x94, 0xd2, 0x90, 0x61,
+0x59, 0xf6, 0x13, 0x53, 0x80, 0x14, 0x12, 0x58, 0x04, 0xe8, 0x5e, 0xe0, 0xc7,
+0x94, 0x5a, 0x1f, 0x50, 0x1e, 0xda, 0x62, 0x59, 0xf6, 0x5f, 0x4d, 0x48, 0xb2,
+0xaa, 0x28, 0x84, 0x29, 0x49, 0x3a, 0x45, 0x00, 0xab, 0x04, 0x5c, 0xdf, 0xe8,
+0x6d, 0x01, 0xa0, 0x95, 0x87, 0x62, 0x95, 0xa6, 0x4f, 0x21, 0x48, 0x50, 0x01,
+0x5e, 0xbd, 0xae, 0x2e, 0xf0, 0xdb, 0x2d, 0xff, 0x96, 0x02, 0xd4, 0x00, 0xd7,
+0xcc, 0xc0, 0x29, 0xd9, 0x1c, 0xd1, 0x3c, 0x24, 0x02, 0xf0, 0xb1, 0x2c, 0xfb,
+0x46, 0x03, 0xfc, 0xaa, 0xf2, 0xe5, 0xd6, 0x5c, 0x67, 0xa8, 0x10, 0x96, 0x09,
+0xec, 0x1e, 0xf0, 0x3f, 0x06, 0x90, 0x01, 0x70, 0x60, 0xf0, 0xfc, 0xd3, 0x8a,
+0x4c, 0xcf, 0x00, 0x08, 0x68, 0xc0, 0x5f, 0xd7, 0x01, 0x5e, 0x57, 0x21, 0x2c,
+0x02, 0x74, 0x67, 0x4d, 0x0f, 0x69, 0xe4, 0xba, 0xaa, 0xde, 0x27, 0x12, 0x89,
+0xc0, 0xd4, 0xd4, 0x94, 0xf6, 0x29, 0x8e, 0x65, 0xd9, 0x03, 0xc5, 0xdc, 0x45,
+0xf4, 0x5e, 0xab, 0x80, 0xcf, 0xa9, 0x24, 0xb1, 0x08, 0xd0, 0xbd, 0x11, 0x01,
+0x20, 0x56, 0x02, 0x15, 0x8d, 0x46, 0xc7, 0x2e, 0x2e, 0x2e, 0x78, 0x51, 0x14,
+0x7d, 0x6e, 0x77, 0x59, 0x62, 0x07, 0x01, 0x88, 0x3a, 0xaa, 0xd0, 0xf5, 0xe0,
+0x5b, 0x04, 0xd0, 0x6f, 0xcf, 0x02, 0x8a, 0x02, 0x54, 0x81, 0x2f, 0x08, 0x82,
+0xcf, 0x66, 0xb3, 0x61, 0x7c, 0x7c, 0x5c, 0x7d, 0x6a, 0x55, 0x01, 0x37, 0x66,
+0x90, 0xf5, 0x55, 0xe5, 0xa1, 0xdb, 0xc2, 0x9a, 0x04, 0x56, 0x67, 0x3f, 0x14,
+0x67, 0x5f, 0x8a, 0xf3, 0xf3, 0xf3, 0xb0, 0x20, 0x08, 0xbe, 0x42, 0xa1, 0x00,
+0x8d, 0xf4, 0x47, 0x14, 0x70, 0x63, 0xd9, 0x6c, 0x96, 0x16, 0x45, 0x11, 0x17,
+0x17, 0x17, 0x7a, 0xe0, 0x73, 0x2c, 0xcb, 0x1e, 0x77, 0xeb, 0x2f, 0x6c, 0x29,
+0xc0, 0x55, 0x96, 0xaf, 0x2b, 0x59, 0x9c, 0xd1, 0xba, 0xff, 0xfd, 0xfd, 0xfd,
+0xa7, 0x3f, 0xfe, 0xf8, 0x63, 0xb0, 0x50, 0x28, 0x60, 0x62, 0x62, 0x02, 0x0e,
+0x87, 0x43, 0x25, 0x48, 0x26, 0x9f, 0xcf, 0x47, 0x12, 0x89, 0x04, 0x72, 0xb9,
+0x1c, 0xa6, 0xa7, 0xa7, 0x31, 0x3c, 0x3c, 0xac, 0x07, 0xbe, 0x35, 0x0a, 0xee,
+0x11, 0xe3, 0xb7, 0x5a, 0x99, 0xfd, 0xd1, 0x68, 0xf4, 0xe9, 0x4f, 0x3f, 0xfd,
+0x14, 0x2c, 0x14, 0x0a, 0xb0, 0xd9, 0x6c, 0xa0, 0x28, 0x0a, 0x00, 0xc4, 0xdf,
+0x7e, 0xfb, 0x0d, 0x3f, 0xff, 0xfc, 0xf3, 0xea, 0xe9, 0xe9, 0x29, 0x00, 0x80,
+0x24, 0x49, 0x6d, 0x59, 0x28, 0x33, 0x86, 0xdd, 0xfe, 0xbb, 0x5b, 0x04, 0x00,
+0xf0, 0xeb, 0xaf, 0xbf, 0x86, 0x73, 0xb9, 0x9c, 0xfb, 0xd6, 0xad, 0x5b, 0x25,
+0x02, 0x44, 0xa3, 0xd1, 0xcf, 0x44, 0x51, 0x0c, 0xe6, 0x72, 0x39, 0x00, 0x80,
+0xc7, 0xe3, 0xc1, 0xf0, 0xf0, 0x70, 0xe6, 0xe2, 0xe2, 0x02, 0x3f, 0xfc, 0xf0,
+0x43, 0xa0, 0x50, 0x28, 0x00, 0x00, 0x46, 0x47, 0x47, 0x41, 0xd3, 0x55, 0xe5,
+0x3f, 0xd8, 0x0b, 0xe0, 0x03, 0xd6, 0x20, 0x08, 0xd1, 0x68, 0x74, 0x3a, 0x91,
+0x48, 0x88, 0x36, 0x9b, 0x0d, 0x93, 0x93, 0x93, 0x50, 0x7a, 0xf7, 0x40, 0x22,
+0x91, 0x88, 0xa8, 0x19, 0xee, 0x74, 0x3a, 0xe1, 0xf5, 0x7a, 0x91, 0xcd, 0x66,
+0xf1, 0xfa, 0xf5, 0x6b, 0x5c, 0x5e, 0x5e, 0x02, 0x00, 0x6c, 0x36, 0x1b, 0x66,
+0x67, 0x67, 0x2b, 0xa5, 0x3f, 0x78, 0x9d, 0x45, 0x20, 0xcb, 0x04, 0x76, 0x3e,
+0x42, 0x92, 0x24, 0xa9, 0x7f, 0xe7, 0x01, 0x04, 0xd2, 0xe9, 0x74, 0x09, 0x7c,
+0x00, 0x98, 0x9a, 0x9a, 0x42, 0x32, 0x99, 0x84, 0x20, 0x08, 0x25, 0xf0, 0x01,
+0x80, 0x61, 0x98, 0x9e, 0x06, 0x7f, 0xe0, 0x4b, 0x40, 0x34, 0x1a, 0x9d, 0xce,
+0xe7, 0xf3, 0xc1, 0xcb, 0xcb, 0x4b, 0xd8, 0x6c, 0x36, 0xa8, 0xc6, 0xee, 0xe4,
+0xe4, 0xa4, 0x74, 0xcd, 0xc4, 0xc4, 0x04, 0x92, 0xc9, 0x24, 0xde, 0xbc, 0x29,
+0xef, 0xe2, 0xa6, 0xa7, 0xa7, 0x55, 0x43, 0xa8, 0x46, 0xb8, 0xd7, 0xc0, 0xb7,
+0x3c, 0x00, 0x10, 0x54, 0xb3, 0xdf, 0xe1, 0x70, 0xe0, 0xe2, 0xe2, 0x22, 0x20,
+0x8a, 0x62, 0x59, 0x96, 0x4b, 0x92, 0x54, 0xf6, 0x6f, 0x03, 0xd3, 0x17, 0xa9,
+0xb5, 0xac, 0x6b, 0x95, 0x80, 0xee, 0x8c, 0xd5, 0x6c, 0x36, 0x5b, 0xfa, 0x47,
+0x2a, 0x95, 0x82, 0x6a, 0xee, 0xd4, 0xa8, 0x04, 0x5f, 0xc7, 0xf4, 0x35, 0xb4,
+0xb2, 0x67, 0x11, 0xa0, 0x7b, 0xe4, 0xff, 0xde, 0xd9, 0xd9, 0x99, 0x5b, 0x05,
+0x3c, 0x9b, 0xcd, 0x42, 0x5b, 0xf7, 0xf5, 0xc2, 0x66, 0xb3, 0x81, 0x61, 0x18,
+0xed, 0x43, 0x5b, 0xbd, 0x0c, 0xfe, 0xa0, 0x2b, 0x40, 0x20, 0x93, 0xc9, 0x94,
+0x65, 0x7f, 0x3d, 0xe0, 0x6b, 0x4c, 0x5f, 0x0c, 0x5d, 0xb6, 0xb2, 0x67, 0x11,
+0xa0, 0xb1, 0xe0, 0xb4, 0xf2, 0x5f, 0x2b, 0x3c, 0x1e, 0x8f, 0xd6, 0xf4, 0xc5,
+0xd0, 0xa5, 0x8b, 0x3b, 0x16, 0x01, 0xea, 0x74, 0xff, 0x00, 0x68, 0x75, 0xc8,
+0x53, 0x2b, 0x26, 0x26, 0x26, 0xb4, 0xa6, 0xaf, 0x6f, 0xc0, 0x1f, 0x64, 0x05,
+0xe0, 0xf2, 0xf9, 0x7c, 0x95, 0xc1, 0xd3, 0x8b, 0xb1, 0xb1, 0x31, 0xed, 0x02,
+0x50, 0x06, 0x5d, 0xbc, 0xb2, 0x67, 0x11, 0xa0, 0x41, 0x02, 0xd4, 0x8a, 0x0a,
+0xc7, 0x9f, 0x41, 0x97, 0xaf, 0xec, 0x59, 0x04, 0xa8, 0x3f, 0x7c, 0x95, 0xed,
+0x9e, 0x9e, 0xe9, 0x7b, 0xeb, 0xad, 0xb7, 0x54, 0xd3, 0xa7, 0x82, 0x7f, 0xd0,
+0x6f, 0x6f, 0xc4, 0xc0, 0x12, 0xc0, 0x4c, 0x01, 0x54, 0xc7, 0x3f, 0x32, 0x32,
+0x52, 0x52, 0x8c, 0x7e, 0x04, 0x7f, 0x20, 0x09, 0xa0, 0xec, 0xfa, 0x81, 0x99,
+0x01, 0xa4, 0x69, 0x5a, 0xeb, 0xf8, 0x83, 0xfd, 0x0a, 0x7e, 0x5f, 0x12, 0x80,
+0x20, 0x88, 0x69, 0x82, 0x20, 0xc6, 0x4c, 0x2e, 0xa1, 0xcd, 0xb2, 0x9f, 0xa2,
+0x28, 0x68, 0xf6, 0xfc, 0x05, 0x7b, 0x71, 0xbe, 0x3f, 0xe8, 0x0a, 0x20, 0x02,
+0xc8, 0x10, 0x04, 0xf1, 0xd4, 0x80, 0x08, 0x86, 0xf2, 0x3f, 0x36, 0x36, 0xa6,
+0x2e, 0x09, 0x0f, 0x04, 0xf8, 0xfd, 0x4a, 0x80, 0x18, 0xbb, 0x42, 0x61, 0x7a,
+0x61, 0x2c, 0x08, 0x40, 0x24, 0x08, 0xe2, 0xe3, 0x7a, 0x0c, 0xa0, 0xdd, 0x6e,
+0xd7, 0x3a, 0xfe, 0xf0, 0x20, 0x80, 0xdf, 0xaf, 0x04, 0x08, 0xc7, 0xb7, 0x25,
+0xfc, 0x7e, 0xe3, 0x77, 0xf0, 0x3f, 0x66, 0xdc, 0x4e, 0xca, 0x1e, 0x26, 0x08,
+0xe2, 0x1b, 0x82, 0x20, 0xa6, 0xcd, 0x4a, 0x00, 0x4d, 0xd3, 0xaa, 0xe3, 0xef,
+0xd9, 0x95, 0x3d, 0x8b, 0x00, 0x00, 0x64, 0x59, 0x7e, 0x96, 0x4b, 0x9d, 0x8b,
+0xf1, 0xed, 0x34, 0x26, 0x59, 0x17, 0xee, 0x6f, 0xce, 0x80, 0xf1, 0x93, 0x1c,
+0x80, 0x18, 0x41, 0x10, 0xf7, 0xa0, 0x33, 0x01, 0xa4, 0x28, 0x0a, 0x2e, 0x97,
+0x4b, 0x05, 0xff, 0x43, 0x0c, 0x50, 0xf4, 0xe5, 0x96, 0x30, 0x82, 0x20, 0xee,
+0x39, 0x29, 0xfb, 0xd6, 0xfd, 0xcd, 0x19, 0x8c, 0xb8, 0x8a, 0x8b, 0x37, 0x22,
+0x9f, 0x01, 0x1f, 0x12, 0xf1, 0xee, 0x3f, 0xdf, 0xc5, 0xdd, 0xbb, 0x77, 0x4b,
+0x2e, 0x5f, 0xdd, 0xee, 0x85, 0x2e, 0x3b, 0xb3, 0x67, 0x29, 0xc0, 0xf5, 0x54,
+0xe0, 0xab, 0x5c, 0xea, 0x9c, 0x3f, 0x7a, 0x7e, 0xb5, 0xbc, 0x4b, 0x73, 0x6e,
+0xdc, 0xdf, 0x9c, 0xc1, 0xff, 0xbe, 0xe6, 0xb1, 0xb1, 0xb1, 0x81, 0x44, 0x22,
+0x01, 0x9b, 0xcd, 0xa6, 0xd6, 0xfd, 0x18, 0xfa, 0x60, 0x65, 0xcf, 0x52, 0x80,
+0x72, 0x15, 0x58, 0xb0, 0x3b, 0x6d, 0x7c, 0x90, 0xf7, 0x55, 0x3d, 0xf7, 0x72,
+0x23, 0x01, 0x2d, 0x39, 0xa0, 0x1c, 0xf0, 0xa8, 0xb8, 0x8c, 0x97, 0x65, 0xf9,
+0x51, 0xbf, 0x13, 0xa0, 0x6f, 0xb7, 0x84, 0xc9, 0xb2, 0xbc, 0x47, 0x10, 0x04,
+0x1f, 0xdf, 0x4e, 0x73, 0xde, 0xc5, 0xf2, 0x3d, 0xfb, 0x34, 0xe7, 0xc6, 0x51,
+0xf4, 0x14, 0x58, 0x53, 0x1e, 0x88, 0xc0, 0x3d, 0xcf, 0x30, 0xdc, 0x7c, 0xb0,
+0xb8, 0xd9, 0xe3, 0x24, 0x26, 0xe1, 0xc5, 0x27, 0xfb, 0x00, 0x60, 0x11, 0xa0,
+0xc7, 0x23, 0x72, 0xf4, 0xfc, 0xb4, 0x8a, 0x00, 0x55, 0x41, 0x02, 0x24, 0xed,
+0x82, 0x97, 0x9b, 0x1c, 0xb8, 0x12, 0xd0, 0xd7, 0xa3, 0x60, 0x59, 0x96, 0x9f,
+0x49, 0x42, 0x21, 0x93, 0x4d, 0x9e, 0xc1, 0x8a, 0x01, 0x24, 0x80, 0x12, 0x5b,
+0x22, 0x9f, 0xb1, 0x90, 0x1e, 0x60, 0x02, 0xc4, 0x24, 0xa1, 0x60, 0x21, 0x3d,
+0xc8, 0x04, 0xc8, 0xa6, 0xac, 0x12, 0x30, 0xc8, 0x04, 0x70, 0x5b, 0x30, 0x0f,
+0x36, 0x01, 0x38, 0x92, 0x71, 0x34, 0xf4, 0x02, 0x87, 0xdb, 0x0e, 0x14, 0xef,
+0xe5, 0x67, 0x11, 0xa0, 0x0f, 0x22, 0x40, 0x73, 0x8d, 0x89, 0xc0, 0x94, 0x6f,
+0x1c, 0x00, 0xdc, 0x04, 0x41, 0x2c, 0x58, 0x04, 0xe8, 0xe1, 0x20, 0x08, 0x62,
+0xd9, 0x49, 0xd9, 0xe9, 0x49, 0xd6, 0xd5, 0xf0, 0x6b, 0x97, 0x9f, 0x2e, 0x60,
+0x74, 0xcc, 0xce, 0x13, 0x04, 0xb1, 0x6e, 0x11, 0xa0, 0x37, 0xc1, 0x1f, 0x03,
+0x10, 0xe6, 0x42, 0x74, 0xed, 0x8b, 0x49, 0x20, 0xb6, 0x25, 0x96, 0x3d, 0x74,
+0x27, 0xe8, 0xc5, 0x1a, 0xef, 0x87, 0x67, 0x8e, 0x0c, 0x11, 0x04, 0xf1, 0x9d,
+0x66, 0x39, 0xd9, 0x22, 0x40, 0xaf, 0xf4, 0xff, 0x8c, 0x9f, 0x74, 0xd7, 0x95,
+0xfd, 0x77, 0x80, 0x93, 0x13, 0x09, 0x2f, 0x23, 0xf1, 0xaa, 0x52, 0xf0, 0xef,
+0xb1, 0xfb, 0x78, 0xe7, 0xe3, 0x59, 0x1f, 0xae, 0x96, 0x93, 0x2d, 0x02, 0xf4,
+0x40, 0xf6, 0x3f, 0x25, 0x99, 0x51, 0x6e, 0x7e, 0xcd, 0xd3, 0x80, 0xe6, 0x03,
+0x2f, 0x56, 0xf7, 0x91, 0xcf, 0x54, 0xb7, 0x8c, 0x7f, 0x08, 0xdf, 0xc1, 0x47,
+0x5f, 0xde, 0x75, 0x8f, 0x8e, 0xd9, 0xb7, 0x4c, 0xb6, 0x9a, 0x59, 0x04, 0xe8,
+0x06, 0xd9, 0x57, 0xc0, 0x0f, 0xfa, 0x1f, 0x33, 0xa5, 0xbd, 0x00, 0x75, 0x85,
+0x17, 0x28, 0xdc, 0x3a, 0xc7, 0x6e, 0xf8, 0x48, 0xf7, 0x69, 0x5f, 0x80, 0xc6,
+0x5f, 0xc5, 0x25, 0x30, 0x0b, 0x54, 0x10, 0x00, 0x4f, 0x10, 0xc4, 0x9c, 0x45,
+0x80, 0xee, 0x02, 0x7f, 0x1a, 0x00, 0xdf, 0x14, 0xf8, 0x6a, 0xf8, 0x81, 0xdd,
+0xf0, 0xa1, 0xae, 0x0a, 0x14, 0xdb, 0xc3, 0x11, 0xac, 0xf1, 0x8b, 0xf0, 0xaf,
+0xb3, 0x3e, 0x85, 0x04, 0xcb, 0x16, 0x01, 0x6e, 0x1e, 0xf8, 0x05, 0x82, 0x20,
+0xbe, 0x01, 0x20, 0xce, 0x2e, 0x4d, 0xf8, 0xee, 0x6f, 0xbe, 0xdd, 0x1c, 0xf8,
+0x75, 0xa8, 0x80, 0x1a, 0x8b, 0x21, 0x16, 0x7f, 0xfc, 0xc6, 0xef, 0x1e, 0x1d,
+0xb3, 0x47, 0x08, 0x82, 0x78, 0x6a, 0x11, 0xe0, 0x06, 0x81, 0xb7, 0x3b, 0x6d,
+0x3c, 0xbb, 0x42, 0x71, 0xcb, 0xdf, 0xcc, 0xe1, 0xce, 0xda, 0xd4, 0xf5, 0xbf,
+0xb1, 0xa2, 0x02, 0x35, 0xb9, 0xc2, 0x4d, 0xe2, 0xaf, 0xe2, 0x12, 0x3c, 0x73,
+0x64, 0xb0, 0x97, 0xbb, 0x84, 0xa1, 0x1e, 0x04, 0x7e, 0x9a, 0x20, 0x88, 0x2f,
+0x55, 0xe0, 0x97, 0xb6, 0x67, 0xc1, 0xae, 0x4c, 0x36, 0x9f, 0xf5, 0x06, 0x2a,
+0x50, 0xd9, 0x11, 0x18, 0x95, 0x84, 0x8a, 0x2e, 0x61, 0xce, 0x22, 0x40, 0x7b,
+0xc1, 0x5f, 0x07, 0x10, 0x63, 0xfc, 0x64, 0xa0, 0xe5, 0xc0, 0x6b, 0x63, 0x1e,
+0xd8, 0x09, 0x45, 0xeb, 0xbe, 0xfc, 0x0f, 0xe1, 0x3b, 0x58, 0x7e, 0xba, 0xe0,
+0x56, 0x48, 0xb0, 0x6c, 0x11, 0xa0, 0x3d, 0x59, 0xff, 0x1d, 0xc9, 0x8c, 0x86,
+0xfc, 0x8f, 0x19, 0x37, 0x17, 0xa2, 0xdb, 0x03, 0xbc, 0x66, 0x2e, 0x20, 0xe5,
+0x72, 0x88, 0xf3, 0xc9, 0xfa, 0x5f, 0x12, 0xf4, 0xe2, 0x2f, 0xdf, 0xbd, 0x87,
+0x5e, 0xf3, 0x05, 0x43, 0x3d, 0x00, 0xfe, 0x32, 0x80, 0x98, 0x6a, 0xf0, 0x9a,
+0x19, 0xeb, 0x56, 0x46, 0x2a, 0x9a, 0x05, 0x3c, 0xb5, 0x55, 0x60, 0x3f, 0x22,
+0x34, 0xf4, 0x7d, 0xa7, 0x7c, 0xe3, 0xf8, 0x4b, 0xec, 0xbe, 0xea, 0x0b, 0xbe,
+0xec, 0x85, 0x79, 0xc1, 0x50, 0x97, 0x83, 0xff, 0xd4, 0xee, 0xb4, 0x45, 0xfc,
+0x8f, 0x19, 0x77, 0x4b, 0x0c, 0x5e, 0x59, 0x01, 0xaf, 0x83, 0x00, 0xcf, 0x04,
+0xc3, 0x96, 0xd0, 0x28, 0xc6, 0x69, 0x17, 0xd6, 0x78, 0x3f, 0x98, 0x05, 0x2a,
+0xa0, 0xb4, 0x8a, 0x63, 0x16, 0x01, 0x9a, 0x1b, 0xe8, 0x7c, 0x43, 0x32, 0xa3,
+0xc1, 0xfb, 0x9b, 0x33, 0x2d, 0xc9, 0xfa, 0x86, 0x63, 0x1c, 0xc0, 0x5c, 0xe3,
+0x2a, 0xa0, 0x9d, 0x17, 0xcc, 0x2f, 0x33, 0xbe, 0x6e, 0x27, 0xc1, 0x50, 0x37,
+0x82, 0x0f, 0x80, 0x9f, 0x5e, 0x18, 0xe3, 0xfc, 0x8f, 0x19, 0xb8, 0x26, 0x47,
+0xda, 0xf7, 0x9f, 0xa5, 0x01, 0xfc, 0x59, 0xf9, 0xd3, 0xc0, 0x0b, 0xbc, 0x6c,
+0x82, 0x00, 0x6a, 0x04, 0x23, 0x9c, 0x4a, 0x02, 0xb1, 0x5b, 0x3b, 0x84, 0xa1,
+0x6e, 0x04, 0x9f, 0xf1, 0x93, 0xbe, 0xdf, 0x6f, 0xfc, 0xee, 0xda, 0x46, 0x2f,
+0xfa, 0x24, 0x89, 0xff, 0x5e, 0xfb, 0xb1, 0x66, 0x96, 0xe3, 0x85, 0xc1, 0xf3,
+0x3e, 0xe0, 0x44, 0x90, 0x90, 0x88, 0xa5, 0xaf, 0x45, 0x82, 0x77, 0x3e, 0x9e,
+0x75, 0xa3, 0x4b, 0xc7, 0xc7, 0x43, 0xdd, 0x08, 0x7e, 0x5d, 0x4b, 0xb8, 0x66,
+0x89, 0x1d, 0xcf, 0xe3, 0xf3, 0x07, 0xdf, 0x43, 0xe4, 0x33, 0x60, 0x57, 0x6a,
+0xec, 0xf5, 0x5f, 0x04, 0x20, 0xa0, 0xfa, 0x5c, 0x90, 0x86, 0x04, 0xd7, 0x51,
+0x81, 0x8a, 0x36, 0xb1, 0xeb, 0x48, 0x30, 0xd4, 0x6f, 0xe0, 0x47, 0x9f, 0x24,
+0xf1, 0xc5, 0x07, 0xaf, 0x94, 0xb3, 0x80, 0x6f, 0x63, 0xdc, 0xeb, 0xa8, 0x6d,
+0x06, 0xdf, 0x37, 0x57, 0x81, 0x83, 0x8a, 0xbd, 0x02, 0x4d, 0x75, 0x96, 0x41,
+0x6f, 0x57, 0x92, 0xa0, 0x5b, 0x14, 0x20, 0x32, 0xbd, 0x30, 0x76, 0x2d, 0xf0,
+0xcf, 0xb2, 0x17, 0xd8, 0x7e, 0x18, 0x87, 0xc8, 0x67, 0xf0, 0xde, 0xdf, 0x67,
+0x6a, 0x67, 0x7e, 0x45, 0xad, 0x07, 0x09, 0x60, 0x5b, 0x9f, 0x00, 0xd2, 0x69,
+0xee, 0x5a, 0x65, 0x40, 0x4b, 0x82, 0xf9, 0x65, 0xc6, 0x0d, 0x60, 0xab, 0x5b,
+0x8c, 0xe1, 0x50, 0x17, 0x64, 0xff, 0x67, 0x24, 0x33, 0x1a, 0xb8, 0x0e, 0xf8,
+0xc9, 0x68, 0x16, 0xcf, 0x17, 0x8f, 0xe0, 0xa2, 0x46, 0xe0, 0x7f, 0xcc, 0xd4,
+0xce, 0x7a, 0xbd, 0xf0, 0x03, 0xd8, 0x05, 0x90, 0xd7, 0x27, 0x81, 0xc0, 0xa7,
+0x5a, 0xf2, 0xfb, 0x2a, 0xc6, 0x90, 0xee, 0x96, 0xee, 0x60, 0xe8, 0x86, 0xc1,
+0xbf, 0x67, 0x77, 0xda, 0x56, 0xef, 0xfe, 0xed, 0xad, 0xa6, 0x0d, 0x5f, 0xf4,
+0x49, 0x12, 0x3b, 0x0f, 0x05, 0xcc, 0xaf, 0x79, 0x70, 0xad, 0x09, 0xa1, 0x17,
+0x00, 0xa3, 0x90, 0xa0, 0x0d, 0x3e, 0xa0, 0x92, 0x04, 0x73, 0xf7, 0xa6, 0x7d,
+0x28, 0xff, 0xec, 0xe1, 0xc1, 0x22, 0x80, 0xc2, 0xfe, 0x08, 0x17, 0xa2, 0x9b,
+0x6a, 0xf5, 0xce, 0xb2, 0x17, 0xe0, 0x43, 0x22, 0x0e, 0x37, 0x4f, 0xf1, 0xde,
+0xdf, 0x67, 0x50, 0xf3, 0x00, 0x68, 0x3d, 0xf1, 0x3e, 0x80, 0x1d, 0x9d, 0xb6,
+0x90, 0x01, 0x4e, 0x0e, 0xa4, 0x86, 0x87, 0x42, 0xb5, 0x48, 0xe0, 0x99, 0x23,
+0x03, 0x04, 0x41, 0x7c, 0x36, 0xa8, 0x0a, 0x10, 0x61, 0xfc, 0xa4, 0xbb, 0xd1,
+0x2d, 0xdb, 0x2a, 0xf8, 0x3b, 0x0f, 0x05, 0x48, 0x42, 0x1e, 0x4b, 0xdb, 0xb3,
+0xcd, 0x49, 0xbe, 0x51, 0x5b, 0x38, 0xaf, 0x90, 0xa0, 0xd2, 0x28, 0x32, 0xad,
+0x2b, 0x03, 0xea, 0xb0, 0xe8, 0xa3, 0xad, 0xbb, 0x18, 0x1d, 0xb3, 0xaf, 0xde,
+0xe4, 0x5e, 0xc3, 0xa1, 0x1b, 0xca, 0xfe, 0x7b, 0x76, 0xa7, 0x2d, 0xd0, 0xd0,
+0x9e, 0x3d, 0x4d, 0x8b, 0xb7, 0xf3, 0x50, 0x00, 0xc9, 0x38, 0xd0, 0xf4, 0xce,
+0x9f, 0x5a, 0x5e, 0x60, 0x5f, 0xc7, 0x0b, 0x30, 0xd5, 0x3b, 0x87, 0xaf, 0xcd,
+0x37, 0xda, 0x85, 0x60, 0x84, 0x03, 0x80, 0xc8, 0x4d, 0xf9, 0x81, 0x9b, 0x52,
+0x80, 0xf0, 0xfc, 0x9a, 0xa7, 0x61, 0xf0, 0xb4, 0xe0, 0xb7, 0x6d, 0x45, 0x50,
+0x55, 0x81, 0xdd, 0x6a, 0x02, 0x08, 0x0d, 0xac, 0x0e, 0xd6, 0x1b, 0xbe, 0x00,
+0x5d, 0xea, 0x0c, 0x06, 0x82, 0x00, 0x04, 0x41, 0xac, 0x53, 0xac, 0x93, 0x6e,
+0xb4, 0x66, 0xab, 0xe0, 0xdf, 0x7e, 0x30, 0x81, 0xeb, 0xce, 0x0a, 0x6a, 0xc6,
+0xbb, 0x3a, 0x1d, 0x81, 0x17, 0x90, 0x8e, 0x73, 0x2d, 0xf5, 0x01, 0x25, 0xeb,
+0x11, 0x9e, 0x07, 0x39, 0xed, 0xe4, 0x6e, 0xa2, 0x14, 0x0c, 0x75, 0x18, 0xfc,
+0x31, 0x00, 0xab, 0x0d, 0xf5, 0xe8, 0x1a, 0xf0, 0xe7, 0xd7, 0x3c, 0x68, 0xf4,
+0xb5, 0x86, 0x91, 0x30, 0x79, 0x6e, 0x4a, 0xf9, 0x8a, 0xe9, 0xa9, 0x40, 0xaa,
+0xe5, 0xef, 0x8b, 0xc3, 0x3d, 0x82, 0xf7, 0xc3, 0x77, 0x00, 0x20, 0xdc, 0xe9,
+0x52, 0xd0, 0x69, 0x05, 0x58, 0xa5, 0x58, 0xa7, 0xbb, 0x91, 0xd5, 0x3d, 0x15,
+0x7c, 0x76, 0x85, 0x6a, 0xda, 0xe9, 0xeb, 0xde, 0x21, 0xe4, 0xc0, 0x60, 0xf0,
+0xa3, 0x86, 0x9e, 0x19, 0x64, 0x80, 0x44, 0x4c, 0x6a, 0xcb, 0x1b, 0xe3, 0x0b,
+0xd0, 0x60, 0x16, 0x28, 0x1a, 0x57, 0x9f, 0x61, 0xdc, 0x97, 0x04, 0x08, 0x36,
+0x92, 0xc1, 0x67, 0xd9, 0x0b, 0xec, 0x3d, 0x12, 0x41, 0x73, 0x6e, 0xdc, 0x7e,
+0x70, 0xab, 0xa9, 0xff, 0x50, 0xe4, 0x33, 0xf8, 0xfc, 0xc1, 0x2b, 0xa4, 0xe3,
+0x15, 0xae, 0x6e, 0x4e, 0x91, 0x79, 0xa3, 0xad, 0x7f, 0x77, 0x94, 0x12, 0x90,
+0x28, 0x57, 0x86, 0x76, 0xf8, 0x80, 0x92, 0xff, 0x0c, 0xb1, 0xe8, 0x5b, 0x02,
+0x28, 0x37, 0x6f, 0x6c, 0xe8, 0xa0, 0xa6, 0xd6, 0xf0, 0x35, 0x3b, 0x24, 0xe2,
+0x43, 0x22, 0xb8, 0x10, 0x5d, 0xdd, 0x2a, 0x4e, 0xa1, 0xb8, 0x10, 0xf4, 0x0c,
+0xfa, 0xd3, 0x3f, 0xe8, 0x98, 0x41, 0x0f, 0x20, 0xec, 0xa5, 0xda, 0xf6, 0x1e,
+0x79, 0xb9, 0x49, 0x78, 0xe6, 0x48, 0x77, 0x27, 0xf7, 0x15, 0x76, 0x52, 0x01,
+0x82, 0xb7, 0x97, 0x26, 0xea, 0xbe, 0xf8, 0xe5, 0x46, 0x31, 0xf5, 0x9a, 0x69,
+0x15, 0xd5, 0x21, 0x51, 0x7c, 0x5b, 0x82, 0xff, 0x31, 0x03, 0xc3, 0x59, 0xc3,
+0xbb, 0x28, 0xae, 0x01, 0xec, 0x9a, 0xa8, 0x40, 0xac, 0xa2, 0x43, 0x18, 0x05,
+0xd2, 0x62, 0xb6, 0x6d, 0x6f, 0xd2, 0xbb, 0xab, 0xb3, 0x00, 0x10, 0xe8, 0x2b,
+0x02, 0x28, 0xc6, 0x26, 0xc0, 0x2c, 0x92, 0x75, 0xcb, 0xb6, 0xb0, 0x2d, 0xa1,
+0x99, 0x11, 0xb1, 0x76, 0x48, 0x74, 0x7f, 0x73, 0x46, 0x77, 0x48, 0x94, 0x8e,
+0xe7, 0x8b, 0xc0, 0x03, 0xc0, 0x32, 0xf4, 0xa7, 0x7f, 0xaa, 0x4a, 0x38, 0x2a,
+0x48, 0x30, 0x55, 0xbc, 0x8f, 0x60, 0xbb, 0xc2, 0x17, 0xa0, 0xfb, 0x8f, 0x00,
+0x00, 0x02, 0xd3, 0x0b, 0x63, 0x75, 0x81, 0xa9, 0x66, 0x6f, 0x33, 0x23, 0x62,
+0xed, 0x9c, 0xc0, 0xec, 0x84, 0xd0, 0x79, 0xee, 0xf2, 0x8a, 0x00, 0xe3, 0x00,
+0xde, 0xd1, 0x31, 0x7c, 0x5a, 0xaf, 0x10, 0xeb, 0x8c, 0x11, 0x54, 0x3b, 0x02,
+0xcf, 0x1c, 0x89, 0x4e, 0xdd, 0x9c, 0xa2, 0x63, 0x04, 0xa8, 0xb7, 0xf6, 0xf3,
+0x21, 0x11, 0x14, 0xeb, 0x44, 0xa3, 0x23, 0xe2, 0xca, 0x21, 0x51, 0x43, 0xb1,
+0xa8, 0x80, 0x9c, 0x36, 0x28, 0x03, 0xda, 0x75, 0x20, 0x07, 0x5a, 0xb2, 0x34,
+0x6c, 0x16, 0x53, 0x3e, 0x12, 0xe8, 0xd0, 0x2d, 0x6a, 0x3a, 0x45, 0x00, 0xae,
+0x1e, 0x40, 0x93, 0xd1, 0x2c, 0x52, 0xd1, 0x5c, 0xc3, 0x00, 0xaa, 0xe0, 0xd3,
+0x9c, 0xbb, 0x39, 0xc3, 0xe8, 0x50, 0xfc, 0xc0, 0x8e, 0x41, 0x19, 0xc8, 0x6b,
+0xc8, 0xe1, 0x01, 0x0a, 0x99, 0xf3, 0xb6, 0xbe, 0x59, 0x24, 0xed, 0x02, 0x3a,
+0x74, 0x73, 0xab, 0xb6, 0x13, 0x80, 0x20, 0x88, 0x39, 0x27, 0x65, 0x77, 0xd7,
+0x23, 0xe7, 0xd1, 0x27, 0x49, 0xb0, 0x2b, 0x54, 0x43, 0x75, 0xff, 0xda, 0xe0,
+0x6b, 0x1d, 0xff, 0xbe, 0x81, 0x0a, 0x30, 0x1a, 0x15, 0x98, 0x6a, 0x6f, 0x27,
+0xa0, 0x09, 0x77, 0xbf, 0x28, 0x00, 0x47, 0x32, 0xa3, 0x75, 0x65, 0x7f, 0x36,
+0x79, 0xde, 0x50, 0xbf, 0x7f, 0x96, 0xbd, 0xc0, 0xd7, 0x7f, 0x7a, 0x7d, 0x7d,
+0xf0, 0x55, 0x2f, 0xa0, 0x92, 0xa0, 0xaa, 0x3f, 0xd3, 0x10, 0xc0, 0xd1, 0xfe,
+0x37, 0x8c, 0xe1, 0xa8, 0xbe, 0x2a, 0x01, 0x74, 0x3d, 0xcb, 0xb5, 0x87, 0x9b,
+0xbf, 0xc0, 0x5b, 0x67, 0x97, 0xa0, 0x75, 0xfb, 0x93, 0xac, 0xab, 0x75, 0x6b,
+0x03, 0xef, 0x1a, 0x10, 0xc0, 0x03, 0x40, 0xeb, 0xfb, 0x48, 0x34, 0x74, 0x6c,
+0xac, 0x9b, 0xa3, 0x13, 0x04, 0xf0, 0x51, 0x35, 0x0c, 0xe0, 0x59, 0xf6, 0x02,
+0xc7, 0x7b, 0x6f, 0x30, 0xdb, 0xc0, 0x9c, 0x80, 0x0f, 0x89, 0x45, 0x79, 0x69,
+0xe5, 0xc2, 0x90, 0x7a, 0xf8, 0x28, 0xa6, 0xf3, 0xb8, 0x50, 0x4e, 0x80, 0x7e,
+0x89, 0x8e, 0x10, 0xc0, 0x45, 0xd9, 0x4d, 0x2f, 0x48, 0x45, 0x73, 0xa0, 0x58,
+0x67, 0xdd, 0xb5, 0xff, 0x70, 0xf3, 0x17, 0x48, 0x42, 0x01, 0xfe, 0xc7, 0x4c,
+0x1b, 0x26, 0x31, 0x3a, 0x04, 0x70, 0xa0, 0x6f, 0xa3, 0x13, 0x04, 0xa8, 0x69,
+0x00, 0x93, 0xd1, 0x6c, 0xdd, 0xc7, 0xbf, 0xd2, 0xf1, 0x3c, 0xf6, 0x3f, 0x3d,
+0xc1, 0x75, 0xf6, 0x11, 0x02, 0x00, 0x4e, 0x8c, 0x0a, 0x30, 0xf4, 0xcf, 0x08,
+0x78, 0x50, 0xb6, 0x6e, 0xd0, 0xee, 0x4e, 0xa0, 0xdf, 0x06, 0x41, 0xa6, 0x21,
+0x09, 0x79, 0x50, 0x75, 0x12, 0x60, 0xef, 0x91, 0x08, 0x76, 0x85, 0x6a, 0x7a,
+0x1b, 0x58, 0x3a, 0x9e, 0x87, 0x14, 0x2f, 0x14, 0x57, 0x02, 0xf3, 0x06, 0x65,
+0xc0, 0x81, 0xea, 0xe5, 0x62, 0x47, 0xe7, 0x86, 0x41, 0x0a, 0xb9, 0x32, 0x03,
+0x43, 0x80, 0xf3, 0xec, 0x65, 0x5d, 0xd7, 0x45, 0x9f, 0x14, 0x8d, 0x57, 0xb3,
+0x7b, 0x02, 0xd4, 0xd5, 0xc5, 0xf3, 0xdc, 0x65, 0x11, 0xd0, 0x17, 0x0d, 0xaa,
+0x40, 0x87, 0x42, 0x21, 0x57, 0x6c, 0x80, 0x14, 0xa0, 0x80, 0x5a, 0x3e, 0xe1,
+0x2c, 0x7b, 0x81, 0xc3, 0xcd, 0x53, 0xcc, 0x5f, 0xe3, 0x98, 0xf8, 0xfe, 0xc6,
+0x09, 0xec, 0x2e, 0x1b, 0x28, 0xd6, 0x69, 0xbc, 0xf7, 0xaf, 0xb2, 0xef, 0xef,
+0xf3, 0xe8, 0x04, 0x01, 0x62, 0xc9, 0xa8, 0xf9, 0xea, 0x19, 0xc5, 0x3a, 0x91,
+0x4d, 0x99, 0xd7, 0xd4, 0xa3, 0xe7, 0xa7, 0xa0, 0x58, 0x67, 0xd3, 0x47, 0xc5,
+0x45, 0x3e, 0x03, 0x91, 0xcf, 0x80, 0x5b, 0xa7, 0xaf, 0x9c, 0xfc, 0x9c, 0x41,
+0xdb, 0xc7, 0xc0, 0x7c, 0xc7, 0x50, 0x02, 0x20, 0x69, 0x67, 0xdb, 0xde, 0x30,
+0x65, 0xcf, 0x41, 0xdf, 0x28, 0x40, 0xa6, 0x5e, 0x89, 0x37, 0x8b, 0xf8, 0xb6,
+0xd4, 0xf4, 0xa6, 0x10, 0xc3, 0x05, 0xa6, 0x3b, 0xd0, 0x5f, 0x0a, 0x1e, 0x07,
+0x50, 0x80, 0xf1, 0xb1, 0xf1, 0x42, 0x69, 0x5c, 0xdb, 0x96, 0xc8, 0xf7, 0x99,
+0x07, 0xe0, 0x25, 0x21, 0x6f, 0x7a, 0x81, 0x8b, 0x1a, 0x81, 0x14, 0xcf, 0x9b,
+0x66, 0x2f, 0x80, 0xa6, 0xb3, 0x3f, 0xfa, 0x24, 0x05, 0xd2, 0x3b, 0x5a, 0xbd,
+0xc0, 0xe4, 0x43, 0xf5, 0xae, 0x1f, 0xad, 0x0a, 0x68, 0x7d, 0x9e, 0xa0, 0x99,
+0x13, 0xb4, 0x39, 0x4e, 0x0e, 0x24, 0xc8, 0xb2, 0xbc, 0x37, 0x30, 0x25, 0xc0,
+0x35, 0x69, 0x37, 0x2d, 0x01, 0x92, 0x90, 0x47, 0x33, 0x07, 0x48, 0x54, 0xd7,
+0x7f, 0xf4, 0xfc, 0xf4, 0x4a, 0xfa, 0xab, 0xa6, 0x14, 0x06, 0xf5, 0x9e, 0xd4,
+0x69, 0x15, 0xd5, 0x4e, 0x20, 0xdf, 0xbe, 0x37, 0x2b, 0xde, 0x41, 0xf9, 0xef,
+0x18, 0x01, 0xa4, 0x78, 0xa1, 0x86, 0x07, 0x70, 0xc1, 0x4c, 0x25, 0x1a, 0x99,
+0x13, 0x54, 0x19, 0xbf, 0x4f, 0x13, 0x60, 0x57, 0x28, 0xe3, 0xbd, 0x05, 0x3e,
+0x83, 0xb7, 0x9b, 0xd4, 0x00, 0x9d, 0xaf, 0x9e, 0x21, 0xb4, 0xeb, 0x33, 0x06,
+0x95, 0xc3, 0x27, 0x7c, 0xdf, 0x10, 0x40, 0x96, 0xe5, 0xe3, 0xf3, 0xdc, 0xa5,
+0x98, 0x36, 0x91, 0x78, 0x92, 0x19, 0x45, 0x2a, 0x9a, 0x33, 0xfd, 0x3e, 0x76,
+0x97, 0xad, 0xe1, 0xff, 0x3b, 0x19, 0xcd, 0x42, 0x8a, 0x17, 0xcc, 0x47, 0xcc,
+0x66, 0x8e, 0x5f, 0xba, 0x32, 0x7d, 0x60, 0xda, 0x9f, 0xfd, 0x45, 0x03, 0x98,
+0xea, 0x2f, 0x02, 0xa8, 0x3e, 0xe0, 0x78, 0xcf, 0xd8, 0xd3, 0x8c, 0xb8, 0x86,
+0xe1, 0xa4, 0xec, 0xa8, 0x55, 0x2a, 0x1a, 0x8d, 0xc3, 0xcd, 0x5f, 0x70, 0xfb,
+0xc1, 0x84, 0xf9, 0xc4, 0xd0, 0xa1, 0x64, 0x7b, 0xdc, 0xc4, 0x03, 0x14, 0xca,
+0x3b, 0x00, 0x66, 0x81, 0x6a, 0xcb, 0x9b, 0x94, 0x16, 0xb3, 0x38, 0x39, 0x90,
+0x32, 0xb2, 0x2c, 0x7f, 0xd5, 0x6f, 0x04, 0xa8, 0xf9, 0xe1, 0x8d, 0x34, 0xe7,
+0x86, 0xd9, 0x35, 0x8d, 0x76, 0x12, 0xd9, 0xe4, 0x99, 0xe1, 0x02, 0x53, 0xd5,
+0xf7, 0xaa, 0x5c, 0xed, 0xd3, 0x69, 0xfb, 0x4a, 0x0a, 0x70, 0xd2, 0xbe, 0x0e,
+0x40, 0xb9, 0x47, 0xf1, 0x56, 0xbf, 0xcd, 0x01, 0x20, 0xcb, 0xf2, 0x57, 0x92,
+0x50, 0xc8, 0x98, 0x95, 0x81, 0x49, 0xd6, 0x65, 0x48, 0x00, 0x92, 0x71, 0xa0,
+0x56, 0x27, 0xa1, 0xd7, 0x39, 0x30, 0x7e, 0x52, 0x37, 0xfb, 0x25, 0xa1, 0x50,
+0x5c, 0xe3, 0x57, 0x63, 0xaa, 0x0e, 0x02, 0x90, 0x57, 0x7f, 0x57, 0xb6, 0x6c,
+0xb5, 0x3c, 0x94, 0x5b, 0xd1, 0x84, 0xfb, 0x8e, 0x00, 0x4a, 0x44, 0x84, 0x1d,
+0xc9, 0x54, 0x01, 0xce, 0xb3, 0x97, 0xd0, 0x23, 0x89, 0x19, 0x39, 0x0c, 0x09,
+0xb0, 0x97, 0xa9, 0xbf, 0x73, 0x98, 0xd2, 0xf1, 0x01, 0x85, 0x72, 0xd3, 0x57,
+0x22, 0x80, 0x50, 0xda, 0xb0, 0xd1, 0xd2, 0x78, 0x19, 0x89, 0x43, 0x3a, 0xce,
+0xf1, 0xb2, 0x2c, 0x1f, 0xf4, 0x2b, 0x01, 0xc2, 0xc2, 0xb6, 0x84, 0xb3, 0xec,
+0x85, 0xb1, 0x1f, 0x5b, 0x24, 0x71, 0xf4, 0xfc, 0x54, 0xa7, 0x4b, 0x70, 0x42,
+0x12, 0x0a, 0xa6, 0xaf, 0xad, 0xca, 0xf2, 0x78, 0x01, 0xf5, 0xec, 0x44, 0x02,
+0x00, 0x8c, 0x9a, 0xc8, 0x7e, 0x5e, 0x51, 0x07, 0x6f, 0x71, 0x30, 0x34, 0x7a,
+0x61, 0x57, 0x3f, 0x56, 0xae, 0xa5, 0xa1, 0xdc, 0x9c, 0x3a, 0x82, 0x0e, 0x47,
+0xc7, 0x08, 0xa0, 0x74, 0x03, 0xbc, 0x1e, 0xc0, 0x6a, 0xdc, 0x5e, 0x9a, 0x80,
+0xc8, 0x67, 0xaa, 0x80, 0x1e, 0x71, 0x0d, 0x83, 0x62, 0x9d, 0x0d, 0xa9, 0xc0,
+0x79, 0xee, 0xb2, 0xfe, 0x6d, 0xe5, 0x53, 0x26, 0x9d, 0x80, 0xa0, 0xa9, 0xff,
+0x07, 0xed, 0xc9, 0xfe, 0xdd, 0xf0, 0x21, 0xa4, 0xe3, 0x5c, 0x4c, 0x96, 0xe5,
+0x67, 0x7d, 0x4b, 0x00, 0x25, 0x42, 0x87, 0x9b, 0xa7, 0x86, 0x99, 0xec, 0x9a,
+0x1c, 0x01, 0xcd, 0xb9, 0x75, 0x55, 0x80, 0xf1, 0x93, 0x68, 0xdb, 0xa7, 0x80,
+0x3b, 0x0c, 0x80, 0x9f, 0x52, 0xba, 0x03, 0xf5, 0x70, 0x52, 0xbc, 0x74, 0x70,
+0xa3, 0x65, 0x91, 0xcf, 0x9c, 0x61, 0xbb, 0x98, 0xfd, 0xab, 0xb8, 0x81, 0xe8,
+0x28, 0x01, 0x64, 0x59, 0xde, 0x3b, 0xcf, 0x5d, 0x6e, 0x45, 0x9f, 0x18, 0xef,
+0xaa, 0x65, 0x57, 0x28, 0xe8, 0x91, 0x84, 0xe6, 0xdc, 0x38, 0xde, 0x7b, 0xa3,
+0x7f, 0xd2, 0x57, 0x27, 0x9c, 0x94, 0x1d, 0x66, 0xa6, 0xb3, 0x66, 0xa8, 0xc6,
+0x4f, 0xb8, 0x92, 0x7f, 0x1c, 0xb4, 0x9e, 0x00, 0x91, 0x20, 0x8f, 0xc2, 0x9b,
+0xf3, 0x48, 0xa7, 0x46, 0xbf, 0x37, 0xad, 0x00, 0x00, 0xb0, 0x7a, 0xf4, 0xfc,
+0xd4, 0xb0, 0x23, 0x50, 0x55, 0x60, 0x7f, 0xe3, 0xa4, 0xaa, 0x0c, 0x30, 0x7e,
+0x12, 0x66, 0x46, 0xb2, 0x72, 0xb8, 0xd4, 0x68, 0xe7, 0x70, 0xd5, 0x90, 0x6b,
+0xbc, 0xc1, 0x09, 0x8a, 0xd3, 0xc2, 0x03, 0x60, 0xee, 0xde, 0x34, 0x1c, 0xee,
+0xd6, 0xdd, 0xbb, 0xf8, 0x65, 0x24, 0x8e, 0x83, 0xaf, 0x8e, 0x33, 0x37, 0x95,
+0xfd, 0x37, 0x42, 0x00, 0x59, 0x96, 0x8f, 0x01, 0x84, 0xf7, 0x1e, 0x89, 0xa6,
+0x2a, 0x20, 0xf2, 0x99, 0xaa, 0xc1, 0xd0, 0xec, 0xd2, 0x04, 0xcc, 0x4a, 0x48,
+0x65, 0xe7, 0x50, 0x6b, 0xba, 0x68, 0x18, 0x6a, 0xdd, 0x3f, 0x40, 0x71, 0xc9,
+0x18, 0x00, 0x76, 0x8b, 0x37, 0x7a, 0x6c, 0x55, 0x24, 0x62, 0x69, 0xbc, 0x58,
+0xdd, 0x07, 0x80, 0x80, 0x2c, 0xcb, 0x6f, 0x06, 0x86, 0x00, 0x0a, 0x09, 0x1e,
+0x49, 0x42, 0x81, 0x57, 0x4f, 0x00, 0xeb, 0xa9, 0x00, 0xbb, 0x42, 0x81, 0x0f,
+0x89, 0x65, 0x60, 0x8f, 0x7b, 0x1d, 0x20, 0xbd, 0xa3, 0x30, 0x33, 0x92, 0xf5,
+0x0e, 0x96, 0x4c, 0x23, 0xa6, 0xc8, 0xfe, 0x4b, 0x94, 0xd6, 0x0a, 0x48, 0xa7,
+0xb3, 0x65, 0xf2, 0x9f, 0xcf, 0x9c, 0x61, 0x83, 0xdb, 0x41, 0xe1, 0xcd, 0xf9,
+0xea, 0x4d, 0x49, 0xff, 0x8d, 0x12, 0x40, 0x89, 0xc0, 0xd1, 0xf3, 0xd3, 0x4c,
+0x7c, 0x5b, 0x7f, 0xd1, 0xfd, 0xf6, 0x83, 0x5b, 0x70, 0x4d, 0xda, 0xab, 0x4a,
+0x01, 0xb7, 0x4e, 0x23, 0xfa, 0x24, 0x55, 0xd3, 0x0b, 0xb8, 0x26, 0x47, 0xe0,
+0x9a, 0xb4, 0x37, 0x4e, 0x82, 0xbc, 0x92, 0xf9, 0x1e, 0x8d, 0xfc, 0xef, 0x96,
+0x6e, 0xde, 0xd0, 0x4a, 0xf0, 0x23, 0xb2, 0x2c, 0xff, 0x27, 0x6e, 0x38, 0x6e,
+0x8c, 0x00, 0x8a, 0xec, 0x71, 0x7b, 0x8f, 0x8e, 0x0d, 0xcd, 0xda, 0xdd, 0xbf,
+0xbd, 0x05, 0x91, 0xcf, 0x40, 0x4b, 0x12, 0xd7, 0xe4, 0x08, 0x66, 0x97, 0x26,
+0xc0, 0x9b, 0x94, 0x90, 0xb2, 0x92, 0xf1, 0xfc, 0x97, 0xda, 0x3f, 0x8c, 0xd6,
+0xe9, 0xc7, 0x70, 0xb5, 0x40, 0x34, 0x5f, 0x34, 0x83, 0xe4, 0x99, 0xb3, 0x25,
+0xf2, 0xaf, 0x82, 0x7f, 0x72, 0x20, 0x45, 0x64, 0x59, 0xfe, 0x10, 0x5d, 0x10,
+0x37, 0xba, 0x27, 0x50, 0x99, 0x7a, 0x05, 0x77, 0x1e, 0x0a, 0xba, 0x24, 0x18,
+0x71, 0x0d, 0xc3, 0xff, 0x98, 0xc1, 0xfe, 0xc6, 0x49, 0x99, 0x1f, 0x60, 0x57,
+0x28, 0x9c, 0x67, 0x2f, 0x4b, 0x9b, 0x44, 0xcd, 0xca, 0x80, 0x14, 0x2f, 0xd4,
+0x5e, 0x64, 0x92, 0x70, 0x35, 0xe9, 0xdb, 0xc5, 0xd5, 0x9d, 0x41, 0xe6, 0x01,
+0x3c, 0x6b, 0x4d, 0xf6, 0x27, 0x62, 0xe9, 0xae, 0x03, 0xff, 0xc6, 0x09, 0xa0,
+0x90, 0xe0, 0xd9, 0x79, 0xee, 0xd2, 0x90, 0x04, 0xe3, 0x5e, 0x07, 0xe6, 0xd7,
+0x3c, 0xf8, 0x7a, 0xed, 0x75, 0xe9, 0xf9, 0x11, 0xd7, 0x30, 0x16, 0xd6, 0x69,
+0x1c, 0x6e, 0x9e, 0x9a, 0x4a, 0xfc, 0x88, 0x6b, 0x18, 0xb7, 0x1f, 0x4c, 0xd4,
+0x24, 0x0a, 0x12, 0x9a, 0x9e, 0x5f, 0xd2, 0x0c, 0x87, 0x4e, 0x00, 0x8f, 0x87,
+0xbc, 0x76, 0xf6, 0xc7, 0xf9, 0x64, 0x57, 0x82, 0xdf, 0x15, 0x04, 0xd0, 0x92,
+0xe0, 0x8b, 0x0f, 0x5e, 0x41, 0xcf, 0x13, 0x78, 0x17, 0xc7, 0x31, 0xbf, 0xe6,
+0x81, 0x96, 0x24, 0xe3, 0xde, 0xe2, 0x7d, 0x00, 0xf8, 0x90, 0x68, 0xda, 0xef,
+0xcf, 0x2e, 0x4d, 0xd4, 0x56, 0x01, 0xd5, 0xf5, 0xef, 0xe0, 0xea, 0x98, 0x38,
+0x03, 0x60, 0xbb, 0x78, 0x0f, 0xbf, 0xeb, 0xc4, 0x6e, 0xf8, 0x10, 0x9f, 0xfe,
+0xcb, 0x0e, 0x0a, 0x6f, 0xce, 0x83, 0xdd, 0x06, 0x7e, 0xd7, 0x10, 0x40, 0x25,
+0x01, 0x00, 0xdf, 0xde, 0xa3, 0xe3, 0x8c, 0x5e, 0x77, 0xa0, 0x25, 0x81, 0x0a,
+0x26, 0xcd, 0xb9, 0xab, 0x88, 0xa1, 0xa7, 0x02, 0xec, 0x0a, 0x85, 0x7d, 0x83,
+0x8e, 0x03, 0x69, 0x94, 0x6f, 0xfc, 0x70, 0x28, 0xfd, 0xbf, 0x00, 0xbc, 0xb3,
+0x32, 0xdb, 0xf4, 0xce, 0x9f, 0xb4, 0x98, 0xc5, 0x06, 0xb7, 0x8d, 0x17, 0x9f,
+0xec, 0x8b, 0x00, 0x7c, 0x37, 0x31, 0xe6, 0xed, 0x29, 0x02, 0x68, 0x3c, 0x81,
+0xef, 0xe8, 0xf9, 0x69, 0xec, 0xf3, 0x07, 0xdf, 0x57, 0x39, 0x7d, 0x2d, 0x09,
+0x54, 0xa5, 0x50, 0x1f, 0x33, 0x52, 0x0f, 0xb5, 0xa3, 0x00, 0xa0, 0x5f, 0x0a,
+0xf6, 0x15, 0xa7, 0xbf, 0xa3, 0xd4, 0xfc, 0xed, 0xa2, 0x1f, 0x20, 0xcf, 0x9c,
+0x58, 0x6c, 0xb2, 0xf6, 0xef, 0x86, 0x0f, 0xf1, 0x1f, 0xbe, 0xcf, 0x21, 0xec,
+0xa5, 0xc2, 0x0a, 0xf8, 0x07, 0xe8, 0xd2, 0x18, 0xee, 0xb6, 0x1f, 0x48, 0x19,
+0x14, 0xfd, 0x13, 0x41, 0x10, 0xeb, 0x9f, 0x3f, 0x78, 0x15, 0x62, 0x57, 0xa8,
+0xb2, 0xed, 0xe0, 0xde, 0xc5, 0x71, 0x90, 0x8c, 0x43, 0xb9, 0x11, 0x54, 0x01,
+0x77, 0xd6, 0xa6, 0xca, 0x1e, 0x4b, 0x45, 0x73, 0xd0, 0xbb, 0x0f, 0xf1, 0xc2,
+0x3a, 0x8d, 0x2f, 0x3e, 0x78, 0x85, 0xe9, 0x05, 0x77, 0x35, 0x01, 0x3c, 0x15,
+0x46, 0xf0, 0x00, 0xf8, 0xe8, 0xbb, 0xbb, 0x0d, 0x4f, 0xfd, 0xe2, 0x7c, 0x12,
+0xcf, 0x82, 0x3c, 0xa4, 0xe3, 0x9c, 0x08, 0x20, 0x78, 0xd3, 0x3d, 0x7e, 0x3d,
+0x41, 0xc8, 0xb2, 0xdc, 0xbd, 0x3f, 0x5c, 0xf1, 0xb3, 0x75, 0x22, 0x24, 0x33,
+0xea, 0x9b, 0x5f, 0x9b, 0x2a, 0xdb, 0x18, 0x9a, 0x4d, 0x9e, 0xe1, 0xeb, 0x3f,
+0xbd, 0x2e, 0x81, 0x3b, 0xee, 0x75, 0x94, 0xf6, 0xff, 0x4b, 0x42, 0x41, 0xf7,
+0xce, 0xa2, 0xd1, 0x27, 0x49, 0x88, 0x7c, 0xa6, 0xb8, 0x21, 0xe4, 0xb1, 0x32,
+0xe8, 0x51, 0x8f, 0x87, 0xcd, 0x03, 0xf8, 0x9f, 0xe2, 0x5f, 0x97, 0x9f, 0x2e,
+0x34, 0x64, 0xfc, 0xe2, 0x7c, 0x12, 0x3b, 0xa1, 0x28, 0x84, 0xbd, 0x54, 0x06,
+0x40, 0xa8, 0x1b, 0xfa, 0xfb, 0xbe, 0x20, 0x80, 0x86, 0x08, 0xcb, 0x00, 0x42,
+0x14, 0xeb, 0xa4, 0xd9, 0x95, 0xc9, 0x32, 0x22, 0x44, 0x9f, 0x24, 0x71, 0xb8,
+0x79, 0x0a, 0xad, 0x52, 0x24, 0xa3, 0xd9, 0xd2, 0xfd, 0x03, 0xd8, 0x15, 0x0a,
+0x34, 0xe7, 0x2e, 0x29, 0xc2, 0xe7, 0x0f, 0xbe, 0xbf, 0x22, 0xc0, 0x9f, 0x95,
+0xcc, 0x57, 0xf7, 0xff, 0x49, 0xc0, 0xfc, 0x32, 0xa3, 0xde, 0xc2, 0xbd, 0x66,
+0xbc, 0x8c, 0xc4, 0xb1, 0x1b, 0x3e, 0xc2, 0xc9, 0x81, 0x94, 0x41, 0x71, 0x27,
+0x4f, 0xf8, 0x26, 0xc7, 0xba, 0x7d, 0x4b, 0x00, 0x85, 0x04, 0x63, 0x28, 0x2e,
+0x9a, 0x04, 0x49, 0x66, 0x94, 0x9e, 0x5d, 0x9a, 0x28, 0x65, 0x78, 0x3a, 0x9e,
+0x87, 0xba, 0xb6, 0xa0, 0x55, 0x8a, 0xf8, 0x76, 0x1a, 0xc2, 0x8e, 0x04, 0x29,
+0x5e, 0x00, 0xcd, 0xb9, 0x41, 0xb1, 0x4e, 0xb8, 0x26, 0x47, 0xb0, 0xf3, 0x50,
+0x28, 0x9e, 0x0d, 0xdc, 0x51, 0x0c, 0x9f, 0xb2, 0x1f, 0xa0, 0x1e, 0xf0, 0xd3,
+0x62, 0x16, 0xbb, 0xe1, 0x43, 0xec, 0x47, 0x04, 0x14, 0xde, 0x9c, 0x8b, 0x00,
+0x42, 0x00, 0xb6, 0x7a, 0x0d, 0xf8, 0x9e, 0x23, 0x80, 0x8e, 0x22, 0xac, 0xda,
+0x9d, 0x36, 0x1f, 0xcd, 0xb9, 0x31, 0xbb, 0x34, 0x81, 0x71, 0xaf, 0x03, 0x87,
+0x9b, 0xbf, 0x20, 0xfa, 0x24, 0x05, 0x8a, 0x75, 0xe2, 0xce, 0xda, 0x54, 0x69,
+0x43, 0x48, 0x36, 0x79, 0x56, 0x5a, 0x5c, 0x4a, 0x45, 0x73, 0xc5, 0xd3, 0xc1,
+0x6a, 0x28, 0x23, 0x5f, 0x33, 0xf0, 0xd3, 0x62, 0x16, 0x07, 0x5b, 0x22, 0x5e,
+0x46, 0x04, 0x35, 0xdb, 0xb7, 0x00, 0x44, 0x7a, 0xa1, 0xc6, 0xf7, 0x25, 0x01,
+0x34, 0x44, 0x98, 0x56, 0x54, 0x21, 0xa0, 0xde, 0x87, 0x58, 0xdd, 0x3e, 0x26,
+0x6c, 0x4b, 0xa0, 0x39, 0x37, 0x98, 0x45, 0xb2, 0xac, 0x64, 0x24, 0xa3, 0xd9,
+0xa2, 0x02, 0x98, 0x80, 0x9f, 0xcf, 0x9c, 0x41, 0xe0, 0x53, 0x88, 0xf3, 0x49,
+0x1c, 0x6c, 0x89, 0x90, 0x8e, 0x73, 0x19, 0x14, 0xf7, 0xea, 0x6f, 0xf5, 0x72,
+0xb6, 0xf7, 0x1d, 0x01, 0x74, 0x0c, 0x23, 0x87, 0xe2, 0x6d, 0x56, 0x39, 0x27,
+0x65, 0x47, 0x4e, 0x39, 0x6e, 0x46, 0x32, 0xa3, 0x98, 0x5d, 0x9a, 0x28, 0x8e,
+0x86, 0x85, 0xc2, 0x15, 0x01, 0x00, 0xbc, 0xf3, 0xf1, 0x2c, 0x7c, 0x01, 0x1a,
+0x27, 0x31, 0x09, 0x89, 0x98, 0x04, 0x81, 0x4f, 0x42, 0x3a, 0xce, 0x01, 0xc5,
+0x55, 0x01, 0x5e, 0x01, 0x7c, 0x0f, 0x7d, 0x1a, 0x7d, 0x43, 0x00, 0x1d, 0x42,
+0x2c, 0x28, 0x1d, 0xbe, 0x0f, 0x00, 0xad, 0x90, 0x03, 0x5a, 0x62, 0x68, 0x82,
+0x07, 0x20, 0x2a, 0xa0, 0xc7, 0xba, 0x1d, 0xf0, 0x7f, 0x1b, 0x1e, 0x26, 0xfe,
+0xeb, 0xe2, 0xa2, 0x25, 0xc0, 0x0d, 0xf7, 0x2b, 0xb3, 0x15, 0x10, 0xf7, 0x0c,
+0x88, 0xa1, 0x46, 0xac, 0x17, 0xe5, 0x5c, 0x96, 0xe5, 0x7f, 0x00, 0x70, 0x6e,
+0x11, 0xa0, 0x79, 0x62, 0xf4, 0xfa, 0xef, 0xf0, 0x8f, 0xad, 0x22, 0x40, 0xdf,
+0x96, 0x00, 0x2b, 0xea, 0x8b, 0xff, 0x1f, 0x00, 0xcc, 0x76, 0x1f, 0x47, 0xd4,
+0x27, 0x0e, 0xf1, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4e, 0x44, 0xae, 0x42,
+0x60, 0x82 };
+
+/** A PNG image stating that using Tor as HTTP Proxy is wrong! */
+const char proxytest_image[] = {
+0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00,
+0x00, 0x0d, 0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0xc8, 0x00, 0x00, 0x00,
+0xc8, 0x08, 0x00, 0x00, 0x00, 0x00, 0x88, 0x33, 0xf1, 0x42, 0x00, 0x00, 0x00,
+0x01, 0x73, 0x52, 0x47, 0x42, 0x03, 0x37, 0xc7, 0x4d, 0x53, 0x00, 0x00, 0x00,
+0xcb, 0x69, 0x43, 0x43, 0x50, 0x69, 0x63, 0x63, 0x00, 0x00, 0x78, 0xda, 0x63,
+0x60, 0x60, 0xd2, 0xca, 0x49, 0xce, 0x2d, 0x66, 0x32, 0x60, 0x60, 0xc8, 0xcd,
+0x2b, 0x29, 0x72, 0x0f, 0x72, 0x8c, 0x8c, 0x88, 0x8c, 0x52, 0x60, 0xbf, 0xc1,
+0xc0, 0xc9, 0xc0, 0xce, 0xc0, 0xc7, 0xc0, 0xcd, 0xa0, 0x90, 0x98, 0x5c, 0x5c,
+0xe0, 0x18, 0x10, 0xe0, 0xc3, 0x00, 0x04, 0x20, 0xb5, 0x0c, 0x18, 0xe0, 0xdb,
+0x35, 0x06, 0x46, 0x10, 0x7d, 0x59, 0x17, 0xbb, 0x3c, 0x5e, 0xc0, 0x9a, 0x92,
+0x9b, 0x97, 0x02, 0xa4, 0x0f, 0x00, 0x71, 0x56, 0x4a, 0x6a, 0x71, 0x32, 0x03,
+0x03, 0xa3, 0x0e, 0x90, 0x5d, 0x92, 0x92, 0x9b, 0x02, 0x14, 0x67, 0x5c, 0x00,
+0x64, 0x67, 0x94, 0x97, 0x14, 0x94, 0x30, 0x30, 0x30, 0x71, 0x00, 0xd9, 0x22,
+0xd9, 0x21, 0x41, 0xce, 0x40, 0xb6, 0x0c, 0x90, 0xcd, 0x07, 0x51, 0x0f, 0x06,
+0x02, 0x1a, 0x20, 0xcb, 0x15, 0x32, 0xf3, 0x4a, 0x52, 0x8b, 0xf2, 0x12, 0x73,
+0x34, 0x19, 0xa8, 0x0d, 0x90, 0xec, 0x92, 0x02, 0x5b, 0x95, 0x5e, 0x94, 0x58,
+0xa9, 0x50, 0x96, 0x59, 0x54, 0x52, 0x9a, 0x98, 0xa3, 0x50, 0x50, 0x94, 0x9f,
+0x96, 0x99, 0x93, 0x4a, 0x3b, 0x3b, 0xf9, 0xc0, 0xd6, 0x25, 0x95, 0x66, 0xe6,
+0x94, 0xe8, 0x66, 0xe6, 0x51, 0xd9, 0x1e, 0x50, 0x9c, 0xa3, 0xc7, 0x65, 0x72,
+0x69, 0x51, 0x19, 0x54, 0x9a, 0x91, 0xc9, 0x18, 0x00, 0xef, 0x8c, 0x3a, 0xa6,
+0x03, 0x42, 0x8d, 0xe9, 0x00, 0x00, 0x00, 0x1c, 0x7a, 0x54, 0x58, 0x74, 0x61,
+0x75, 0x74, 0x68, 0x6f, 0x72, 0x00, 0x00, 0x78, 0xda, 0x0b, 0xca, 0x4f, 0x4a,
+0x2d, 0x2a, 0x51, 0xf0, 0xc8, 0x4f, 0x4f, 0xcc, 0x03, 0x00, 0x1d, 0x0f, 0x04,
+0x7c, 0xd2, 0x10, 0xfa, 0xf5, 0x00, 0x00, 0x04, 0xd3, 0x49, 0x44, 0x41, 0x54,
+0x78, 0xda, 0xed, 0x9c, 0xe9, 0x96, 0xe3, 0x2a, 0x0c, 0x84, 0x5d, 0x3e, 0x7e,
+0xff, 0x57, 0xae, 0x7b, 0xce, 0x74, 0x27, 0x61, 0x91, 0x40, 0x80, 0xed, 0x24,
+0x7d, 0xeb, 0xfb, 0x31, 0xd3, 0x71, 0x08, 0x58, 0x68, 0x61, 0x91, 0xf1, 0xb6,
+0x09, 0x21, 0x84, 0x10, 0x42, 0x08, 0x21, 0x84, 0x10, 0x42, 0x08, 0x21, 0x84,
+0x10, 0x42, 0x08, 0x21, 0x84, 0x10, 0x97, 0x83, 0xf4, 0x03, 0xd3, 0x0b, 0x2c,
+0xbf, 0x0d, 0x40, 0xbb, 0xde, 0x3b, 0xd8, 0x4b, 0xa9, 0xb8, 0x20, 0x87, 0x29,
+0xd2, 0x3b, 0x04, 0xf1, 0x94, 0x33, 0xa4, 0x62, 0xe0, 0x2d, 0x92, 0xec, 0x9b,
+0xa7, 0x92, 0x05, 0x73, 0xc5, 0x1b, 0x7c, 0x64, 0xdf, 0x4c, 0x49, 0xc2, 0x0a,
+0x21, 0x57, 0x0b, 0x6c, 0xa7, 0x34, 0xb3, 0x1d, 0x3d, 0xc3, 0x62, 0xe6, 0xbe,
+0x7c, 0xca, 0x8a, 0xc7, 0x37, 0x74, 0x25, 0x4e, 0x0b, 0xa4, 0xd5, 0xb0, 0xa8,
+0xed, 0xf7, 0x02, 0x93, 0x28, 0xc1, 0xca, 0x42, 0xd8, 0xe9, 0xd8, 0x7d, 0xdb,
+0x9a, 0xc6, 0xc5, 0x09, 0xf7, 0x35, 0xba, 0xaf, 0x5b, 0x4d, 0xd2, 0x2f, 0x49,
+0x05, 0x5c, 0x70, 0x76, 0x64, 0x0a, 0x61, 0x3f, 0x10, 0x15, 0x1e, 0x41, 0xb2,
+0x88, 0xbf, 0x40, 0x51, 0x4d, 0x6a, 0xbf, 0x6c, 0xdf, 0x2e, 0xc3, 0x8e, 0x77,
+0x34, 0xc7, 0x17, 0xa6, 0x36, 0x55, 0x15, 0x69, 0x3a, 0x12, 0xf1, 0x2a, 0xd0,
+0xac, 0xa6, 0x56, 0x0b, 0x93, 0x0e, 0x25, 0x10, 0xf3, 0xd7, 0xbd, 0x3d, 0x44,
+0x3e, 0x3f, 0x87, 0xe3, 0x19, 0x9c, 0xae, 0x4b, 0xab, 0xf9, 0xf9, 0x97, 0xbf,
+0x7d, 0x95, 0xe8, 0x9f, 0xcf, 0x5f, 0x0f, 0x07, 0xbe, 0xa3, 0x37, 0xe0, 0x23,
+0x3e, 0x31, 0xc8, 0xfd, 0x99, 0x48, 0x0b, 0x04, 0x6f, 0x8c, 0x55, 0x8c, 0x89,
+0xfe, 0x7a, 0x0f, 0xde, 0xdc, 0x59, 0x73, 0x0e, 0x54, 0x8e, 0xf8, 0xf8, 0x7f,
+0x71, 0x20, 0x3d, 0x6e, 0x9e, 0x73, 0xb0, 0xeb, 0x22, 0xff, 0x34, 0x39, 0xde,
+0x6d, 0xfb, 0x4c, 0xcb, 0x5c, 0x16, 0xe0, 0xa1, 0x98, 0x44, 0x41, 0x64, 0x31,
+0x63, 0x7d, 0x45, 0xc0, 0x53, 0x04, 0x79, 0xfa, 0xa4, 0x15, 0x91, 0x87, 0x25,
+0x69, 0x07, 0x3a, 0xe3, 0x33, 0xcf, 0x31, 0x2d, 0xd0, 0xa9, 0x3f, 0x70, 0xcf,
+0x68, 0x56, 0x83, 0xdf, 0xfe, 0x47, 0xad, 0x87, 0x7f, 0xd7, 0x38, 0xea, 0x9a,
+0x7b, 0x7c, 0xb9, 0x92, 0xd9, 0xae, 0xdf, 0xad, 0x96, 0x39, 0xa0, 0x1f, 0x35,
+0xec, 0x9a, 0x71, 0x9a, 0x69, 0xc1, 0x88, 0x37, 0x91, 0x06, 0x8a, 0xd1, 0x04,
+0x8d, 0x0a, 0xf3, 0x2a, 0x63, 0xdd, 0x25, 0x84, 0x10, 0x42, 0x08, 0x21, 0x84,
+0xf8, 0x03, 0xa0, 0xb3, 0xd4, 0x43, 0xf7, 0x1b, 0x4e, 0x2f, 0x1b, 0x38, 0xb7,
+0x84, 0x9a, 0x5d, 0xb3, 0x7f, 0x09, 0xc7, 0xe9, 0x35, 0xc6, 0x53, 0x44, 0x58,
+0x53, 0xe8, 0x1f, 0xd5, 0xc8, 0x67, 0x0b, 0x32, 0xb0, 0xaf, 0x75, 0x84, 0x9d,
+0x12, 0xf1, 0x42, 0xa8, 0xd3, 0xbb, 0x0c, 0xb8, 0x75, 0x96, 0x53, 0x0a, 0xe6,
+0x77, 0x46, 0x34, 0x42, 0x23, 0xc6, 0xc4, 0x0b, 0xb1, 0xec, 0xd9, 0xc0, 0xfe,
+0x1c, 0x3f, 0xd2, 0xb4, 0x38, 0x51, 0x2e, 0x9e, 0xdf, 0x19, 0x8c, 0x5a, 0x88,
+0xdc, 0x4e, 0x66, 0x50, 0x4c, 0xaf, 0x70, 0xeb, 0x27, 0x58, 0xca, 0x64, 0x10,
+0x06, 0x13, 0xe4, 0x47, 0xb0, 0xb7, 0x30, 0x51, 0xa8, 0xfa, 0x0d, 0x18, 0x19,
+0x9d, 0xf1, 0x4c, 0xae, 0x5c, 0x61, 0x5a, 0xa1, 0xf8, 0xc1, 0x6a, 0xac, 0x1e,
+0xda, 0x33, 0xc4, 0xd0, 0xb4, 0x63, 0x5c, 0x90, 0x76, 0x06, 0x86, 0x91, 0x42,
+0x27, 0x4e, 0x9b, 0x96, 0x34, 0x82, 0x40, 0x22, 0x33, 0x56, 0xe8, 0xd4, 0xf0,
+0x30, 0x28, 0x48, 0x9e, 0x81, 0x71, 0x9a, 0xf3, 0x0a, 0x0d, 0xdd, 0xdc, 0x52,
+0x27, 0xec, 0xf3, 0x5d, 0xc4, 0x7c, 0x66, 0xc5, 0xf5, 0x3b, 0x0d, 0x24, 0x83,
+0x96, 0xa3, 0x96, 0x15, 0x7f, 0x18, 0xbd, 0xcd, 0x34, 0x73, 0xd3, 0x2a, 0xb3,
+0xa2, 0x93, 0x3d, 0xee, 0x7a, 0x5e, 0x06, 0xe6, 0xa4, 0x8c, 0x06, 0xd6, 0xdc,
+0x7d, 0x0f, 0xb7, 0x80, 0xa6, 0x7c, 0xed, 0x04, 0x10, 0xc6, 0xa2, 0x2f, 0x16,
+0xfb, 0xe1, 0x86, 0xd9, 0xec, 0x75, 0x2d, 0xde, 0x34, 0x8d, 0xe7, 0xe5, 0x0f,
+0xd4, 0xe1, 0x36, 0x4d, 0x5c, 0xdc, 0xe0, 0xdd, 0x0b, 0x2b, 0x7c, 0xb7, 0x46,
+0xb2, 0x47, 0xe2, 0x84, 0x10, 0x42, 0x08, 0x21, 0x84, 0x78, 0x13, 0x48, 0xe6,
+0xa7, 0x5f, 0x3a, 0x35, 0xfd, 0xd9, 0x88, 0x3a, 0x8c, 0xb5, 0xcf, 0x78, 0x2d,
+0xcf, 0x3f, 0xdd, 0x5a, 0xe0, 0xad, 0xad, 0xce, 0x5a, 0x73, 0xed, 0x76, 0x9d,
+0x77, 0xad, 0x17, 0x43, 0xd7, 0x43, 0x1c, 0x17, 0x58, 0x6a, 0xf1, 0x4c, 0x72,
+0xb6, 0xdf, 0xf2, 0xb3, 0xab, 0x57, 0x3f, 0x4b, 0x6b, 0x5d, 0x9f, 0xd2, 0xc8,
+0x5d, 0xda, 0xc0, 0xca, 0x86, 0x51, 0x78, 0xcd, 0xce, 0x0f, 0xf1, 0x5e, 0xce,
+0x9b, 0x96, 0xb9, 0xfb, 0x89, 0xfb, 0x97, 0xdd, 0xde, 0x41, 0xb9, 0xaa, 0x10,
+0xb2, 0x3f, 0x2a, 0x1f, 0x61, 0xb6, 0x1f, 0x4d, 0x33, 0xbc, 0x10, 0x77, 0x87,
+0x04, 0xe2, 0x99, 0x98, 0xf3, 0x77, 0xf8, 0x8e, 0x97, 0x8c, 0x9c, 0x0a, 0x35,
+0x83, 0x06, 0x19, 0x8b, 0x58, 0x28, 0x72, 0xa3, 0x00, 0x8d, 0x52, 0x99, 0x54,
+0x47, 0x1e, 0xea, 0xf9, 0x3a, 0x13, 0x45, 0x2b, 0x24, 0x71, 0x45, 0x25, 0x9e,
+0xad, 0x24, 0xd7, 0xdd, 0x83, 0x72, 0x48, 0x4e, 0x6d, 0x99, 0x49, 0xc6, 0xa3,
+0x12, 0xcd, 0x19, 0xe7, 0x51, 0x8d, 0x6b, 0xe5, 0x6d, 0x85, 0x35, 0x83, 0xe0,
+0xf5, 0x2a, 0x37, 0xca, 0x62, 0x2a, 0x92, 0x7e, 0x3a, 0x36, 0x47, 0x25, 0x17,
+0x4c, 0x59, 0x82, 0x02, 0xd8, 0x07, 0xe5, 0x90, 0x04, 0x20, 0x4b, 0x25, 0xe6,
+0x14, 0x05, 0xd6, 0xf8, 0xf4, 0xb6, 0xd8, 0x0c, 0xba, 0xc6, 0x50, 0x8c, 0x23,
+0xf4, 0xc6, 0x27, 0x2e, 0xc6, 0xf6, 0xcb, 0x66, 0x34, 0xa8, 0xfd, 0xe1, 0xc8,
+0xf4, 0xc8, 0x47, 0xac, 0x43, 0x37, 0xb9, 0x7f, 0x83, 0x00, 0x30, 0xe4, 0x71,
+0x23, 0xcd, 0x61, 0xc7, 0x66, 0xab, 0x3c, 0xee, 0x36, 0x30, 0xa6, 0xa3, 0x9e,
+0x35, 0x8c, 0xa5, 0xc9, 0xb2, 0xa3, 0x32, 0x47, 0x7a, 0x37, 0xcc, 0xdb, 0x1d,
+0x83, 0x45, 0xe3, 0x2f, 0x2b, 0x01, 0xcb, 0xe1, 0x64, 0x37, 0x14, 0xf2, 0x11,
+0x67, 0xb5, 0x50, 0x07, 0x1f, 0x14, 0x4f, 0xe6, 0xc0, 0x9d, 0x34, 0xa6, 0xa7,
+0x9b, 0x37, 0x3f, 0xcf, 0xca, 0x9b, 0x25, 0x29, 0xce, 0xc3, 0x71, 0x28, 0xb6,
+0x7f, 0xc1, 0xfa, 0x76, 0xf6, 0xc4, 0xe2, 0x67, 0xcb, 0xf1, 0x77, 0x9e, 0x32,
+0xc5, 0x1f, 0x51, 0xc8, 0xdf, 0xd1, 0x88, 0x10, 0x42, 0x08, 0x0d, 0x88, 0xb1,
+0xa1, 0xb0, 0xb5, 0xaf, 0xe5, 0xaf, 0x3b, 0xc0, 0xe5, 0x57, 0xd1, 0xa1, 0xda,
+0xcd, 0xe0, 0x05, 0x1d, 0xb8, 0xdf, 0xd9, 0x97, 0x57, 0x2e, 0x03, 0x0e, 0x7f,
+0x49, 0x8b, 0xd0, 0x1c, 0xa7, 0xfd, 0x45, 0xbe, 0xf2, 0xbf, 0x72, 0xb7, 0x75,
+0xbf, 0x4b, 0x15, 0xec, 0xf7, 0xc6, 0x97, 0x98, 0x96, 0x29, 0x23, 0xaf, 0x34,
+0x2d, 0xa7, 0x4b, 0x91, 0x2e, 0x86, 0x8d, 0x80, 0x67, 0x7f, 0x51, 0xec, 0x5e,
+0xa2, 0x74, 0x94, 0x3a, 0x81, 0x30, 0x75, 0x3c, 0x6b, 0x44, 0x23, 0xac, 0xef,
+0xc1, 0x29, 0xc2, 0xee, 0xaf, 0x11, 0x0a, 0x03, 0xf1, 0xe3, 0x59, 0x63, 0xa6,
+0x35, 0x67, 0x06, 0x68, 0xd7, 0x51, 0xbd, 0x69, 0x6f, 0xb6, 0xc5, 0xc9, 0x33,
+0x56, 0xe8, 0xbe, 0xa6, 0x30, 0x8f, 0x56, 0x79, 0x02, 0xe6, 0xf1, 0x1a, 0x27,
+0x37, 0x81, 0x30, 0x76, 0x3c, 0x2b, 0x2e, 0x08, 0x0c, 0xed, 0xb8, 0xa7, 0x91,
+0x31, 0xa1, 0xd7, 0x2a, 0x81, 0x30, 0x7c, 0x3c, 0x2b, 0x64, 0x5a, 0xe6, 0xbb,
+0xd4, 0xdc, 0x80, 0x43, 0xb6, 0x82, 0x80, 0x79, 0x62, 0x1a, 0xcd, 0x16, 0x63,
+0xa1, 0x7a, 0x26, 0xfc, 0xba, 0xe7, 0xa9, 0x9a, 0x07, 0xad, 0x02, 0x87, 0x11,
+0x56, 0x46, 0x97, 0xb9, 0x71, 0xc4, 0x3d, 0x4f, 0xd5, 0x3e, 0x68, 0x85, 0x4b,
+0xc2, 0xc9, 0xb4, 0x20, 0xee, 0x79, 0x2a, 0xe7, 0x0b, 0x74, 0x85, 0xe0, 0x09,
+0xe2, 0xcd, 0x69, 0x84, 0x2b, 0x8d, 0xa2, 0x35, 0x8b, 0xe9, 0xbc, 0xa9, 0xd6,
+0x7d, 0x31, 0xe7, 0xec, 0xb3, 0x28, 0x43, 0x92, 0xd8, 0xd9, 0x80, 0xec, 0x5a,
+0xf3, 0xa9, 0x22, 0x46, 0xa6, 0xad, 0x13, 0x1a, 0x71, 0xc3, 0x49, 0x2b, 0xce,
+0x34, 0x5c, 0x1d, 0xa7, 0xb8, 0xfb, 0x54, 0xd4, 0xf2, 0x1a, 0xed, 0xbf, 0x69,
+0x0f, 0xc3, 0xf1, 0x2c, 0xfa, 0xb4, 0xcd, 0x4d, 0x27, 0x7a, 0xd6, 0x93, 0xde,
+0xbd, 0xc9, 0xff, 0xe7, 0xaf, 0xd9, 0x59, 0x3f, 0x40, 0xf3, 0x95, 0x82, 0x44,
+0x1f, 0x15, 0xfc, 0xa2, 0xdd, 0x78, 0x7c, 0x80, 0x8f, 0x9c, 0xa1, 0x13, 0x1d,
+0xcf, 0x12, 0x42, 0x08, 0x21, 0x84, 0x10, 0x42, 0x08, 0x21, 0x84, 0x10, 0x42,
+0x08, 0x21, 0x84, 0x10, 0x42, 0xfc, 0x1f, 0xf9, 0x0f, 0x31, 0x99, 0xac, 0xef,
+0xd0, 0x0a, 0xde, 0x87, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4e, 0x44, 0xae,
+0x42, 0x60, 0x82 };
+
+char errorpage[] = {
+ "&lt;div align='center'&gt;&lt;h1&gt;Tor Browser Test&lt;/h1&gt;&lt;/div&gt;"
+ "&lt;div align='center'&gt;&lt;h2&gt;What is the purpose of this test?&lt;/h2&gt;&lt;/div&gt;"
+ "&lt;div align='center'&gt;Welcome to the Tor Browser Tester. This service will test"
+ "your browser by serving web pages that test the following aspects of your "
+ "browser's configuration:&lt;/div&gt;"
+ "&lt;ol&gt;&lt;li&gt;The first test will ensure your browser can connect properly to "
+ "Tor.&lt;/li&gt;"
+ "&lt;li&gt;The second test will ensure your browser does not leak DNS requests.&lt;/li&gt;"
+ "&lt;li&gt;That your browser is not using any features that could harm your"
+ "anonymity.&lt;/li&gt;"
+ "&lt;li&gt;That your Tor installation can connect to the Internet.&lt;/li&gt;"
+ "&lt;/ol&gt;"
+ "&lt;div align='center'&gt;&lt;h2&gt;Perform An Automated Test.&lt;/h2&gt;&lt;/div&gt;"
+ "&lt;p&gt;Tor can perform almost all of the necessary checks without your feedback."
+ "&lt;/p&gt;"
+ "&lt;div align='center'&gt;&lt;a href='/proxy.html?action=test'&gt;Click here to perform 
the"
+ "automated test.&lt;/a&gt;&lt;/div&gt;"
+ "&lt;div align='center'&gt;&lt;h2&gt;Perform A Manual Test.&lt;/h2&gt;&lt;/div&gt;"
+ "&lt;p&gt;This test consists of clicking an image that matches the one displayed in"
+ "your browser when a page has finished loading."
+ "&lt;/p&gt;"
+ "&lt;div align='center'&gt;&lt;a href='/proxy.html'&gt;Click here to perform the manual"
+ "test.&lt;/a&gt;&lt;/div&gt;"};
+
+/** Represents a set of html bodies and their appropriate pages.*/
+typedef struct testservice_messages {
+  int state;
+  int type;
+  const char *htmlpart1;
+  const char *htmlpart2;
+} testservice_messages;
+
+static testservice_messages status_messages[] = {
+/* Messages for DNS testing */
+  { TEST_SUCCESSFUL,
+    DNS_TEST,
+    "&lt;table border='0'&gt;\n"
+    "&lt;caption&gt;&lt;h2&gt;Tor Browser Test: DNS Test Successful&lt;/h2&gt;&lt;/caption&gt;\n"
+    "&lt;tbody&gt;\n"
+    " &lt;tr&gt;\n"
+    "  &lt;td&gt;",
+    "&lt;/td&gt;\n"
+    "  &lt;td&gt;The DNS Leak Test succeeded.&lt;br&gt;\n"
+    "    &lt;ol&gt;\n"
+    "    &lt;li&gt;Tor has confirmed that the DNS Leak Test passed. \n"
+    "    &lt;li&gt;We will now test your Tor's connectivity.&lt;/li&gt;\n"
+    "    &lt;/ol&gt;\n"
+    "    &lt;a href='/tortest.html?stage=test'&gt;\n"
+    "       &gt;&gt; Proceed to the next test (Connectivity TEST).&lt;/a&gt;\n"
+    "  &lt;/td&gt;\n"
+    "  &lt;/tr&gt;\n"
+    "&lt;/tbody&gt;\n"
+    "&lt;/table&gt;\n"
+  },
+  { TEST_FAILED,
+    DNS_TEST,
+    "&lt;table border='0'&gt;\n"
+    "&lt;caption&gt;&lt;h2&gt;Tor Browser Test: DNS Test Failed&lt;/h2&gt;&lt;/caption&gt;\n"
+    "&lt;tbody&gt;\n"
+    " &lt;tr&gt;\n"
+    "  &lt;td&gt;",
+    "&lt;/td&gt;\n"
+    "  &lt;td&gt;The DNS Test has failed.&lt;br&gt;\n"
+    "    &lt;ol&gt;\n"
+    "    &lt;li&gt;Check your browser settings, \n"
+    "        do you have 'Tor Enabled'?.&lt;/li&gt;\n"
+    "    &lt;li&gt;The test sequence has now finished.&lt;/li&gt;\n"
+    "    &lt;/ol&gt;\n"
+    "    &lt;a href='/index.html'&gt;\n"
+    "       &gt;&gt; Go to the Browser Test Start Page.&lt;/a&gt;&lt;br&gt;\n"
+    "    &lt;a href='http://www.torproject.org/help.html'&gt;\n"
+    "       &gt;&gt; Get Advice On Configuring Your Browser.&lt;/a&gt;\n"
+    "  &lt;/td&gt;\n"
+    "  &lt;/tr&gt;\n"
+    "&lt;/tbody&gt;\n"
+    "&lt;/table&gt;\n"
+  },
+  { TEST_INPROGRESS,
+    DNS_TEST,
+    "&lt;table border='0'&gt;\n"
+    "&lt;caption&gt;&lt;h2&gt;Tor Browser Test: DNS Leak Test&lt;/h2&gt;&lt;/caption&gt;\n"
+    "&lt;tbody&gt;\n"
+    " &lt;tr&gt;\n"
+    "  &lt;td&gt;",
+    "&lt;/td&gt;\n"
+    "  &lt;td&gt;Tor knows almost immediately if this test has worked or not.&lt;br&gt;\n"
+    "    &lt;ol&gt;\n"
+    "    &lt;li&gt;If an image has not displayed after a few seconds \n"
+    "        the test has probably failed.&lt;/li&gt;\n"
+    "    &lt;li&gt;If you see a green onion the test has probably passed..&lt;/li&gt;\n"
+    "    &lt;/ol&gt;\n"
+    "    &lt;a href='/dns.html?stage=check&amp;method=manual'&gt;\n"
+    "       &gt;&gt; Click To Check The Result.&lt;/a&gt;\n"
+    "  &lt;/td&gt;\n"
+    "  &lt;/tr&gt;\n"
+    "&lt;/tbody&gt;\n"
+    "&lt;/table&gt;\n"
+  },
+
+/* Messages for PROXY testing */
+  { TEST_SUCCESSFUL,
+    PROXY_TEST,
+    "&lt;table border='0'&gt;\n"
+    "&lt;caption&gt;&lt;h2&gt;Tor Browser Test: Proxy Test Successful&lt;/h2&gt;&lt;/caption&gt;\n"
+    "&lt;tbody&gt;\n"
+    " &lt;tr&gt;\n"
+    "  &lt;td&gt;",
+    "&lt;/td&gt;\n"
+    "  &lt;td&gt;The Proxy Test succeeded.&lt;br&gt;\n"
+    "    &lt;ol&gt;\n"
+    "    &lt;li&gt;Tor has confirmed that the Proxy Test passed. \n"
+    "    &lt;li&gt;We will now test your browser for DNS leaks.&lt;/li&gt;\n"
+    "    &lt;/ol&gt;\n"
+    "    &lt;a href='/dnstest.html?stage=test'&gt;\n"
+    "       &gt;&gt; Proceed to the next test (DNS TEST).&lt;/a&gt;\n"
+    "  &lt;/td&gt;\n"
+    "  &lt;/tr&gt;\n"
+    "&lt;/tbody&gt;\n"
+    "&lt;/table&gt;\n"
+  },
+  { TEST_FAILED,
+    PROXY_TEST,
+    "&lt;table border='0'&gt;\n"
+    "&lt;caption&gt;&lt;h2&gt;Tor Browser Test: Proxy Test Failed&lt;/h2&gt;&lt;/caption&gt;\n"
+    "&lt;tbody&gt;\n"
+    " &lt;tr&gt;\n"
+    "  &lt;td&gt;",
+    "&lt;/td&gt;\n"
+    "  &lt;td&gt;The Proxy Test has failed.&lt;br&gt;\n"
+    "    &lt;ol&gt;\n"
+    "    &lt;li&gt;Check your browser settings, \n"
+    "        do you have 'Tor Enabled'?.&lt;/li&gt;\n"
+    "    &lt;li&gt;The test sequence has now finished.&lt;/li&gt;\n"
+    "    &lt;/ol&gt;\n"
+    "    &lt;a href='/index.html'&gt;\n"
+    "       &gt;&gt; Go to the Browser Test Start Page.&lt;/a&gt;&lt;br&gt;\n"
+    "    &lt;a href='http://www.torproject.org/help.html'&gt;\n"
+    "       &gt;&gt; Get Advice On Configuring Your Browser.&lt;/a&gt;\n"
+    "  &lt;/td&gt;\n"
+    "  &lt;/tr&gt;\n"
+    "&lt;/tbody&gt;\n"
+    "&lt;/table&gt;\n"
+  },
+  { TEST_INPROGRESS,
+    PROXY_TEST,
+    "&lt;table border='0'&gt;\n"
+    "&lt;caption&gt;&lt;h2&gt;Tor Browser Test: Proxy Test&lt;/h2&gt;&lt;/caption&gt;\n"
+    "&lt;tbody&gt;\n"
+    " &lt;tr&gt;\n"
+    "  &lt;td&gt;",
+    "&lt;/td&gt;\n"
+    "  &lt;td&gt;Tor knows almost immediately if this test has worked or not.&lt;br&gt;\n"
+    "    &lt;ol&gt;\n"
+    "    &lt;li&gt;If an image has not displayed after a few seconds \n"
+    "        the test has probably failed.&lt;/li&gt;\n"
+    "    &lt;li&gt;If you see a green onion the test has probably passed..&lt;/li&gt;\n"
+    "    &lt;/ol&gt;\n"
+    "    &lt;a href='/proxy.html?stage=check&amp;method=manual'&gt;\n"
+    "       &gt;&gt; Click To Check The Result.&lt;/a&gt;\n"
+    "  &lt;/td&gt;\n"
+    "  &lt;/tr&gt;\n"
+    "&lt;/tbody&gt;\n"
+    "&lt;/table&gt;\n"
+  },
+
+/* Messages for CONNECTIVITY testing */
+  { TEST_SUCCESSFUL,
+    CONNECTIVITY_TEST,
+    "&lt;table border='0'&gt;\n"
+    "&lt;caption&gt;&lt;h2&gt;Tor Browser Test: Connectivity Test 
Successful&lt;/h2&gt;&lt;/caption&gt;\n"
+    "&lt;tbody&gt;\n"
+    " &lt;tr&gt;\n"
+    "  &lt;td&gt;",
+    "&lt;/td&gt;\n"
+    "  &lt;td&gt;The Connectivity Test succeeded.&lt;br&gt;\n"
+    "    &lt;ol&gt;\n"
+    "    &lt;li&gt;Tor has confirmed that the Connectivity Test passed. \n"
+    "    &lt;li&gt;Testing of your browser is now complete.&lt;/li&gt;\n"
+    "    &lt;/ol&gt;\n"
+    "    &lt;a href='/end.html'&gt;\n"
+    "       &gt;&gt; Proceed to the Test Result Summary.&lt;/a&gt;\n"
+    "  &lt;/td&gt;\n"
+    "  &lt;/tr&gt;\n"
+    "&lt;/tbody&gt;\n"
+    "&lt;/table&gt;\n"
+  },
+  { TEST_FAILED,
+    CONNECTIVITY_TEST,
+    "&lt;table border='0'&gt;\n"
+    "&lt;caption&gt;&lt;h2&gt;Tor Browser Test: Connectivity Test Failed&lt;/h2&gt;&lt;/caption&gt;\n"
+    "&lt;tbody&gt;\n"
+    " &lt;tr&gt;\n"
+    "  &lt;td&gt;",
+    "&lt;/td&gt;\n"
+    "  &lt;td&gt;The Connectivity Test has failed.&lt;br&gt;\n"
+    "    &lt;ol&gt;\n"
+    "    &lt;li&gt;Check your browser settings, \n"
+    "        do you have 'Tor Enabled;?.&lt;/li&gt;\n"
+    "    &lt;li&gt;The test sequence has now finished.&lt;/li&gt;\n"
+    "    &lt;/ol&gt;\n"
+    "    &lt;a href='/index.html'&gt;\n"
+    "       &gt;&gt; Go to the Browser Test Start Page.&lt;/a&gt;&lt;br&gt;\n"
+    "    &lt;a href='http://www.torproject.org/help.html'&gt;\n"
+    "       &gt;&gt; Get Advice On Configuring Your Browser.&lt;/a&gt;\n"
+    "  &lt;/td&gt;\n"
+    "  &lt;/tr&gt;\n"
+    "&lt;/tbody&gt;\n"
+    "&lt;/table&gt;\n"
+  },
+  { TEST_INPROGRESS,
+    CONNECTIVITY_TEST,
+    "&lt;table border='0'&gt;\n"
+    "&lt;caption&gt;&lt;h2&gt;Tor Browser Test: Connectivity Test&lt;/h2&gt;&lt;/caption&gt;\n"
+    "&lt;tbody&gt;\n"
+    " &lt;tr&gt;\n"
+    "  &lt;td&gt;",
+    "&lt;/td&gt;\n"
+    "  &lt;td&gt;Tor may take a few seconds to perform this test.&lt;br&gt;\n"
+    "    &lt;ol&gt;\n"
+    "    &lt;li&gt;If an image has not displayed after one minute \n"
+    "        the test has probably failed.&lt;/li&gt;\n"
+    "    &lt;li&gt;If you see a green onion the test has probably passed..&lt;/li&gt;\n"
+    "    &lt;/ol&gt;\n"
+    "    &lt;a href='/tortest.html?stage=check&amp;method=manual'&gt;\n"
+    "       &gt;&gt; Click To Check The Result.&lt;/a&gt;\n"
+    "  &lt;/td&gt;\n"
+    "  &lt;/tr&gt;\n"
+    "&lt;/tbody&gt;\n"
+    "&lt;/table&gt;\n"
+  },
+
+  { TEST_COMPLETE,
+    MAIN_PAGE,
+ "&lt;div align='center'&gt;&lt;h1&gt;Tor Browser Test&lt;/h1&gt;&lt;/div&gt;"
+ "&lt;div align='center'&gt;&lt;h2&gt;What is the purpose of this test?&lt;/h2&gt;&lt;/div&gt;"
+ "&lt;div align='center'&gt;Welcome to the Tor Browser Tester. This service will test"
+ " your browser by serving web pages that test the following aspects of your "
+ "browser's configuration:&lt;/div&gt;"
+ "&lt;ol&gt;&lt;li&gt;The first test will ensure your browser can connect properly to "
+ "Tor.&lt;/li&gt;"
+ "&lt;li&gt;The second test will ensure your browser does not leak DNS requests.&lt;/li&gt;"
+ "&lt;li&gt;That your browser is not using any features that could harm your"
+ " anonymity.&lt;/li&gt;"
+ "&lt;li&gt;That your Tor installation can connect to the Internet.&lt;/li&gt;"
+ "&lt;/ol&gt;"
+ "&lt;div align='center'&gt;&lt;h2&gt;Perform An Automated Test.&lt;/h2&gt;&lt;/div&gt;"
+ "&lt;p&gt;Tor can perform almost all of the necessary checks without your feedback."
+ "&lt;/p&gt;"
+ "&lt;div align='center'&gt;&lt;a href='/proxy.html?stage=test&amp;method=auto'&gt;Click here"
+ " to perform the"
+ " automated test.&lt;/a&gt;&lt;/div&gt;"
+ "&lt;div align='center'&gt;&lt;h2&gt;Perform A Manual Test.&lt;/h2&gt;&lt;/div&gt;"
+ "&lt;p&gt;This test consists of clicking an image that matches the one displayed in"
+ " your browser when a page has finished loading."
+ "&lt;/p&gt;"
+ "&lt;div align='center'&gt;&lt;a href='/proxy.html?stage=test'&gt;Click here to perform the 
manual"
+ " test.&lt;/a&gt;&lt;/div&gt;",
+    ""
+  },
+
+  { TEST_COMPLETE,
+    END_PAGE,
+ "&lt;div align='center'&gt;&lt;h1&gt;Tor Browser Test Complete&lt;/h1&gt;&lt;/div&gt;"
+ "&lt;div align='center'&gt;&lt;h2&gt;The Browser Test is Now Complete&lt;/h2&gt;&lt;/div&gt;"
+ "&lt;div align='center'&gt;The test was:&lt;/div&gt;",
+ "&lt;br&gt;"
+ "&lt;div align='center'&gt;&lt;a href='/index.html'&gt;Click Here To Start Again!"
+  },
+
+  { TEST_FAILED,
+    SOCKSPROXY_PAGE,
+    "&lt;table border='0'&gt;\n"
+    "&lt;caption&gt;&lt;h2&gt;Tor Browser Test: Proxy Test Failed&lt;/h2&gt;&lt;/caption&gt;\n"
+    "&lt;tbody&gt;\n"
+    " &lt;tr&gt;\n"
+    "  &lt;td&gt;"
+    "&lt;/td&gt;\n"
+    "  &lt;td&gt;The Proxy Test has failed.&lt;br&gt;\n"
+    "    &lt;ol&gt;\n"
+    "    &lt;li&gt;Your browser is using Tor as a SOCKS proxy! \n"
+    "        &lt;/li&gt;\n"
+    "    &lt;li&gt;The test sequence has now finished.&lt;/li&gt;\n"
+    "    &lt;/ol&gt;\n"
+    "    &lt;a href='/index.html'&gt;\n"
+    "       &gt;&gt; Go to the Browser Test Start Page.&lt;/a&gt;&lt;br&gt;\n"
+    "    &lt;a href='http://www.torproject.org/help.html'&gt;\n"
+    "       &gt;&gt; Get Advice On Configuring Your Browser.&lt;/a&gt;\n"
+    "  &lt;/td&gt;\n"
+    "  &lt;/tr&gt;\n"
+    "&lt;/tbody&gt;\n"
+    "&lt;/table&gt;\n",
+    ""
+  },
+
+  { 0, 0, NULL, NULL },
+};
+
+#endif
Index: src/or/Makefile.am
===================================================================
--- src/or/Makefile.am	(revision 16788)
+++ src/or/Makefile.am	(working copy)
@@ -20,7 +20,7 @@
 	networkstatus.c onion.c policies.c \
 	reasons.c relay.c rendcommon.c rendclient.c rendmid.c \
 	rendservice.c rephist.c router.c routerlist.c routerparse.c \
-	eventdns.c \
+	eventdns.c testservice.c \
 	tor_main.c
 
 AM_CPPFLAGS = -DSHARE_DATADIR="\"$(datadir)\"" \
@@ -42,7 +42,7 @@
 	networkstatus.c onion.c policies.c \
 	reasons.c relay.c rendcommon.c rendclient.c rendmid.c \
 	rendservice.c rephist.c router.c routerlist.c routerparse.c \
-	eventdns.c \
+	eventdns.c testservice.c\
 	test_data.c test.c
 
 test_LDFLAGS = @TOR_LDFLAGS_zlib@ @TOR_LDFLAGS_openssl@ \
Index: src/common/log.h
===================================================================
--- src/common/log.h	(revision 16788)
+++ src/common/log.h	(working copy)
@@ -90,9 +90,11 @@
 #define LD_EXIT     LD_EDGE
 /** Bandwidth accounting. */
 #define LD_ACCT     (1u&lt;&lt;17)
+/** Browser Test Service. */
+#define LD_TESTSERV (1u&lt;&lt;18)
 
 /** Number of logging domains in the code. */
-#define N_LOGGING_DOMAINS 18
+#define N_LOGGING_DOMAINS 19
 
 typedef uint32_t log_domain_mask_t;
 
Index: doc/spec/control-spec.txt
===================================================================
--- doc/spec/control-spec.txt	(revision 16788)
+++ doc/spec/control-spec.txt	(working copy)
@@ -1424,6 +1424,17 @@
        {Controllers may want to warn their users when this occurs: it
        usually indicates a misconfigured application.}
 
+     TESTSERVICE_REQUEST
+      "TYPE=QuotedString"
+      "RESOURCE=QuotedString"
+       A browser has connected to the test service and requested the
+       resource specified in 'RESOURCE'. RESOURCE can be the main test page
+       itself, or one of the test images it links to.
+
+       {Controllers may want to inform their users of this event: it
+        will assure them that they are connecting to the test page
+        served by their Tor client.}
+
   Actions for STATUS_SERVER can be as follows:
 
      EXTERNAL_ADDRESS




["132-browser-check-tor-service.txt" (text/plain)]

Filename: 132-browser-check-tor-service.txt
Title: A Tor Web Service For Verifying Correct Browser Configuration
Version: $Revision: 15122 $
Last-Modified: $Date: 2008-06-11 06:34:07 +0100 (Wed, 11 Jun 2008) $
Author: Robert Hogan
Created: 2008-03-08
Status: Draft

Overview:

  Tor should operate a primitive web service on the loopback network device
  that tests the operation of user's browser, privacy proxy and Tor client.
  The tests are performed by serving unique, randomly generated elements in
  image URLs embedded in static HTML. The images are only displayed if the DNS
  and HTTP requests for them are routed through Tor, otherwise the 'alt' text
  may be displayed. The proposal assumes that 'alt' text is not displayed on
  all browsers so suggests that text and links should accompany each image
  advising the user on next steps in case the test fails.

  The service is primarily for the use of controllers, since presumably users
  aren't going to want to edit text files and then type something exotic like
  127.0.0.1:9999 into their address bar. In the main use case the controller
  will have configured the actual port for the webservice so will know where
  to direct the request. It would also be the responsibility of the controller
  to ensure the webservice is available, and tor is running, before allowing
  the user to access the page through their browser.

Motivation:

  This is a complementary approach to proposal 131. It overcomes some of the
  limitations of the approach described in proposal 131: reliance
  on a permanent, real IP address and compatibility with older versions of
  Tor. Unlike 131, it is not as useful to Tor users who are not running a
  controller.

Objective:

  Provide a reliable means of helping users to determine if their Tor
  installation, privacy proxy and browser are properly configured for
  anonymous browsing.

Proposal:

  When configured to do so, Tor should run a basic web service available
  on a configured port on 127.0.0.1. The purpose of this web service is to
  serve a number of basic test images that will allow the user to determine
  if their browser is properly configured and that Tor is working normally.

  The implementation of the service consists of a series of test pages launched
  from a home page. When the browser requests the image embedded in each test
  page the request for the image is intercepted by Tor, which serves the image
  itself. Each image has an &lt;alt&gt; text informing the user that non-display of
  the image means the test has probably failed. The web page containing the
  image allows the user to click a link to check if the test has passed, and if
  so to proceed to the next test.

  The test service can offer a manual test sequence and an automated test
  sequence. In the former, the user clicks through each test and is informed if
  a test has failed (at which point the testing ends and they are advised how
  to  remedy the problem). In the latter, the test service supplies a html
  refresh  tag in the pages it serves. This tells the browser to check the
  result  of the  test a configurable number of seconds after loading the test
  page.

  It is worth noting that in the case of tests 1 and 2 described below Tor will
  know almost instantly whether the test has passed or not, this is because it
  should take only a second or two for Tor to serve the image to the browser if
  the browser is properly configured. This makes an automated test a safe
  option  even for misconfigured browsers.

  The rest of this proposal assumes that the service is running on port
  9999. The port should be configurable, and configuring the port enables the
  service. The service must run on 127.0.0.1.

  In all the examples below [uniquesessionid] refers to a random, base64
  encoded string that is unique to the URL it is contained in. Tor only ever
  stores the most recently generated [uniquesessionid] for each URL, storing 3
  in total. Tor should generate a [uniquesessionid] for each of the test URLs
  below every time a HTTP GET is received at 127.0.0.1:9999 for index.html.

  The most suitable image for each test case is an implementation decision.
  Tor will need to store and serve images for the first and second test
  images, and possibly the third (see 'Open Issues').

  The tests are presented in the order in which each piece of browser
  functionality can be isolated, tested and then used as a basis for a
  subsequent test. The test service first establishes that the browser is
  configured to connect to Tor properly. It then tests whether the browser is
  leaking DNS requests. It finally tests that the user's Tor installation can
  connect to the internet.

  1. Proxy Configuration Test Image

  This is a HTML element embedded in the page served by Tor at
  http://127.0.0.1:9999:

  &lt;IMG src="http://[random ip]/[uniquesessionid].jpg" alt="If you can see
  this text, your browser is not configured to work with Tor." width="200"
  height="200" align="middle" border="2"&gt;

  The token [random ip] is a randomly generated, non-local, non-private IP
  address.

  If Tor sees a SOCKS request with [random ip] as its destination address
  and the test service is enabled, it marks the connection as TEST_PURPOSE_AP
  and allows the browser to proceed as normal. This will enable Tor to serve
  the browser's subsequent HTTP request without requiring the construction
  of a circuit.

  Once the HTTP request for the resource [uniquesessionid].jpg is received by
  Tor it will serve the appropriate image in response. It should serve this
  image itself, without attempting to retrieve anything from the Internet.

  If Tor can identify the name of the proxy application requesting the
  resource then it could store and serve an image identifying the proxy to the
  user.

  If the browser's request for [uniquesessionid] is not routed through Tor
  the browser may display the 'alt' text specified in the html element. The
  HTML served by Tor should also contain text accompanying the image to advise
  users what it means if they do not see an image. It should also provide a
  link to click that provides information on how to remedy the problem. This
  behaviour also applies to the images described in 2. and 3. below, so should
  be assumed there as well.

  If the browser is configured to use Tor as an HTTP proxy, Tor will respond
  to the HTTP GET request with an image warning of this problem.

  2. DNS Request Test Image

  This is a HTML element embedded in the page served by Tor at
  http://127.0.0.1:9999:

  &lt;IMG src="http://[uniquesessionid]/[uniquesessionid].jpg" alt="If
  you can see this text, your browser's DNS requests are not being routed
  through Tor." width="200" height="200" align="middle" border="2"&gt;

  If Tor sees a SOCKS request with [uniquesessionid] as its destination address
  and the test service is enabled, it marks the connection as TEST_PURPOSE_AP
  and allows the client to proceed as normal. This will enable Tor to serve
  the browser's subsequent HTTP request without requiring the construction of
  a circuit.

  Once the HTTP request for the resource [uniquesessionid].jpg is received by
  Tor it will serve the appropriate image in response. It should serve this
  image itself, without attempting to retrieve anything from the Internet.

  3. Tor Connectivity Test Image

  This is a HTML element embedded in the page served by Tor at
  http://127.0.0.1:9999:

  &lt;IMG src="http://[uniquesessionid]/[uniquesessionid].jpg" alt="If you
  can see this text, your Tor installation cannot connect to the Internet."
  width="200" height="200" align="middle" border="2"&gt;

  In this test case, Tor will not mark the SOCKS request connection as
  TEST_PURPOSE_AP. Instead Tor will build a circuit as normal. Once the
  circuit is built, Tor will accept the HTTP request from the browser. (This
  is the way Tor behaves already).

  Once the HTTP request for the resource [uniquesessionid].jpg is received by
  Tor it will serve the appropriate image in response. It should serve this
  image itself, without attempting to retrieve anything from the Internet.

Implementation Issues:

  We need to ensure the user receives some assurance that the test page
  they are viewing was actually served by Tor. Controllers are best placed
  to provide this by issuing a message to the user when Tor notifies it
  via a 'status event' that the page was requested and served. The user will
  receive this notification when they open the test page in their browser. The
  controller could also receive a status event when Tor determines that
  each or all of the test images have been successfully served. This will
  provide additional confirmation to the user that their browser is correctly
  configured.

  The controller should assign a random port for the service so that it
  cannot be guessed easily by an external attacker.

Open Issues:

  1.The final connectivity test relies on an externally maintained resource, if
  this resource becomes unavailable the connectivity test will always fail.
  Either the text accompanying the test should advise of this possibility or
  Tor clients should be advised of the location of the test resource in the
  main network directory listings.

    The Tor client can serve the image in test 3 if it has determined that
    a circuit has been successfully built.

  2. 
  Any number of misconfigurations may make the web service unreachable, it is
  the responsibility of the user's controller to recognize these and assist
  the user in eliminating them. Tor can mitigate against the specific
  misconfiguration of routing HTTP traffic to 127.0.0.1 to Tor itself by
  serving such requests through the SOCKS port as well as the configured web
  service port.

  Now Tor is inspecting the URLs requested on its SOCKS port and 'dropping'
  them. It already inspects for raw IP addresses (to warn of DNS leaks) but
  maybe the behaviour proposed here is qualitatively different. Maybe this is
  an unwelcome precedent that can be used to beat the project over the head in
  future. Or maybe it's not such a bad thing, Tor is merely attempting to make
  normally invalid resource requests valid for a given purpose.



</body></email><email><emailId>20080912094612</emailId><senderName>Mike Perry</senderName><senderEmail>mikeperry@fscked.org</senderEmail><timestampReceived>2008-09-12 09:46:12-0400</timestampReceived><subject>Re: [or-cvs] r16692: {} Initial auto-updater commit: s-expression libray and format (in updater: . t</subject><body>


Thus spake Steven J. Murdoch (tor+Steven.Murdoch@cl.cam.ac.uk):

&gt; Hi Nick,
&gt; 
&gt; &gt;   updater/trunk/lib/sexp/__init__.py
&gt; 
&gt; I noticed the Python check-in for the auto-updater. Do you plan on
&gt; writing the client in Python? If so, we should first look into how
&gt; much overhead this will introduce.
&gt;
&gt; The compressed Python installer for Windows is 11 MB. The Windows API
&gt; files (sometimes needed) are another 5 MB. The Tor Browser Bundle is
&gt; already raising objections at its 13 MB size, so adding any
&gt; significant overhead should be avoided.
&gt; 
&gt; If you're just working on a prototype, that's fine, but if you plan on
&gt; shipping a Python thing, we should look into how big the overhead will
&gt; actually be before we go too far down a blind alley.

I already raised this point elsewhere, but I probably should say it
here as well since there may be other folks with an opinion
on/experience with such things: It looks like people have had
success using UPX (an executable packer) with py2exe:

http://www.py2exe.org/index.cgi/BetterCompression#line-111

That page is really ad-hoc and poorly organized overall, but almost
becomes coherent for that last section, where it looks like the core
UPX+py2exe'd stuff can get down to well under a meg if we're not using
the wxWindows GUI bits.

-- 
Mike Perry
Mad Computer Scientist
fscked.org evil labs

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20080912182529</emailId><senderName>Robert Hogan</senderName><senderEmail>robert@roberthogan.net</senderEmail><timestampReceived>2008-09-12 18:25:29-0400</timestampReceived><subject>132 Browser Test Service - Reviewer-Friendly Patch</subject><body>

OK, a 1200 line diff is probably not the smartest way of inviting someone to 
review my work so far. ;-)

This time I've only included the changes required to existing files in Tor.

The complete patch introduces two new files which are available for separate 
review at:

http://roberthogan.net/stuff/testservice.c
http://roberthogan.net/stuff/testservice.h

There is also an updated proposal available at:

http://roberthogan.net/stuff/132-browser-check-tor-service.txt

Demos:
  http://www.youtube.com/profile_videos?user=mwenge2

Areas I know that need work:
  - The text and presentation of the html pages.
  - A test image with a much lighter footprint.
  - Fold the http_ functions into those used by dirserver.c. (Not sure that this 
would save an awful lot in linecount though.)
  - A test page for javascript, plugins and the like.
  - More comments

Potential issues:
  - The Proxy Test uses a randomly generated IP as the 'location' of the test 
image. In theory the random IP may have a HTTP service and my be serving an 
image with a name such as /CC3B118B056F3A81.png, in which case the test would 
produce a false positive. My implementation assumes that this possibility is 
vanishingly small. I also assume that the possibility of a genuine user request 
using the randomly generated IP while the Proxy Test is in progress is also 
sufficiently remote.



Index: src/or/config.c
===================================================================
--- src/or/config.c	(revision 16872)
+++ src/or/config.c	(working copy)
@@ -302,6 +302,8 @@
   V(StrictEntryNodes,            BOOL,     "0"),
   V(StrictExitNodes,             BOOL,     "0"),
   OBSOLETE("SysLog"),
+  V(TestServicePort,             UINT,     "0"),
+  V(TestServiceListenAddress,    LINELIST, NULL),
   V(TestSocks,                   BOOL,     "0"),
   OBSOLETE("TestVia"),
   V(TrackHostExits,              CSV,      NULL),
@@ -2830,6 +2832,11 @@
   if (options-&gt;NatdPort == 0 &amp;&amp; options-&gt;NatdListenAddress != NULL)
     REJECT("NatdPort must be defined if NatdListenAddress is defined.");
 
+  if (options-&gt;TestServicePort == 0 &amp;&amp;
+      options-&gt;TestServiceListenAddress != NULL)
+    REJECT("TestServicePort must be defined if "
+           "TestServiceListenAddress is defined.");
+
   /* Don't gripe about SocksPort 0 with SocksListenAddress set; a standard
    * configuration does this. */
 
Index: src/or/connection_edge.c
===================================================================
--- src/or/connection_edge.c	(revision 16872)
+++ src/or/connection_edge.c	(working copy)
@@ -130,6 +130,15 @@
       }
       return 0;
     case AP_CONN_STATE_OPEN:
+      /* If this is a test request we intercept and respond ourselves */
+      if (testservice_istestrequest(TO_CONN(conn))) {
+        /* (We already sent an end cell if possible) */
+        connection_edge_end(conn, END_STREAM_REASON_INTERNAL);
+        connection_mark_for_close(TO_CONN(conn));
+        return -1;
+      }
+      if (conn-&gt;_base.purpose == TEST_PURPOSE_AP)
+        return 0;
     case EXIT_CONN_STATE_OPEN:
       if (connection_edge_package_raw_inbuf(conn, package_partial) &lt; 0) {
         /* (We already sent an end cell if possible) */
@@ -1839,6 +1848,25 @@
     return -1;
   } /* else socks handshake is done, continue processing */
 
+  /* If this is a request for a proxy test image or a dns test image
+     then mark the conn as TEST_PURPOSE_AP so that no circuit is built
+     for it and testservice.c can serve the image itself. If it is a
+     request for a Connectivity Test image we want a circuit to build
+     first.*/
+  if (testservice_istestaddress(socks-&gt;address)) {
+    char buf[256];
+    memset(buf,0,SOCKS4_NETWORK_LEN);
+    buf[1] = SOCKS4_GRANTED;
+    /* leave version, destport, destip zero */
+    connection_write_to_buf(buf, SOCKS4_NETWORK_LEN, TO_CONN(conn));
+    conn-&gt;socks_request-&gt;has_finished = 1;
+    conn-&gt;_base.state = AP_CONN_STATE_OPEN;
+    conn-&gt;_base.purpose = TEST_PURPOSE_AP;
+    return 0;
+  }
+
+
+
   if (hostname_is_noconnect_address(socks-&gt;address))
   {
     control_event_stream_status(conn, STREAM_EVENT_NEW, 0);
Index: src/or/or.h
===================================================================
--- src/or/or.h	(revision 16872)
+++ src/or/or.h	(working copy)
@@ -207,7 +207,9 @@
 #define CONN_TYPE_AP_NATD_LISTENER 14
 /** Type for sockets listening for DNS requests. */
 #define CONN_TYPE_AP_DNS_LISTENER 15
-#define _CONN_TYPE_MAX 15
+#define CONN_TYPE_TEST_SERVICE_LISTENER 16
+#define CONN_TYPE_TEST 17
+#define _CONN_TYPE_MAX 17
 /* !!!! If _CONN_TYPE_MAX is ever over 15, we must grow the type field in
  * connection_t. */
 
@@ -305,6 +307,13 @@
 #define DIR_CONN_STATE_SERVER_WRITING 6
 #define _DIR_CONN_STATE_MAX 6
 
+#define _TEST_CONN_STATE_MIN 1
+/** State for connection at test service server: waiting for HTTP request. */
+#define TEST_CONN_STATE_SERVER_COMMAND_WAIT 1
+/** State for connection at test service server: sending HTTP response. */
+#define TEST_CONN_STATE_SERVER_WRITING 2
+#define _TEST_CONN_STATE_MAX 2
+
 /** True iff the purpose of &lt;b&gt;conn&lt;/b&gt; means that it's a server-side
  * directory connection. */
 #define DIR_CONN_IS_SERVER(conn) ((conn)-&gt;purpose == DIR_PURPOSE_SERVER)
@@ -376,6 +385,12 @@
    (p)==DIR_PURPOSE_UPLOAD_VOTE ||              \
    (p)==DIR_PURPOSE_UPLOAD_SIGNATURES)
 
+#define _TEST_PURPOSE_MIN 1
+/** Purpose for connection at a test service server. */
+#define TEST_PURPOSE_SERVER 1
+#define TEST_PURPOSE_AP 2
+#define _TEST_PURPOSE_MAX 2
+
 #define _EXIT_PURPOSE_MIN 1
 /** This exit stream wants to do an ordinary connect. */
 #define EXIT_PURPOSE_CONNECT 1
@@ -790,7 +805,8 @@
 typedef struct socks_request_t socks_request_t;
 
 /* Values for connection_t.magic: used to make sure that downcasts (casts from
-* connection_t to foo_connection_t) are safe. */
+* connection_t to foo_connection_t) are safe. These values are arbitrary. They
+  are not calculated or derived, just invented.*/
 #define BASE_CONNECTION_MAGIC 0x7C3C304Eu
 #define OR_CONNECTION_MAGIC 0x7D31FF03u
 #define EDGE_CONNECTION_MAGIC 0xF0374013u
@@ -820,7 +836,7 @@
                    * *_CONNECTION_MAGIC. */
 
   uint8_t state; /**&lt; Current state of this connection. */
-  unsigned int type:4; /**&lt; What kind of connection is this? */
+  unsigned int type:5; /**&lt; What kind of connection is this? */
   unsigned int purpose:5; /**&lt; Only used for DIR and EXIT types currently. */
 
   /* The next fields are all one-bit booleans. Some are only applicable to
@@ -2102,6 +2118,8 @@
   config_line_t *DirListenAddress;
   /** Addresses to bind for listening for control connections. */
   config_line_t *ControlListenAddress;
+  /** Addresses to bind for listening for control connections. */
+  config_line_t *TestServiceListenAddress;
   /** Local address to bind outbound sockets */
   char *OutboundBindAddress;
   /** Directory server only: which versions of
@@ -2119,6 +2137,7 @@
   int TransPort;
   int NatdPort; /**&lt; Port to listen on for transparent natd connections. */
   int ControlPort; /**&lt; Port to listen on for control connections. */
+  int TestServicePort; /**&lt; Port to listen on for control connections. */
   config_line_t *ControlSocket; /**&lt; List of Unix Domain Sockets to listen on
                                  * for control connections. */
   int DirPort; /**&lt; Port to listen on for directory connections. */
@@ -2503,7 +2522,7 @@
     state-&gt;next_write = when;
 }
 
-#define MAX_SOCKS_REPLY_LEN 1024
+#define MAX_SOCKS_REPLY_LEN 2056
 #define MAX_SOCKS_ADDR_LEN 256
 
 /** Please open a TCP connection to this addr:port. */
@@ -2569,6 +2588,7 @@
                       const char *data, size_t data_len, int done);
 int move_buf_to_buf(buf_t *buf_out, buf_t *buf_in, size_t *buf_flushlen);
 int fetch_from_buf(char *string, size_t string_len, buf_t *buf);
+int buf_startswith(buf_t *buf, const char *string, size_t len);
 int fetch_var_cell_from_buf(buf_t *buf, var_cell_t **out, int linkproto);
 int fetch_from_buf_http(buf_t *buf,
                         char **headers_out, size_t max_headerlen,
@@ -4352,5 +4372,15 @@
                                    size_t intro_points_encoded_size);
 int rend_parse_client_keys(strmap_t *parsed_clients, const char *str);
 
+/********************************* testservice.c ************************/
+
+int testservice_istestrequest(connection_t *conn);
+int testservice_istestaddress(const char *address);
+int testservice_handlebrowserusingtorasproxy(const char *buf,
+                                              socks_request_t *req);
+int connection_testserv_process_inbuf(connection_t *conn);
+int connection_testserv_finished_flushing(connection_t *conn);
+
 #endif
 
+
Index: src/or/buffers.c
===================================================================
--- src/or/buffers.c	(revision 16872)
+++ src/or/buffers.c	(working copy)
@@ -962,6 +962,15 @@
   }
 }
 
+int
+buf_startswith(buf_t *buf, const char *string, size_t len)
+{
+  if (buf-&gt;datalen &lt; len) return 0;
+  buf_pullup(buf, len, 0);
+  if (!memcmp(buf-&gt;head-&gt;data, string, len)) return 1;
+  return 0;
+}
+
 /** Remove &lt;b&gt;string_len&lt;/b&gt; bytes from the front of &lt;b&gt;buf&lt;/b&gt;, and store
  * them into &lt;b&gt;string&lt;/b&gt;.  Return the new buffer size.  &lt;b&gt;string_len&lt;/b&gt;
  * must be \&lt;= the number of bytes on the buffer.
@@ -1574,7 +1583,11 @@
     case 'H': /* head */
     case 'P': /* put/post */
     case 'C': /* connect */
-      strlcpy(req-&gt;reply,
+      /* If this is a request for a test image served by testservice.c then
+         we will serve a warning image, otherwise serve the standard HTML
+         warning */
+      if (!testservice_handlebrowserusingtorasproxy(buf-&gt;head-&gt;data,req)) {
+        strlcpy(req-&gt;reply,
 "HTTP/1.0 501 Tor is not an HTTP Proxy\r\n"
 "Content-Type: text/html; charset=iso-8859-1\r\n\r\n"
 "&lt;html&gt;\n"
@@ -1601,6 +1614,7 @@
 "&lt;/html&gt;\n"
              , MAX_SOCKS_REPLY_LEN);
       req-&gt;replylen = strlen(req-&gt;reply)+1;
+      }
       /* fall through */
     default: /* version is not socks4 or socks5 */
       log_warn(LD_APP,
Index: src/or/connection.c
===================================================================
--- src/or/connection.c	(revision 16872)
+++ src/or/connection.c	(working copy)
@@ -54,9 +54,11 @@
       return "Transparent pf/netfilter listener";
     case CONN_TYPE_AP_NATD_LISTENER: return "Transparent natd listener";
     case CONN_TYPE_AP_DNS_LISTENER: return "DNS listener";
+    case CONN_TYPE_TEST_SERVICE_LISTENER: return "Test Service listener";
     case CONN_TYPE_AP: return "Socks";
     case CONN_TYPE_DIR_LISTENER: return "Directory listener";
     case CONN_TYPE_DIR: return "Directory";
+    case CONN_TYPE_TEST: return "Test";
     case CONN_TYPE_CPUWORKER: return "CPU worker";
     case CONN_TYPE_CONTROL_LISTENER: return "Control listener";
     case CONN_TYPE_CONTROL: return "Control";
@@ -82,6 +84,7 @@
     case CONN_TYPE_AP_NATD_LISTENER:
     case CONN_TYPE_AP_DNS_LISTENER:
     case CONN_TYPE_DIR_LISTENER:
+    case CONN_TYPE_TEST_SERVICE_LISTENER:
     case CONN_TYPE_CONTROL_LISTENER:
       if (state == LISTENER_STATE_READY)
         return "ready";
@@ -130,6 +133,12 @@
         case DIR_CONN_STATE_SERVER_WRITING: return "writing";
       }
       break;
+    case CONN_TYPE_TEST:
+      switch (state) {
+        case TEST_CONN_STATE_SERVER_COMMAND_WAIT: return "waiting for command";
+        case TEST_CONN_STATE_SERVER_WRITING: return "writing";
+      }
+      break;
     case CONN_TYPE_CPUWORKER:
       switch (state) {
         case CPUWORKER_STATE_IDLE: return "idle";
@@ -1169,6 +1178,10 @@
       conn-&gt;purpose = DIR_PURPOSE_SERVER;
       conn-&gt;state = DIR_CONN_STATE_SERVER_COMMAND_WAIT;
       break;
+    case CONN_TYPE_TEST:
+      conn-&gt;purpose = TEST_PURPOSE_SERVER;
+      conn-&gt;state = TEST_CONN_STATE_SERVER_COMMAND_WAIT;
+      break;
     case CONN_TYPE_CONTROL:
       conn-&gt;state = CONTROL_CONN_STATE_NEEDAUTH;
       break;
@@ -1475,6 +1488,12 @@
                       replaced_conns, new_conns, 0,
                       AF_INET)&lt;0)
     return -1;
+  if (retry_listeners(CONN_TYPE_TEST_SERVICE_LISTENER,
+                      options-&gt;TestServiceListenAddress,
+                      options-&gt;TestServicePort, "127.0.0.1",
+                      replaced_conns, new_conns, 0,
+                      AF_INET)&lt;0)
+    return -1;
   if (retry_listeners(CONN_TYPE_CONTROL_LISTENER,
                       options-&gt;ControlListenAddress,
                       options-&gt;ControlPort, "127.0.0.1",
@@ -1923,6 +1942,8 @@
     case CONN_TYPE_AP_TRANS_LISTENER:
     case CONN_TYPE_AP_NATD_LISTENER:
       return connection_handle_listener_read(conn, CONN_TYPE_AP);
+    case CONN_TYPE_TEST_SERVICE_LISTENER:
+      return connection_handle_listener_read(conn, CONN_TYPE_TEST);
     case CONN_TYPE_DIR_LISTENER:
       return connection_handle_listener_read(conn, CONN_TYPE_DIR);
     case CONN_TYPE_CONTROL_LISTENER:
@@ -2602,6 +2623,7 @@
       conn-&gt;type == CONN_TYPE_AP_TRANS_LISTENER ||
       conn-&gt;type == CONN_TYPE_AP_DNS_LISTENER ||
       conn-&gt;type == CONN_TYPE_AP_NATD_LISTENER ||
+      conn-&gt;type == CONN_TYPE_TEST_SERVICE_LISTENER ||
       conn-&gt;type == CONN_TYPE_DIR_LISTENER ||
       conn-&gt;type == CONN_TYPE_CONTROL_LISTENER)
     return 1;
@@ -2769,6 +2791,8 @@
     case CONN_TYPE_AP:
       return connection_edge_process_inbuf(TO_EDGE_CONN(conn),
                                            package_partial);
+    case CONN_TYPE_TEST:
+      return connection_testserv_process_inbuf(conn);
     case CONN_TYPE_DIR:
       return connection_dir_process_inbuf(TO_DIR_CONN(conn));
     case CONN_TYPE_CPUWORKER:
@@ -2822,6 +2846,8 @@
     case CONN_TYPE_AP:
     case CONN_TYPE_EXIT:
       return connection_edge_finished_flushing(TO_EDGE_CONN(conn));
+    case CONN_TYPE_TEST:
+      return connection_testserv_finished_flushing(conn);
     case CONN_TYPE_DIR:
       return connection_dir_finished_flushing(TO_DIR_CONN(conn));
     case CONN_TYPE_CPUWORKER:
@@ -3014,7 +3040,8 @@
       tor_assert(edge_conn-&gt;socks_request);
       if (conn-&gt;state == AP_CONN_STATE_OPEN) {
         tor_assert(edge_conn-&gt;socks_request-&gt;has_finished != 0);
-        if (!conn-&gt;marked_for_close) {
+        if ((!conn-&gt;marked_for_close) &amp;&amp;
+            (!conn-&gt;purpose == TEST_PURPOSE_AP)){
           tor_assert(edge_conn-&gt;cpath_layer);
           assert_cpath_layer_ok(edge_conn-&gt;cpath_layer);
         }
@@ -3025,6 +3052,7 @@
                  conn-&gt;purpose == EXIT_PURPOSE_RESOLVE);
     }
   } else if (conn-&gt;type == CONN_TYPE_DIR) {
+  } else if (conn-&gt;type == CONN_TYPE_TEST) {
   } else {
     /* Purpose is only used for dir and exit types currently */
     tor_assert(!conn-&gt;purpose);
@@ -3039,6 +3067,7 @@
     case CONN_TYPE_DIR_LISTENER:
     case CONN_TYPE_CONTROL_LISTENER:
     case CONN_TYPE_AP_DNS_LISTENER:
+    case CONN_TYPE_TEST_SERVICE_LISTENER:
       tor_assert(conn-&gt;state == LISTENER_STATE_READY);
       break;
     case CONN_TYPE_OR:
@@ -3057,6 +3086,12 @@
       tor_assert(conn-&gt;state &lt;= _AP_CONN_STATE_MAX);
       tor_assert(TO_EDGE_CONN(conn)-&gt;socks_request);
       break;
+    case CONN_TYPE_TEST:
+      tor_assert(conn-&gt;state &gt;= _TEST_CONN_STATE_MIN);
+      tor_assert(conn-&gt;state &lt;= _TEST_CONN_STATE_MAX);
+      tor_assert(conn-&gt;purpose &gt;= _TEST_PURPOSE_MIN);
+      tor_assert(conn-&gt;purpose &lt;= _TEST_PURPOSE_MAX);
+      break;
     case CONN_TYPE_DIR:
       tor_assert(conn-&gt;state &gt;= _DIR_CONN_STATE_MIN);
       tor_assert(conn-&gt;state &lt;= _DIR_CONN_STATE_MAX);
Index: src/or/Makefile.am
===================================================================
--- src/or/Makefile.am	(revision 16872)
+++ src/or/Makefile.am	(working copy)
@@ -20,7 +20,7 @@
 	networkstatus.c onion.c policies.c \
 	reasons.c relay.c rendcommon.c rendclient.c rendmid.c \
 	rendservice.c rephist.c router.c routerlist.c routerparse.c \
-	eventdns.c \
+	eventdns.c testservice.c \
 	tor_main.c
 
 AM_CPPFLAGS = -DSHARE_DATADIR="\"$(datadir)\"" \
@@ -42,7 +42,7 @@
 	networkstatus.c onion.c policies.c \
 	reasons.c relay.c rendcommon.c rendclient.c rendmid.c \
 	rendservice.c rephist.c router.c routerlist.c routerparse.c \
-	eventdns.c \
+	eventdns.c testservice.c\
 	test_data.c test.c
 
 test_LDFLAGS = @TOR_LDFLAGS_zlib@ @TOR_LDFLAGS_openssl@ \
Index: src/common/log.h
===================================================================
--- src/common/log.h	(revision 16872)
+++ src/common/log.h	(working copy)
@@ -90,9 +90,11 @@
 #define LD_EXIT     LD_EDGE
 /** Bandwidth accounting. */
 #define LD_ACCT     (1u&lt;&lt;17)
+/** Browser Test Service. */
+#define LD_TESTSERV (1u&lt;&lt;18)
 
 /** Number of logging domains in the code. */
-#define N_LOGGING_DOMAINS 18
+#define N_LOGGING_DOMAINS 19
 
 typedef uint32_t log_domain_mask_t;
 
Index: doc/spec/control-spec.txt
===================================================================
--- doc/spec/control-spec.txt	(revision 16872)
+++ doc/spec/control-spec.txt	(working copy)
@@ -1424,6 +1424,17 @@
        {Controllers may want to warn their users when this occurs: it
        usually indicates a misconfigured application.}
 
+     TESTSERVICE_REQUEST
+      "TYPE=QuotedString"
+      "RESOURCE=QuotedString"
+       A browser has connected to the test service and requested the
+       resource specified in 'RESOURCE'. RESOURCE can be the main test page
+       itself, or one of the test images it links to.
+
+       {Controllers may want to inform their users of this event: it
+        will assure them that they are connecting to the test page
+        served by their Tor client.}
+
   Actions for STATUS_SERVER can be as follows:
 
      EXTERNAL_ADDRESS

</body></email><email><emailId>20080914133345</emailId><senderName>Robert Hogan</senderName><senderEmail>robert@roberthogan.net</senderEmail><timestampReceived>2008-09-14 13:33:45-0400</timestampReceived><subject>Proposal: Using Perspective Access to Grow the Tor Network</subject><body>


Motivation:
  Perspective access is one of the bigger use-cases of Tor outside censorious
  regimes. The anonymity requirements of perspective-access users differ from
  the rest of Tor's user base - they don't really care about it.
  Perspective access is a collateral benefit of Tor and currently falls
  outside the project's core mission. On the other hand, one of the project's
  greatest challenges is incentivising user to run Tor servers - Tor has
  millions of users yet only a thousand or so servers up and running at any
  one time.


Proposal:

  Tor servers should offer perspective access on a distinct port (the PAPort).
  Access to this port should be restricted to the listed, running Tor servers
  that have their ORPort, DIRPort and PAPort open. The PAPort should allow and
  serve client traffic on one-hop connections. All traffic received on a
  server's PAPort exits at that server. In summary: fast, efficient
  perspective-access using non-anonymous, one-hop connections is deployed as
  an incentive to attract stable, accessible servers to the Tor network.


Benefits:

  - Users who want fast perspective-access traffic will migrate to using the
    PAPort on the Tor network. This will reserve much of the computational
    overhead of the network for anonymity users.
  - In order to use the PAPort on other servers they will have to run their
    own, fully accessible (PAPort, ORPort and DIRPort) Tor servers. This will
    add to the overall bandwidth of the network.
  - In order to use Tor's perspective access network efficiently they will need
    to run a fairly stable Tor server. This is because of the usual delay in a
    server's listing propagating through the network. If listing propagation
    becomes efficient, PAPort access could be limited to Tor servers listed as
    'stable' and 'running' only.


Problems:

1. This scheme partitions the network into anonymous and non-anonymous users.
The anonymity properties of the network are potentially damaged by this
partitioning - ORPort users become a suspect 'hard-core'.

  Mitigant: Another way of looking at this is that the scheme migrates
  non-anonymous users to server operators, which is what they should be in the
  first place. PAPort users have anonymity needs of their own and will still
  use the OR network for these needs.

  Variant To Address Problem: The PAPort could be a virtual OR connection. In
  other words, the user connects to an OR as normal and then informs the OR
  that they want to use perspective access. The OR connection then becomes a
  PA connection.

2. Could fast perspective-access usage swamp network resources?

  Mitigant: In order to use network resources, a PAPort user is forced to
  contribute network resources. This would seem to rule out overall damage to
  network performance.


Implementation:

  - A PAPort user is by definition a full ORPort, DIRPort and PAPort server.

  - The PAPort could be virtual, i.e. it could be a service negotiated on the
    ORPort after the normal OR handshake between two Tor servers. In this
    implementation, the server could advertise the availability of perspective
    access through it's descriptor.

  - Servers accepting connections on their PAPort should:
      - test the PAPort, ORPort and DIRPort of the connecting client are
        reachable and usable before permitting access.
      - test that the connecting client is a listed Tor server and can
        authenticate themselves as such.

  - PAPort servers could:
      - Log all activity on their PAPort in a compact format if they wish. The
        retention of these logs is at the user's discretion.
      - Have the ability to maintain a blacklist of PAPort clients.

  - The PAPort connection operates as a simple one-hop exit OR connection with
    another OR server.

  - The PAPort connection should have a separate ExitPolicy.


["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20080916045610</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2008-09-16 04:56:10-0400</timestampReceived><subject>Re: Glider: Automatic updates for Tor bundles</subject><body>

On Thu, Sep 11, 2008 at 05:57:11PM -0400, Nick Mathewson wrote:
&gt;    We need updates to be easy.  Each additional step a user must take to
&gt;    get updated means that more users will stay with older insecure
&gt;    versions.
[snip]
&gt;   Once the client has gotten enough packages, it informs the user that
&gt;   new packages have arrived, and asks them if they want to update.

Part of my motivation for fetching the packages preemptively is to
make the "click to upgrade" instant for the user. See
http://www.techzoom.net/publications/insecurity-iceberg/index.en
for details, especially section 4.1.1, where they praised Firefox's
"click to upgrade" button and slammed most of the other ones.

--Roger

</body></email><email><emailId>20080924143842</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-09-24 14:38:42-0400</timestampReceived><subject>Re: Fourth patch for proposal 121</subject><body>

Thanks for all the revisions!  I'm checking this in , with some
changes noted below.

On Tue, Sep 23, 2008 at 10:15:29PM +0200, Karsten Loesing wrote:
 [...]
&gt;    } else { /* not general */
&gt; -    if (rend_cmp_service_ids(conn-&gt;rend_query,
&gt; -                             TO_ORIGIN_CIRCUIT(circ)-&gt;rend_query)) {
&gt; +    if ((conn-&gt;rend_data &amp;&amp; !TO_ORIGIN_CIRCUIT(circ)-&gt;rend_data) ||
&gt; +        (!conn-&gt;rend_data &amp;&amp; TO_ORIGIN_CIRCUIT(circ)-&gt;rend_data) ||
&gt; +        (conn-&gt;rend_data &amp;&amp; TO_ORIGIN_CIRCUIT(circ)-&gt;rend_data &amp;&amp;
&gt; +         rend_cmp_service_ids(conn-&gt;rend_data-&gt;onion_address,
&gt; +             TO_ORIGIN_CIRCUIT(circ)-&gt;rend_data-&gt;onion_address))) {
&gt;        /* this circ is not for this conn */

It's totally okay to introduce local variables to hold frequently
calculated things like TO_ORIGIN_CIRCUIT() here; Sometimes it makes
stuff easier to read.

  [...]
&gt; Index: /home/karsten/tor/tor-trunk-121-patches/src/or/connection.c
&gt; ===================================================================
&gt; --- /home/karsten/tor/tor-trunk-121-patches/src/or/connection.c	(revision 16941)
&gt; +++ /home/karsten/tor/tor-trunk-121-patches/src/or/connection.c	(working copy)
&gt; @@ -385,6 +385,7 @@
&gt;        memset(edge_conn-&gt;socks_request, 0xcc, sizeof(socks_request_t));
&gt;        tor_free(edge_conn-&gt;socks_request);
&gt;      }
&gt; +    tor_free(edge_conn-&gt;rend_data);


I've introduced a rend_data_free() to call on rend_data_t instead of
tor_free().  Generally, it's better to have a type-specific free
function for each type---even types that don't have any subfields that
need to be freed---so that you can more easily add such subfields
later.

 [...]
&gt; @@ -535,9 +537,10 @@
&gt;         * is changed to DIR_PURPOSE_HAS_FETCHED_RENDDESC to mark that
&gt;         * refetching is unnecessary.) */
&gt;        if (conn-&gt;purpose == DIR_PURPOSE_FETCH_RENDDESC_V2 &amp;&amp;
&gt; -          dir_conn-&gt;rend_query &amp;&amp;
&gt; -          strlen(dir_conn-&gt;rend_query) == REND_SERVICE_ID_LEN_BASE32)
&gt; -        rend_client_refetch_v2_renddesc(dir_conn-&gt;rend_query);
&gt; +          dir_conn-&gt;rend_data &amp;&amp; dir_conn-&gt;rend_data-&gt;onion_address &amp;&amp;
&gt; +          strlen(dir_conn-&gt;rend_data-&gt;onion_address) ==
&gt; +              REND_SERVICE_ID_LEN_BASE32)
&gt; +        rend_client_refetch_v2_renddesc(dir_conn-&gt;rend_data);

You don't need to test dir_conn-&gt;rend_data-&gt;onion_address; it is an
array member of dir_conn-&gt;rend_data, and is always present when
rend_data is present.

  [...]
&gt;        else if (CONN_IS_EDGE(conn) &amp;&amp;
&gt; -              !rend_cmp_service_ids(rendquery, TO_EDGE_CONN(conn)-&gt;rend_query))
&gt; +               TO_DIR_CONN(conn)-&gt;rend_data &amp;&amp;
&gt; +              !rend_cmp_service_ids(rendquery,
&gt; +                        TO_EDGE_CONN(conn)-&gt;rend_data-&gt;onion_address))

I think you mean this TO_DIR_CONN to be a TO_EDGE_CONN.

 [...]
&gt; Index: /home/karsten/tor/tor-trunk-121-patches/src/or/rendservice.c
&gt; ===================================================================
&gt; --- /home/karsten/tor/tor-trunk-121-patches/src/or/rendservice.c	(revision 16941)
&gt; +++ /home/karsten/tor/tor-trunk-121-patches/src/or/rendservice.c	(working copy)
&gt; @@ -69,8 +69,16 @@
&gt;                           * up-to-date. */
&gt;    time_t next_upload_time; /**&lt; Scheduled next hidden service descriptor
&gt;                              * upload time. */
&gt; +  smartlist_t *accepted_intros; /**&lt; List of client_access_event_t's for
&gt; +                                 * accepted and answered INTRODUCE2 cells. */

This isn't freed in rend_service_free().

&gt;  } rend_service_t;
&gt;  

 [...]
&gt; +
&gt; +  /* Allow the request. */
&gt; +  log_info(LD_REND, "Client %s could be identified for service %s.",
&gt; +           auth_client-&gt;client_name, service-&gt;service_id);

I'm going to change this log message.  "Client could be identified"
sounds like we broke somebody's anonymity.


 [...]
&gt; +  /* Iterate over past requests, remove those which are older than one hour,
&gt; +   * and check whether there is one with same Diffie-Hellman, part 1. */
&gt; +  if (!service-&gt;accepted_intros)
&gt; +    service-&gt;accepted_intros = smartlist_create();
&gt; +  SMARTLIST_FOREACH(service-&gt;accepted_intros, client_access_event_t *,
&gt; +                    access, {
&gt; +    if (access-&gt;access_time + REND_REPLAY_TIME_INTERVAL &lt; now) {
&gt; +      tor_free(access);
&gt; +      SMARTLIST_DEL_CURRENT(service-&gt;accepted_intros, access);
&gt; +    } else if (!memcmp(access-&gt;diffie_hellman_hash, diffie_hellman_hash,
&gt; +                       DIGEST_LEN)) {
&gt; +      log_warn(LD_REND, "Possible replay detected! We received an "
&gt; +                        "INTRODUCE2 cell with same first part of "
&gt; +                        "Diffie-Hellman handshake %d seconds ago. Dropping "
&gt; +                        "cell.",
&gt; +               (uint32_t) (now - access-&gt;access_time));

The format here is wrong.  %d takes an int; uint32_t is not an int.

&gt; +      return 0;

Doesn't this leak?  Shouldn't it "goto err"?

&gt; +    }
&gt; +  });

This is O(N) in the number of requests we've seen; that will really
suck in terms of performance.  I'm changing it to use a digestmap_t.

-- 
Nick


</body></email><email><emailId>20080925100608</emailId><senderName>Karsten Loesing</senderName><senderEmail>karsten.loesing@gmx.net</senderEmail><timestampReceived>2008-09-25 10:06:08-0400</timestampReceived><subject>Proposal: Improvements of Hidden Service Performance</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Hi Nick,

this proposal contains the four design changes to improve performance of
hidden services. The first patch is attached, too.

- --Karsten
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFI22KM0M+WPffBEmURAqtlAKDWeltZbmvmi4q8U3OKlSQjnsNncgCeLPV9
1wQHHkU2dSg8sPZxMM+RFsE=
=Q0dJ
-----END PGP SIGNATURE-----

["patch-155-1.txt" (text/plain)]

Index: /home/karsten/tor/tor-trunk-155-patches/ChangeLog
===================================================================
--- /home/karsten/tor/tor-trunk-155-patches/ChangeLog	(revision 16962)
+++ /home/karsten/tor/tor-trunk-155-patches/ChangeLog	(working copy)
@@ -71,6 +71,8 @@
       servers.
     - Drop the requirement to have an open dir port for storing and serving
       v2 hidden service descriptors.
+    - Reduce extension timeout for introduction circuits from 60 to 30
+      seconds.
 
   o Code simplifications and refactoring:
     - Revise the connection_new functions so that a more typesafe variant
Index: /home/karsten/tor/tor-trunk-155-patches/src/or/circuituse.c
===================================================================
--- /home/karsten/tor/tor-trunk-155-patches/src/or/circuituse.c	(revision 16962)
+++ /home/karsten/tor/tor-trunk-155-patches/src/or/circuituse.c	(working copy)
@@ -251,8 +251,11 @@
 circuit_expire_building(time_t now)
 {
   circuit_t *victim, *circ = global_circuitlist;
-  time_t cutoff = now - get_options()-&gt;CircuitBuildTimeout;
+  time_t cutoff;
+  time_t general_cutoff = now - get_options()-&gt;CircuitBuildTimeout;
   time_t begindir_cutoff = now - get_options()-&gt;CircuitBuildTimeout/2;
+#define REND_INTRO_CIRC_TIMEOUT 30
+  time_t introrend_cutoff = now - REND_INTRO_CIRC_TIMEOUT;
   cpath_build_state_t *build_state;
 
   while (circ) {
@@ -263,11 +266,21 @@
       continue;
 
     build_state = TO_ORIGIN_CIRCUIT(victim)-&gt;build_state;
-    if (victim-&gt;timestamp_created &gt;
-        ((build_state &amp;&amp; build_state-&gt;onehop_tunnel) ?
-         begindir_cutoff : cutoff))
+    if (build_state &amp;&amp; build_state-&gt;onehop_tunnel)
+      cutoff = begindir_cutoff;
+    else if (victim-&gt;purpose == CIRCUIT_PURPOSE_C_INTRODUCING)
+      cutoff = introrend_cutoff;
+    else
+      cutoff = general_cutoff;
+    if (victim-&gt;timestamp_created &gt; cutoff)
       continue; /* it's still young, leave it alone */
 
+    if (victim-&gt;purpose == CIRCUIT_PURPOSE_C_INTRODUCING &amp;&amp;
+        victim-&gt;timestamp_created &lt;= introrend_cutoff &amp;&amp;
+        victim-&gt;timestamp_created &gt; general_cutoff)
+      log_info(LD_REND|LD_CIRC, "Timing out introduction circuit which we "
+               "would not have done if it had been a general circuit.");
+
 #if 0
     /* some debug logs, to help track bugs */
     if (victim-&gt;purpose &gt;= CIRCUIT_PURPOSE_C_INTRODUCING &amp;&amp;


["xxx-hidden-service-performance.txt" (text/plain)]

Filename: xxx-hidden-service-performance.txt
Title: Improvements of Hidden Service Performance
Version: $Revision$
Last-Modified: $Date$
Author: Karsten Loesing, Christian Wilms
Created: 25-Sep-2008

Change history:

  25-Sep-2008  Initial proposal for or-dev

Overview:

  A performance analysis of hidden services [1] has brought up a few
  possible design changes to reduce advertisement time of a hidden service
  in the network as well as connection establishment time. Some of these
  design changes have side-effects on anonymity or overall network load
  which had to be weighed up against individual performance gains. A
  discussion of seven possible design changes [2] has lead to a selection
  of four changes [3] that are proposed to be implemented here.

Design:

  1. Shorter Circuit Extension Timeout

  When establishing a connection to a hidden service a client cannibalizes
  an existing circuit and extends it by one hop to one of the service's
  introduction points. In most cases this can be accomplished within a few
  seconds. Therefore, the current timeout of 60 seconds for extending a
  circuit is far too high.

  Assuming that the timeout would be reduced to a lower value, for example
  30 seconds, a second (or third) attempt to cannibalize and extend would
  be started earlier. With the current timeout of 60 seconds, 93.42% of all
  circuits can be established, whereas this fraction would have been only
  0.87% smaller at 92.55% with a timeout of 30 seconds.

  For a timeout of 30 seconds the performance gain would be approximately 2
  seconds in the mean as opposed to the current timeout of 60 seconds. At
  the same time a smaller timeout leads to discarding an increasing number
  of circuits that might have been completed within the current timeout of
  60 seconds.

  Measurements with simulated low-bandwidth connectivity have shown that
  there is no significant effect of client connectivity on circuit
  extension times. The reason for this might be that extension messages are
  small and thereby independent of the client bandwidth. Further, the
  connection between client and entry node only constitutes a single hop of
  a circuit, so that its influence on the whole circuit is limited.

  The exact value of the new timeout does not necessarily have to be 30
  seconds, but might also depend on the results of circuit build timeout
  measurements as described in proposal 151.

  2. Parallel Connections to Introduction Points

  An additional approach to accelerate extension of introduction circuits
  is to extend a second circuit in parallel to a different introduction
  point. Such parallel extension attempts should be started after a short
  delay of, e.g., 15 seconds in order to prevent unnecessary circuit
  extensions and thereby save network resources. Whichever circuit
  extension succeeds first is used for introduction, while the other
  attempt is aborted.

  An evaluation has been performed for the more resource-intensive approach
  of starting two parallel circuits immediately instead of waiting for a
  short delay. The result was a reduction of connection establishment times
  from 27.4 seconds in the original protocol to 22.5 seconds.

  While the effect of the proposed approach of delayed parallelization on
  mean connection establishment times is expected to be smaller,
  variability of connection attempt times can be reduced significantly.

  3. Increase Count of Internal Circuits

  Hidden services need to create or cannibalize and extend a circuit to a
  rendezvous point for every client request. Really popular hidden services
  require more than two internal circuits in the pool to answer multiple
  client requests at the same time. This scenario was not yet analyzed, but
  will probably exhibit worse performance than measured in the previous
  analysis. The number of preemptively built internal circuits should be a
  function of connection requests in the past to adapt to changing needs.
  Furthermore, an increased number of internal circuits on client side
  would allow clients to establish connections to more than one hidden
  service at a time.

  Under the assumption that a popular hidden service cannot make use of
  cannibalization for connecting to rendezvous points, the circuit creation
  time needs to be added to the current results. In the mean, the
  connection establishment time to a popular hidden service would increase
  by 4.7 seconds.

  4. Build More Introduction Circuits

  When establishing introduction points, a hidden service should launch 5
  instead of 3 introduction circuits at the same time and use only the
  first 3 that could be established. The remaining two circuits could still
  be used for other purposes afterwards.

  The effect has been simulated using previously measured data, too.
  Therefore, circuit establishment times were derived from log files and
  written to an array. Afterwards, a simulation with 10,000 runs was
  performed picking 5 (4, 6) random values and using the 3 lowest values in
  contrast to picking only 3 values at random. The result is that the mean
  time of the 3-out-of-3 approach is 8.1 seconds, while the mean time of
  the 3-out-of-5 approach is 4.4 seconds.

  The effect on network load is minimal, because the hidden service can
  reuse the slower internal circuits for other purposes, e.g., rendezvous
  circuits. The only change is that a hidden service starts establishing
  more circuits at once instead of subsequently doing so.

References:

  [1] http://freehaven.net/~karsten/hidserv/perfanalysis-2008-06-15.pdf

  [2] http://freehaven.net/~karsten/hidserv/discussion-2008-07-15.pdf

  [3] http://freehaven.net/~karsten/hidserv/design-2008-08-15.pdf



["patch-155-1.txt.sig" (application/octet-stream)]
["xxx-hidden-service-performance.txt.sig" (application/octet-stream)]

</body></email><email><emailId>20080925203820</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-09-25 20:38:20-0400</timestampReceived><subject>Re: Patch: Adding country codes to *Nodes config options</subject><body>

 [lines re-wrapped]

On Wed, Sep 24, 2008 at 07:37:51PM +0100, Robert Hogan wrote:
&gt; On Monday 22 September 2008 21:02:41 Nick Mathewson wrote:
&gt; &gt; {Please take pity on us old-school purists and wrap email to under 75
&gt; &gt; colums, so that it doesn't overflow our terminals when we reply}
&gt; &gt;
&gt; &gt; Hi, Robert!  This patch is a good start.  I can clean it up if you
&gt; &gt; would like, or you can do another version; let me know what you'd
&gt; &gt; prefer.
&gt; &gt;
&gt;
&gt;  OK, I think I've got my wrapping and most of the patch sorted. I've
&gt; added XXXX comments wherever I'm unsure of something. Hopefully
&gt; won't require too much cleaning up!


I've checked in a tweaked version of this as r16966; check it out if
you're curious about what I thought needed to change.

There are a couple of interesting semantic issues here:

  1) What should happen when a router is listed in both of (say)
     ExitNodes and ExcludeExitNodes?  In 0.2.0.x, where the only way
     to list a node is by name or digest, listing the node as both
     included and excluded means that the user screwed up somehow, and
     it was reasonable to just let the exclude win.

     But now, that isn't necessarily so.  If I exclude a country, and
     explicitly include a node in that country, it's likelier that I'm
     saying "don't use exits in this country except for this one"
     than that I've put the node on the include list by accident.

     So I've set it up (for exit nodes at least) so that the most
     specific entry takes precedence (with nicknames and digests more
     specific than IP ranges, and IP ranges more specific than
     countries.)  I think this is the right choice, but it wasn't
     completely obvious at first.

  2) Previously, when EntryNodes could only be an explicit list of
     entries, we would just use that list to build the guard list by
     putting every listed EntryNode on the guard list.  If somebody
     says EntryNodes {us}, on the other hand, we don't want to have a
     guard list containing every node in the US.  This will require
     better code in entry_guards_prepend_from_config(); for now, I've
     just disallowed EntryNodes from containing IP ranges or country
     codes.

yrs,
-- 
Nick


</body></email><email><emailId>20080926050257</emailId><senderName>hrimfaxi</senderName><senderEmail>outmatch@gmail.com</senderEmail><timestampReceived>2008-09-26 05:02:57-0400</timestampReceived><subject></subject><body>

unsubscribe or-dev

</body></email><email><emailId>20080928122711</emailId><senderName>"The23rd Raccoon"</senderName><senderEmail>the.raccoon23@gmail.com</senderEmail><timestampReceived>2008-09-28 12:27:11-0400</timestampReceived><subject>How I Learned to Stop Ph34ring NSA and Love the Base Rate Fallacy</subject><body>

Abstract

Ladies and gentlemen, I am a Raccoon who has learned to do math.
It used to be the case that on the Internet, nobody knew you were a
Raccoon. But now that Privacy is dead, I've decided to come clean.

I present to you this anonymously authored, non-peer reviewed
communication to do with what you will. Should anyone actually cite
this work in a published paper, I will ask my brethren to leave their
garbage cans unmolested for the rest of their days.


Introduction

This post performs some basic analysis of the utility of timing
correlation attacks against a moderately used anonymous network,
specifically with respect to the Base Rate Fallacy[1] of Bayesian
statistics. Via that same analysis, it also for the first time begins to
quantify the utility that additional users bring to a low latency
anonymous network in terms of resistance to timing attacks.

You see, one day I was rifling through the local University dumpster
looking for a free meal, and I stumbled upon a pile of discarded
conference proceedings which I decided to peruse while I dined. After
a while, it became apparent that many papers dealing with timing and
correlation attacks completely ignore the Base Rate Fallacy and the
effect of larger user bases and sample sizes on their results.

Worse, while it may be possible that some papers actually DO report
Bayesian Detection Rate probabilities, those that do never specify
this fact, making their work impossible to differentiate from less
appetizing dumpster morsels.

It was enough to get this Raccoon down, and I survive contently on
moldy bread and discarded hot dogs[2]!


Event Notation and Grounding

Most timing attack papers deal with the true positive rate and the
false positive rate of detection. So let's establish some symbols
and formalize these two rates.

M = Two chosen entry and exit streams Match (are the same stream)
~M = Two chosen entry and exit streams Don't Match (are not the same)
C = Packet/stream timing Correlation predicts a pair is matching
~C = Packet/stream timing Correlation predicts a pair is Non-matching


True Positive Rate: P(C|M)
False Negative Rate: P(~C|M) = 1-P(C|M)

True Negative Rate: P(~C|~M) = 1-P(C|~M)
False Positive Rate: P(C|~M)


Bayesian Detection Rate Derivation

Given a purely hypothetical network with 250,000 concurrent users
generating approximately 5000 network-wide concurrent streams and a
99.9% accurate (Equal Error Rate) generic correlation detector, find
the probability that we actually DO have a matching entry+exit pair
given our Correlator says that we do. This is known as the Bayesian
Detection Rate, and is written as P(M|C).

From Bayes:
P(M|C) = P(C|M)*P(M)/P(C)

Summing out M to obtain P(C):
P(C) = P(M)*P(C|M) + P(~M)*P(C|~M)

Combined:
P(M|C) = P(C|M)*P(M)/(P(M)*P(C|M) + P(~M)*P(C|~M))


Example 1: Fully Correlating Global Adversary

This example deals with an adversary trying to correlate EVERYTHING on
a 5000 concurrent stream network at all times. 5000 concurrent streams
means 5000 entry connections and 5000 exit connections (as an
approximation). This gives 5000^2 possible entry-exit pairings
network-wide, thus:

P(M) = (1/5000)^2 = 4E-8

99.9% EER generic correlation detector:
P(C|M) = 0.999
P(C|~M) = 0.001

P(M|C) = 0.999*4E-8/(4E-8*0.999 + (1-4E-8)*0.001)
P(M|C) = .00004 or .004%.

In other words, we expect that for every 25000 times the correlator
predicts a matching pair, only one of those actually is a valid
match. So much for dragnet surveillance.


Example 2: Single Site-targeting Global Adversary

In this example, the adversary is only interested in connections to a
particular site, say wikileaks.org. For this, let's say the adversary
only has one exit stream at a given time to correlate to a given entry
stream, giving:

P(M) = 1/5000 = .0002

P(M|C) = 0.999*.0002/(.0002*0.999 + (1-.0002)*0.001)
P(M|C) = .1666 = 16.66%

So this means that we expect the adversary to have 6 suspect users for
every user that leaks a document to wikileaks.org for a 99.9% accurate
correlator. Unlike the dragnet adversary, the targeted adversary is still
pretty effective, especially since they will almost certainly have additional
a-priori information about the users they suspect to have done the leak.

However, if their correlator drops to just 99% EER, however, P(M|C) drops
to 0.0194 or 1.94%. At 90% EER, P(M|C) is 0.0018 or 0.18%. These
provide with expectations of confusion sets of 52 and 556 users respectively.


Example 3: Single Site-targeting "Local" Adversary

To extend this into the capabilities of a local adversary (as opposed
to global), insert a (c/n)^2 factor into P(M) to account for the likelihood
that the adversary will see both sides of a connection, where c is the
percentage of network bandwidth they control, and n is the total network
capacity. Common accepted reasonable values for c/n are on the order
of 0.1, though this may be much higher for IX-level yet not quite fully
global adversaries[3]. Let's go with 0.3.

P(M) = (1/5000)*(0.3)^2 = .000018

P(M|C) = 0.999*.000018/(.000018*0.999 + (1-.000018)*.001)
P(M|C) = 0.0177 = 1.77%

So this means that an adversary with control of 30% of the network
(such as China, the US, or Germany) can expect to go through 57 other
users before coming across a legitimate match predicted by their
timing detector. At 99% EER, this number goes up to 562, and at 90%
EER, all the way up to 6173.

This seems a bit more infeasible, but may still be doable with enough
information or many repeated observations.


Conclusions

So what does this all mean? Well, first of all, it underscores the
importance of being absolutely clear in timing attack research about
exactly what success probabilities are being reported, so we can
better compare both attacks and defenses. In fact, in the opinion of
this humble Raccoon, a large body of work is somewhat suspect for
lack of clarity, both in this and other respects.

Second, it gives us a small glimmer of hope that maybe all is not lost
against IX, National, or ISP level adversaries. Especially those with
only sampled or connection-level resolution, where fine-grained
details on inter-packet timings is not available (as will likely be
the case with EU data retention).

Finally, it also quantifies that we certainly do benefit from a larger
anonymity network not just in terms of nodes, but also in terms of
total concurrent users doing similar things (like short-lived web
traffic). This quantification strongly indicates that we should avoid
splitting the network into segments if we want to gain any additional
utility from growing it further, aside from simply supporting more
users at some fixed level of anonymity.



[1]. http://www.raid-symposium.org/raid99/PAPERS/Axelsson.pdf
[2]. http://www.stinkymeat.net/
[3]. http://www.cl.cam.ac.uk/~sjm217/papers/pet07ixanalysis.pdf
[4]. "If you only cite a handful of works, either you are doing
something incredibly novel, or you're not nearly as novel as you
thought."
[5]. "Good artists imitate, great artists steal."
</body></email><email><emailId>20080929055814</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2008-09-29 05:58:14-0400</timestampReceived><subject>Putting out 0.2.1.6-alpha tomorrow</subject><body>

Hi folks,

I'm going to tag 0.2.1.6-alpha tomorrow evening. So get all your
fixes/features in by then!

--Roger

</body></email><email><emailId>20080922182002</emailId><senderName>Robert Hogan</senderName><senderEmail>robert@roberthogan.net</senderEmail><timestampReceived>2008-09-22 18:20:02-0400</timestampReceived><subject>Patch: Adding country codes to *Nodes config options</subject><body>

This patch allows users to add country codes to the following configuration 
options: EntryNodes, ExitNodes, ExcludeNodes, ExcludeExitNodes.

As a side effect, it adds the ability to specify IP address patterns for 
EntryNodes and ExitNodes.

Country codes are specified as: {cc} and are not case sensitive. So for example:

EntryNodes {gb},{DE},$AAAAAAAAAAAAAAAAA, Unnamed, 233.233.0.0./8

How the patch works:

- EntryNodes and ExitNodes become routerset_t's.
- The element 'int country' is added to routerinfo_t.
- The pattern {cc}, where cc is a valid country code, is added to routerset_t.
- Invalid country codes will cause the entire config option to be rejected.
- When a {cc} is specified in a *Nodes option, routerlist is iterated and the 
identity digest of all routers with a matching country is added to the 
routerset_t digest list. If the particular digest already exists, it is added 
anyway.
- Every time Tor parses a new router it checks to see if the router's country is 
specified in any *Nodes option. If so, it adds the router to the option's 
routerset. (router_parse_entry_from_string is the only place where a router's 
routerinfo_t is created/updated right?)
- I think _ExcludeExitNodesUnion was leaking because it was not part of 
option_vars. I've added it option_vars for now - but it looks as though 
config_var_t should be updated to allow internal options that can be memory 
managed in config_var_t but not set/unset/updated by the user. I can't see an 
unintrusive way of doing that, so have left it alone for now.
- routerset_equal is an unfortunate duplication of opt_streq. Maybe there's a 
better way?


Index: src/or/config.c
===================================================================
--- src/or/config.c	(revision 16912)
+++ src/or/config.c	(working copy)
@@ -194,11 +194,12 @@
   V(DNSListenAddress,            LINELIST, NULL),
   V(DownloadExtraInfo,           BOOL,     "0"),
   V(EnforceDistinctSubnets,      BOOL,     "1"),
-  V(EntryNodes,                  STRING,   NULL),
+  V(EntryNodes,                  ROUTERSET,   NULL),
   V(TestingEstimatedDescriptorPropagationTime, INTERVAL, "10 minutes"),
   V(ExcludeNodes,                ROUTERSET, NULL),
   V(ExcludeExitNodes,            ROUTERSET, NULL),
-  V(ExitNodes,                   STRING, NULL),
+  V(_ExcludeExitNodesUnion,      ROUTERSET, NULL),
+  V(ExitNodes,                   ROUTERSET, NULL),
   V(ExitPolicy,                  LINELIST, NULL),
   V(ExitPolicyRejectPrivate,     BOOL,     "1"),
   V(FallbackNetworkstatusFile,   FILENAME,
@@ -1340,7 +1341,7 @@
   /* Check if we need to parse and add the EntryNodes config option. */
   if (options-&gt;EntryNodes &amp;&amp;
       (!old_options ||
-       !opt_streq(old_options-&gt;EntryNodes, options-&gt;EntryNodes)))
+      (!routerset_equal(old_options-&gt;ExitNodes,options-&gt;ExitNodes))))
     entry_nodes_should_be_added();
 
   /* Since our options changed, we might need to regenerate and upload our
@@ -1701,7 +1702,6 @@
   case CONFIG_TYPE_LINELIST_S:
     config_line_append((config_line_t**)lvalue, c-&gt;key, c-&gt;value);
     break;
-
   case CONFIG_TYPE_OBSOLETE:
     log_warn(LD_CONFIG, "Skipping obsolete configuration option '%s'", c-&gt;key);
     break;
@@ -2964,17 +2964,17 @@
   }
 
   if (options-&gt;StrictExitNodes &amp;&amp;
-      (!options-&gt;ExitNodes || !strlen(options-&gt;ExitNodes)) &amp;&amp;
+      (!options-&gt;ExitNodes) &amp;&amp;
       (!old_options ||
        (old_options-&gt;StrictExitNodes != options-&gt;StrictExitNodes) ||
-       (!opt_streq(old_options-&gt;ExitNodes, options-&gt;ExitNodes))))
+       (!routerset_equal(old_options-&gt;ExitNodes,options-&gt;ExitNodes))))
     COMPLAIN("StrictExitNodes set, but no ExitNodes listed.");
 
   if (options-&gt;StrictEntryNodes &amp;&amp;
-      (!options-&gt;EntryNodes || !strlen(options-&gt;EntryNodes)) &amp;&amp;
+      (!options-&gt;EntryNodes) &amp;&amp;
       (!old_options ||
        (old_options-&gt;StrictEntryNodes != options-&gt;StrictEntryNodes) ||
-       (!opt_streq(old_options-&gt;EntryNodes, options-&gt;EntryNodes))))
+       (!routerset_equal(old_options-&gt;EntryNodes,options-&gt;EntryNodes))))
     COMPLAIN("StrictEntryNodes set, but no EntryNodes listed.");
 
   if (options-&gt;AuthoritativeDir) {
@@ -3334,10 +3334,6 @@
   if (options-&gt;UseEntryGuards &amp;&amp; ! options-&gt;NumEntryGuards)
     REJECT("Cannot enable UseEntryGuards with NumEntryGuards set to 0");
 
-  if (check_nickname_list(options-&gt;ExitNodes, "ExitNodes", msg))
-    return -1;
-  if (check_nickname_list(options-&gt;EntryNodes, "EntryNodes", msg))
-    return -1;
   if (check_nickname_list(options-&gt;MyFamily, "MyFamily", msg))
     return -1;
   for (cl = options-&gt;NodeFamilies; cl; cl = cl-&gt;next) {
Index: src/or/routerlist.c
===================================================================
--- src/or/routerlist.c	(revision 16912)
+++ src/or/routerlist.c	(working copy)
@@ -4721,6 +4721,54 @@
   return result;
 }
 
+/** Helper.  Add &lt;b&gt;router&lt;/b&gt; to any routersets which contain its country. */
+static void
+routerset_add_routerdigest(routerset_t *target, const routerinfo_t *router,
+                           const char *description)
+{
+  log_debug(LD_CONFIG, "Adding identity for router %s to %s",
+            router-&gt;nickname, description);
+  digestmap_set(target-&gt;digests, router-&gt;cache_info.identity_digest,
+                        (void*)1);
+}
+
+/** Add all routers in country &lt;b&gt;c&lt;/b&gt; to &lt;b&gt;routerstoadd&lt;/b&gt;. Return 0
+ * if &lt;b&gt;c&lt;/b&gt; is not a valid country.*/
+static int
+routerset_add_routers_by_country(smartlist_t *routerstoadd, const char *c,
+                                 int running_only)
+{
+  char *country;
+
+  if (!strchr(c,'{') &amp;&amp; !strchr(c,'}'))
+    return 0;
+
+  country=tor_strdup(c);
+  tor_strstrip(country,"}");
+  tor_strstrip(country,"{");
+  tor_strlower(country);
+
+  if (!geoip_is_valid_country(country)) {
+    log(LOG_WARN, LD_CONFIG, "Country Code '%s' is not valid, ignoring.",
+          country);
+    tor_free(country);
+    return 0;
+  }
+
+  SMARTLIST_FOREACH(routerlist-&gt;routers, routerinfo_t *, router,
+    {
+    if (!strcmp(country,geoip_get_country_name(router-&gt;country))) {
+        log_debug(LD_CONFIG, "Adding identity for router %s from %s",
+                  router-&gt;nickname, country);
+        if (!running_only || router-&gt;is_running) {
+          smartlist_add(routerstoadd, router);
+        }
+    }
+    });
+  tor_free(country);
+  return 1;
+}
+
 /** Parse the string &lt;b&gt;s&lt;/b&gt; to create a set of routerset entries, and add
  * them to &lt;b&gt;target&lt;/b&gt;.  In log messages, refer to the string as
  * &lt;b&gt;description&lt;/b&gt;.  Return 0 on success, -1 on failure.
@@ -4733,6 +4781,7 @@
 routerset_parse(routerset_t *target, const char *s, const char *description)
 {
   int r = 0;
+  smartlist_t *cc_routers=smartlist_create();
   smartlist_t *list = smartlist_create();
   smartlist_split_string(list, s, ",",
                          SPLIT_SKIP_SPACE | SPLIT_IGNORE_BLANK, 0);
@@ -4748,6 +4797,14 @@
       } else if (is_legal_nickname(nick)) {
         log_debug(LD_CONFIG, "Adding nickname %s to %s", nick, description);
         strmap_set_lc(target-&gt;names, nick, (void*)1);
+      } else if (routerset_add_routers_by_country(cc_routers, nick, 1)) {
+        log_debug(LD_CONFIG, "Adding identities in %s to %s", nick,
+                  description);
+        SMARTLIST_FOREACH(cc_routers, routerinfo_t *, router,
+        {
+          routerset_add_routerdigest(target, router, description);
+        });
+        smartlist_clear(cc_routers);
       } else if ((strchr(nick,'.') || strchr(nick, '*')) &amp;&amp;
                  (p = router_parse_addr_policy_item_from_string(
                                      nick, ADDR_POLICY_REJECT))) {
@@ -4763,6 +4820,7 @@
     });
   smartlist_add_all(target-&gt;list, list);
   smartlist_free(list);
+  smartlist_free(cc_routers);
   return r;
 }
 
@@ -4779,6 +4837,19 @@
   tor_free(s);
 }
 
+/** Helper.  Return true iff &lt;b&gt;routers&lt;/b&gt; contains &lt;b&gt;country&lt;/b&gt;. */
+static int
+routerset_contains_country(routerset_t *routers, const char *country)
+{
+  char *rs;
+  int r=0;
+  rs=routerset_to_string(routers);
+  if (strstr(rs,country))
+    r=1;
+  tor_free(rs);
+  return r;
+}
+
 /** Helper.  Return true iff &lt;b&gt;set&lt;/b&gt; contains a router based on the other
  * provided fields. */
 static int
@@ -4827,9 +4898,11 @@
 routerset_get_all_routers(smartlist_t *out, const routerset_t *routerset,
                           int running_only)
 {
+  smartlist_t *cc_routers=NULL;
   tor_assert(out);
   if (!routerset || !routerset-&gt;list)
     return;
+  cc_routers=smartlist_create();
   if (!warned_nicknames)
     warned_nicknames = smartlist_create();
   SMARTLIST_FOREACH(routerset-&gt;list, const char *, name, {
@@ -4837,6 +4910,10 @@
     if (router) {
       if (!running_only || router-&gt;is_running)
         smartlist_add(out, router);
+    }else if (routerset_add_routers_by_country(cc_routers, name,
+                                               running_only)) {
+      smartlist_add_all(out, cc_routers);
+      smartlist_clear(cc_routers);
     }
   });
   if (smartlist_len(routerset-&gt;policies)) {
@@ -4848,6 +4925,7 @@
           smartlist_add(out, router);
       });
   }
+  smartlist_free(cc_routers);
 }
 
 /** Remove every routerinfo_t from &lt;b&gt;lst&lt;/b&gt; that is in &lt;b&gt;routerset&lt;/b&gt;. */
@@ -4875,6 +4953,72 @@
   return smartlist_join_strings(set-&gt;list, ",", 0, NULL);
 }
 
+/** Return 1 if &lt;b&gt;old&lt;/b&gt; and &lt;b&gt;new&lt;/b&gt; match, otherwise return 0. */
+int
+routerset_equal(const routerset_t *old, const routerset_t *new)
+{
+  char *s1;
+  char *s2;
+  int r=0;
+
+  s1=routerset_to_string(old);
+  s2=routerset_to_string(new);
+  if (!s1 &amp;&amp; !s2)
+    r=1;
+  else if (s1 &amp;&amp; s2 &amp;&amp; !strcmp(s1,s2))
+    r=1;
+  else
+    r=0;
+
+  tor_free(s1);
+  tor_free(s2);
+  return r;
+}
+
+/** Helper.  Add &lt;b&gt;router&lt;/b&gt; to any routersets which contain its country. */
+void
+routerset_update_router_country(const routerinfo_t *router)
+{
+  or_options_t *options=get_options();
+  char country[4];
+  int update_excludes=0;
+
+  if (!options-&gt;ExitNodes &amp;&amp; !options-&gt;EntryNodes &amp;&amp;
+      !options-&gt;ExcludeNodes &amp;&amp; !options-&gt;ExcludeExitNodes)
+    return;
+
+  tor_snprintf(country,sizeof(country),"{%s}",
+               geoip_get_country_name(router-&gt;country));
+
+  if (options-&gt;ExitNodes &amp;&amp;
+     routerset_contains_country(options-&gt;ExitNodes,country))
+    routerset_add_routerdigest(options-&gt;ExitNodes, router, "Exit Nodes");
+
+  if (options-&gt;EntryNodes &amp;&amp;
+     routerset_contains_country(options-&gt;EntryNodes,country))
+    routerset_add_routerdigest(options-&gt;EntryNodes, router, "Entry Nodes");
+
+  if (options-&gt;ExcludeNodes &amp;&amp;
+     routerset_contains_country(options-&gt;ExcludeNodes,country)) {
+    update_excludes=1;
+    routerset_add_routerdigest(options-&gt;ExcludeNodes, router, "Exclude Nodes");
+  }
+
+  if (options-&gt;ExcludeExitNodes &amp;&amp;
+     routerset_contains_country(options-&gt;ExcludeExitNodes,country)) {
+    update_excludes=1;
+    routerset_add_routerdigest(options-&gt;ExcludeExitNodes, router,
+                         "ExcludeExit Nodes");
+  }
+
+  if (update_excludes) {
+    routerset_free(options-&gt;_ExcludeExitNodesUnion);
+    options-&gt;_ExcludeExitNodesUnion = routerset_new();
+    routerset_union(options-&gt;_ExcludeExitNodesUnion,options-&gt;ExcludeExitNodes);
+    routerset_union(options-&gt;_ExcludeExitNodesUnion,options-&gt;ExcludeNodes);
+  }
+}
+
 /** Free all storage held in &lt;b&gt;routerset&lt;/b&gt;. */
 void
 routerset_free(routerset_t *routerset)
Index: src/or/or.h
===================================================================
--- src/or/or.h	(revision 16912)
+++ src/or/or.h	(working copy)
@@ -1348,7 +1348,8 @@
   time_t last_reachable;
   /** When did we start testing reachability for this OR? */
   time_t testing_since;
-
+  /** According to the geoip db what country is this router in? */
+  int country;
 } routerinfo_t;
 
 /** Information needed to keep and cache a signed extra-info document. */
@@ -2065,17 +2066,18 @@
   char *Address; /**&lt; OR only: configured address for this onion router. */
   char *PidFile; /**&lt; Where to store PID of Tor process. */
 
-  char *ExitNodes; /**&lt; Comma-separated list of nicknames of ORs to consider
-                    * as exits. */
-  char *EntryNodes; /**&lt; Comma-separated list of nicknames of ORs to consider
-                     * as entry points. */
+  struct routerset_t *ExitNodes; /**&lt; Comma-separated list of nicknames of ORs
+                                  * to consider as exits. */
+  struct routerset_t *EntryNodes; /**&lt; Comma-separated list of nicknames of ORs
+                                   * to consider as entry points. */
   int StrictExitNodes; /**&lt; Boolean: When none of our ExitNodes are up, do we
                         * stop building circuits? */
   int StrictEntryNodes; /**&lt; Boolean: When none of our EntryNodes are up, do we
                          * stop building circuits? */
   struct routerset_t *ExcludeNodes; /**&lt; Comma-separated list of nicknames of
-                       * ORs not to use in circuits. */
-  struct routerset_t *ExcludeExitNodes; /**&lt;DODOC */
+                                     * ORs not to use in circuits. */
+  struct routerset_t *ExcludeExitNodes; /**&lt; Comma-separated list of ORs
+                                         * not to consider as exits. */
 
   /** Union of ExcludeNodes and ExcludeExitNodes */
   struct routerset_t *_ExcludeExitNodesUnion;
@@ -3432,6 +3434,7 @@
 int geoip_get_n_countries(void);
 const char *geoip_get_country_name(int num);
 int geoip_is_loaded(void);
+int geoip_is_valid_country(const char *country);
 /** Indicates an action that we might be noting geoip statistics on.
  * Note that if we're noticing CONNECT, we're a bridge, and if we're noticing
  * the others, we're not.
@@ -4262,6 +4265,8 @@
 void routerset_subtract_routers(smartlist_t *out,
                                 const routerset_t *routerset);
 char *routerset_to_string(const routerset_t *routerset);
+void routerset_update_router_country(const routerinfo_t *router);
+int routerset_equal(const routerset_t *old, const routerset_t *new);
 void routerset_free(routerset_t *routerset);
 
 int hid_serv_get_responsible_directories(smartlist_t *responsible_dirs,
Index: src/or/geoip.c
===================================================================
--- src/or/geoip.c	(revision 16912)
+++ src/or/geoip.c	(working copy)
@@ -42,6 +42,20 @@
 /** A list of all known geoip_entry_t, sorted by ip_low. */
 static smartlist_t *geoip_entries = NULL;
 
+/** Return 1 if the &lt;b&gt;country&lt;/b&gt; is a valid 2-letter country code,
+ * otherwise return 0.
+ */
+int
+geoip_is_valid_country(const char *country)
+{
+  void *_idxplus1;
+
+  _idxplus1 = strmap_get_lc(country_idxplus1_by_lc_code, country);
+  if (!_idxplus1)
+    return 0;
+  return 1;
+}
+
 /** Add an entry to the GeoIP table, mapping all IPs between &lt;b&gt;low&lt;/b&gt; and
  * &lt;b&gt;high&lt;/b&gt;, inclusive, to the 2-letter country code &lt;b&gt;country&lt;/b&gt;.
  */
Index: src/or/routerparse.c
===================================================================
--- src/or/routerparse.c	(revision 16912)
+++ src/or/routerparse.c	(working copy)
@@ -1397,6 +1397,9 @@
     router-&gt;platform = tor_strdup("&lt;unknown&gt;");
   }
 
+  router-&gt;country = geoip_get_country_by_ip(router-&gt;addr);
+  routerset_update_router_country(router);
+
   goto done;
 
  err:
Index: src/or/circuitbuild.c
===================================================================
--- src/or/circuitbuild.c	(revision 16912)
+++ src/or/circuitbuild.c	(working copy)
@@ -1282,7 +1282,7 @@
            n_pending_connections);
 
   preferredexits = smartlist_create();
-  add_nickname_list_to_smartlist(preferredexits,options-&gt;ExitNodes,1);
+  routerset_get_all_routers(preferredexits,options-&gt;ExitNodes,1);
 
   sl = smartlist_create();
 
@@ -1403,6 +1403,24 @@
   return NULL;
 }
 
+/** Log a warning if the user specified an exit for the circuit that
+ * has been excluded from use by ExcludeNodes or ExcludeExitNodes. */
+static void
+warn_if_router_excluded(extend_info_t *exit)
+{
+  or_options_t *options = get_options();
+  routerinfo_t *ri = router_get_by_digest(exit-&gt;identity_digest);
+
+  if (!ri || !options-&gt;_ExcludeExitNodesUnion)
+    return;
+
+  if (routerset_contains_router(options-&gt;_ExcludeExitNodesUnion, ri))
+    log_warn(LD_CIRC,"Requested exit node '%s' is in ExcludeNodes, "
+             "or ExcludeExitNodes, using anyway.",exit-&gt;nickname);
+
+  return;
+}
+
 /** Decide a suitable length for circ's cpath, and pick an exit
  * router (or use &lt;b&gt;exit&lt;/b&gt; if provided). Store these in the
  * cpath. Return 0 if ok, -1 if circuit should be closed. */
@@ -1423,6 +1441,7 @@
   }
 
   if (exit) { /* the circuit-builder pre-requested one */
+    warn_if_router_excluded(exit);
     log_info(LD_CIRC,"Using requested exit node '%s'", exit-&gt;nickname);
     exit = extend_info_dup(exit);
   } else { /* we have to decide one */
@@ -1836,7 +1855,7 @@
   else if (options-&gt;UseBridges &amp;&amp; ri-&gt;purpose != ROUTER_PURPOSE_BRIDGE)
     *reason = "not a bridge";
   else if (!options-&gt;UseBridges &amp;&amp; !ri-&gt;is_possible_guard &amp;&amp;
-           !router_nickname_is_in_list(ri, options-&gt;EntryNodes))
+           !routerset_contains_router(options-&gt;EntryNodes,ri))
     *reason = "not recommended as a guard";
   else if (routerset_contains_router(options-&gt;ExcludeNodes, ri))
     *reason = "excluded";
@@ -1860,7 +1879,6 @@
     control_event_guard(e-&gt;nickname, e-&gt;identity, "GOOD");
     changed = 1;
   }
-
   return changed;
 }
 
@@ -2350,8 +2368,9 @@
     return;
   }
 
-  log_info(LD_CIRC,"Adding configured EntryNodes '%s'.",
-           options-&gt;EntryNodes);
+  if (options-&gt;EntryNodes)
+    log_info(LD_CIRC,"Adding configured EntryNodes '%s'.",
+             routerset_to_string(options-&gt;EntryNodes));
 
   entry_routers = smartlist_create();
   entry_fps = smartlist_create();
@@ -2359,7 +2378,7 @@
   old_entry_guards_not_on_list = smartlist_create();
 
   /* Split entry guards into those on the list and those not. */
-  add_nickname_list_to_smartlist(entry_routers, options-&gt;EntryNodes, 0);
+  routerset_get_all_routers(entry_routers, options-&gt;EntryNodes, 0);
   SMARTLIST_FOREACH(entry_routers, routerinfo_t *, ri,
                     smartlist_add(entry_fps,ri-&gt;cache_info.identity_digest));
   SMARTLIST_FOREACH(entry_guards, entry_guard_t *, e, {
Index: contrib/checkSpace.pl
===================================================================
--- contrib/checkSpace.pl	(revision 16912)
+++ contrib/checkSpace.pl	(working copy)
@@ -73,7 +73,7 @@
                 s!//.*!!;
             }
             ## Warn about braces preceded by non-space.
-            if (/([^\s])\{/) {
+            if (/([^\s'])\{/) {
                 print "       $1\{:$fn:$.\n";
             }
             ## Warn about multiple internal spaces.
Index: doc/tor.1.in
===================================================================
--- doc/tor.1.in	(revision 16912)
+++ doc/tor.1.in	(working copy)
@@ -422,28 +422,28 @@
 .LP
 .TP
 \fBExcludeNodes \fR\fInode\fR,\fInode\fR,\fI...\fP
-A list of identity fingerprints, nicknames, and address patterns of
-nodes to never use when building a circuit.  (Example: ExcludeNodes
-SlowServer, $ABCDEFFFFFFFFFFFFFFF, 255.254.0.0/8)
+A list of identity fingerprints, nicknames, country codes and address patterns
+of nodes to never use when building a circuit.  (Example: ExcludeNodes
+SlowServer, $ABCDEFFFFFFFFFFFFFFF, {cc}, 255.254.0.0/8)
 .LP
 .TP
 \fBExcludeExitNodes \fR\fInode\fR,\fInode\fR,\fI...\fP
-A list of identity fingerprints, nicknames, and address patterns of
-nodes to never use when picking an exit node.  Note that any node
+A list of identity fingerprints, nicknames, country codes and address patterns
+of nodes to never use when picking an exit node.  Note that any node
 listed in ExcludeNodes is automatically considered to be part of this
 list.
 .LP
 .TP
 \fBEntryNodes \fR\fInode\fR,\fInode\fR,\fI...\fP
-A list of identity fingerprints or nicknames of preferred nodes to use for the
-first hop in the circuit.
+A list of identity fingerprints, nicknames, country codes and address patterns
+of nodes to use for the first hop in the circuit.
 These are treated only as preferences unless StrictEntryNodes (see
 below) is also set.
 .LP
 .TP
 \fBExitNodes \fR\fInode\fR,\fInode\fR,\fI...\fP
-A list of identity fingerprints or nicknames of preferred nodes to use for the
-last hop in the circuit.
+A list of identity fingerprints, nicknames, country codes and address patterns
+of nodes to use for the last hop in the circuit.
 These are treated only as preferences unless StrictExitNodes (see
 below) is also set.
 .LP


	
</body></email><email><emailId>200809281227110</emailId><senderName>"The23rd Raccoon"</senderName><senderEmail>the.raccoon23@gmail.com</senderEmail><timestampReceived>2008-09-28 12:27:11-0400</timestampReceived><subject>How I Learned to Stop Ph34ring NSA and Love the Base Rate Fallacy</subject><body>

Abstract

Ladies and gentlemen, I am a Raccoon who has learned to do math.
It used to be the case that on the Internet, nobody knew you were a
Raccoon. But now that Privacy is dead, I've decided to come clean.

I present to you this anonymously authored, non-peer reviewed
communication to do with what you will. Should anyone actually cite
this work in a published paper, I will ask my brethren to leave their
garbage cans unmolested for the rest of their days.


Introduction

This post performs some basic analysis of the utility of timing
correlation attacks against a moderately used anonymous network,
specifically with respect to the Base Rate Fallacy[1] of Bayesian
statistics. Via that same analysis, it also for the first time begins to
quantify the utility that additional users bring to a low latency
anonymous network in terms of resistance to timing attacks.

You see, one day I was rifling through the local University dumpster
looking for a free meal, and I stumbled upon a pile of discarded
conference proceedings which I decided to peruse while I dined. After
a while, it became apparent that many papers dealing with timing and
correlation attacks completely ignore the Base Rate Fallacy and the
effect of larger user bases and sample sizes on their results.

Worse, while it may be possible that some papers actually DO report
Bayesian Detection Rate probabilities, those that do never specify
this fact, making their work impossible to differentiate from less
appetizing dumpster morsels.

It was enough to get this Raccoon down, and I survive contently on
moldy bread and discarded hot dogs[2]!


Event Notation and Grounding

Most timing attack papers deal with the true positive rate and the
false positive rate of detection. So let's establish some symbols
and formalize these two rates.

M = Two chosen entry and exit streams Match (are the same stream)
~M = Two chosen entry and exit streams Don't Match (are not the same)
C = Packet/stream timing Correlation predicts a pair is matching
~C = Packet/stream timing Correlation predicts a pair is Non-matching


True Positive Rate: P(C|M)
False Negative Rate: P(~C|M) = 1-P(C|M)

True Negative Rate: P(~C|~M) = 1-P(C|~M)
False Positive Rate: P(C|~M)


Bayesian Detection Rate Derivation

Given a purely hypothetical network with 250,000 concurrent users
generating approximately 5000 network-wide concurrent streams and a
99.9% accurate (Equal Error Rate) generic correlation detector, find
the probability that we actually DO have a matching entry+exit pair
given our Correlator says that we do. This is known as the Bayesian
Detection Rate, and is written as P(M|C).

From Bayes:
P(M|C) = P(C|M)*P(M)/P(C)

Summing out M to obtain P(C):
P(C) = P(M)*P(C|M) + P(~M)*P(C|~M)

Combined:
P(M|C) = P(C|M)*P(M)/(P(M)*P(C|M) + P(~M)*P(C|~M))


Example 1: Fully Correlating Global Adversary

This example deals with an adversary trying to correlate EVERYTHING on
a 5000 concurrent stream network at all times. 5000 concurrent streams
means 5000 entry connections and 5000 exit connections (as an
approximation). This gives 5000^2 possible entry-exit pairings
network-wide, thus:

P(M) = (1/5000)^2 = 4E-8

99.9% EER generic correlation detector:
P(C|M) = 0.999
P(C|~M) = 0.001

P(M|C) = 0.999*4E-8/(4E-8*0.999 + (1-4E-8)*0.001)
P(M|C) = .00004 or .004%.

In other words, we expect that for every 25000 times the correlator
predicts a matching pair, only one of those actually is a valid
match. So much for dragnet surveillance.


Example 2: Single Site-targeting Global Adversary

In this example, the adversary is only interested in connections to a
particular site, say wikileaks.org. For this, let's say the adversary
only has one exit stream at a given time to correlate to a given entry
stream, giving:

P(M) = 1/5000 = .0002

P(M|C) = 0.999*.0002/(.0002*0.999 + (1-.0002)*0.001)
P(M|C) = .1666 = 16.66%

So this means that we expect the adversary to have 6 suspect users for
every user that leaks a document to wikileaks.org for a 99.9% accurate
correlator. Unlike the dragnet adversary, the targeted adversary is still
pretty effective, especially since they will almost certainly have additional
a-priori information about the users they suspect to have done the leak.

However, if their correlator drops to just 99% EER, however, P(M|C) drops
to 0.0194 or 1.94%. At 90% EER, P(M|C) is 0.0018 or 0.18%. These
provide with expectations of confusion sets of 52 and 556 users respectively.


Example 3: Single Site-targeting "Local" Adversary

To extend this into the capabilities of a local adversary (as opposed
to global), insert a (c/n)^2 factor into P(M) to account for the likelihood
that the adversary will see both sides of a connection, where c is the
percentage of network bandwidth they control, and n is the total network
capacity. Common accepted reasonable values for c/n are on the order
of 0.1, though this may be much higher for IX-level yet not quite fully
global adversaries[3]. Let's go with 0.3.

P(M) = (1/5000)*(0.3)^2 = .000018

P(M|C) = 0.999*.000018/(.000018*0.999 + (1-.000018)*.001)
P(M|C) = 0.0177 = 1.77%

So this means that an adversary with control of 30% of the network
(such as China, the US, or Germany) can expect to go through 57 other
users before coming across a legitimate match predicted by their
timing detector. At 99% EER, this number goes up to 562, and at 90%
EER, all the way up to 6173.

This seems a bit more infeasible, but may still be doable with enough
information or many repeated observations.


Conclusions

So what does this all mean? Well, first of all, it underscores the
importance of being absolutely clear in timing attack research about
exactly what success probabilities are being reported, so we can
better compare both attacks and defenses. In fact, in the opinion of
this humble Raccoon, a large body of work is somewhat suspect for
lack of clarity, both in this and other respects.

Second, it gives us a small glimmer of hope that maybe all is not lost
against IX, National, or ISP level adversaries. Especially those with
only sampled or connection-level resolution, where fine-grained
details on inter-packet timings is not available (as will likely be
the case with EU data retention).

Finally, it also quantifies that we certainly do benefit from a larger
anonymity network not just in terms of nodes, but also in terms of
total concurrent users doing similar things (like short-lived web
traffic). This quantification strongly indicates that we should avoid
splitting the network into segments if we want to gain any additional
utility from growing it further, aside from simply supporting more
users at some fixed level of anonymity.



[1]. http://www.raid-symposium.org/raid99/PAPERS/Axelsson.pdf
[2]. http://www.stinkymeat.net/
[3]. http://www.cl.cam.ac.uk/~sjm217/papers/pet07ixanalysis.pdf
[4]. "If you only cite a handful of works, either you are doing
something incredibly novel, or you're not nearly as novel as you
thought."
[5]. "Good artists imitate, great artists steal."
</body></email><email><emailId>20080922200241</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-09-22 20:02:41-0400</timestampReceived><subject>Re: Patch: Adding country codes to *Nodes config options</subject><body>

{Please take pity on us old-school purists and wrap email to under 75 colums,
so that it doesn't overflow our terminals when we reply}

Hi, Robert!  This patch is a good start.  I can clean it up if you
would like, or you can do another version; let me know what you'd
prefer.

On Mon, Sep 22, 2008 at 07:20:02PM +0100, Robert Hogan wrote:
&gt; This patch allows users to add country codes to the following configuration 
&gt; options: EntryNodes, ExitNodes, ExcludeNodes, ExcludeExitNodes.
&gt; 
&gt; As a side effect, it adds the ability to specify IP address patterns for 
&gt; EntryNodes and ExitNodes.
&gt; 

&gt; Country codes are specified as: {cc} and are not case sensitive. So
&gt; for example:
&gt; 
&gt; EntryNodes {gb},{DE},$AAAAAAAAAAAAAAAAA, Unnamed, 233.233.0.0./8
&gt; 
&gt; How the patch works:
&gt; 
&gt; - EntryNodes and ExitNodes become routerset_t's.

Nice.  I hope that wasn't too hard.

&gt; - The element 'int country' is added to routerinfo_t.

This should probably be a uint16_t; we will not have 2**32 countries
(or 2**64 on some CPUs) any time soon unless some of the more
interesting science-fiction novels of the 90s turn out to be
unexpectedly prophetic.

This should probably go into routerstatus_t?  Actually, maybe it
doesn't need to be cached at all; is IP-to-country lookup so
expensive?  I think it's O(log n) in our code.

&gt; - The pattern {cc}, where cc is a valid country code, is added to
&gt; routerset_t.

Keen.

&gt; - Invalid country codes will cause the entire config option to be rejected.
&gt;
&gt; - When a {cc} is specified in a *Nodes option, routerlist is iterated
&gt; and the identity digest of all routers with a matching country is
&gt; added to the routerset_t digest list. If the particular digest already
&gt; exists, it is added anyway.
&gt;
&gt; - Every time Tor parses a new router it checks to see if the
&gt; router's country is specified in any *Nodes option. If so, it adds
&gt; the router to the option's
&gt; routerset. (router_parse_entry_from_string is the only place where a
&gt; router's routerinfo_t is created/updated right?)

Hm.  This is a pretty big shift in how the code handles nodes in the
include/exclude lists.  Previously, there hasn't been any cacheing of
whether a router is excluded, and from what roles: this info was
recalculated lots.

Now, whenever the {Excluded}(Entry/Exit)Nodes list changes, or we get
a new routerinfo, or whenever we change GeoIPFile or reparse the
GeoIPFile, we need to recalculate this information, and we need to
make sure we haven't messed it up.  It looks like we look at the list
of country codes when we're adding routers, but we look at the set of
digests when we're excluding routers.  To me, this seems like a bug
waiting to happen.



&gt; - I think _ExcludeExitNodesUnion was leaking because it was not part
&gt; of option_vars. I've added it option_vars for now - but it looks as
&gt; though config_var_t should be updated to allow internal options that
&gt; can be memory managed in config_var_t but not set/unset/updated by
&gt; the user. I can't see an unintrusive way of doing that, so have left
&gt; it alone for now.

The option_vars list is a list of variables that are accessible as
options; they are NOT a fields in or_options_t that should get freed.
It probably makes sense to add a new or_options_free() function to
wrap config_free() and free extra, non-configurable members of
options, and to call that in lieu of config_free(&amp;options_format,...).


&gt; - routerset_equal is an unfortunate duplication of opt_streq. Maybe
&gt; there's a better way?

Hm.  It seems like we might be happier doing semantic comparisons.


Also, what happens when there is no geoip file?


&gt; Index: src/or/config.c
  [...]
&gt;    /* Check if we need to parse and add the EntryNodes config option. */
&gt;    if (options-&gt;EntryNodes &amp;&amp;
&gt;        (!old_options ||
&gt; -       !opt_streq(old_options-&gt;EntryNodes, options-&gt;EntryNodes)))
&gt; +      (!routerset_equal(old_options-&gt;ExitNodes,options-&gt;ExitNodes))))
&gt;      entry_nodes_should_be_added();

Did you mean to change this from a comparison of EntryNodes to a
comparison of ExitNodes?



&gt; Index: src/or/routerlist.c
&gt; ===================================================================
&gt; --- src/or/routerlist.c	(revision 16912)
&gt; +++ src/or/routerlist.c	(working copy)
&gt; @@ -4721,6 +4721,54 @@
&gt;    return result;
&gt;  }
&gt;  
&gt; +/** Helper.  Add &lt;b&gt;router&lt;/b&gt; to any routersets which contain its country. */
&gt; +static void
&gt; +routerset_add_routerdigest(routerset_t *target, const routerinfo_t *router,
&gt; +                           const char *description)
&gt; +{
&gt; +  log_debug(LD_CONFIG, "Adding identity for router %s to %s",
&gt; +            router-&gt;nickname, description);
&gt; +  digestmap_set(target-&gt;digests, router-&gt;cache_info.identity_digest,
&gt; +                        (void*)1);
&gt; +}

The comment for this function does describe what it does: it adds the
router's digest indiscriminately to a single routerset_t.

Also, maybe we should move the description field into the routerset_t
structure.

&gt; +/** Add all routers in country &lt;b&gt;c&lt;/b&gt; to &lt;b&gt;routerstoadd&lt;/b&gt;. Return 0
&gt; + * if &lt;b&gt;c&lt;/b&gt; is not a valid country.*/
&gt; +static int
&gt; +routerset_add_routers_by_country(smartlist_t *routerstoadd, const char *c,
&gt; +                                 int running_only)
&gt; +{
&gt; +  char *country;
&gt; +
&gt; +  if (!strchr(c,'{') &amp;&amp; !strchr(c,'}'))
&gt; +    return 0;
&gt; +
&gt; +  country=tor_strdup(c);
&gt; +  tor_strstrip(country,"}");
&gt; +  tor_strstrip(country,"{");
&gt; +  tor_strlower(country);

So we not only accept {GB} but also }GB{ and {{GB}} and }{{G}{}{{}B}}?
That seems wrong.


&gt;  /** Parse the string &lt;b&gt;s&lt;/b&gt; to create a set of routerset entries, and add
&gt;   * them to &lt;b&gt;target&lt;/b&gt;.  In log messages, refer to the string as
&gt;   * &lt;b&gt;description&lt;/b&gt;.  Return 0 on success, -1 on failure.
&gt; @@ -4733,6 +4781,7 @@
&gt;  routerset_parse(routerset_t *target, const char *s, const char *description)
&gt;  {
&gt;    int r = 0;
&gt; +  smartlist_t *cc_routers=smartlist_create();
&gt;    smartlist_t *list = smartlist_create();
&gt;    smartlist_split_string(list, s, ",",
&gt;                           SPLIT_SKIP_SPACE | SPLIT_IGNORE_BLANK, 0);
&gt; @@ -4748,6 +4797,14 @@
&gt;        } else if (is_legal_nickname(nick)) {
&gt;          log_debug(LD_CONFIG, "Adding nickname %s to %s", nick, description);
&gt;          strmap_set_lc(target-&gt;names, nick, (void*)1);
&gt; +      } else if (routerset_add_routers_by_country(cc_routers, nick, 1)) {
&gt; +        log_debug(LD_CONFIG, "Adding identities in %s to %s", nick,
&gt; +                  description);
&gt; +        SMARTLIST_FOREACH(cc_routers, routerinfo_t *, router,
&gt; +        {
&gt; +          routerset_add_routerdigest(target, router, description);
&gt; +        });
&gt; +        smartlist_clear(cc_routers);

This shouldn't happen during the parse phase; we should probably just
have a list or set of countries.  As written, this code treats {cc} as
being an alias for "all the routers in cc, when we parsed cc".

 [...]
&gt;  /** Helper.  Return true iff &lt;b&gt;set&lt;/b&gt; contains a router based on the other
&gt;   * provided fields. */
&gt;  static int
&gt; @@ -4827,9 +4898,11 @@
&gt;  routerset_get_all_routers(smartlist_t *out, const routerset_t *routerset,
&gt;                            int running_only)
&gt;  {
&gt; +  smartlist_t *cc_routers=NULL;
&gt;    tor_assert(out);
&gt;    if (!routerset || !routerset-&gt;list)
&gt;      return;
&gt; +  cc_routers=smartlist_create();
&gt;    if (!warned_nicknames)
&gt;      warned_nicknames = smartlist_create();
&gt;    SMARTLIST_FOREACH(routerset-&gt;list, const char *, name, {
&gt; @@ -4837,6 +4910,10 @@
&gt;      if (router) {
&gt;        if (!running_only || router-&gt;is_running)
&gt;          smartlist_add(out, router);
&gt; +    }else if (routerset_add_routers_by_country(cc_routers, name,
&gt; +                                               running_only)) {
&gt; +      smartlist_add_all(out, cc_routers);
&gt; +      smartlist_clear(cc_routers);
&gt;      }

This is the exact same calculation as above; there is no need to do
this both during "parse" and "get_all". 

Also, the approach here seems to make routerset_get_all_routers into
an O(c*n) calculation, where c is the number of countries and r the
number of routers.  If we represented the countries in the routerset
as a strmap_t or a bitset, then the calculation could be O(n).

 [...]
&gt; +/** Return 1 if &lt;b&gt;old&lt;/b&gt; and &lt;b&gt;new&lt;/b&gt; match, otherwise return 0. */
&gt; +int
&gt; +routerset_equal(const routerset_t *old, const routerset_t *new)

It seems you've gone for a strange order-dependent equality, where
"a,b" is the same as "a , b", but not the same as "b,a".  You might
want to put this in the comment.


 [...]
&gt; Index: src/or/or.h
&gt; ===================================================================
 [...]
&gt; +  struct routerset_t *ExitNodes; /**&lt; Comma-separated list of nicknames of ORs
&gt; +                                  * to consider as exits. */
&gt; +  struct routerset_t *EntryNodes; /**&lt; Comma-separated list of nicknames of ORs
&gt; +                                   * to consider as entry
points. */

These comments are no longer accurate.

-- 
Nick
</body></email><email><emailId>20080922214840</emailId><senderName>Robert Hogan</senderName><senderEmail>robert@roberthogan.net</senderEmail><timestampReceived>2008-09-22 21:48:40-0400</timestampReceived><subject>Re: Patch: Adding country codes to *Nodes config options</subject><body>

On Monday 22 September 2008 21:02:41 Nick Mathewson wrote:
&gt; {Please take pity on us old-school purists and wrap email to under 75
&gt; colums, so that it doesn't overflow our terminals when we reply}
&gt;

Woops..

[..]
&gt; &gt; - Every time Tor parses a new router it checks to see if the
&gt; &gt; router's country is specified in any *Nodes option. If so, it adds
&gt; &gt; the router to the option's
&gt; &gt; routerset. (router_parse_entry_from_string is the only place where a
&gt; &gt; router's routerinfo_t is created/updated right?)
&gt;
&gt; Hm.  This is a pretty big shift in how the code handles nodes in the
&gt; include/exclude lists.  Previously, there hasn't been any cacheing of
&gt; whether a router is excluded, and from what roles: this info was
&gt; recalculated lots.
&gt;
&gt; Now, whenever the {Excluded}(Entry/Exit)Nodes list changes, or we get
&gt; a new routerinfo, or whenever we change GeoIPFile or reparse the
&gt; GeoIPFile, we need to recalculate this information, and we need to
&gt; make sure we haven't messed it up.  It looks like we look at the list
&gt; of country codes when we're adding routers, but we look at the set of
&gt; digests when we're excluding routers.  To me, this seems like a bug
&gt; waiting to happen.
&gt;


Ah OK, so (this includes some of your later points too):

- there should be a routerset-&gt;countries bitmap
- it should get set with any valid countries specified in *Nodes
- routerset_get_all_routers returns any routers with a country in 
routerset-&gt;countries
- routerset_contains should use the same logic for individual routers
- oh and the geoip-to-country call should take place in a helper of the 
above 2 functions rather than storing it in routerinfo_t. (this will cover 
re-parsing the geoip file)

I'll try it out tomorrow so let me know if I've misapprehended anything.

Everything else I'm pretty sure I got first time! ;-)
	
[..]
</body></email><email><emailId>20080924183751</emailId><senderName>Robert Hogan</senderName><senderEmail>robert@roberthogan.net</senderEmail><timestampReceived>2008-09-24 18:37:51-0400</timestampReceived><subject>Re: Patch: Adding country codes to *Nodes config options</subject><body>

On Monday 22 September 2008 21:02:41 Nick Mathewson wrote:
&gt; {Please take pity on us old-school purists and wrap email to under 75
&gt; colums, so that it doesn't overflow our terminals when we reply}
&gt;
&gt; Hi, Robert!  This patch is a good start.  I can clean it up if you
&gt; would like, or you can do another version; let me know what you'd
&gt; prefer.
&gt;

OK, I think I've got my wrapping and most of the patch sorted. I've added XXXX 
comments wherever I'm unsure of something. Hopefully won't require too much 
cleaning up!


Index: src/or/config.c
===================================================================
--- src/or/config.c	(revision 16958)
+++ src/or/config.c	(working copy)
@@ -194,11 +194,11 @@
   V(DNSListenAddress,            LINELIST, NULL),
   V(DownloadExtraInfo,           BOOL,     "0"),
   V(EnforceDistinctSubnets,      BOOL,     "1"),
-  V(EntryNodes,                  STRING,   NULL),
+  V(EntryNodes,                  ROUTERSET,   NULL),
   V(TestingEstimatedDescriptorPropagationTime, INTERVAL, "10 minutes"),
   V(ExcludeNodes,                ROUTERSET, NULL),
   V(ExcludeExitNodes,            ROUTERSET, NULL),
-  V(ExitNodes,                   STRING, NULL),
+  V(ExitNodes,                   ROUTERSET, NULL),
   V(ExitPolicy,                  LINELIST, NULL),
   V(ExitPolicyRejectPrivate,     BOOL,     "1"),
   V(FallbackNetworkstatusFile,   FILENAME,
@@ -817,13 +817,22 @@
   return _version;
 }
 
+/** Release additional memory allocated in options
+ */
+static void
+or_options_free(void)
+{
+  routerset_free(global_options-&gt;_ExcludeExitNodesUnion);
+  config_free(&amp;options_format, global_options);
+}
+
 /** Release all memory and resources held by global configuration structures.
  */
 void
 config_free_all(void)
 {
   if (global_options) {
-    config_free(&amp;options_format, global_options);
+    or_options_free();
     global_options = NULL;
   }
   if (global_state) {
@@ -1336,11 +1345,21 @@
 #endif
     geoip_load_file(actual_fname, options);
     tor_free(actual_fname);
+
+    /* XXXX Would iterating through all option_var's routersets be better? */
+    if (options-&gt;EntryNodes)
+      routerset_refresh_countries(options-&gt;EntryNodes);
+    if (options-&gt;ExitNodes)
+      routerset_refresh_countries(options-&gt;ExitNodes);
+    if (options-&gt;ExcludeNodes)
+      routerset_refresh_countries(options-&gt;ExcludeNodes);
+    if (options-&gt;ExcludeExitNodes)
+      routerset_refresh_countries(options-&gt;ExcludeExitNodes);
   }
   /* Check if we need to parse and add the EntryNodes config option. */
   if (options-&gt;EntryNodes &amp;&amp;
       (!old_options ||
-       !opt_streq(old_options-&gt;EntryNodes, options-&gt;EntryNodes)))
+      (!routerset_equal(old_options-&gt;EntryNodes,options-&gt;EntryNodes))))
     entry_nodes_should_be_added();
 
   /* Since our options changed, we might need to regenerate and upload our
@@ -1701,7 +1720,6 @@
   case CONFIG_TYPE_LINELIST_S:
     config_line_append((config_line_t**)lvalue, c-&gt;key, c-&gt;value);
     break;
-
   case CONFIG_TYPE_OBSOLETE:
     log_warn(LD_CONFIG, "Skipping obsolete configuration option '%s'", 
c-&gt;key);
     break;
@@ -2964,17 +2982,17 @@
   }
 
   if (options-&gt;StrictExitNodes &amp;&amp;
-      (!options-&gt;ExitNodes || !strlen(options-&gt;ExitNodes)) &amp;&amp;
+      (!options-&gt;ExitNodes) &amp;&amp;
       (!old_options ||
        (old_options-&gt;StrictExitNodes != options-&gt;StrictExitNodes) ||
-       (!opt_streq(old_options-&gt;ExitNodes, options-&gt;ExitNodes))))
+       (!routerset_equal(old_options-&gt;ExitNodes,options-&gt;ExitNodes))))
     COMPLAIN("StrictExitNodes set, but no ExitNodes listed.");
 
   if (options-&gt;StrictEntryNodes &amp;&amp;
-      (!options-&gt;EntryNodes || !strlen(options-&gt;EntryNodes)) &amp;&amp;
+      (!options-&gt;EntryNodes) &amp;&amp;
       (!old_options ||
        (old_options-&gt;StrictEntryNodes != options-&gt;StrictEntryNodes) ||
-       (!opt_streq(old_options-&gt;EntryNodes, options-&gt;EntryNodes))))
+       (!routerset_equal(old_options-&gt;EntryNodes,options-&gt;EntryNodes))))
     COMPLAIN("StrictEntryNodes set, but no EntryNodes listed.");
 
   if (options-&gt;AuthoritativeDir) {
@@ -3334,10 +3352,6 @@
   if (options-&gt;UseEntryGuards &amp;&amp; ! options-&gt;NumEntryGuards)
     REJECT("Cannot enable UseEntryGuards with NumEntryGuards set to 0");
 
-  if (check_nickname_list(options-&gt;ExitNodes, "ExitNodes", msg))
-    return -1;
-  if (check_nickname_list(options-&gt;EntryNodes, "EntryNodes", msg))
-    return -1;
   if (check_nickname_list(options-&gt;MyFamily, "MyFamily", msg))
     return -1;
   for (cl = options-&gt;NodeFamilies; cl; cl = cl-&gt;next) {
Index: src/or/routerlist.c
===================================================================
--- src/or/routerlist.c	(revision 16958)
+++ src/or/routerlist.c	(working copy)
@@ -4707,6 +4707,7 @@
   /** An address policy for routers in the set.  For implementation reasons,
    * a router belongs to the set if it is _rejected_ by this policy. */
   smartlist_t *policies;
+  bitarray_t *countries;
 };
 
 /** Return a new empty routerset. */
@@ -4718,9 +4719,62 @@
   result-&gt;names = strmap_new();
   result-&gt;digests = digestmap_new();
   result-&gt;policies = smartlist_create();
+  result-&gt;countries = bitarray_init_zero(geoip_get_n_countries());
   return result;
 }
 
+/** Add the GeoIP database's integer index (+1) of a valid two-character
+ * country code to the routerset's &lt;b&gt;countries&lt;/b&gt; bitarray. Return the
+ * integer index if the country code is valid, zero otherwise.*/
+static int
+routerset_add_country(const char *c)
+{
+  char *country;
+  int cc;
+
+  /* XXXX: Country codes must be of the form \{[a-z\?]{2}\} but this accepts
+     \{[.]{2}\}. Do we need to be strict? */
+  if (!(*c=='{') || !(*(c+3)=='}'))
+    return 0;
+
+  if (!geoip_is_loaded()) {
+    log(LOG_WARN, LD_CONFIG, "GeoIP Database Not Loaded: Cannot add country"
+                             "entry %s, ignoring.", c);
+    return 0;
+  }
+
+  country=tor_strdup(c);
+  tor_strstrip(country,"}");
+  tor_strstrip(country,"{");
+  tor_strlower(country);
+
+  if ((cc=geoip_is_valid_country(country))==-1) {
+    log(LOG_WARN, LD_CONFIG, "Country Code '%s' is not valid, ignoring.",
+          country);
+  }
+  tor_free(country);
+  return cc;
+}
+
+/** Update the routerset's &lt;b&gt;countries&lt;/b&gt; bitarray_t. Called whenever
+ * the GeoIP database is reloaded.
+ */
+void
+routerset_refresh_countries(routerset_t *target)
+{
+  int cc;
+  /* XXX: Is this the proper check for a bitarray_t that is empty? */
+  if (!target-&gt;countries)
+    return;
+  bitarray_free(target-&gt;countries);
+  target-&gt;countries=bitarray_init_zero(geoip_get_n_countries());
+  SMARTLIST_FOREACH(target-&gt;list, char *, nick, {
+    if ((cc=routerset_add_country(nick))!=-1) {
+        bitarray_set(target-&gt;countries,cc);
+    }
+  });
+}
+
 /** Parse the string &lt;b&gt;s&lt;/b&gt; to create a set of routerset entries, and add
  * them to &lt;b&gt;target&lt;/b&gt;.  In log messages, refer to the string as
  * &lt;b&gt;description&lt;/b&gt;.  Return 0 on success, -1 on failure.
@@ -4732,7 +4786,7 @@
 int
 routerset_parse(routerset_t *target, const char *s, const char *description)
 {
-  int r = 0;
+  int r = 0,cc=0;
   smartlist_t *list = smartlist_create();
   smartlist_split_string(list, s, ",",
                          SPLIT_SKIP_SPACE | SPLIT_IGNORE_BLANK, 0);
@@ -4748,6 +4802,10 @@
       } else if (is_legal_nickname(nick)) {
         log_debug(LD_CONFIG, "Adding nickname %s to %s", nick, description);
         strmap_set_lc(target-&gt;names, nick, (void*)1);
+      } else if ((cc=routerset_add_country(nick))!=-1) {
+        log_debug(LD_CONFIG, "Adding country %s to %s", nick,
+                  description);
+        bitarray_set(target-&gt;countries,cc);
       } else if ((strchr(nick,'.') || strchr(nick, '*')) &amp;&amp;
                  (p = router_parse_addr_policy_item_from_string(
                                      nick, ADDR_POLICY_REJECT))) {
@@ -4795,6 +4853,10 @@
   if (addr &amp;&amp; compare_tor_addr_to_addr_policy(addr, orport, set-&gt;policies)
       == ADDR_POLICY_REJECTED)
     return 1;
+  if (addr &amp;&amp;
+     bitarray_is_set(set-&gt;countries,
+                    geoip_get_country_by_ip(tor_addr_to_ipv4h(addr))))
+    return 1;
   return 0;
 }
 
@@ -4856,14 +4918,16 @@
         smartlist_add(out, router);
     }
   });
-  if (smartlist_len(routerset-&gt;policies)) {
+  if (smartlist_len(routerset-&gt;policies) || (routerset-&gt;countries)) {
     routerlist_t *rl = router_get_routerlist();
     SMARTLIST_FOREACH(rl-&gt;routers, routerinfo_t *, router,
-      if (compare_addr_to_addr_policy(router-&gt;addr, router-&gt;or_port,
-               routerset-&gt;policies) == ADDR_POLICY_REJECT) {
+      if ((compare_addr_to_addr_policy(router-&gt;addr, router-&gt;or_port,
+          routerset-&gt;policies) == ADDR_POLICY_REJECT) ||
+          (bitarray_is_set(routerset-&gt;countries,
+                           geoip_get_country_by_ip(router-&gt;addr)))) {
         if (!running_only || router-&gt;is_running)
           smartlist_add(out, router);
-      });
+  });
   }
 }
 
@@ -4892,6 +4956,29 @@
   return smartlist_join_strings(set-&gt;list, ",", 0, NULL);
 }
 
+/** Helper: return true iff old and new are both NULL, or both non-NULL
+ * equal routersets. */
+int
+routerset_equal(const routerset_t *old, const routerset_t *new)
+{
+  /* XXXX: This won't work if the names/digests are identical but in a
+     different order. Checking for exact equality would be heavy going,
+     is it worth it? */
+  if (sizeof(old-&gt;names) != sizeof(new-&gt;names))
+    return 0;
+  if (memcmp(old-&gt;names,new-&gt;names,sizeof(new-&gt;names)))
+    return 0;
+  if (sizeof(old-&gt;digests) != sizeof(new-&gt;digests))
+    return 0;
+  if (memcmp(old-&gt;digests,new-&gt;digests,sizeof(new-&gt;digests)))
+    return 0;
+  if (sizeof(old-&gt;countries) != sizeof(new-&gt;countries))
+    return 0;
+  if (memcmp(old-&gt;countries,new-&gt;countries,sizeof(new-&gt;countries)))
+    return 0;
+  return 1;
+}
+
 /** Free all storage held in &lt;b&gt;routerset&lt;/b&gt;. */
 void
 routerset_free(routerset_t *routerset)
@@ -4904,7 +4991,7 @@
 
   strmap_free(routerset-&gt;names, NULL);
   digestmap_free(routerset-&gt;digests, NULL);
-
+  bitarray_free(routerset-&gt;countries);
   tor_free(routerset);
 }
 
Index: src/or/or.h
===================================================================
--- src/or/or.h	(revision 16958)
+++ src/or/or.h	(working copy)
@@ -1394,7 +1394,8 @@
   time_t last_reachable;
   /** When did we start testing reachability for this OR? */
   time_t testing_since;
-
+  /** According to the geoip db what country is this router in? */
+  int country;
 } routerinfo_t;
 
 /** Information needed to keep and cache a signed extra-info document. */
@@ -2090,17 +2091,25 @@
   char *Address; /**&lt; OR only: configured address for this onion router. */
   char *PidFile; /**&lt; Where to store PID of Tor process. */
 
-  char *ExitNodes; /**&lt; Comma-separated list of nicknames of ORs to consider
-                    * as exits. */
-  char *EntryNodes; /**&lt; Comma-separated list of nicknames of ORs to consider
-                     * as entry points. */
+  struct routerset_t *ExitNodes; /**&lt; Structure containing nicknames,
+                                   * digests, country codes and IP address
+                                   * patterns of ORs to consider as exits. */
+  struct routerset_t *EntryNodes;/**&lt; Structure containing nicknames,
+                                   * digests, country codes and IP address
+                                   * patterns of ORs to consider as entry
+                                   * points. */
   int StrictExitNodes; /**&lt; Boolean: When none of our ExitNodes are up, do we
                         * stop building circuits? */
   int StrictEntryNodes; /**&lt; Boolean: When none of our EntryNodes are up, do 
we
                          * stop building circuits? */
-  struct routerset_t *ExcludeNodes; /**&lt; Comma-separated list of nicknames of
-                       * ORs not to use in circuits. */
-  struct routerset_t *ExcludeExitNodes; /**&lt;DODOC */
+  struct routerset_t *ExcludeNodes;/**&lt; Structure containing nicknames,
+                                   * digests, country codes and IP address
+                                   * patterns of ORs not to use in
+                                   * circuits. */
+  struct routerset_t *ExcludeExitNodes;/**&lt; Structure containing nicknames,
+                                   * digests, country codes and IP address
+                                   * patterns of ORs not to consider as exits.
+                                   */
 
   /** Union of ExcludeNodes and ExcludeExitNodes */
   struct routerset_t *_ExcludeExitNodesUnion;
@@ -3468,6 +3477,7 @@
 int geoip_get_n_countries(void);
 const char *geoip_get_country_name(int num);
 int geoip_is_loaded(void);
+int geoip_is_valid_country(const char *country);
 /** Indicates an action that we might be noting geoip statistics on.
  * Note that if we're noticing CONNECT, we're a bridge, and if we're noticing
  * the others, we're not.
@@ -4292,6 +4302,8 @@
 void routerset_subtract_routers(smartlist_t *out,
                                 const routerset_t *routerset);
 char *routerset_to_string(const routerset_t *routerset);
+void routerset_refresh_countries(routerset_t *target);
+int routerset_equal(const routerset_t *old, const routerset_t *new);
 void routerset_free(routerset_t *routerset);
 
 int hid_serv_get_responsible_directories(smartlist_t *responsible_dirs,
Index: src/or/geoip.c
===================================================================
--- src/or/geoip.c	(revision 16958)
+++ src/or/geoip.c	(working copy)
@@ -42,6 +42,23 @@
 /** A list of all known geoip_entry_t, sorted by ip_low. */
 static smartlist_t *geoip_entries = NULL;
 
+/** Return the index of the &lt;b&gt;country&lt;/b&gt;'s entry in the GeoIP DB
+ * if it is a valid 2-letter country code, otherwise return zero.
+ */
+int
+geoip_is_valid_country(const char *country)
+{
+  void *_idxplus1;
+  intptr_t idx;
+
+  _idxplus1 = strmap_get_lc(country_idxplus1_by_lc_code, country);
+  if (!_idxplus1)
+    return -1;
+
+  idx = ((uintptr_t)_idxplus1)-1;
+  return (int)idx;
+}
+
 /** Add an entry to the GeoIP table, mapping all IPs between &lt;b&gt;low&lt;/b&gt; and
  * &lt;b&gt;high&lt;/b&gt;, inclusive, to the 2-letter country code &lt;b&gt;country&lt;/b&gt;.
  */
Index: src/or/circuitbuild.c
===================================================================
--- src/or/circuitbuild.c	(revision 16958)
+++ src/or/circuitbuild.c	(working copy)
@@ -1278,7 +1278,7 @@
            n_pending_connections);
 
   preferredexits = smartlist_create();
-  add_nickname_list_to_smartlist(preferredexits,options-&gt;ExitNodes,1);
+  routerset_get_all_routers(preferredexits,options-&gt;ExitNodes,1);
 
   sl = smartlist_create();
 
@@ -1399,6 +1399,24 @@
   return NULL;
 }
 
+/** Log a warning if the user specified an exit for the circuit that
+ * has been excluded from use by ExcludeNodes or ExcludeExitNodes. */
+static void
+warn_if_router_excluded(const extend_info_t *exit)
+{
+  or_options_t *options = get_options();
+  routerinfo_t *ri = router_get_by_digest(exit-&gt;identity_digest);
+
+  if (!ri || !options-&gt;_ExcludeExitNodesUnion)
+    return;
+
+  if (routerset_contains_router(options-&gt;_ExcludeExitNodesUnion, ri))
+    log_warn(LD_CIRC,"Requested exit node '%s' is in ExcludeNodes, "
+             "or ExcludeExitNodes, using anyway.",exit-&gt;nickname);
+
+  return;
+}
+
 /** Decide a suitable length for circ's cpath, and pick an exit
  * router (or use &lt;b&gt;exit&lt;/b&gt; if provided). Store these in the
  * cpath. Return 0 if ok, -1 if circuit should be closed. */
@@ -1419,6 +1437,7 @@
   }
 
   if (exit) { /* the circuit-builder pre-requested one */
+    warn_if_router_excluded(exit);
     log_info(LD_CIRC,"Using requested exit node '%s'", exit-&gt;nickname);
     exit = extend_info_dup(exit);
   } else { /* we have to decide one */
@@ -1832,7 +1851,7 @@
   else if (options-&gt;UseBridges &amp;&amp; ri-&gt;purpose != ROUTER_PURPOSE_BRIDGE)
     *reason = "not a bridge";
   else if (!options-&gt;UseBridges &amp;&amp; !ri-&gt;is_possible_guard &amp;&amp;
-           !router_nickname_is_in_list(ri, options-&gt;EntryNodes))
+           !routerset_contains_router(options-&gt;EntryNodes,ri))
     *reason = "not recommended as a guard";
   else if (routerset_contains_router(options-&gt;ExcludeNodes, ri))
     *reason = "excluded";
@@ -1856,7 +1875,6 @@
     control_event_guard(e-&gt;nickname, e-&gt;identity, "GOOD");
     changed = 1;
   }
-
   return changed;
 }
 
@@ -2346,8 +2364,9 @@
     return;
   }
 
-  log_info(LD_CIRC,"Adding configured EntryNodes '%s'.",
-           options-&gt;EntryNodes);
+  if (options-&gt;EntryNodes)
+    log_info(LD_CIRC,"Adding configured EntryNodes '%s'.",
+             routerset_to_string(options-&gt;EntryNodes));
 
   entry_routers = smartlist_create();
   entry_fps = smartlist_create();
@@ -2355,7 +2374,7 @@
   old_entry_guards_not_on_list = smartlist_create();
 
   /* Split entry guards into those on the list and those not. */
-  add_nickname_list_to_smartlist(entry_routers, options-&gt;EntryNodes, 0);
+  routerset_get_all_routers(entry_routers, options-&gt;EntryNodes, 0);
   SMARTLIST_FOREACH(entry_routers, routerinfo_t *, ri,
                     smartlist_add(entry_fps,ri-&gt;cache_info.identity_digest));
   SMARTLIST_FOREACH(entry_guards, entry_guard_t *, e, {
Index: contrib/checkSpace.pl
===================================================================
--- contrib/checkSpace.pl	(revision 16958)
+++ contrib/checkSpace.pl	(working copy)
@@ -73,7 +73,7 @@
                 s!//.*!!;
             }
             ## Warn about braces preceded by non-space.
-            if (/([^\s])\{/) {
+            if (/([^\s'])\{/) {
                 print "       $1\{:$fn:$.\n";
             }
             ## Warn about multiple internal spaces.
Index: doc/tor.1.in
===================================================================
--- doc/tor.1.in	(revision 16958)
+++ doc/tor.1.in	(working copy)
@@ -422,28 +422,28 @@
 .LP
 .TP
 \fBExcludeNodes \fR\fInode\fR,\fInode\fR,\fI...\fP
-A list of identity fingerprints, nicknames, and address patterns of
-nodes to never use when building a circuit.  (Example: ExcludeNodes
-SlowServer, $ABCDEFFFFFFFFFFFFFFF, 255.254.0.0/8)
+A list of identity fingerprints, nicknames, country codes and address patterns
+of nodes to never use when building a circuit.  (Example: ExcludeNodes
+SlowServer, $ABCDEFFFFFFFFFFFFFFF, {cc}, 255.254.0.0/8)
 .LP
 .TP
 \fBExcludeExitNodes \fR\fInode\fR,\fInode\fR,\fI...\fP
-A list of identity fingerprints, nicknames, and address patterns of
-nodes to never use when picking an exit node.  Note that any node
+A list of identity fingerprints, nicknames, country codes and address patterns
+of nodes to never use when picking an exit node.  Note that any node
 listed in ExcludeNodes is automatically considered to be part of this
 list.
 .LP
 .TP
 \fBEntryNodes \fR\fInode\fR,\fInode\fR,\fI...\fP
-A list of identity fingerprints or nicknames of preferred nodes to use for the
-first hop in the circuit.
+A list of identity fingerprints, nicknames, country codes and address patterns
+of nodes to use for the first hop in the circuit.
 These are treated only as preferences unless StrictEntryNodes (see
 below) is also set.
 .LP
 .TP
 \fBExitNodes \fR\fInode\fR,\fInode\fR,\fI...\fP
-A list of identity fingerprints or nicknames of preferred nodes to use for the
-last hop in the circuit.
+A list of identity fingerprints, nicknames, country codes and address patterns
+of nodes to use for the last hop in the circuit.
 These are treated only as preferences unless StrictExitNodes (see
 below) is also set.
 .LP
</body></email><email><emailId>20080801142443</emailId><senderName>Carsten_Krüger</senderName><senderEmail>c.krueger@gmx.org</senderEmail><timestampReceived>2008-08-01 14:24:43-0400</timestampReceived><subject>Re: Proposal: Automatic Tor Software Updates</subject><body>

Hi,

&gt; if the site is blocked directly, this would allow updates over an
&gt; existing working client installation.

Good point but maybe only use tor network for update if client uses
guard nodes to enter Tor, this would lower traffic on the network.

&gt; (among other reasons)

important ones?

&gt; why not?  (https is to be encouraged! :)

It's not nessary if the update process is properly secured but it
won't hurt :)

greetings
Carsten

</body></email><email><emailId>20080808222508</emailId><senderName>Karsten Loesing</senderName><senderEmail>karsten.loesing@gmx.net</senderEmail><timestampReceived>2008-08-08 22:25:08-0400</timestampReceived><subject>Re: First patch for proposal 121</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Hi Nick,

all issues resolved (hopefully); see attached patch.

- --Karsten
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFInMfC0M+WPffBEmURAla7AJ0fML/oNrvDdwSjlkimzvGzdcCSdQCfaYVz
rTAQAR4q1RMOzlqzxKfa4bY=
=Gn9U
-----END PGP SIGNATURE-----

["patch-121-1b.txt" (text/plain)]

Index: /home/karsten/tor/tor-trunk-121-patches/src/or/or.h
===================================================================
--- /home/karsten/tor/tor-trunk-121-patches/src/or/or.h	(revision 16477)
+++ /home/karsten/tor/tor-trunk-121-patches/src/or/or.h	(working copy)
@@ -653,6 +653,9 @@
 #define REND_LEGAL_CLIENTNAME_CHARACTERS \
   "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+-_"
 
+/** Maximum length of authorized client names for a hidden service. */
+#define REND_CLIENTNAME_MAX_LEN 16
+
 #define CELL_DIRECTION_IN 1
 #define CELL_DIRECTION_OUT 2
 
Index: /home/karsten/tor/tor-trunk-121-patches/src/or/rendservice.c
===================================================================
--- /home/karsten/tor/tor-trunk-121-patches/src/or/rendservice.c	(revision 16477)
+++ /home/karsten/tor/tor-trunk-121-patches/src/or/rendservice.c	(working copy)
@@ -57,7 +57,8 @@
   rend_auth_type_t auth_type; /**&lt; Client authorization type or 0 if no client
                                * authorization is performed. */
   smartlist_t *clients; /**&lt; List of rend_authorized_client_t's of
-                         * clients that may access our service. */
+                         * clients that may access our service. Can be NULL
+                         * if no client authorization is peformed. */
   /* Other fields */
   crypto_pk_env_t *private_key; /**&lt; Permanent hidden-service key. */
   char service_id[REND_SERVICE_ID_LEN_BASE32+1]; /**&lt; Onion address without
@@ -181,7 +182,7 @@
     service-&gt;descriptor_version = 2; /* Versioned descriptor. */
   }
 
-  if (service-&gt;auth_type &amp;&amp; !service-&gt;descriptor_version) {
+  if (service-&gt;auth_type != REND_NO_AUTH &amp;&amp; !service-&gt;descriptor_version) {
     log_warn(LD_CONFIG, "Hidden service with client authorization and "
                         "version 0 descriptors configured; ignoring.");
     rend_service_free(service);
@@ -188,7 +189,8 @@
     return;
   }
 
-  if (service-&gt;auth_type &amp;&amp; smartlist_len(service-&gt;clients) == 0) {
+  if (service-&gt;auth_type != REND_NO_AUTH &amp;&amp;
+      smartlist_len(service-&gt;clients) == 0) {
     log_warn(LD_CONFIG, "Hidden service with client authorization but no "
                         "clients; ignoring.");
     rend_service_free(service);
@@ -329,7 +331,8 @@
        * of authorized clients. */
       smartlist_t *type_names_split, *clients;
       const char *authname;
-      if (service-&gt;auth_type) {
+      int num_clients;
+      if (service-&gt;auth_type != REND_NO_AUTH) {
         log_warn(LD_CONFIG, "Got multiple HiddenServiceAuthorizeClient "
                  "lines for a single service.");
         rend_service_free(service);
@@ -336,7 +339,7 @@
         return -1;
       }
       type_names_split = smartlist_create();
-      smartlist_split_string(type_names_split, line-&gt;value, " ", 0, 0);
+      smartlist_split_string(type_names_split, line-&gt;value, " ", 0, 2);
       if (smartlist_len(type_names_split) &lt; 1) {
         log_warn(LD_BUG, "HiddenServiceAuthorizeClient has no value. This "
                          "should have been prevented when parsing the "
@@ -346,13 +349,14 @@
         return -1;
       }
       authname = smartlist_get(type_names_split, 0);
-      if (!strcasecmp(authname, "basic") || !strcmp(authname, "1")) {
+      if (!strcasecmp(authname, "basic")) {
         service-&gt;auth_type = REND_BASIC_AUTH;
-      } else if (!strcasecmp(authname, "stealth") || !strcmp(authname, "2")) {
+      } else if (!strcasecmp(authname, "stealth")) {
         service-&gt;auth_type = REND_STEALTH_AUTH;
       } else {
         log_warn(LD_CONFIG, "HiddenServiceAuthorizeClient contains "
-                 "unrecognized auth-type '%s'. Only 1 or 2 are recognized.",
+                 "unrecognized auth-type '%s'. Only 'basic' or 'stealth' "
+                 "are recognized.",
                  (char *) smartlist_get(type_names_split, 0));
         SMARTLIST_FOREACH(type_names_split, char *, cp, tor_free(cp));
         smartlist_free(type_names_split);
@@ -362,8 +366,8 @@
       service-&gt;clients = smartlist_create();
       if (smartlist_len(type_names_split) &lt; 2) {
         log_warn(LD_CONFIG, "HiddenServiceAuthorizeClient contains "
-                            "authorization type %d, but no client names.",
-                 service-&gt;auth_type);
+                            "auth-type '%s', but no client names.",
+                 service-&gt;auth_type == 1 ? "basic" : "stealth");
         SMARTLIST_FOREACH(type_names_split, char *, cp, tor_free(cp));
         smartlist_free(type_names_split);
         continue;
@@ -368,24 +372,21 @@
         smartlist_free(type_names_split);
         continue;
       }
-      if (smartlist_len(type_names_split) &gt; 2) {
-        log_warn(LD_CONFIG, "HiddenServiceAuthorizeClient contains "
-                            "illegal value '%s'. Must be formatted "
-                            "as 'HiddenServiceAuthorizeClient auth-type "
-                            "client-name,client-name,...' (without "
-                            "additional spaces in comma-separated client "
-                            "list).",
-                 line-&gt;value);
-        SMARTLIST_FOREACH(type_names_split, char *, cp, tor_free(cp));
-        smartlist_free(type_names_split);
-        rend_service_free(service);
-        return -1;
-      }
       clients = smartlist_create();
       smartlist_split_string(clients, smartlist_get(type_names_split, 1),
-                             ",", 0, 0);
+                             ",", SPLIT_SKIP_SPACE, 0);
       SMARTLIST_FOREACH(type_names_split, char *, cp, tor_free(cp));
       smartlist_free(type_names_split);
+      /* Remove duplicate client names. */
+      num_clients = smartlist_len(clients);
+      smartlist_sort_strings(clients);
+      smartlist_uniq_strings(clients);
+      if (smartlist_len(clients) &lt; num_clients) {
+        log_info(LD_CONFIG, "HiddenServiceAuthorizeClient contains %d "
+                            "duplicate client name(s); removing.",
+                 num_clients - smartlist_len(clients));
+        num_clients = smartlist_len(clients);
+      }
       SMARTLIST_FOREACH_BEGIN(clients, const char *, client_name)
       {
         rend_authorized_client_t *client;
@@ -390,13 +391,11 @@
       {
         rend_authorized_client_t *client;
         size_t len = strlen(client_name);
-        int found_duplicate = 0;
-        /* XXXX proposal 121 Why 19?  Also, this should be a constant. */
-        if (len &lt; 1 || len &gt; 19) {
+        if (len &lt; 1 || len &gt; REND_CLIENTNAME_MAX_LEN) {
           log_warn(LD_CONFIG, "HiddenServiceAuthorizeClient contains an "
                               "illegal client name: '%s'. Length must be "
-                              "between 1 and 19 characters.",
-                   client_name);
+                              "between 1 and %d characters.",
+                   client_name, REND_CLIENTNAME_MAX_LEN);
           SMARTLIST_FOREACH(clients, char *, cp, tor_free(cp));
           smartlist_free(clients);
           rend_service_free(service);
@@ -412,18 +411,6 @@
           rend_service_free(service);
           return -1;
         }
-        /* Check if client name is duplicate. */
-        /*XXXX proposal 121 This is O(N^2).  That's not so good. */
-        SMARTLIST_FOREACH(service-&gt;clients, rend_authorized_client_t *, c, {
-          if (!strcmp(c-&gt;client_name, client_name)) {
-            log_warn(LD_CONFIG, "HiddenServiceAuthorizeClient contains a "
-                     "duplicate client name: '%s'; ignoring.", client_name);
-            found_duplicate = 1;
-            break;
-          }
-        });
-        if (found_duplicate)
-          continue;
         client = tor_malloc_zero(sizeof(rend_authorized_client_t));
         client-&gt;client_name = tor_strdup(client_name);
         smartlist_add(service-&gt;clients, client);
@@ -440,10 +427,10 @@
         log_warn(LD_CONFIG, "HiddenServiceAuthorizeClient contains %d "
                             "client authorization entries, but only a "
                             "maximum of %d entries is allowed for "
-                            "authorization type %d.",
+                            "authorization type '%s'.",
                  smartlist_len(service-&gt;clients),
                  service-&gt;auth_type == REND_BASIC_AUTH ? 512 : 16,
-                 (int)service-&gt;auth_type);
+                 service-&gt;auth_type == 1 ? "basic" : "stealth");
         rend_service_free(service);
         return -1;
       }
@@ -583,7 +570,7 @@
     }
 
     /* If client authorization is configured, load or generate keys. */
-    if (s-&gt;auth_type) {
+    if (s-&gt;auth_type != REND_NO_AUTH) {
       char *client_keys_str = NULL;
       strmap_t *parsed_clients = strmap_new();
       char cfname[512];
@@ -676,7 +663,6 @@
         if (written &lt; 0) {
           log_warn(LD_BUG, "Could not write client entry.");
           goto err;
-
         }
         if (client-&gt;client_key) {
           char *client_key_out;
@@ -710,7 +696,8 @@
           char extended_desc_cookie[REND_DESC_COOKIE_LEN+1];
           memcpy(extended_desc_cookie, client-&gt;descriptor_cookie,
                  REND_DESC_COOKIE_LEN);
-          extended_desc_cookie[REND_DESC_COOKIE_LEN] = (s-&gt;auth_type - 1) &lt;&lt; 4;
+          extended_desc_cookie[REND_DESC_COOKIE_LEN] =
+              ((int)s-&gt;auth_type - 1) &lt;&lt; 4;
           if (base64_encode(desc_cook_out, 3*REND_DESC_COOKIE_LEN_BASE64+1,
                             extended_desc_cookie,
                             REND_DESC_COOKIE_LEN+1) &lt; 0) {
Index: /home/karsten/tor/tor-trunk-121-patches/src/or/routerparse.c
===================================================================
--- /home/karsten/tor/tor-trunk-121-patches/src/or/routerparse.c	(revision 16477)
+++ /home/karsten/tor/tor-trunk-121-patches/src/or/routerparse.c	(working copy)
@@ -3718,9 +3718,7 @@
   /* Begin parsing with first entry, skipping comments or whitespace at the
    * beginning. */
   area = memarea_new(4096);
-  /* XXXX proposal 121 This skips _everything_, not just comments or
-   * whitespace.  That's no good. */
-  current_entry = strstr(ckstr, "client-name ");
+  current_entry = eat_whitespace(ckstr);
   while (!strcmpstart(current_entry, "client-name ")) {
     rend_authorized_client_t *parsed_entry;
     size_t len;


["patch-121-1b.txt.sig" (application/octet-stream)]

</body></email><email><emailId>20080810225232</emailId><senderName>"John Brooks"</senderName><senderEmail>aspecialj@gmail.com</senderEmail><timestampReceived>2008-08-10 22:52:32-0400</timestampReceived><subject>Re: [or-cvs] Update OpenBSD via tor?</subject><body>

Tor only works directly as a SOCKS proxy. There are a couple options here -
first is the 'torify' program (which uses tricks to force all sockets in a
process to be sent through Tor even without application support for SOCKS).
That'd be the simplest solution, probably. You could also set up a HTTP
proxy to redirect to tor (this is what privoxy usually does - although it'd
need to support non-HTTP connections, which i'm not sure it does), or simply
use different software that includes SOCKS support :P

I don't think this is relevant in this situation, but always remember that
passwords sent in plaintext over tor are visible to the exit node. FTP would
fall under that category.

- John


On Sun, Aug 10, 2008 at 7:30 AM, macintoshzoom &lt;macintoshzoom@lavabit.com&gt;wrote:

&gt; $ export ftp_proxy="http://127.0.0.1:9050"
&gt; $ ftp ftp://ftp.debian.org/debian/README
&gt; Trying 127.0.0.1...
&gt; Requesting ftp://ftp.debian.org/debian/README (via http://127.0.0.1:9050)
&gt; ftp: Error retrieving file: 501 Tor is not an HTTP Proxy
&gt; $
&gt;
&gt;
&gt; $ export ftp_proxy="http://127.0.0.1:8118/"
&gt; $ ftp ftp://ftp.debian.org/debian/README
&gt; Trying 127.0.0.1...
&gt; Requesting ftp://ftp.debian.org/debian/README (via http://127.0.0.1:8118/)
&gt; ftp: Error retrieving file: 400 Invalid request received from client
&gt; $
&gt; as privoxy don't support ftp, only http-https.
&gt;
&gt; Christian Kellermann wrote:
&gt;
&gt;&gt; * macintoshzoom &lt;macintoshzoom@lavabit.com&gt; [080801 22:16]:
&gt;&gt;
&gt;&gt;&gt; pkg_add, the perl tool that OpenBSD uses for installs and updates, uses
&gt;&gt;&gt; ftp to fecth http and ftp files and sources.
&gt;&gt;&gt;
&gt;&gt;&gt; But in OpenBSD this ftp can't be socksified (otherwise using dsocks that
&gt;&gt;&gt; do the job honestly), and so I don't know how to use it via tor.
&gt;&gt;&gt;
&gt;&gt;
&gt;&gt; The ftp command in openbsd honors the http_proxy and ftp_proxy environment
&gt;&gt; variable.
&gt;&gt; See ftp(1) for details.
&gt;&gt;
&gt;&gt; HTH,
&gt;&gt;
&gt;&gt; Christian
&gt;&gt;
&gt;&gt;
&gt;

[Attachment #3 (text/html)]

&lt;div dir="ltr"&gt;Tor only works directly as a SOCKS proxy. There are a couple options \
here - first is the 'torify' program (which uses tricks to force all sockets \
in a process to be sent through Tor even without application support for SOCKS). \
That'd be the simplest solution, probably. You could also set up a HTTP proxy to \
redirect to tor (this is what privoxy usually does - although it'd need to \
support non-HTTP connections, which i'm not sure it does), or simply use \
different software that includes SOCKS support :P&lt;br&gt; &lt;br&gt;I don't think this is \
relevant in this situation, but always remember that passwords sent in plaintext over \
tor are visible to the exit node. FTP would fall under that category.&lt;br&gt;&lt;br \
clear="all"&gt;- John&lt;br&gt; &lt;br&gt;&lt;br&gt;&lt;div class="gmail_quote"&gt;On Sun, Aug 10, 2008 at 7:30 \
AM, macintoshzoom &lt;span dir="ltr"&gt;&lt;&lt;a \
href="mailto:macintoshzoom@lavabit.com"&gt;macintoshzoom@lavabit.com&lt;/a&gt;&gt;&lt;/span&gt; \
wrote:&lt;br&gt;&lt;blockquote class="gmail_quote" style="border-left: 1px solid rgb(204, 204, \
204); margin: 0pt 0pt 0pt 0.8ex; padding-left: 1ex;"&gt; $ export ftp_proxy="&lt;a \
href="http://127.0.0.1:9050" target="_blank"&gt;http://127.0.0.1:9050&lt;/a&gt;"&lt;br&gt; $ \
ftp &lt;a href="ftp://ftp.debian.org/debian/README" \
target="_blank"&gt;ftp://ftp.debian.org/debian/README&lt;/a&gt;&lt;br&gt; Trying 127.0.0.1...&lt;br&gt;
Requesting &lt;a href="ftp://ftp.debian.org/debian/README" \
target="_blank"&gt;ftp://ftp.debian.org/debian/README&lt;/a&gt; (via &lt;a \
                href="http://127.0.0.1:9050" \
                target="_blank"&gt;http://127.0.0.1:9050&lt;/a&gt;)&lt;br&gt;
ftp: Error retrieving file: 501 Tor is not an HTTP Proxy&lt;br&gt;
$&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
$ export ftp_proxy="&lt;a href="http://127.0.0.1:8118/" \
target="_blank"&gt;http://127.0.0.1:8118/&lt;/a&gt;"&lt;br&gt; $ ftp &lt;a \
href="ftp://ftp.debian.org/debian/README" \
target="_blank"&gt;ftp://ftp.debian.org/debian/README&lt;/a&gt;&lt;br&gt; Trying 127.0.0.1...&lt;br&gt;
Requesting &lt;a href="ftp://ftp.debian.org/debian/README" \
target="_blank"&gt;ftp://ftp.debian.org/debian/README&lt;/a&gt; (via &lt;a \
                href="http://127.0.0.1:8118/" \
                target="_blank"&gt;http://127.0.0.1:8118/&lt;/a&gt;)&lt;br&gt;
ftp: Error retrieving file: 400 Invalid request received from client&lt;br&gt;
$&lt;br&gt;
as privoxy don't support ftp, only http-https.&lt;br&gt;
&lt;br&gt;
Christian Kellermann wrote:&lt;br&gt;
&lt;blockquote class="gmail_quote" style="border-left: 1px solid rgb(204, 204, 204); \
                margin: 0pt 0pt 0pt 0.8ex; padding-left: 1ex;"&gt;
* macintoshzoom &lt;&lt;a href="mailto:macintoshzoom@lavabit.com" \
target="_blank"&gt;macintoshzoom@lavabit.com&lt;/a&gt;&gt; [080801 22:16]:&lt;br&gt; &lt;blockquote \
class="gmail_quote" style="border-left: 1px solid rgb(204, 204, 204); margin: 0pt 0pt \
0pt 0.8ex; padding-left: 1ex;"&gt; pkg_add, the perl tool that OpenBSD uses for installs \
and updates, uses&lt;br&gt; ftp to fecth http and ftp files and sources.&lt;br&gt;
&lt;br&gt;
But in OpenBSD this ftp can't be socksified (otherwise using dsocks that&lt;br&gt;
do the job honestly), and so I don't know how to use it via tor.&lt;br&gt;
&lt;/blockquote&gt;
&lt;br&gt;
The ftp command in openbsd honors the http_proxy and ftp_proxy environment \
variable.&lt;br&gt; See ftp(1) for details.&lt;br&gt;
&lt;br&gt;
HTH,&lt;br&gt;
&lt;br&gt;
Christian&lt;br&gt;
&lt;br&gt;
&lt;/blockquote&gt;
&lt;br&gt;
&lt;/blockquote&gt;&lt;/div&gt;&lt;br&gt;&lt;/div&gt;



</body></email><email><emailId>20080811201845</emailId><senderName>Karsten Loesing</senderName><senderEmail>karsten.loesing@gmx.net</senderEmail><timestampReceived>2008-08-11 20:18:45-0400</timestampReceived><subject>Re: Second patch for proposal 121</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Hi Nick,

attached to this mail you find an improved patch.

I didn't quote and respond to your comments, because for half of them I
could only say: "Argh. How could I overlook that." And for the remaining
ones my answer would be: "Wow, I didn't imagine that Tor has a function
for *that*. If the Tor project should ever fail, let's go and sell it as
an API." ;)

Please let me know if there are more issues with this patch. Always
happy to learn! :)

Thanks!
- --Karsten
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFIoJ5k0M+WPffBEmURAiBlAJ4oxy4s8rVQat3UBHMU66ZmDcAvXgCgoMCk
okHNpoitYGeoKJzJdFurYZA=
=X00S
-----END PGP SIGNATURE-----

["patch-121-2a.txt" (text/plain)]

Index: /home/karsten/tor/tor-trunk-121-patches/src/or/config.c
===================================================================
--- /home/karsten/tor/tor-trunk-121-patches/src/or/config.c	(revision 16498)
+++ /home/karsten/tor/tor-trunk-121-patches/src/or/config.c	(working copy)
@@ -227,6 +227,7 @@
   VAR("HiddenServicePort",   LINELIST_S, RendConfigLines,    NULL),
   VAR("HiddenServiceVersion",LINELIST_S, RendConfigLines,    NULL),
   VAR("HiddenServiceAuthorizeClient",LINELIST_S,RendConfigLines, NULL),
+  V(HidServAuth,                 LINELIST, NULL),
   V(HSAuthoritativeDir,          BOOL,     "0"),
   V(HSAuthorityRecordStats,      BOOL,     "0"),
   V(HttpProxy,                   STRING,   NULL),
@@ -1191,6 +1192,12 @@
     return -1;
   }
 
+  if (running_tor &amp;&amp; rend_parse_service_authorization(options, 0) &lt; 0) {
+    log_warn(LD_BUG, "Previously validated client authorization for "
+                     "hidden services could not be added!");
+    return -1;
+  }
+
   if (running_tor &amp;&amp; directory_caches_v2_dir_info(options)) {
     len = strlen(options-&gt;DataDirectory)+32;
     fn = tor_malloc(len);
@@ -3402,6 +3409,11 @@
   if (rend_config_services(options, 1) &lt; 0)
     REJECT("Failed to configure rendezvous options. See logs for details.");
 
+  /* Parse client-side authorization for hidden services. */
+  if (rend_parse_service_authorization(options, 1) &lt; 0)
+    REJECT("Failed to configure client authorization for hidden services. "
+           "See logs for details.");
+
   if (parse_virtual_addr_network(options-&gt;VirtualAddrNetwork, 1, NULL)&lt;0)
     return -1;
 
Index: /home/karsten/tor/tor-trunk-121-patches/src/or/main.c
===================================================================
--- /home/karsten/tor/tor-trunk-121-patches/src/or/main.c	(revision 16498)
+++ /home/karsten/tor/tor-trunk-121-patches/src/or/main.c	(working copy)
@@ -1873,6 +1873,7 @@
   dirserv_free_all();
   rend_service_free_all();
   rend_cache_free_all();
+  rend_service_authorization_free_all();
   rep_hist_free_all();
   hs_usage_free_all();
   dns_free_all();
Index: /home/karsten/tor/tor-trunk-121-patches/src/or/or.h
===================================================================
--- /home/karsten/tor/tor-trunk-121-patches/src/or/or.h	(revision 16498)
+++ /home/karsten/tor/tor-trunk-121-patches/src/or/or.h	(working copy)
@@ -612,6 +612,9 @@
 /** Length of 'y' portion of 'y.onion' URL. */
 #define REND_SERVICE_ID_LEN_BASE32 16
 
+/** Length of 'y.onion' including '.onion' URL. */
+#define REND_SERVICE_ADDRESS_LEN (16+1+5)
+
 /** Length of a binary-encoded rendezvous service ID. */
 #define REND_SERVICE_ID_LEN 10
 
@@ -2239,6 +2242,8 @@
                    * other ORs are running. */
   config_line_t *RendConfigLines; /**&lt; List of configuration lines
                                           * for rendezvous services. */
+  config_line_t *HidServAuth; /**&lt; List of configuration lines for client-side
+                               * authorizations for hidden services */
   char *ContactInfo; /**&lt; Contact info to be published in the directory. */
 
   char *HttpProxy; /**&lt; hostname[:port] to use as http proxy, if any. */
@@ -3806,6 +3811,26 @@
 int rend_client_send_introduction(origin_circuit_t *introcirc,
                                   origin_circuit_t *rendcirc);
 
+/** Client authorization type that a hidden service performs. */
+typedef enum rend_auth_type_t {
+  REND_NO_AUTH      = 0,
+  REND_BASIC_AUTH   = 1,
+  REND_STEALTH_AUTH = 2,
+} rend_auth_type_t;
+
+/** Client-side configuration of authorization for a hidden service. */
+typedef struct rend_service_authorization_t {
+  char descriptor_cookie[REND_DESC_COOKIE_LEN];
+  char onion_address[REND_SERVICE_ADDRESS_LEN+1];
+  rend_auth_type_t auth_type;
+} rend_service_authorization_t;
+
+int rend_parse_service_authorization(or_options_t *options,
+                                     int validate_only);
+rend_service_authorization_t *rend_client_lookup_service_authorization(
+                                                const char *onion_address);
+void rend_service_authorization_free_all(void);
+
 /********************************* rendcommon.c ***************************/
 
 /** Hidden-service side configuration of client authorization. */
Index: /home/karsten/tor/tor-trunk-121-patches/src/or/rendclient.c
===================================================================
--- /home/karsten/tor/tor-trunk-121-patches/src/or/rendclient.c	(revision 16498)
+++ /home/karsten/tor/tor-trunk-121-patches/src/or/rendclient.c	(working copy)
@@ -713,3 +713,136 @@
   return extend_info_dup(intro-&gt;extend_info);
 }
 
+/** Client-side authorizations for hidden services; map of onion address to
+ * rend_service_authorization_t*. */
+static strmap_t *auth_hid_servs = NULL;
+
+/** Look up the client-side authorization for the hidden service with
+ * &lt;b&gt;onion_address&lt;/b&gt;. Return NULL if no authorization is available for
+ * that address. */
+rend_service_authorization_t*
+rend_client_lookup_service_authorization(const char *onion_address)
+{
+  tor_assert(onion_address);
+  if (!auth_hid_servs) return NULL;
+  return strmap_get(auth_hid_servs, onion_address);
+}
+
+/** Helper: Free storage held by rend_service_authorization_t. */
+static void
+rend_service_authorization_free(rend_service_authorization_t *auth)
+{
+  tor_free(auth);
+}
+
+/** Helper for strmap_free. */
+static void
+rend_service_authorization_strmap_item_free(void *service_auth)
+{
+  rend_service_authorization_free(service_auth);
+}
+
+/** Release all the storage held in auth_hid_servs.
+ */
+void
+rend_service_authorization_free_all(void)
+{
+  if (!auth_hid_servs) {
+    return;
+  }
+  strmap_free(auth_hid_servs, rend_service_authorization_strmap_item_free);
+  auth_hid_servs = NULL;
+}
+
+/** Parse &lt;b&gt;config_line&lt;/b&gt; as a client-side authorization for a hidden
+ * service and add it to the local map of hidden service authorizations.
+ * Return 0 for success and -1 for failure. */
+int
+rend_parse_service_authorization(or_options_t *options, int validate_only)
+{
+  config_line_t *line;
+  int res = -1;
+  strmap_t *parsed = strmap_new();
+  smartlist_t *sl = smartlist_create();
+
+  for (line = options-&gt;HidServAuth; line; line = line-&gt;next) {
+    char *onion_address, *descriptor_cookie;
+    char descriptor_cookie_tmp[REND_DESC_COOKIE_LEN+2];
+    char descriptor_cookie_base64ext[REND_DESC_COOKIE_LEN_BASE64+2+1];
+    rend_service_authorization_t *auth = NULL;
+    int auth_type_val = 0;
+    SMARTLIST_FOREACH(sl, char *, c, tor_free(c););
+    smartlist_clear(sl);
+    smartlist_split_string(sl, line-&gt;value, " ",
+                           SPLIT_SKIP_SPACE|SPLIT_IGNORE_BLANK, 3);
+    if (smartlist_len(sl) &lt; 2) {
+      log_warn(LD_CONFIG, "Configuration line does not consist of "
+               "\"onion-address authorization-cookie [service-name]\": "
+               "'%s'", line-&gt;value);
+      goto err;
+    }
+    auth = tor_malloc_zero(sizeof(rend_service_authorization_t));
+    /* Parse onion address. */
+    onion_address = smartlist_get(sl, 0);
+    if (strlen(onion_address) != REND_SERVICE_ADDRESS_LEN ||
+        strcmpend(onion_address, ".onion")) {
+      log_warn(LD_CONFIG, "Onion address has wrong format: '%s'",
+               onion_address);
+      goto err;
+    }
+    strlcpy(auth-&gt;onion_address, onion_address, REND_SERVICE_ID_LEN_BASE32+1);
+    if (!rend_valid_service_id(auth-&gt;onion_address)) {
+      log_warn(LD_CONFIG, "Onion address has wrong format: '%s'",
+               onion_address);
+      goto err;
+    }
+    /* Parse descriptor cookie. */
+    descriptor_cookie = smartlist_get(sl, 1);
+    if (strlen(descriptor_cookie) != REND_DESC_COOKIE_LEN_BASE64) {
+      log_warn(LD_CONFIG, "Authorization cookie has wrong length: '%s'",
+               descriptor_cookie);
+      goto err;
+    }
+    /* Add trailing zero bytes (AA) to make base64-decoding happy. */
+    tor_snprintf(descriptor_cookie_base64ext,
+                 REND_DESC_COOKIE_LEN_BASE64+2+1,
+                 "%sAA", descriptor_cookie);
+    if (base64_decode(descriptor_cookie_tmp, sizeof(descriptor_cookie_tmp),
+                      descriptor_cookie_base64ext,
+                      strlen(descriptor_cookie_base64ext)) &lt; 0) {
+      log_warn(LD_CONFIG, "Decoding authorization cookie failed: '%s'",
+               descriptor_cookie);
+      goto err;
+    }
+    auth_type_val = (descriptor_cookie_tmp[16] &gt;&gt; 4) + 1;
+    if (auth_type_val &lt; 1 || auth_type_val &gt; 2) {
+      log_warn(LD_CONFIG, "Authorization cookie has unknown authorization "
+                          "type encoded.");
+      goto err;
+    }
+    auth-&gt;auth_type = auth_type_val == 1 ? REND_BASIC_AUTH : REND_STEALTH_AUTH;
+    memcpy(auth-&gt;descriptor_cookie, descriptor_cookie_tmp,
+           REND_DESC_COOKIE_LEN);
+    if (strmap_get(parsed, auth-&gt;onion_address)) {
+      log_warn(LD_CONFIG, "Duplicate authorization for the same hidden "
+                          "service.");
+      goto err;
+    }
+    strmap_set(parsed, auth-&gt;onion_address, auth);
+  }
+  res = 0;
+  goto done;
+ err:
+  res = -1;
+ done:
+  SMARTLIST_FOREACH(sl, char *, c, tor_free(c););
+  smartlist_free(sl);
+  if (!validate_only &amp;&amp; res == 0) {
+    rend_service_authorization_free_all();
+    auth_hid_servs = parsed;
+  } else {
+    strmap_free(parsed, rend_service_authorization_strmap_item_free);
+  }
+  return res;
+}
+
Index: /home/karsten/tor/tor-trunk-121-patches/src/or/rendservice.c
===================================================================
--- /home/karsten/tor/tor-trunk-121-patches/src/or/rendservice.c	(revision 16498)
+++ /home/karsten/tor/tor-trunk-121-patches/src/or/rendservice.c	(working copy)
@@ -40,13 +40,6 @@
  * rendezvous point before giving up? */
 #define MAX_REND_TIMEOUT 30
 
-/** DOCDOC */
-typedef enum rend_auth_type_t {
-  REND_NO_AUTH      = 0,
-  REND_BASIC_AUTH   = 1,
-  REND_STEALTH_AUTH = 2,
-} rend_auth_type_t;
-
 /** Represents a single hidden service running at this OP. */
 typedef struct rend_service_t {
   /* Fields specified in config file */


["patch-121-2a.txt.sig" (application/octet-stream)]

</body></email><email><emailId>20080810133039</emailId><senderName>macintoshzoom</senderName><senderEmail>macintoshzoom@lavabit.com</senderEmail><timestampReceived>2008-08-10 13:30:39-0400</timestampReceived><subject>Re: [or-cvs] Update OpenBSD via tor?</subject><body>

$ export ftp_proxy="http://127.0.0.1:9050"
$ ftp ftp://ftp.debian.org/debian/README
Trying 127.0.0.1...
Requesting ftp://ftp.debian.org/debian/README (via http://127.0.0.1:9050)
ftp: Error retrieving file: 501 Tor is not an HTTP Proxy
$


$ export ftp_proxy="http://127.0.0.1:8118/"
$ ftp ftp://ftp.debian.org/debian/README
Trying 127.0.0.1...
Requesting ftp://ftp.debian.org/debian/README (via http://127.0.0.1:8118/)
ftp: Error retrieving file: 400 Invalid request received from client
$
as privoxy don't support ftp, only http-https.

Christian Kellermann wrote:
&gt; * macintoshzoom &lt;macintoshzoom@lavabit.com&gt; [080801 22:16]:
&gt;&gt; pkg_add, the perl tool that OpenBSD uses for installs and updates, uses
&gt;&gt; ftp to fecth http and ftp files and sources.
&gt;&gt;
&gt;&gt; But in OpenBSD this ftp can't be socksified (otherwise using dsocks that
&gt;&gt; do the job honestly), and so I don't know how to use it via tor.
&gt; 
&gt; The ftp command in openbsd honors the http_proxy and ftp_proxy environment variable.
&gt; See ftp(1) for details.
&gt; 
&gt; HTH,
&gt; 
&gt; Christian
&gt; 

</body></email><email><emailId>20080809223835</emailId><senderName>Karsten Loesing</senderName><senderEmail>karsten.loesing@gmx.net</senderEmail><timestampReceived>2008-08-09 22:38:35-0400</timestampReceived><subject>Second patch for proposal 121</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Hi Nick,

this is the second patch to implement proposal 121. I switched patches 2
and 3 as compared to my original plan, so that all configuration options
can be used (however, without having an effect). The current plan for
the remaining 121 patches is as follows:

2. This second patch enables users to configure authorization data for
hidden services on client side.

3. The third patch will use authorization data on server side to
advertise hidden services and restrict access to authorized clients only.

4. Finally, the fourth patch uses authorization data to access a hidden
service.

Thanks!
- --Karsten
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFInhxp0M+WPffBEmURAohAAKCF5wUfuRiKmqgvHZMgZ9mdz85vDACgtJ4l
HcIn1sFkzQqBEbOrNxHRY00=
=mpqv
-----END PGP SIGNATURE-----

["patch-121-2.txt" (text/plain)]

Index: /home/karsten/tor/tor-trunk-121-patches/src/or/config.c
===================================================================
--- /home/karsten/tor/tor-trunk-121-patches/src/or/config.c	(revision 16480)
+++ /home/karsten/tor/tor-trunk-121-patches/src/or/config.c	(working copy)
@@ -227,6 +227,7 @@
   VAR("HiddenServicePort",   LINELIST_S, RendConfigLines,    NULL),
   VAR("HiddenServiceVersion",LINELIST_S, RendConfigLines,    NULL),
   VAR("HiddenServiceAuthorizeClient",LINELIST_S,RendConfigLines, NULL),
+  V(HidServAuth,                 LINELIST, NULL),
   V(HSAuthoritativeDir,          BOOL,     "0"),
   V(HSAuthorityRecordStats,      BOOL,     "0"),
   V(HttpProxy,                   STRING,   NULL),
@@ -3154,6 +3155,16 @@
     options-&gt;MinUptimeHidServDirectoryV2 = 0;
   }
 
+  /* Parse client-side authorization for hidden services. */
+  if (options-&gt;HidServAuth) {
+    for (cl = options-&gt;HidServAuth; cl; cl = cl-&gt;next) {
+      if (rend_parse_client_auth(cl-&gt;value) &lt; 0) {
+        log_warn(LD_CONFIG, "HidServAuth contains illegal value: '%s'; "
+                            "ignoring.", cl-&gt;value);
+      }
+    }
+  }
+
   if (options-&gt;RendPostPeriod &lt; MIN_REND_POST_PERIOD) {
     log(LOG_WARN,LD_CONFIG,"RendPostPeriod option must be at least %d seconds."
         " Clipping.", MIN_REND_POST_PERIOD);
Index: /home/karsten/tor/tor-trunk-121-patches/src/or/or.h
===================================================================
--- /home/karsten/tor/tor-trunk-121-patches/src/or/or.h	(revision 16480)
+++ /home/karsten/tor/tor-trunk-121-patches/src/or/or.h	(working copy)
@@ -2239,6 +2239,8 @@
                    * other ORs are running. */
   config_line_t *RendConfigLines; /**&lt; List of configuration lines
                                           * for rendezvous services. */
+  config_line_t *HidServAuth; /**&lt; List of configuration lines for client-side
+                               * authorizations for hidden services */
   char *ContactInfo; /**&lt; Contact info to be published in the directory. */
 
   char *HttpProxy; /**&lt; hostname[:port] to use as http proxy, if any. */
@@ -3805,6 +3807,7 @@
 
 int rend_client_send_introduction(origin_circuit_t *introcirc,
                                   origin_circuit_t *rendcirc);
+int rend_parse_client_auth(char *config_line);
 
 /********************************* rendcommon.c ***************************/
 
@@ -3815,6 +3818,13 @@
   crypto_pk_env_t *client_key;
 } rend_authorized_client_t;
 
+/** Client-side configuration of authorization for a hidden service. */
+typedef struct rend_service_authorization_t {
+  char descriptor_cookie[REND_DESC_COOKIE_LEN];
+  char onion_address[REND_SERVICE_ID_LEN_BASE32+1+5+1];
+  int auth_type;
+} rend_service_authorization_t;
+
 /** ASCII-encoded v2 hidden service descriptor. */
 typedef struct rend_encoded_v2_service_descriptor_t {
   char desc_id[DIGEST_LEN]; /**&lt; Descriptor ID. */
@@ -3890,6 +3900,7 @@
 void rend_get_descriptor_id_bytes(char *descriptor_id_out,
                                   const char *service_id,
                                   const char *secret_id_part);
+rend_service_authorization_t *lookup_client_auth(char *onion_address);
 
 /********************************* rendservice.c ***************************/
 
Index: /home/karsten/tor/tor-trunk-121-patches/src/or/rendclient.c
===================================================================
--- /home/karsten/tor/tor-trunk-121-patches/src/or/rendclient.c	(revision 16480)
+++ /home/karsten/tor/tor-trunk-121-patches/src/or/rendclient.c	(working copy)
@@ -713,3 +713,104 @@
   return extend_info_dup(intro-&gt;extend_info);
 }
 
+/** Client-side authorizations for hidden services; map of onion address to
+ * rend_service_authorization_t*. */
+static strmap_t *auth_hid_servs = NULL;
+
+/** Look up the client-side authorization for the hidden service with
+ * &lt;b&gt;onion_address&lt;/b&gt;. Return NULL if no authorization is available for
+ * that address. */
+rend_service_authorization_t*
+lookup_client_auth(char *onion_address)
+{
+  tor_assert(onion_address);
+  if (!auth_hid_servs) return NULL;
+  return strmap_get(auth_hid_servs, onion_address);
+}
+
+/** Helper: Free storage held by rend_service_authorization_t. */
+static void
+rend_service_authorization_free(rend_service_authorization_t *auth)
+{
+  if (!auth) return;
+  tor_free(auth);
+}
+
+/** Parse &lt;b&gt;config_line&lt;/b&gt; as a client-side authorization for a hidden
+ * service and add it to the local map of hidden service authorizations.
+ * Return 0 for success and -1 for failure. */
+int
+rend_parse_client_auth(char *config_line)
+{
+  char *onion_address, *descriptor_cookie;
+  char descriptor_cookie_tmp[REND_DESC_COOKIE_LEN+2];
+  char descriptor_cookie_base64ext[REND_DESC_COOKIE_LEN_BASE64+2+1];
+  smartlist_t *sl = smartlist_create();
+  rend_service_authorization_t *auth = NULL;
+  int res = -1, auth_type = 0;
+  tor_assert(config_line);
+  smartlist_split_string(sl, config_line, " ",
+                         SPLIT_SKIP_SPACE|SPLIT_IGNORE_BLANK, 3);
+  if (smartlist_len(sl) &lt; 2) {
+    log_warn(LD_CONFIG, "Configuration line does not consist of "
+             "\"onion-address authorization-cookie [service-name]\": '%s'",
+             config_line);
+    goto free;
+  }
+  auth = tor_malloc_zero(sizeof(rend_service_authorization_t));
+  /* Parse onion address. */
+  onion_address = smartlist_get(sl, 0);
+  if (strlen(onion_address) != 16+1+5 ||
+      strstr(onion_address, ".onion") != onion_address + 16) {
+    log_warn(LD_CONFIG, "Onion address has wrong format: '%s'",
+             onion_address);
+    goto free;
+  }
+  strlcpy(auth-&gt;onion_address, onion_address, 16+1);
+  if (!rend_valid_service_id(auth-&gt;onion_address)) {
+    log_warn(LD_CONFIG, "Onion address has wrong format: '%s'",
+             onion_address);
+    goto free;
+  }
+  /* Parse descriptor cookie. */
+  descriptor_cookie = smartlist_get(sl, 1);
+  if (strlen(descriptor_cookie) != 22) {
+    log_warn(LD_CONFIG, "Authorization cookie has wrong length: '%s'",
+             descriptor_cookie);
+    goto free;
+  }
+  /* Add trailing zero bytes (AA) to make base64-decoding happy. */
+  tor_snprintf(descriptor_cookie_base64ext,
+               REND_DESC_COOKIE_LEN_BASE64+2+1,
+               "%sAA", descriptor_cookie);
+  if (base64_decode(descriptor_cookie_tmp, REND_DESC_COOKIE_LEN+2,
+                    descriptor_cookie_base64ext,
+                    strlen(descriptor_cookie_base64ext)) &lt; 0) {
+    log_warn(LD_CONFIG, "Decoding authorization cookie failed: '%s'",
+             descriptor_cookie);
+    goto free;
+  }
+  auth_type = (descriptor_cookie_tmp[16] &gt;&gt; 4) + 1;
+  if (auth_type &lt; 1 || auth_type &gt; 2) {
+    log_warn(LD_CONFIG, "Authorization cookie has unknown authorization type "
+             "encoded.");
+    goto free;
+  }
+  auth-&gt;auth_type = auth_type;
+  memcpy(auth-&gt;descriptor_cookie, descriptor_cookie_tmp,
+         REND_DESC_COOKIE_LEN);
+  /* Add parsed client authorization to local map. */
+  if (!auth_hid_servs)
+    auth_hid_servs = strmap_new();
+  strmap_set(auth_hid_servs, auth-&gt;onion_address, auth);
+  auth = NULL;
+  res = 0;
+ free:
+  if (sl)
+    SMARTLIST_FOREACH(sl, char *, c, tor_free(c););
+  smartlist_free(sl);
+  if (auth)
+    rend_service_authorization_free(auth);
+  return res;
+}
+


["patch-121-2.txt.sig" (application/octet-stream)]

</body></email><email><emailId>20080805172900</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2008-08-05 17:29:00-0400</timestampReceived><subject>Re: [or-cvs] r16423: We put bw info directory into the consensus, also versions a (tor/trunk/doc/spe</subject><body>

On Tue, Aug 05, 2008 at 12:29:20PM -0400, weasel@seul.org wrote:
[...]
&gt;    tor/trunk/doc/spec/proposals/141-jit-sd-downloads.txt
[...]
&gt; +   "w Bandwidth=193671"
[...]
&gt; +  The bandwidth item is added as another item in the router tuple
&gt; +  described in dir-spec section 3.4:
&gt; +   | * Two router entries are "the same" if they have the same
&gt; +   | &lt;descriptor digest, published time, nickname, IP, ports&gt; tuple.
&gt; +   | We choose the tuple for a given router as whichever tuple appears
&gt; +   | for that router in the most votes.  We break ties in favor of
&gt; +   | the more recently published.

Shouldn't we take the median here? The edge case of "all votes have
different numbers" worries me, especially if we move one day to having
the directory authorities measure their own estimates for bandwidth
rather than just reflecting what's in the descriptor.

(And while we're speaking of edge cases, if there are an odd number of
votes, we can pick the lower median or the mean of the two medians.)

--Roger

</body></email><email><emailId>20080805173711</emailId><senderName>Peter Palfrader</senderName><senderEmail>peter@palfrader.org</senderEmail><timestampReceived>2008-08-05 17:37:11-0400</timestampReceived><subject>Re: [or-cvs] r16423: We put bw info directory into the consensus, also versions a (tor/trunk/doc/spe</subject><body>

On Tue, 05 Aug 2008, Roger Dingledine wrote:

&gt; &gt; +   "w Bandwidth=193671"
&gt; [...]
&gt; &gt; +  The bandwidth item is added as another item in the router tuple
&gt; &gt; +  described in dir-spec section 3.4:
&gt; &gt; +   | * Two router entries are "the same" if they have the same
&gt; &gt; +   | &lt;descriptor digest, published time, nickname, IP, ports&gt; tuple.
&gt; &gt; +   | We choose the tuple for a given router as whichever tuple appears
&gt; &gt; +   | for that router in the most votes.  We break ties in favor of
&gt; &gt; +   | the more recently published.
&gt; 
&gt; Shouldn't we take the median here? The edge case of "all votes have
&gt; different numbers" worries me, especially if we move one day to having
&gt; the directory authorities measure their own estimates for bandwidth
&gt; rather than just reflecting what's in the descriptor.
&gt; 
&gt; (And while we're speaking of edge cases, if there are an odd number of
&gt; votes, we can pick the lower median or the mean of the two medians.)

The bandwidth info comes directly from the server descriptor, as will
the exit policy summary (once I write that up).  This line should - at
least for now - be the one from the descriptor we are going to reference
by digest.

When we decide to come up with our own numbers then that logic should
obviously change, but for now I think it's fine.
-- 
                           |  .''`.  ** Debian GNU/Linux **
      Peter Palfrader      | : :' :      The  universal
 http://www.palfrader.org/ | `. `'      Operating System
                           |   `-    http://www.debian.org/
</body></email><email><emailId>20080811201001</emailId><senderName>Peter Palfrader</senderName><senderEmail>peter@palfrader.org</senderEmail><timestampReceived>2008-08-11 20:10:01-0400</timestampReceived><subject>141: exit policy summary</subject><body>

The current plan is:

  The consensus document will once again be extended to contain the
  information required by clients.  This information will be a summary
  of each node's exit policy.  The exit policy summary will only contain
  the list of ports to which a node exits to most destination IP
  addresses.

  A summary should claim a router exits to a specific TCP port if,
  ignoring private IP addresses (link and site local per RFC3300), the
  exit policy indicates that the router would exit to this port to any
  IP address with the exception of at most 2^25 single addresses (That's
  either two /8 netblocks, or one /8 and a couple of /12s or any other
  combination).

  An exit policy summary will be included in votes and consensus as a
  new line attached to each exit node.  A lack of policy should indicate
  a non-exit policy.  The line will have the format
   "p" &lt;space&gt; "accept"|"reject" &lt;portlist&gt;
  where portlist is a comma seperated list of single port numbers or
  portranges (e.g.  "22,80-88,1024-6000,6667").  Whether the summary
  shows the list of accepted ports or the list of rejected ports depends
  on which list is shorter (has less elements).  In case of ties we
  choose the list of accepted ports.

  Similarly to IP address, ports, timestamp, and bandwidth a consensus
  should list the exit policy matching the descriptor digest referenced
  in the consensus document.

3.4.1 Client behaviour

  When choosing an exit node for a specific request a Tor client will
  choose from the list of nodes that exit to the requested port as given
  by the consensus document.  If a client has additional knowledge (like
  cached full descriptors) that indicates the so chosen exit node will
  reject the request then it MAY use that knowledge (or not include such
  nodes in the selection to begin with).  However, clients MUST NOT use
  nodes that do not list the port as accepted in the summary (but for
  which they know that the node would exit to that address from other
  sources, like a cached descriptor).

  An exception to this is exit enclave behaviour: A client MAY use the
  node at a specific IP address to exit to any port on the same address
  even if that node is not listed as exiting to the port in the summary.




Should we get much better ideas for summaries later on we can always
build one with a new consensus method number I suppose.
-- 
                           |  .''`.  ** Debian GNU/Linux **
      Peter Palfrader      | : :' :      The  universal
 http://www.palfrader.org/ | `. `'      Operating System
                           |   `-    http://www.debian.org/
</body></email><email><emailId>20080811230053</emailId><senderName>Peter Palfrader</senderName><senderEmail>peter@palfrader.org</senderEmail><timestampReceived>2008-08-11 23:00:53-0400</timestampReceived><subject>Re: 141: exit policy summary</subject><body>

On Mon, 11 Aug 2008, Peter Palfrader wrote:

&gt;   An exit policy summary will be included in votes and consensus as a
&gt;   new line attached to each exit node.  A lack of policy should indicate
&gt;   a non-exit policy.  The line will have the format
&gt;    "p" &lt;space&gt; "accept"|"reject" &lt;portlist&gt;
&gt;   where portlist is a comma seperated list of single port numbers or
&gt;   portranges (e.g.  "22,80-88,1024-6000,6667").  Whether the summary
&gt;   shows the list of accepted ports or the list of rejected ports depends
&gt;   on which list is shorter (has less elements).  In case of ties we
                                 s/less elements/a shorter string representation/
&gt;   choose the list of accepted ports.


-rw-r--r--  1 weasel weasel 462899 Aug 12 00:56 cons-accept
-rw-r--r--  1 weasel weasel 432127 Aug 12 00:56 cons-reject
-rw-r--r--  1 weasel weasel 423023 Aug 12 00:56 cons-shorter
-rw-r--r--  1 weasel weasel 331860 Aug 12 00:48 consensus

It turns out that always using accept is significantly larger than
always using reject lines.  Of course always using the shorter one is
even better.

-rw-r--r--  1 weasel weasel 154109 Aug 12 00:56 cons-accept.gz
-rw-r--r--  1 weasel weasel 153364 Aug 12 00:56 cons-reject.gz
-rw-r--r--  1 weasel weasel 152669 Aug 12 00:56 cons-shorter.gz
-rw-r--r--  1 weasel weasel 146360 Aug 12 00:48 consensus.gz

However, when compressed it makes almost no difference anymore.

I'd still go for "shorter string representation", even if only because
it usually is nicer to read to the human.

Does anybody else have an opinion on that?
-- 
                           |  .''`.  ** Debian GNU/Linux **
      Peter Palfrader      | : :' :      The  universal
 http://www.palfrader.org/ | `. `'      Operating System
                           |   `-    http://www.debian.org/
</body></email><email><emailId>20080813120245</emailId><senderName>Karsten Loesing</senderName><senderEmail>karsten.loesing@gmx.net</senderEmail><timestampReceived>2008-08-13 12:02:45-0400</timestampReceived><subject>Third patch for proposal 121</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Hi Nick,

here is the third patch to implement proposal 121---which is the first
that actually changes protocol messages and not just the local
configuration. This is the plan:

3. This third patch uses authorization data that was configured using
the code in patch 1 to encode, encrypt, and upload hidden service
descriptors for services with either 'basic' or 'stealth' client
authorization.

4. The fourth patch will then use authorization data on client side
(that was introduced with patch 2) to download and decrypt hidden
service descriptors and establish connections to services that perform
client authorization.

Thanks!
- --Karsten
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFIos1k0M+WPffBEmURAhm8AKCS7CHjycCZCxp9zfbbsXyPEWU9qgCfXGoO
Dr3KOfPQDwOAAoDL6SlYnrE=
=rr0n
-----END PGP SIGNATURE-----

["patch-121-3.txt" (text/plain)]

Index: /home/karsten/tor/tor-trunk-121-patches/src/or/or.h
===================================================================
--- /home/karsten/tor/tor-trunk-121-patches/src/or/or.h	(revision 16516)
+++ /home/karsten/tor/tor-trunk-121-patches/src/or/or.h	(working copy)
@@ -651,6 +651,23 @@
  * exchanging client authorization between hidden service and client. */
 #define REND_DESC_COOKIE_LEN_BASE64 22
 
+/** Length of client identifier in encrypted introduction points for hidden
+ * service authorization type 'basic'. */
+#define REND_BASIC_AUTH_CLIENT_ID_LEN 4
+
+/** Multiple of the number of clients to which the real number of clients
+ * is padded with fake clients for hidden service authorization type
+ * 'basic'. */
+#define REND_BASIC_AUTH_CLIENT_MULTIPLE 16
+
+/** Length of client entry consisting of client identifier and encrypted
+ * session key for hidden service authorization type 'basic'. */
+#define REND_BASIC_AUTH_CLIENT_ENTRY_LEN (REND_BASIC_AUTH_CLIENT_ID_LEN \
+                                          + CIPHER_KEY_LEN)
+
+/** Maximum size of v2 hidden service descriptors. */
+#define REND_DESC_MAX_SIZE (20 * 1024)
+
 /** Legal characters for use in authorized client names for a hidden
  * service. */
 #define REND_LEGAL_CLIENTNAME_CHARACTERS \
@@ -3907,7 +3924,9 @@
 int rend_cache_size(void);
 int rend_encode_v2_descriptors(smartlist_t *descs_out,
                                rend_service_descriptor_t *desc, time_t now,
-                               const char *descriptor_cookie, uint8_t period);
+                               uint8_t period, rend_auth_type_t auth_type,
+                               crypto_pk_env_t *client_key,
+                               smartlist_t *client_cookies);
 int rend_compute_v2_desc_id(char *desc_id_out, const char *service_id,
                             const char *descriptor_cookie,
                             time_t now, uint8_t replica);
@@ -4295,10 +4314,14 @@
                                      size_t *intro_points_encrypted_size_out,
                                      size_t *encoded_size_out,
                                      const char **next_out, const char *desc);
-int rend_decrypt_introduction_points(rend_service_descriptor_t *parsed,
+int rend_decrypt_introduction_points(char **ipos_decrypted,
+                                     size_t *ipos_decrypted_size,
                                      const char *descriptor_cookie,
-                                     const char *intro_content,
-                                     size_t intro_size);
+                                     const char *ipos_encrypted,
+                                     size_t ipos_encrypted_size);
+int rend_parse_introduction_points(rend_service_descriptor_t *parsed,
+                                   const char *intro_points_encoded,
+                                   size_t intro_points_encoded_size);
 int rend_parse_client_keys(strmap_t *parsed_clients, const char *str);
 
 #endif
Index: /home/karsten/tor/tor-trunk-121-patches/src/or/rendcommon.c
===================================================================
--- /home/karsten/tor/tor-trunk-121-patches/src/or/rendcommon.c	(revision 16516)
+++ /home/karsten/tor/tor-trunk-121-patches/src/or/rendcommon.c	(working copy)
@@ -150,15 +150,11 @@
   return 0;
 }
 
-/* Encode the introduction points in &lt;b&gt;desc&lt;/b&gt;, optionally encrypt them with
- * an optional &lt;b&gt;descriptor_cookie&lt;/b&gt; of length REND_DESC_COOKIE_LEN,
- * encode it in base64, and write it to a newly allocated string, and write a
- * pointer to it to *&lt;b&gt;ipos_base64&lt;/b&gt;. Return 0 for success, -1
- * otherwise. */
+/** Encode the introduction points in &lt;b&gt;desc&lt;/b&gt; and write the result to a
+ * newly allocated string pointed to by &lt;b&gt;encoded&lt;/b&gt;. Return 0 for
+ * success, -1 otherwise. */
 static int
-rend_encode_v2_intro_points(char **ipos_base64,
-                            rend_service_descriptor_t *desc,
-                            const char *descriptor_cookie)
+rend_encode_v2_intro_points(char **encoded, rend_service_descriptor_t *desc)
 {
   size_t unenc_len;
   char *unenc = NULL;
@@ -166,7 +162,6 @@
   int i;
   int r = -1;
   /* Assemble unencrypted list of introduction points. */
-  *ipos_base64 = NULL;
   unenc_len = smartlist_len(desc-&gt;intro_nodes) * 1000; /* too long, but ok. */
   unenc = tor_malloc_zero(unenc_len);
   for (i = 0; i &lt; smartlist_len(desc-&gt;intro_nodes); i++) {
@@ -231,37 +226,157 @@
   }
   unenc[unenc_written++] = '\n';
   unenc[unenc_written++] = 0;
-  /* If a descriptor cookie is passed, encrypt introduction points. */
-  if (descriptor_cookie) {
-    char *enc = tor_malloc_zero(unenc_written + CIPHER_IV_LEN);
-    crypto_cipher_env_t *cipher =
-      crypto_create_init_cipher(descriptor_cookie, 1);
-    int enclen = crypto_cipher_encrypt_with_iv(cipher, enc,
-                                               unenc_written + CIPHER_IV_LEN,
-                                               unenc, unenc_written);
+  *encoded = unenc;
+  r = 0;
+ done:
+  if (r&lt;0)
+    tor_free(unenc);
+  return r;
+}
+
+/** Encrypt the encoded introduction points in &lt;b&gt;encoded&lt;/b&gt; using
+ * authorization type  'basic' with &lt;b&gt;client_cookies&lt;/b&gt; and write the
+ * result to a newly allocated string pointed to by &lt;b&gt;encrypted&lt;/b&gt; of
+ * length &lt;b&gt;encrypted_len&lt;/b&gt;. Return 0 for success, -1 otherwise. */
+static int
+rend_encrypt_v2_intro_points_basic(char **encrypted, size_t *encrypted_len,
+                                   const char *encoded,
+                                   smartlist_t *client_cookies)
+{
+  int r = -1, i, pos, enclen, client_blocks;
+  size_t len, client_entries_len;
+  char *enc = NULL, iv[CIPHER_IV_LEN], *client_part = NULL,
+       session_key[CIPHER_KEY_LEN];
+  smartlist_t *encrypted_session_keys = NULL;
+  crypto_digest_env_t *digest;
+  crypto_cipher_env_t *cipher;
+  tor_assert(encoded);
+  tor_assert(client_cookies &amp;&amp; smartlist_len(client_cookies) &gt; 0);
+
+  /* Generate session key. */
+  if (crypto_rand(session_key, CIPHER_KEY_LEN) &lt; 0) {
+    log_warn(LD_REND, "Unable to generate random session key to encrypt "
+                      "introduction point string.");
+    goto done;
+  }
+
+  /* Determine length of encrypted introduction points including session
+   * keys. */
+  client_blocks = 1 + ((smartlist_len(client_cookies) - 1) /
+                       REND_BASIC_AUTH_CLIENT_MULTIPLE);
+  client_entries_len = client_blocks * REND_BASIC_AUTH_CLIENT_MULTIPLE *
+                       REND_BASIC_AUTH_CLIENT_ENTRY_LEN;
+  len = 2 + client_entries_len + CIPHER_IV_LEN + strlen(encoded);
+  enc = tor_malloc_zero(len);
+  enc[0] = 0x01;
+  enc[1] = (uint8_t)client_blocks;
+
+  /* Encrypt with random session key. */
+  cipher = crypto_create_init_cipher(session_key, 1);
+  enclen = crypto_cipher_encrypt_with_iv(cipher,
+      enc + 2 + client_entries_len,
+      CIPHER_IV_LEN + strlen(encoded), encoded, strlen(encoded));
+  crypto_free_cipher_env(cipher);
+  if (enclen &lt; 0) {
+    log_warn(LD_REND, "Could not encrypt introduction point string.");
+    goto done;
+  }
+  memcpy(iv, enc + 2 + client_entries_len, CIPHER_IV_LEN);
+
+  /* Encrypt session key for cookies, determine client IDs, and put both
+   * in a smartlist. */
+  encrypted_session_keys = smartlist_create();
+  SMARTLIST_FOREACH(client_cookies, char *, cookie, {
+    client_part = tor_malloc_zero(REND_BASIC_AUTH_CLIENT_ENTRY_LEN);
+    /* Encrypt session key. */
+    cipher = crypto_create_init_cipher(cookie, 1);
+    if (crypto_cipher_encrypt(cipher, client_part +
+                                  REND_BASIC_AUTH_CLIENT_ID_LEN,
+                              session_key, CIPHER_KEY_LEN) &lt; 0) {
+      log_warn(LD_REND, "Could not encrypt session key for client.");
+      crypto_free_cipher_env(cipher);
+      tor_free(client_part);
+      goto done;
+    }
     crypto_free_cipher_env(cipher);
-    if (enclen &lt; 0) {
-      log_warn(LD_REND, "Could not encrypt introduction point string.");
-      tor_free(enc);
+
+    /* Determine client ID. */
+    digest = crypto_new_digest_env();
+    crypto_digest_add_bytes(digest, cookie, REND_DESC_COOKIE_LEN);
+    crypto_digest_add_bytes(digest, iv, CIPHER_IV_LEN);
+    crypto_digest_get_digest(digest, client_part,
+                             REND_BASIC_AUTH_CLIENT_ID_LEN);
+    crypto_free_digest_env(digest);
+
+    /* Put both together. */
+    smartlist_add(encrypted_session_keys, client_part);
+  });
+  /* Add some fake client IDs and encrypted session keys. */
+  for (i = (smartlist_len(client_cookies) - 1) %
+           REND_BASIC_AUTH_CLIENT_MULTIPLE;
+       i &lt; REND_BASIC_AUTH_CLIENT_MULTIPLE - 1; i++) {
+    client_part = tor_malloc_zero(REND_BASIC_AUTH_CLIENT_ENTRY_LEN);
+    if (crypto_rand(client_part, REND_BASIC_AUTH_CLIENT_ENTRY_LEN) &lt; 0) {
+      log_warn(LD_REND, "Unable to generate fake client entry.");
+      tor_free(client_part);
       goto done;
     }
-    /* Replace original string with the encrypted one. */
-    tor_free(unenc);
-    unenc = enc;
-    unenc_written = enclen;
+    smartlist_add(encrypted_session_keys, client_part);
+  }
+  /* Sort smartlist and put elements in result in order. */
+  smartlist_sort_digests(encrypted_session_keys);
+  pos = 2;
+  SMARTLIST_FOREACH(encrypted_session_keys, char *, entry, {
+    memcpy(enc + pos, entry, REND_BASIC_AUTH_CLIENT_ENTRY_LEN);
+    pos += REND_BASIC_AUTH_CLIENT_ENTRY_LEN;
+  });
+  *encrypted = enc;
+  *encrypted_len = len;
+  r = 0;
+ done:
+  if (r&lt;0)
+    tor_free(enc);
+  if (encrypted_session_keys) {
+    SMARTLIST_FOREACH(encrypted_session_keys, char *, d, tor_free(d););
+    smartlist_free(encrypted_session_keys);
   }
-  /* Base64-encode introduction points. */
-  *ipos_base64 = tor_malloc_zero(unenc_written * 2);
-  if (base64_encode(*ipos_base64, unenc_written * 2, unenc, unenc_written)&lt;0) {
-    log_warn(LD_REND, "Could not encode introduction point string to "
-             "base64.");
+  return r;
+}
+
+/** Encrypt the encoded introduction points in &lt;b&gt;encoded&lt;/b&gt; using
+ * authorization type 'stealth' with &lt;b&gt;descriptor_cookie&lt;/b&gt; of length
+ * REND_DESC_COOKIE_LEN and write the result to a newly allocated string
+ * pointed to by &lt;b&gt;encrypted&lt;/b&gt; of length &lt;b&gt;encrypted_len&lt;/b&gt;. Return 0
+ * for success, -1 otherwise. */
+static int
+rend_encrypt_v2_intro_points_stealth(char **encrypted,
+                                     size_t *encrypted_len,
+                                     const char *encoded,
+                                     const char *descriptor_cookie)
+{
+  int r = -1, enclen;
+  crypto_cipher_env_t *cipher;
+  char *enc;
+  tor_assert(encoded);
+  tor_assert(descriptor_cookie);
+
+  enc = tor_malloc_zero(1 + CIPHER_IV_LEN + strlen(encoded));
+  enc[0] = 0x02;
+  cipher = crypto_create_init_cipher(descriptor_cookie, 1);
+  enclen = crypto_cipher_encrypt_with_iv(cipher, enc + 1,
+                                         CIPHER_IV_LEN+strlen(encoded),
+                                         encoded, strlen(encoded));
+  crypto_free_cipher_env(cipher);
+  if (enclen &lt; 0) {
+    log_warn(LD_REND, "Could not encrypt introduction point string.");
     goto done;
   }
+  *encrypted = enc;
+  *encrypted_len = enclen;
   r = 0;
  done:
   if (r&lt;0)
-    tor_free(*ipos_base64);
-  tor_free(unenc);
+    tor_free(enc);
   return r;
 }
 
@@ -308,22 +423,34 @@
 }
 
 /** Encode a set of rend_encoded_v2_service_descriptor_t's for &lt;b&gt;desc&lt;/b&gt;
- * at time &lt;b&gt;now&lt;/b&gt; using &lt;b&gt;descriptor_cookie&lt;/b&gt; (may be &lt;b&gt;NULL&lt;/b&gt; if
- * introduction points shall not be encrypted) and &lt;b&gt;period&lt;/b&gt; (e.g. 0
- * for the current period, 1 for the next period, etc.) and add them to
- * the existing list &lt;b&gt;descs_out&lt;/b&gt;; return the number of seconds that
- * the descriptors will be found by clients, or -1 if the encoding was not
- * successful. */
+ * at time &lt;b&gt;now&lt;/b&gt; using &lt;b&gt;service_key&lt;/b&gt;, depending on
+ * &lt;b&gt;auth_type&lt;/b&gt; a &lt;b&gt;descriptor_cookie&lt;/b&gt; and a list of
+ * &lt;b&gt;client_cookies&lt;/b&gt; (which are both &lt;b&gt;NULL&lt;/b&gt; if no client
+ * authorization is performed), and &lt;b&gt;period&lt;/b&gt; (e.g. 0 for the current
+ * period, 1 for the next period, etc.) and add them to the existing list
+ * &lt;b&gt;descs_out&lt;/b&gt;; return the number of seconds that the descriptors will
+ * be found by clients, or -1 if the encoding was not successful. */
 int
 rend_encode_v2_descriptors(smartlist_t *descs_out,
                            rend_service_descriptor_t *desc, time_t now,
-                           const char *descriptor_cookie, uint8_t period)
+                           uint8_t period, rend_auth_type_t auth_type,
+                           crypto_pk_env_t *client_key,
+                           smartlist_t *client_cookies)
 {
   char service_id[DIGEST_LEN];
   uint32_t time_period;
-  char *ipos_base64 = NULL;
+  char *ipos_base64 = NULL, *ipos = NULL, *ipos_encrypted = NULL,
+       *descriptor_cookie = NULL;
+  size_t ipos_len = 0, ipos_encrypted_len = 0;
   int k;
   uint32_t seconds_valid;
+  crypto_pk_env_t *service_key = auth_type == REND_STEALTH_AUTH ?
+                                 client_key : desc-&gt;pk;
+  tor_assert(service_key);
+  if (auth_type == REND_STEALTH_AUTH) {
+    descriptor_cookie = smartlist_get(client_cookies, 0);
+    tor_assert(descriptor_cookie);
+  }
   if (!desc) {
     log_warn(LD_REND, "Could not encode v2 descriptor: No desc given.");
     return -1;
@@ -329,7 +456,7 @@
     return -1;
   }
   /* Obtain service_id from public key. */
-  crypto_pk_get_digest(desc-&gt;pk, service_id);
+  crypto_pk_get_digest(service_key, service_id);
   /* Calculate current time-period. */
   time_period = get_time_period(now, period, service_id);
   /* Determine how many seconds the descriptor will be valid. */
@@ -336,10 +463,52 @@
   seconds_valid = period * REND_TIME_PERIOD_V2_DESC_VALIDITY +
                   get_seconds_valid(now, service_id);
   /* Assemble, possibly encrypt, and encode introduction points. */
-  if (smartlist_len(desc-&gt;intro_nodes) &gt; 0 &amp;&amp;
-      rend_encode_v2_intro_points(&amp;ipos_base64, desc, descriptor_cookie) &lt; 0) {
-    log_warn(LD_REND, "Encoding of introduction points did not succeed.");
-    return -1;
+  if (smartlist_len(desc-&gt;intro_nodes) &gt; 0) {
+    if (rend_encode_v2_intro_points(&amp;ipos, desc) &lt; 0) {
+      log_warn(LD_REND, "Encoding of introduction points did not succeed.");
+      return -1;
+    }
+    switch (auth_type) {
+      case REND_NO_AUTH:
+        ipos_len = strlen(ipos);
+        break;
+      case REND_BASIC_AUTH:
+        if (rend_encrypt_v2_intro_points_basic(&amp;ipos_encrypted,
+                                               &amp;ipos_encrypted_len, ipos,
+                                               client_cookies) &lt; 0) {
+          log_warn(LD_REND, "Encrypting of introduction points did not "
+                            "succeed.");
+          tor_free(ipos);
+          return -1;
+        }
+        tor_free(ipos);
+        ipos = ipos_encrypted;
+        ipos_len = ipos_encrypted_len;
+        break;
+      case REND_STEALTH_AUTH:
+        if (rend_encrypt_v2_intro_points_stealth(&amp;ipos_encrypted,
+                                                 &amp;ipos_encrypted_len, ipos,
+                                                 descriptor_cookie) &lt; 0) {
+          log_warn(LD_REND, "Encrypting of introduction points did not "
+                            "succeed.");
+          tor_free(ipos);
+          return -1;
+        }
+        tor_free(ipos);
+        ipos = ipos_encrypted;
+        ipos_len = ipos_encrypted_len;
+        break;
+    }
+    /* Base64-encode introduction points. */
+    ipos_base64 = tor_malloc_zero(ipos_len * 2);
+    if (base64_encode(ipos_base64, ipos_len * 2, ipos, ipos_len)&lt;0) {
+      log_warn(LD_REND, "Could not encode introduction point string to "
+               "base64. length=%d", ipos_len);
+      tor_free(ipos_base64);
+      tor_free(ipos);
+      return -1;
+    }
+    tor_free(ipos);
   }
   /* Encode REND_NUMBER_OF_NON_CONSECUTIVE_REPLICAS descriptors. */
   for (k = 0; k &lt; REND_NUMBER_OF_NON_CONSECUTIVE_REPLICAS; k++) {
@@ -369,7 +538,7 @@
     base32_encode(desc_id_base32, sizeof(desc_id_base32),
                   enc-&gt;desc_id, DIGEST_LEN);
     /* PEM-encode the public key */
-    if (crypto_pk_write_public_key_to_string(desc-&gt;pk, &amp;permanent_key,
+    if (crypto_pk_write_public_key_to_string(service_key, &amp;permanent_key,
                                              &amp;permanent_key_len) &lt; 0) {
       log_warn(LD_BUG, "Could not write public key to string.");
       rend_encoded_v2_service_descriptor_free(enc);
@@ -437,7 +606,7 @@
     }
     if (router_append_dirobj_signature(desc_str + written,
                                        desc_len - written,
-                                       desc_digest, desc-&gt;pk) &lt; 0) {
+                                       desc_digest, service_key) &lt; 0) {
       log_warn(LD_BUG, "Couldn't sign desc.");
       rend_encoded_v2_service_descriptor_free(enc);
       goto err;
@@ -1085,6 +1254,7 @@
   rend_cache_entry_t *e;
   tor_assert(rend_cache);
   tor_assert(desc);
+  (void) descriptor_cookie; /* We don't use it, yet. */
   /* Parse the descriptor. */
   if (rend_parse_v2_service_descriptor(&amp;parsed, desc_id, &amp;intro_content,
                                        &amp;intro_size, &amp;encoded_size,
@@ -1103,8 +1273,8 @@
   }
   /* Decode/decrypt introduction points. */
   if (intro_content) {
-    if (rend_decrypt_introduction_points(parsed, descriptor_cookie,
-                                         intro_content, intro_size) &lt; 0) {
+    if (rend_parse_introduction_points(parsed, intro_content,
+                                       intro_size) &lt; 0) {
       log_warn(LD_PROTOCOL,"Couldn't decode/decrypt introduction points.");
       rend_service_descriptor_free(parsed);
       tor_free(intro_content);
Index: /home/karsten/tor/tor-trunk-121-patches/src/or/rendservice.c
===================================================================
--- /home/karsten/tor/tor-trunk-121-patches/src/or/rendservice.c	(revision 16516)
+++ /home/karsten/tor/tor-trunk-121-patches/src/or/rendservice.c	(working copy)
@@ -487,9 +487,8 @@
   d-&gt;timestamp = time(NULL);
   d-&gt;version = service-&gt;descriptor_version;
   d-&gt;intro_nodes = smartlist_create();
-  /* Whoever understands descriptor version 2 also understands intro
-   * protocol 2. So we only support 2. */
-  d-&gt;protocols = 1 &lt;&lt; 2;
+  /* Support intro protocols 2 and 3. */
+  d-&gt;protocols = (1 &lt;&lt; 2) + (1 &lt;&lt; 3);
 
   for (i = 0; i &lt; smartlist_len(service-&gt;intro_nodes); ++i) {
     rend_intro_point_t *intro_svc = smartlist_get(service-&gt;intro_nodes, i);
@@ -1446,40 +1445,38 @@
       get_options()-&gt;PublishHidServDescriptors) {
     networkstatus_t *c = networkstatus_get_latest_consensus();
     if (c &amp;&amp; smartlist_len(c-&gt;routerstatus_list) &gt; 0) {
-      int seconds_valid;
+      int seconds_valid, i, j, num_descs;
       smartlist_t *descs = smartlist_create();
-      int i;
-      /* Encode the current descriptor. */
-      seconds_valid = rend_encode_v2_descriptors(descs, service-&gt;desc, now,
-                                                 NULL, 0);
-      if (seconds_valid &lt; 0) {
-        log_warn(LD_BUG, "Internal error: couldn't encode service descriptor; "
-                 "not uploading.");
-        smartlist_free(descs);
-        return;
-      }
-      /* Post the current descriptors to the hidden service directories. */
-      rend_get_service_id(service-&gt;desc-&gt;pk, serviceid);
-      log_info(LD_REND, "Sending publish request for hidden service %s",
-                   serviceid);
-      directory_post_to_hs_dir(descs, serviceid, seconds_valid);
-      /* Free memory for descriptors. */
-      for (i = 0; i &lt; smartlist_len(descs); i++)
-        rend_encoded_v2_service_descriptor_free(smartlist_get(descs, i));
-      smartlist_clear(descs);
-      /* Update next upload time. */
-      if (seconds_valid - REND_TIME_PERIOD_OVERLAPPING_V2_DESCS
-          &gt; rendpostperiod)
-        service-&gt;next_upload_time = now + rendpostperiod;
-      else if (seconds_valid &lt; REND_TIME_PERIOD_OVERLAPPING_V2_DESCS)
-        service-&gt;next_upload_time = now + seconds_valid + 1;
-      else
-        service-&gt;next_upload_time = now + seconds_valid -
-            REND_TIME_PERIOD_OVERLAPPING_V2_DESCS + 1;
-      /* Post also the next descriptors, if necessary. */
-      if (seconds_valid &lt; REND_TIME_PERIOD_OVERLAPPING_V2_DESCS) {
+      smartlist_t *client_cookies = smartlist_create();
+      /* Either upload a single descriptor (including replicas) or one
+       * descriptor for each authorized client in case of authorization
+       * type 'stealth'. */
+      num_descs = service-&gt;auth_type == REND_STEALTH_AUTH ?
+                      smartlist_len(service-&gt;clients) : 1;
+      for (j = 0; j &lt; num_descs; j++) {
+        crypto_pk_env_t *client_key = NULL;
+        rend_authorized_client_t *client = NULL;
+        smartlist_clear(client_cookies);
+        switch (service-&gt;auth_type) {
+          case REND_NO_AUTH:
+            /* Do nothing here. */
+            break;
+          case REND_BASIC_AUTH:
+            SMARTLIST_FOREACH(service-&gt;clients, rend_authorized_client_t *,
+                cl, smartlist_add(client_cookies, cl-&gt;descriptor_cookie));
+            break;
+          case REND_STEALTH_AUTH:
+            client = smartlist_get(service-&gt;clients, j);
+            client_key = client-&gt;client_key;
+            smartlist_add(client_cookies, client-&gt;descriptor_cookie);
+            break;
+        }
+        /* Encode the current descriptor. */
         seconds_valid = rend_encode_v2_descriptors(descs, service-&gt;desc,
-                                                   now, NULL, 1);
+                                                   now, 0,
+                                                   service-&gt;auth_type,
+                                                   client_key,
+                                                   client_cookies);
         if (seconds_valid &lt; 0) {
           log_warn(LD_BUG, "Internal error: couldn't encode service "
                    "descriptor; not uploading.");
@@ -1484,8 +1481,13 @@
           log_warn(LD_BUG, "Internal error: couldn't encode service "
                    "descriptor; not uploading.");
           smartlist_free(descs);
+          smartlist_free(client_cookies);
           return;
         }
+        /* Post the current descriptors to the hidden service directories. */
+        rend_get_service_id(service-&gt;desc-&gt;pk, serviceid);
+        log_info(LD_REND, "Sending publish request for hidden service %s",
+                     serviceid);
         directory_post_to_hs_dir(descs, serviceid, seconds_valid);
         /* Free memory for descriptors. */
         for (i = 0; i &lt; smartlist_len(descs); i++)
@@ -1490,8 +1492,39 @@
         /* Free memory for descriptors. */
         for (i = 0; i &lt; smartlist_len(descs); i++)
           rend_encoded_v2_service_descriptor_free(smartlist_get(descs, i));
+        smartlist_clear(descs);
+        /* Update next upload time. */
+        if (seconds_valid - REND_TIME_PERIOD_OVERLAPPING_V2_DESCS
+            &gt; rendpostperiod)
+          service-&gt;next_upload_time = now + rendpostperiod;
+        else if (seconds_valid &lt; REND_TIME_PERIOD_OVERLAPPING_V2_DESCS)
+          service-&gt;next_upload_time = now + seconds_valid + 1;
+        else
+          service-&gt;next_upload_time = now + seconds_valid -
+              REND_TIME_PERIOD_OVERLAPPING_V2_DESCS + 1;
+        /* Post also the next descriptors, if necessary. */
+        if (seconds_valid &lt; REND_TIME_PERIOD_OVERLAPPING_V2_DESCS) {
+          seconds_valid = rend_encode_v2_descriptors(descs, service-&gt;desc,
+                                                     now, 1,
+                                                     service-&gt;auth_type,
+                                                     client_key,
+                                                     client_cookies);
+          if (seconds_valid &lt; 0) {
+            log_warn(LD_BUG, "Internal error: couldn't encode service "
+                     "descriptor; not uploading.");
+            smartlist_free(descs);
+            smartlist_free(client_cookies);
+            return;
+          }
+          directory_post_to_hs_dir(descs, serviceid, seconds_valid);
+          /* Free memory for descriptors. */
+          for (i = 0; i &lt; smartlist_len(descs); i++)
+            rend_encoded_v2_service_descriptor_free(smartlist_get(descs, i));
+          smartlist_clear(descs);
+        }
       }
       smartlist_free(descs);
+      smartlist_free(client_cookies);
       uploaded = 1;
       log_info(LD_REND, "Successfully uploaded v2 rend descriptors!");
     }
Index: /home/karsten/tor/tor-trunk-121-patches/src/or/routerparse.c
===================================================================
--- /home/karsten/tor/tor-trunk-121-patches/src/or/routerparse.c	(revision 16516)
+++ /home/karsten/tor/tor-trunk-121-patches/src/or/routerparse.c	(working copy)
@@ -3421,6 +3421,13 @@
     eos = desc + strlen(desc);
   else
     eos = eos + 1;
+  /* Check length. */
+  if (strlen(desc) &gt; REND_DESC_MAX_SIZE) {
+    log_warn(LD_REND, "Descriptor length is %i which exceeds "
+             "maximum rendezvous descriptor size of %i kilobytes.",
+             strlen(desc), REND_DESC_MAX_SIZE);
+    goto err;
+  }
   /* Tokenize descriptor. */
   area = memarea_new(4096);
   if (tokenize_string(area, desc, eos, tokens, desc_token_table, 0)) {
@@ -3560,21 +3567,123 @@
   return -1;
 }
 
-/** Decrypt and decode the introduction points in
- * &lt;b&gt;intro_points_encrypted&lt;/b&gt; of length
- * &lt;b&gt;intro_points_encrypted_size&lt;/b&gt; using &lt;b&gt;descriptor_cookie&lt;/b&gt;
- * (which may also be &lt;b&gt;NULL&lt;/b&gt; if no decryption, but only parsing is
- * required), parse the introduction points, and write the result to
- * &lt;b&gt;parsed&lt;/b&gt;; return the number of successfully parsed introduction
- * points or -1 in case of a failure.
- */
+/** Decrypt the encrypted introduction points in &lt;b&gt;ipos_encrypted&lt;/b&gt; of
+ * length &lt;b&gt;ipos_encrypted_size&lt;/b&gt; using &lt;b&gt;descriptor_cookie&lt;/b&gt; and
+ * write the result to a newly allocated string that is pointed to by
+ * &lt;b&gt;ipos_decrypted&lt;/b&gt; and its length to &lt;b&gt;ipos_decrypted_size&lt;/b&gt;.
+ * Return 0 if decryption was successful and -1 otherwise. */
 int
-rend_decrypt_introduction_points(rend_service_descriptor_t *parsed,
+rend_decrypt_introduction_points(char **ipos_decrypted,
+                                 size_t *ipos_decrypted_size,
                                  const char *descriptor_cookie,
-                                 const char *intro_points_encrypted,
-                                 size_t intro_points_encrypted_size)
+                                 const char *ipos_encrypted,
+                                 size_t ipos_encrypted_size)
 {
-  char *ipos_decrypted = NULL;
+  tor_assert(ipos_encrypted);
+  tor_assert(descriptor_cookie);
+  if (ipos_encrypted_size &lt; 2) {
+    log_warn(LD_REND, "Size of encrypted introduction points is too "
+                      "small.");
+    return -1;
+  }
+  if (ipos_encrypted[0] == (int)REND_BASIC_AUTH) {
+    char iv[CIPHER_IV_LEN], client_id[REND_BASIC_AUTH_CLIENT_ID_LEN],
+         session_key[CIPHER_KEY_LEN], *dec;
+    int declen, client_blocks;
+    size_t pos = 0, len, client_entries_len;
+    crypto_digest_env_t *digest;
+    crypto_cipher_env_t *cipher;
+    client_blocks = (int) ipos_encrypted[1];
+    client_entries_len = client_blocks * REND_BASIC_AUTH_CLIENT_MULTIPLE *
+                         REND_BASIC_AUTH_CLIENT_ENTRY_LEN;
+    if (ipos_encrypted_size &lt; 2 + client_entries_len + CIPHER_IV_LEN + 1) {
+      log_warn(LD_REND, "Size of encrypted introduction points is too "
+                        "small.");
+      return -1;
+    }
+    memcpy(iv, ipos_encrypted + 2 + client_entries_len, CIPHER_IV_LEN);
+    digest = crypto_new_digest_env();
+    crypto_digest_add_bytes(digest, descriptor_cookie, REND_DESC_COOKIE_LEN);
+    crypto_digest_add_bytes(digest, iv, CIPHER_IV_LEN);
+    crypto_digest_get_digest(digest, client_id,
+                             REND_BASIC_AUTH_CLIENT_ID_LEN);
+    crypto_free_digest_env(digest);
+    for (pos = 2; pos &lt; 2 + client_entries_len;
+         pos += REND_BASIC_AUTH_CLIENT_ENTRY_LEN) {
+      if (!memcmp(ipos_encrypted + pos, client_id,
+                  REND_BASIC_AUTH_CLIENT_ID_LEN)) {
+        /* Attempt to decrypt introduction points. */
+        cipher = crypto_create_init_cipher(descriptor_cookie, 0);
+        if (crypto_cipher_decrypt(cipher, session_key, ipos_encrypted
+                                  + pos + REND_BASIC_AUTH_CLIENT_ID_LEN,
+                                  CIPHER_KEY_LEN) &lt; 0) {
+          log_warn(LD_REND, "Could not decrypt session key for client.");
+          crypto_free_cipher_env(cipher);
+          return -1;
+        }
+        crypto_free_cipher_env(cipher);
+        cipher = crypto_create_init_cipher(session_key, 0);
+        len = ipos_encrypted_size - 2 - client_entries_len - CIPHER_IV_LEN;
+        dec = tor_malloc_zero(len);
+        declen = crypto_cipher_decrypt_with_iv(cipher, dec, len,
+            ipos_encrypted + 2 + client_entries_len,
+            ipos_encrypted_size - 2 - client_entries_len);
+        crypto_free_cipher_env(cipher);
+        if (declen &lt; 0) {
+          log_warn(LD_REND, "Could not decrypt introduction point string.");
+          tor_free(dec);
+          return -1;
+        }
+        if (strcmpstart(dec, "introduction-point ")) {
+          log_warn(LD_REND, "Decrypted introduction points don't "
+                            "look like we could parse them.");
+          tor_free(dec);
+          continue;
+        }
+        *ipos_decrypted = dec;
+        *ipos_decrypted_size = declen;
+        return 0;
+      }
+    }
+    log_warn(LD_REND, "Could not decrypt introduction points. Please "
+             "check your authorization for this service!");
+    return -1;
+  } else if (ipos_encrypted[0] == (int)REND_STEALTH_AUTH) {
+    crypto_cipher_env_t *cipher;
+    char *dec;
+    int declen;
+    dec = tor_malloc_zero(ipos_encrypted_size - CIPHER_IV_LEN - 1);
+    cipher = crypto_create_init_cipher(descriptor_cookie, 0);
+    declen = crypto_cipher_decrypt_with_iv(cipher, dec,
+                                           ipos_encrypted_size -
+                                               CIPHER_IV_LEN - 1,
+                                           ipos_encrypted + 1,
+                                           ipos_encrypted_size - 1);
+    crypto_free_cipher_env(cipher);
+    if (declen &lt; 0) {
+      log_warn(LD_REND, "Decrypting introduction points failed!");
+      tor_free(dec);
+      return -1;
+    }
+    *ipos_decrypted = dec;
+    *ipos_decrypted_size = declen;
+    return 0;
+  } else {
+    log_warn(LD_REND, "Unknown authorization type number: %d",
+             ipos_encrypted[0]);
+    return -1;
+  }
+}
+
+/** Parse the encoded introduction points in &lt;b&gt;intro_points_encoded&lt;/b&gt; of
+ * length &lt;b&gt;intro_points_encoded_size&lt;/b&gt; and write the result to the
+ * descriptor in &lt;b&gt;parsed&lt;/b&gt;; return the number of successfully parsed
+ * introduction points or -1 in case of a failure. */
+int
+rend_parse_introduction_points(rend_service_descriptor_t *parsed,
+                               const char *intro_points_encoded,
+                               size_t intro_points_encoded_size)
+{
   const char **current_ipo;
   smartlist_t *tokens;
   directory_token_t *tok;
@@ -3585,28 +3694,10 @@
   tor_assert(parsed);
   /** Function may only be invoked once. */
   tor_assert(!parsed-&gt;intro_nodes);
-  tor_assert(intro_points_encrypted);
-  tor_assert(intro_points_encrypted_size &gt; 0);
-  /* Decrypt introduction points, if required. */
-  if (descriptor_cookie) {
-    crypto_cipher_env_t *cipher;
-    int unenclen;
-    ipos_decrypted = tor_malloc_zero(intro_points_encrypted_size - 16);
-    cipher = crypto_create_init_cipher(descriptor_cookie, 0);
-    unenclen = crypto_cipher_decrypt_with_iv(cipher, ipos_decrypted,
-                                             intro_points_encrypted_size - 16,
-                                             intro_points_encrypted,
-                                             intro_points_encrypted_size);
-    crypto_free_cipher_env(cipher);
-    if (unenclen &lt; 0) {
-      tor_free(ipos_decrypted);
-      return -1;
-    }
-    intro_points_encrypted = ipos_decrypted;
-    intro_points_encrypted_size = unenclen;
-  }
+  tor_assert(intro_points_encoded);
+  tor_assert(intro_points_encoded_size &gt; 0);
   /* Consider one intro point after the other. */
-  current_ipo = &amp;intro_points_encrypted;
+  current_ipo = &amp;intro_points_encoded;
   tokens = smartlist_create();
   parsed-&gt;intro_nodes = smartlist_create();
   area = memarea_new(4096);
Index: /home/karsten/tor/tor-trunk-121-patches/src/or/test.c
===================================================================
--- /home/karsten/tor/tor-trunk-121-patches/src/or/test.c	(revision 16516)
+++ /home/karsten/tor/tor-trunk-121-patches/src/or/test.c	(working copy)
@@ -3907,8 +3907,8 @@
     intro-&gt;intro_key = crypto_pk_dup_key(pk2);
     smartlist_add(generated-&gt;intro_nodes, intro);
   }
-  test_assert(rend_encode_v2_descriptors(descs, generated, now,
-                                         NULL, 0) &gt; 0);
+  test_assert(rend_encode_v2_descriptors(descs, generated, now, 0,
+                                         REND_NO_AUTH, NULL, NULL) &gt; 0);
   test_assert(rend_compute_v2_desc_id(computed_desc_id, service_id_base32,
                                       NULL, now, 0) == 0);
   test_memeq(((rend_encoded_v2_service_descriptor_t *)
@@ -3923,9 +3923,8 @@
   test_assert(parsed);
   test_memeq(((rend_encoded_v2_service_descriptor_t *)
              smartlist_get(descs, 0))-&gt;desc_id, parsed_desc_id, DIGEST_LEN);
-  test_assert(rend_decrypt_introduction_points(parsed, NULL,
-                                               intro_points_encrypted,
-                                               intro_points_size) == 3);
+  test_assert(rend_parse_introduction_points(parsed, intro_points_encrypted,
+                                             intro_points_size) == 3);
   test_assert(!crypto_pk_cmp_keys(generated-&gt;pk, parsed-&gt;pk));
   test_eq(parsed-&gt;timestamp, now);
   test_eq(parsed-&gt;version, 2);


["patch-121-3.txt.sig" (application/octet-stream)]

</body></email><email><emailId>20080819035445</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2008-08-19 03:54:45-0400</timestampReceived><subject>Rejecting risky extend cells?</subject><body>

Hi Nick, others,

Does this need a proposal, or is it a clearly good patch? Ideas
suggested by rovv.

--Roger

Index: src/or/circuitbuild.c
===================================================================
--- src/or/circuitbuild.c	(revision 16587)
+++ src/or/circuitbuild.c	(working copy)
@@ -712,10 +712,13 @@
   circuit_expire_all_dirty_circs();
 }
 
-/** Take the 'extend' cell, pull out addr/port plus the onion skin. Make
- * sure we're connected to the next hop, and pass it the onion skin using
- * a create cell. Return -1 if we want to warn and tear down the circuit,
- * else return 0.
+/** Take the 'extend' &lt;b&gt;cell&lt;/b&gt;, pull out addr/port plus the onion
+ * skin and identity digest for the next hop. If we're already connected,
+ * pass the onion skin to the next hop using a create cell; otherwise
+ * launch a new OR connection, and &lt;b&gt;circ&lt;/b&gt; will notice when the
+ * connection succeeds or fails.
+ *
+ * Return -1 if we want to warn and tear down the circuit, else return 0.
  */
 int
 circuit_extend(cell_t *cell, circuit_t *circ)
@@ -753,6 +756,28 @@
   onionskin = cell-&gt;payload+RELAY_HEADER_SIZE+4+2;
   id_digest = cell-&gt;payload+RELAY_HEADER_SIZE+4+2+ONIONSKIN_CHALLENGE_LEN;
 
+  /* First, check if they asked us for 0000..0000. We support using
+   * an empty fingerprint for the first hop (e.g. for a bridge relay),
+   * but we don't want to let people send us extend cells for empty
+   * fingerprints -- a) because it opens the user up to a mitm attack,
+   * and b) because it lets an attacker force the relay to hold open a
+   * new TLS connection for each extend request. */
+  if (tor_digest_is_zero(id_digest)) {
+    log_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,
+           "Client asked me to extend without specifying an id_digest.");
+    return -1;
+  }
+
+  /* Next, check if we're being asked to connect to the hop that the
+   * extend cell came from. There isn't any reason for that, and it can
+   * assist circular-path attacks. */
+  if (!memcmp(id_digest, TO_OR_CIRCUIT(circ)-&gt;p_conn-&gt;identity_digest,
+              DIGEST_LEN)) {
+    log_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,
+           "Client asked me to extend back to the previous hop.");
+    return -1;
+  }
+
   n_conn = connection_or_get_by_identity_digest(id_digest);
 
   /* If we don't have an open conn, or the conn we have is obsolete
Index: doc/spec/tor-spec.txt
===================================================================
--- doc/spec/tor-spec.txt	(revision 16587)
+++ doc/spec/tor-spec.txt	(working copy)
@@ -398,9 +398,9 @@
    The port and address field denote the IPV4 address and port of the next
    onion router in the circuit; the public key hash is the hash of the PKCS#1
    ASN1 encoding of the next onion router's identity (signing) key.  (See 0.3
-   above.)  (Including this hash allows the extending OR verify that it is
+   above.)  Including this hash allows the extending OR verify that it is
    indeed connected to the correct target OR, and prevents certain
-   man-in-the-middle attacks.)
+   man-in-the-middle attacks.
 
    The payload for a CREATED cell, or the relay payload for an
    EXTENDED cell, contains:
@@ -525,10 +525,12 @@
 
    When an onion router receives an EXTEND relay cell, it sends a CREATE
    cell to the next onion router, with the enclosed onion skin as its
-   payload.  The initiating onion router chooses some circID not yet
-   used on the connection between the two onion routers.  (But see
-   section 5.1. above, concerning choosing circIDs based on
-   lexicographic order of nicknames.)
+   payload.  As special cases, if the extend cell includes a digest of
+   all zeroes, or asks to extend back to the relay that sent the extend
+   cell, the circuit will fail and be torn down. The initiating onion
+   router chooses some circID not yet used on the connection between the
+   two onion routers.  (But see section 5.1. above, concerning choosing
+   circIDs based on lexicographic order of nicknames.)
 
    When an onion router receives a CREATE cell, if it already has a
    circuit on the given connection with the given circID, it drops the
</body></email><email><emailId>20080819155319</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-08-19 15:53:19-0400</timestampReceived><subject>Re: Rejecting risky extend cells?</subject><body>

On Mon, Aug 18, 2008 at 11:54:45PM -0400, Roger Dingledine wrote:
&gt; Hi Nick, others,
&gt; 
&gt; Does this need a proposal, or is it a clearly good patch? Ideas
&gt; suggested by rovv.

Looks good to me.  I'd say check it in, and mark as backportable for
0.2.0.x.

In addition to checking for 2-hop loops, though, we should also check
for 1-hop loops (i.e., extending to yourself).  Do we?

yrs,
-- 
Nick
</body></email><email><emailId>20080811230203</emailId><senderName>Peter Palfrader</senderName><senderEmail>peter@palfrader.org</senderEmail><timestampReceived>2008-08-11 23:02:03-0400</timestampReceived><subject>Re: 141: exit policy summary</subject><body>

On Tue, 12 Aug 2008, Peter Palfrader wrote:

&gt; -rw-r--r--  1 weasel weasel 462899 Aug 12 00:56 cons-accept
&gt; -rw-r--r--  1 weasel weasel 432127 Aug 12 00:56 cons-reject
&gt; -rw-r--r--  1 weasel weasel 423023 Aug 12 00:56 cons-shorter
&gt; -rw-r--r--  1 weasel weasel 331860 Aug 12 00:48 consensus

exit-summary is in svn (/projects/dir-stats/trunk).

ES=~/exit-summary
rm -f cons-accept cons-reject cons-shorter
cat consensus | while read line; do
        echo $line &gt;&gt; cons-accept
        echo $line &gt;&gt; cons-reject
        echo $line &gt;&gt; cons-shorter
        if echo $line | grep '^r ' &gt; /dev/null; then
                i=`echo $line | awk '$1=="r" {print $4}'`
                sd=`echo $i | 64216`
                wget -q -O t http://tor.noreply.org:80/tor/server/d/$sd
                if [ "`$ES accept &lt; t`" != "accept " ]; then
                        (echo -n 'p '; $ES accept &lt; t) &gt;&gt; cons-accept
                        (echo -n 'p '; $ES reject &lt; t) &gt;&gt; cons-reject
                        (echo -n 'p '; $ES shorter &lt; t) &gt;&gt; cons-shorter
                fi
        fi
done 


[Note that this killed my zsh on sarge - it wouldn't exit anymore.]
-- 
                           |  .''`.  ** Debian GNU/Linux **
      Peter Palfrader      | : :' :      The  universal
 http://www.palfrader.org/ | `. `'      Operating System
                           |   `-    http://www.debian.org/
</body></email><email><emailId>20080812163544</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-08-12 16:35:44-0400</timestampReceived><subject>Re: 141: exit policy summary</subject><body>

On Tue, Aug 12, 2008 at 01:00:53AM +0200, Peter Palfrader wrote:
&gt; On Mon, 11 Aug 2008, Peter Palfrader wrote:
&gt; 
&gt; &gt;   An exit policy summary will be included in votes and consensus as a
&gt; &gt;   new line attached to each exit node.  A lack of policy should indicate
&gt; &gt;   a non-exit policy.  The line will have the format
&gt; &gt;    "p" &lt;space&gt; "accept"|"reject" &lt;portlist&gt;
&gt; &gt;   where portlist is a comma seperated list of single port numbers or
&gt; &gt;   portranges (e.g.  "22,80-88,1024-6000,6667").  Whether the summary
&gt; &gt;   shows the list of accepted ports or the list of rejected ports depends
&gt; &gt;   on which list is shorter (has less elements).  In case of ties we
&gt;                                  s/less elements/a shorter string representation/
&gt; &gt;   choose the list of accepted ports.

I wonder if we shouldn't cap the length in order to keep people from
playing silly games to DOS the directory system with the likes of

   accept: 1,3,5,7,9,11,13,15,...

 [...]
&gt; I'd still go for "shorter string representation", even if only because
&gt; it usually is nicer to read to the human.

I agree; the added logic isn't terribly difficult to do.

yrs,
-- 
Nick
</body></email><email><emailId>20080812163720</emailId><senderName>Peter Palfrader</senderName><senderEmail>peter@palfrader.org</senderEmail><timestampReceived>2008-08-12 16:37:20-0400</timestampReceived><subject>Re: 141: exit policy summary</subject><body>

On Tue, 12 Aug 2008, Nick Mathewson wrote:

&gt; On Tue, Aug 12, 2008 at 01:00:53AM +0200, Peter Palfrader wrote:
&gt; &gt; On Mon, 11 Aug 2008, Peter Palfrader wrote:
&gt; &gt; 
&gt; &gt; &gt;   An exit policy summary will be included in votes and consensus as a
&gt; &gt; &gt;   new line attached to each exit node.  A lack of policy should indicate
&gt; &gt; &gt;   a non-exit policy.  The line will have the format
&gt; &gt; &gt;    "p" &lt;space&gt; "accept"|"reject" &lt;portlist&gt;
&gt; &gt; &gt;   where portlist is a comma seperated list of single port numbers or
&gt; &gt; &gt;   portranges (e.g.  "22,80-88,1024-6000,6667").  Whether the summary
&gt; &gt; &gt;   shows the list of accepted ports or the list of rejected ports depends
&gt; &gt; &gt;   on which list is shorter (has less elements).  In case of ties we
&gt; &gt;                                  s/less elements/a shorter string representation/
&gt; &gt; &gt;   choose the list of accepted ports.
&gt; 
&gt; I wonder if we shouldn't cap the length in order to keep people from
&gt; playing silly games to DOS the directory system with the likes of
&gt; 
&gt;    accept: 1,3,5,7,9,11,13,15,...

Didn't you recently introduce a maximum length for descriptors?

-- 
                           |  .''`.  ** Debian GNU/Linux **
      Peter Palfrader      | : :' :      The  universal
 http://www.palfrader.org/ | `. `'      Operating System
                           |   `-    http://www.debian.org/
</body></email><email><emailId>20080814123957</emailId><senderName>Peter Palfrader</senderName><senderEmail>peter@palfrader.org</senderEmail><timestampReceived>2008-08-14 12:39:57-0400</timestampReceived><subject>Re: 141: exit policy summary</subject><body>

On Tue, 12 Aug 2008, Peter Palfrader wrote:

&gt; On Tue, 12 Aug 2008, Nick Mathewson wrote:
&gt; 
&gt; &gt; On Tue, Aug 12, 2008 at 01:00:53AM +0200, Peter Palfrader wrote:
&gt; &gt; &gt; On Mon, 11 Aug 2008, Peter Palfrader wrote:
&gt; &gt; &gt; 
&gt; &gt; &gt; &gt;   An exit policy summary will be included in votes and consensus as a
&gt; &gt; &gt; &gt;   new line attached to each exit node.  A lack of policy should indicate
&gt; &gt; &gt; &gt;   a non-exit policy.  The line will have the format
&gt; &gt; &gt; &gt;    "p" &lt;space&gt; "accept"|"reject" &lt;portlist&gt;
&gt; &gt; &gt; &gt;   where portlist is a comma seperated list of single port numbers or
&gt; &gt; &gt; &gt;   portranges (e.g.  "22,80-88,1024-6000,6667").  Whether the summary
&gt; &gt; &gt; &gt;   shows the list of accepted ports or the list of rejected ports depends
&gt; &gt; &gt; &gt;   on which list is shorter (has less elements).  In case of ties we
&gt; &gt; &gt;                                  s/less elements/a shorter string representation/
&gt; &gt; &gt; &gt;   choose the list of accepted ports.
&gt; &gt; 
&gt; &gt; I wonder if we shouldn't cap the length in order to keep people from
&gt; &gt; playing silly games to DOS the directory system with the likes of
&gt; &gt; 
&gt; &gt;    accept: 1,3,5,7,9,11,13,15,...
&gt; 
&gt; Didn't you recently introduce a maximum length for descriptors?

The spec now says to truncate lists at 1000 chars - which is still a
lot.

-- 
                           |  .''`.  ** Debian GNU/Linux **
      Peter Palfrader      | : :' :      The  universal
 http://www.palfrader.org/ | `. `'      Operating System
                           |   `-    http://www.debian.org/
</body></email><email><emailId>20080822030215</emailId><senderName>Dave</senderName><senderEmail>someguytryingtohelpwithtor@gmail.com</senderEmail><timestampReceived>2008-08-22 03:02:15-0400</timestampReceived><subject>Documentation patches for ./configure message</subject><body>

Hi everyone,

Sorry if this is the wrong place for this. I searched around and
'or-dev' seemed like the best place to submit a documentation patch.
Let me know if I should send this somewhere else.

--

I recently downloaded tor-0.2.0.30 and attempted to build from source.
When the configuration process could not find my openssl library
(under Ubuntu Edgy) it gave this error message:

"checking for openssl directory... configure: WARNING: Could not find
a linkable openssl.  If you have it installed somewhere unusal, you
can specify an explicit path using --with-ssl-dir"

Looking at the source, however, I believe this message should use the
switch '--with-openssl-dir' instead of '--with-ssl-dir'. A minor issue
perhaps, but nice to fix. Below is a patch to the configure.in file in
case you want to use it. There is also a patch to acinclude.m4 to fix
the minor typo for 'unusal'. Both of these are patched to the head SVN
files I downloaded a few hours ago - I hope that's current enough.


Cheers,
Dave

-------
--- configure.in	2008-08-22 01:58:51.000000000 +0000
+++ configure.in.patched	2008-08-22 02:41:47.000000000 +0000
@@ -286,7 +286,7 @@
 TOR_SEARCH_LIBRARY(openssl, $tryssldir, [-lssl -lcrypto $TOR_LIB_GDI],
     [#include &lt;openssl/rand.h&gt;],
     [void RAND_add(const void *buf, int num, double entropy);],
-    [RAND_add((void*)0,0,0); exit(0);], [--with-ssl-dir],
+    [RAND_add((void*)0,0,0); exit(0);], [--with-openssl-dir],
     [/usr/local/openssl /usr/lib/openssl /usr/local/ssl /usr/lib/ssl
/usr/local /usr/athena /opt/openssl])

 dnl XXXX check for OPENSSL_VERSION_NUMBER == SSLeay()

-------
--- acinclude.m4	2008-08-22 01:58:51.000000000 +0000
+++ acinclude.m4.patched	2008-08-22 02:40:13.000000000 +0000
@@ -129,7 +129,7 @@

   if test "$tor_$1_dir_found" = no; then
     if test "$tor_$1_any_linkable" = no ; then
-      AC_MSG_WARN([Could not find a linkable $1.  If you have it
installed somewhere unusal, you can specify an explicit path using
$7])
+      AC_MSG_WARN([Could not find a linkable $1.  If you have it
installed somewhere unusual, you can specify an explicit path using
$7])
       TOR_WARN_MISSING_LIB($1, pkg)
       AC_MSG_ERROR([Missing libraries; unable to proceed.])
     else
</body></email><email><emailId>20080811202839</emailId><senderName>Peter Palfrader</senderName><senderEmail>peter@palfrader.org</senderEmail><timestampReceived>2008-08-11 20:28:39-0400</timestampReceived><subject>Re: [or-cvs] r16423: We put bw info directory into the consensus, also versions a (tor/trunk/doc/spe</subject><body>

On Tue, 05 Aug 2008, Peter Palfrader wrote:

&gt; &gt; &gt; +   "w Bandwidth=193671"

-rw-r--r--  1 weasel weasel 152368 Aug 11 22:27 bwcons.gz
-rw-r--r--  1 weasel weasel 149638 Aug 11 22:27 bwcons2.gz
-rw-r--r--  1 weasel weasel 144137 Aug 11 22:21 consensus.gz

consensus is a consensus like we have it right now, bwcons is the same
with the new "w Bandwidth=1234" lines added and bwcons2 is the same only
with Bw rounded (or truncated) to kilobytes instead of bytes.  I do not
think we gain much from doing that tho.  Anybody think different?

-- 
                           |  .''`.  ** Debian GNU/Linux **
      Peter Palfrader      | : :' :      The  universal
 http://www.palfrader.org/ | `. `'      Operating System
                           |   `-    http://www.debian.org/
</body></email><email><emailId>20080821193157</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2008-08-21 19:31:57-0400</timestampReceived><subject>Future areas for Tor research</subject><body>

[I'm moving this thread to or-dev from personal mail so we can be more
transparent for the rest of the Tor researchers out there. -RD]

Hi Steven, others,

Here are some research directions that come to mind. We should expand
on this list, and also try to prioritize by a) which ones we can make
progress on, b) which ones matter most, and c) which ones I'm anticipating
funders want done when. I've mostly sorted the list below by 'b' and 'c'.
Eventually the list could go up on the website as research.wml.

Thanks,
--Roger

By end of 2008:
- Paul's NRL project to evaluate path selection under various trust
  distributions. The idea is to figure out safer/better ways to build
  paths if we assume some users trust some relays more than others.
- Peter's proposal 141. How to trade off descriptor fetching overhead
  with circuit-building overhead. Are there even better ways?

By end of 2009:
- Understand the risks from letting people relay traffic through your
  Tor while you're also being a Tor client. Compare risks from being a
  bridge relay to risks from being a 'full' relay. Come up with practical
  ways to mitigate.
- Take Roger's incentive.pdf design, flesh it out further, and see if we
  can find solutions to the long-term intersection attack that arises
  from attackers being able to correlate "that relay is online everytime
  this anonymous high-priority user does an action." (I need to clean up
  incentive.pdf and send it to this list.)

By end of 2010:
- Better load balancing algorithms, path selection choices, etc.
  Building on Mike Perry's work and Steven's PETS 2008 paper. Do we
  do simulations? analysis? How to compare them? Are there cases when
  we can switch to 2-hop paths, or the variable-hop paths?
- Evaluate the latency and clogging attacks that are coming out, figure
  out if they actually work, and produce countermeasures.
- Tor network scalability, the easy version: use several parallel
  networkstatus documents, have algorithms for clients to pick which to
  use, for relays to get assigned to one, and make sure new designs like
  Peter's proposal 141 will be compatible with this.
- There's a vulnerability right now where you can enumerate bridges by
  running a non-guard Tor server and seeing who connects that isn't
  a known relay. One solution is to use two layers of guards, meaning
  bridge users use 4-hop paths. Is this the best option we've got? They
  don't want to be slowed down like that.
- How many bridges do you need to know to maintain reachability? We
  should measure the churn in our bridges. If there is lots of churn,
  are there ways to keep bridge users more likely to stay connected?
- Related, more bridge address distribution strategies: Steven and I
  were talking about a ``bridge loop'' design where bridge identities form
  a ``loop'' at the bridgeDB , and if you know any bridge in the loop you
  can learn all the others. This approach will allow Tor clients who know
  a few bridges to be updated with new bridges as their old ones rotate,
  without opening up the list to full enumeration.

</body></email><email><emailId>20080811203212</emailId><senderName>Peter Palfrader</senderName><senderEmail>peter@palfrader.org</senderEmail><timestampReceived>2008-08-11 20:32:12-0400</timestampReceived><subject>Re: [or-cvs] r16423: We put bw info directory into the consensus, also versions a (tor/trunk/doc/spe</subject><body>

On Mon, 11 Aug 2008, Peter Palfrader wrote:

&gt; On Tue, 05 Aug 2008, Peter Palfrader wrote:
&gt; 
&gt; &gt; &gt; &gt; +   "w Bandwidth=193671"
&gt; 
&gt; -rw-r--r--  1 weasel weasel 152368 Aug 11 22:27 bwcons.gz
&gt; -rw-r--r--  1 weasel weasel 149638 Aug 11 22:27 bwcons2.gz
&gt; -rw-r--r--  1 weasel weasel 144137 Aug 11 22:21 consensus.gz

And just so that my zsh_history isn't the only place that has this code:

wget -O - -q http://tor.noreply.org:80/tor/status-vote/current/consensus | while read line; do
        echo $line
        if echo $line | grep '^r ' &gt; /dev/null; then
                i=`echo $line | awk '$1=="r" {print $4}'`
                sd=`echo $i | 64216`
                wget -q -O t http://tor.noreply.org:80/tor/server/d/$sd
                b=`awk '$1=="bandwidth" { if ($4 &lt; $2) print int($4/1024); else print int($2/1024); }' t`
                echo b $b
        fi
done | tee bwcons2


weasel@anguilla:~$ which 64216
64216: aliased to perl -MMIME::Base64 -e "print unpack(\"H*\", decode_base64(&lt;&gt;)),\"\n\""

-- 
                           |  .''`.  ** Debian GNU/Linux **
      Peter Palfrader      | : :' :      The  universal
 http://www.palfrader.org/ | `. `'      Operating System
                           |   `-    http://www.debian.org/
</body></email><email><emailId>20080811162532</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-08-11 16:25:32-0400</timestampReceived><subject>Re: Second patch for proposal 121</subject><body>

On Sun, Aug 10, 2008 at 12:38:35AM +0200, Karsten Loesing wrote:
 [...]

Hi, Karsten.  This one needs revision before I can check it in.

The big problem here is that the parsing logic in this patch is purely
additive: whenever it sees a HidServAuth line, it adds or replaces an
entry in auth_hid_servs.

Why is this a problem?  Consider what happens when we start with a
torrc file of

   HidServAuth abc.onion cookie1
   HidServAuth xyz.onion cookie2

and then we remove the second line and send Tor a sighup.  The
authorization entry for xyz.onion will still be in auth_hid_servs,
which is not what the user intended.



 [...]
&gt; +/** Client-side configuration of authorization for a hidden service. */
&gt; +typedef struct rend_service_authorization_t {
&gt; +  char descriptor_cookie[REND_DESC_COOKIE_LEN];
&gt; +  char onion_address[REND_SERVICE_ID_LEN_BASE32+1+5+1];
&gt; +  int auth_type;
&gt; +} rend_service_authorization_t;

auth_type should still not be an int.


&gt;  /** ASCII-encoded v2 hidden service descriptor. */
&gt;  typedef struct rend_encoded_v2_service_descriptor_t {
&gt;    char desc_id[DIGEST_LEN]; /**&lt; Descriptor ID. */
&gt; @@ -3890,6 +3900,7 @@
&gt;  void rend_get_descriptor_id_bytes(char *descriptor_id_out,
&gt;                                    const char *service_id,
&gt;                                    const char *secret_id_part);
&gt; +rend_service_authorization_t *lookup_client_auth(char *onion_address);

This should take a "const char *".  When a function takes a "char *",
that usually means that it is going to modify the pointed-to memory
that it gets.  C has had a const modifier since C90, I believe.  18
years in, we should darned well be using it.

The same goes for rend_parse_client_auth, I believe.

Also, the name of this function should to be prefixed to make its
content clear.  If I see it in code, I should know *what* it's looking
up the authorization for.  rend_client_lookup_auth() would be a better
name.



&gt;  
&gt;  /********************************* rendservice.c ***************************/
&gt;  
&gt; Index: /home/karsten/tor/tor-trunk-121-patches/src/or/rendclient.c
&gt; ===================================================================
&gt; --- /home/karsten/tor/tor-trunk-121-patches/src/or/rendclient.c	(revision 16480)
&gt; +++ /home/karsten/tor/tor-trunk-121-patches/src/or/rendclient.c	(working copy)
&gt; @@ -713,3 +713,104 @@
&gt;    return extend_info_dup(intro-&gt;extend_info);
&gt;  }
&gt;  
&gt; +/** Client-side authorizations for hidden services; map of onion address to
&gt; + * rend_service_authorization_t*. */
&gt; +static strmap_t *auth_hid_servs = NULL;

There needs to be an appropriate free_all() function to release the
storage held here, invoked from tor_free_all() in main.c, so that our
leak-checking methods won't freak out.


&gt; +/** Parse &lt;b&gt;config_line&lt;/b&gt; as a client-side authorization for a hidden
&gt; + * service and add it to the local map of hidden service authorizations.
&gt; + * Return 0 for success and -1 for failure. */
&gt; +int
&gt; +rend_parse_client_auth(char *config_line)
&gt; +{
&gt; +  char *onion_address, *descriptor_cookie;
&gt; +  char descriptor_cookie_tmp[REND_DESC_COOKIE_LEN+2];
&gt; +  char descriptor_cookie_base64ext[REND_DESC_COOKIE_LEN_BASE64+2+1];
&gt; +  smartlist_t *sl = smartlist_create();
&gt; +  rend_service_authorization_t *auth = NULL;
&gt; +  int res = -1, auth_type = 0;
&gt; +  tor_assert(config_line);
&gt; +  smartlist_split_string(sl, config_line, " ",
&gt; +                         SPLIT_SKIP_SPACE|SPLIT_IGNORE_BLANK, 3);
&gt; +  if (smartlist_len(sl) &lt; 2) {
&gt; +    log_warn(LD_CONFIG, "Configuration line does not consist of "
&gt; +             "\"onion-address authorization-cookie [service-name]\": '%s'",
&gt; +             config_line);
&gt; +    goto free;
&gt; +  }
&gt; +  auth = tor_malloc_zero(sizeof(rend_service_authorization_t));
&gt; +  /* Parse onion address. */
&gt; +  onion_address = smartlist_get(sl, 0);
&gt; +  if (strlen(onion_address) != 16+1+5 ||

16+1+5 is 3 magic numbers in a row.

&gt; +      strstr(onion_address, ".onion") != onion_address + 16) {

It would be more idiomatic to use strcmpend() for this check.

&gt; +    log_warn(LD_CONFIG, "Onion address has wrong format: '%s'",
&gt; +             onion_address);
&gt; +    goto free;
&gt; +  }
&gt; +  strlcpy(auth-&gt;onion_address, onion_address, 16+1);
&gt; +  if (!rend_valid_service_id(auth-&gt;onion_address)) {
&gt; +    log_warn(LD_CONFIG, "Onion address has wrong format: '%s'",
&gt; +             onion_address);
&gt; +    goto free;
&gt; +  }
&gt; +  /* Parse descriptor cookie. */
&gt; +  descriptor_cookie = smartlist_get(sl, 1);
&gt; +  if (strlen(descriptor_cookie) != 22) {
&gt; +    log_warn(LD_CONFIG, "Authorization cookie has wrong length: '%s'",
&gt; +             descriptor_cookie);
&gt; +    goto free;
&gt; +  }
&gt; +  /* Add trailing zero bytes (AA) to make base64-decoding happy. */
&gt; +  tor_snprintf(descriptor_cookie_base64ext,
&gt; +               REND_DESC_COOKIE_LEN_BASE64+2+1,
&gt; +               "%sAA", descriptor_cookie);
&gt; +  if (base64_decode(descriptor_cookie_tmp, REND_DESC_COOKIE_LEN+2,
&gt; +                    descriptor_cookie_base64ext,
&gt; +                    strlen(descriptor_cookie_base64ext)) &lt; 0) {
&gt; +    log_warn(LD_CONFIG, "Decoding authorization cookie failed: '%s'",
&gt; +             descriptor_cookie);
&gt; +    goto free;
&gt; +  }
&gt; +  auth_type = (descriptor_cookie_tmp[16] &gt;&gt; 4) + 1;
&gt; +  if (auth_type &lt; 1 || auth_type &gt; 2) {
&gt; +    log_warn(LD_CONFIG, "Authorization cookie has unknown authorization type "
&gt; +             "encoded.");
&gt; +    goto free;


Didn't we have an enum for this?

&gt; +  }
&gt; +  auth-&gt;auth_type = auth_type;
&gt; +  memcpy(auth-&gt;descriptor_cookie, descriptor_cookie_tmp,
&gt; +         REND_DESC_COOKIE_LEN);
&gt; +  /* Add parsed client authorization to local map. */
&gt; +  if (!auth_hid_servs)
&gt; +    auth_hid_servs = strmap_new();
&gt; +  strmap_set(auth_hid_servs, auth-&gt;onion_address, auth);

If had an earlier setting for this service, we just leaked the memory
for it.

&gt; +  auth = NULL;
&gt; +  res = 0;
&gt; + free:
&gt; +  if (sl)
&gt; +    SMARTLIST_FOREACH(sl, char *, c, tor_free(c););
&gt; +  smartlist_free(sl);
&gt; +  if (auth)
&gt; +    rend_service_authorization_free(auth);
&gt; +  return res;
&gt; +}
&gt; +
&gt; 


</body></email><email><emailId>20080814124031</emailId><senderName>Peter Palfrader</senderName><senderEmail>peter@palfrader.org</senderEmail><timestampReceived>2008-08-14 12:40:31-0400</timestampReceived><subject>Re: [or-cvs] r16423: We put bw info directory into the consensus, also versions a (tor/trunk/doc/spe</subject><body>

On Mon, 11 Aug 2008, Peter Palfrader wrote:

&gt; On Tue, 05 Aug 2008, Peter Palfrader wrote:
&gt; 
&gt; &gt; &gt; &gt; +   "w Bandwidth=193671"
&gt; 
&gt; -rw-r--r--  1 weasel weasel 152368 Aug 11 22:27 bwcons.gz
&gt; -rw-r--r--  1 weasel weasel 149638 Aug 11 22:27 bwcons2.gz
&gt; -rw-r--r--  1 weasel weasel 144137 Aug 11 22:21 consensus.gz
&gt; 
&gt; consensus is a consensus like we have it right now, bwcons is the same
&gt; with the new "w Bandwidth=1234" lines added and bwcons2 is the same only
&gt; with Bw rounded (or truncated) to kilobytes instead of bytes.  I do not
&gt; think we gain much from doing that tho.  Anybody think different?

Another point of view is that using kilobytes saves us half of what we
add with this, so the proposal and code now both use kb here.

-- 
                           |  .''`.  ** Debian GNU/Linux **
      Peter Palfrader      | : :' :      The  universal
 http://www.palfrader.org/ | `. `'      Operating System
                           |   `-    http://www.debian.org/
</body></email><email><emailId>20080814124602</emailId><senderName>Peter Palfrader</senderName><senderEmail>peter@palfrader.org</senderEmail><timestampReceived>2008-08-14 12:46:02-0400</timestampReceived><subject>consensus method number for 141</subject><body>

On Mon, 11 Aug 2008, weasel@seul.org wrote:

&gt; +4. Migration
&gt; +
&gt; +4.1 Consensus document changes.
&gt; +
&gt; +  The consensus will need to include
&gt; +    - bandwidth information (see 3.1)
&gt; +    - exit policy summaries (3.4)
&gt; +
&gt; +  A new consensus method (number TBD) will be chosen for this.

I claim consensus method number 5.

-- 
                           |  .''`.  ** Debian GNU/Linux **
      Peter Palfrader      | : :' :      The  universal
 http://www.palfrader.org/ | `. `'      Operating System
                           |   `-    http://www.debian.org/
</body></email><email><emailId>20080814230337</emailId><senderName>Peter Palfrader</senderName><senderEmail>peter@palfrader.org</senderEmail><timestampReceived>2008-08-14 23:03:37-0400</timestampReceived><subject>Re: 141: exit policy summary</subject><body>

On Mon, 11 Aug 2008, Peter Palfrader wrote:

&gt;   Similarly to IP address, ports, timestamp, and bandwidth a consensus
&gt;   should list the exit policy matching the descriptor digest referenced
&gt;   in the consensus document.

That doesn't work so well, since some voters can "abstain" - simply by
being too old to support consensus-method 5 and the associated new
fields in votes.

the new version reads:

| 3.4.1 Consensus selection
| 
|   When building a consensus, authorities have to agree on a digest of
|   the server descriptor to list in the router line for each router.
|   This is documented in dir-spec section 3.4.
| 
|   All authorities that listed that agreed upon descriptor digest in
|   their vote should also list the same exit policy summary - or list
|   none at all if the authority has not been upgraded to list that
|   information in their vote.
| 
|   If we have votes with matching server descriptor digest of which at
|   least one of them has an exit policy then we differ between two cases:
|    a) all authorities agree (or abstained) on the policy summary, and we
|       use the exit policy summary that they all listed in their vote,
|    b) something went wrong (or some authority is playing foul) and we
|       have different policy summaries.  In that case we pick the one
|       that is most commonly listed in votes with the matching
|       descriptor.  We break ties in favour of the lexigraphically larger
|       vote.
| 
|   If none one of the votes with a matching server descriptor digest has
|   an exit policy summary we use the most commonly listed one in all
|   votes, breaking ties like in case b above.

-- 
                           |  .''`.  ** Debian GNU/Linux **
      Peter Palfrader      | : :' :      The  universal
 http://www.palfrader.org/ | `. `'      Operating System
                           |   `-    http://www.debian.org/
</body></email><email><emailId>20080815215108</emailId><senderName>Karsten Loesing</senderName><senderEmail>karsten.loesing@gmx.net</senderEmail><timestampReceived>2008-08-15 21:51:08-0400</timestampReceived><subject>Re: Possible design changes to improve hidden service performance</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Hi list,

Karsten Loesing wrote on 2008-07-15:
&gt; Christian Wilms and I have finished a document describing 7 possible 
&gt; design changes to make the hidden service protocol faster. Some of
&gt; those ideas have implications on network load or anonymity which are
&gt; mentioned in that document, too. Our intention is to discuss these
&gt; ideas here until, say, beginning of August and write a proposal
&gt; including the ideas that have survived the discussion process until
&gt; mid of August.
&gt; 
&gt; http://freehaven.net/~karsten/hidserv/discussion-2008-07-15.pdf

Today, one month later, these 7 possible design changes have been
evaluated and discussed in more detail. We plan to implement 5 of them
and have given up on 2 of them for various reasons.

If you are interested in the results, including the reasons for or
against certain designs, you might want to read our mid-August report:

http://freehaven.net/~karsten/hidserv/design-2008-08-15.pdf

This report is part of the NLnet Project: Speed Up Tor Hidden Services
(https://www.torproject.org/projects/hidserv)

Again, comments are most welcome!

- --Karsten
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFIpfpM0M+WPffBEmURAhofAJ99468KWOMOpLift3uFgDOU/tRlAQCdHeX6
uA8axHvPwME9uykYz1QuxRQ=
=UqnD
-----END PGP SIGNATURE-----
</body></email><email><emailId>20080819154359</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-08-19 15:43:59-0400</timestampReceived><subject>Re: Third patch for proposal 121</subject><body>

On Wed, Aug 13, 2008 at 02:02:45PM +0200, Karsten Loesing wrote:
&gt; -----BEGIN PGP SIGNED MESSAGE-----
&gt; Hash: SHA1
&gt; 
&gt; Hi Nick,
&gt; 
&gt; here is the third patch to implement proposal 121---which is the first
&gt; that actually changes protocol messages and not just the local
&gt; configuration. This is the plan:
&gt; 
&gt; 3. This third patch uses authorization data that was configured using
&gt; the code in patch 1 to encode, encrypt, and upload hidden service
&gt; descriptors for services with either 'basic' or 'stealth' client
&gt; authorization.

Applied with slight tweaks.  "const char *" is not just for arguments;
it's also for the variable type in SMARTLIST_FOREACH iterations.

BTW, you _have_ tested this with 0 clients configured, and with over
16 clients configured, yes?

-- 
Nick

</body></email><email><emailId>20080820060029</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2008-08-20 06:00:29-0400</timestampReceived><subject>Re: Rejecting risky extend cells?</subject><body>

On Tue, Aug 19, 2008 at 11:53:19AM -0400, Nick Mathewson wrote:
&gt; On Mon, Aug 18, 2008 at 11:54:45PM -0400, Roger Dingledine wrote:
&gt; &gt; Hi Nick, others,
&gt; &gt; 
&gt; &gt; Does this need a proposal, or is it a clearly good patch? Ideas
&gt; &gt; suggested by rovv.
&gt; 
&gt; Looks good to me.  I'd say check it in,

r16605

&gt; and mark as backportable for 0.2.0.x.

r16606

&gt; In addition to checking for 2-hop loops, though, we should also check
&gt; for 1-hop loops (i.e., extending to yourself).  Do we?

We do. connection_or_connect() checks if (server_mode(options) &amp;&amp;
router_digest_is_me(id_digest)), and returns null if so.

--Roger

</body></email><email><emailId>20080821112414</emailId><senderName>Karsten Loesing</senderName><senderEmail>karsten.loesing@gmx.net</senderEmail><timestampReceived>2008-08-21 11:24:14-0400</timestampReceived><subject>Fourth patch for proposal 121</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Hi Nick,

this is the fourth and final patch to implement the basic functionality
of proposal 121. There are going to be minor tweaks requiring future
patches, but after this one things will work:

4. This patch uses authorization data on client side (that was
introduced with patch 2) to download and decrypt hidden service
descriptors and establish connections to services that perform
client authorization.

Nick Mathewson wrote:
&gt; BTW, you _have_ tested this with 0 clients configured, and with over
&gt; 16 clients configured, yes?

Yes, I have tested these cases before splitting the code into patches
and once more for this fourth patch that puts things back together.

- --Karsten
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFIrVBd0M+WPffBEmURAiyQAKDV2VBvEVT/kawewfbDulcbBpjemgCeIJye
4I5hz/VgBWnNkvdbuuG0vsg=
=j/Us
-----END PGP SIGNATURE-----

["patch-121-4.txt" (text/plain)]

Index: /home/karsten/tor/tor-trunk-121-patches/doc/tor.1.in
===================================================================
--- /home/karsten/tor/tor-trunk-121-patches/doc/tor.1.in	(revision 16614)
+++ /home/karsten/tor/tor-trunk-121-patches/doc/tor.1.in	(working copy)
@@ -472,6 +472,15 @@
 ReachableAddresses instead. (Default: 80, 443)
 .LP
 .TP
+\fBHidServAuth \fR\fIonion-address\fR \fIauth-cookie\fP \fIservice-name\fR 
+Client authorization for a hidden service. Valid onion addresses contain 16
+characters in a-z2-7 plus ".onion", and valid auth cookies contain 22
+characters in A-Za-z0-9+/. The service name is only used for internal
+purposes, e.g., for Tor controllers. This option may be used multiple times
+for different hidden services. If a hidden service uses authorization and
+this option is not set, the hidden service is not accessible.
+.LP
+.TP
 \fBReachableAddresses \fR\fIADDR\fP[\fB/\fP\fIMASK\fP][:\fIPORT\fP]...\fP
 A comma-separated list of IP addresses and ports that your firewall allows you
 to connect to. The format is as
@@ -1268,6 +1277,18 @@
 service. Possible version numbers are 0 and 2. (Default: 0, 2)
 .LP
 .TP
+\fBHiddenServiceAuthorizeClient \fR\fIauth-type\fR \fR\fIclient-name\fR,\fIclient-name\fR,\fI...\fP
+If configured, the hidden service is accessible for authorized clients
+only. The auth-type can either be 'basic' for a general-purpose
+authorization protocol or 'stealth' for a less scalable protocol that also
+hides service activity from unauthorized clients. Only clients that are
+listed here are authorized to access the hidden service. Valid client names
+are 1 to 19 characters long and only use characters in A-Za-z0-9+-_
+(no spaces). If this option is set, the hidden service is not accessible
+for clients without authorization any more. Generated authorization data
+can be found in the hostname file.
+.LP
+.TP
 \fBRendPostPeriod \fR\fIN\fR \fBseconds\fR|\fBminutes\fR|\fBhours\fR|\fBdays\fR|\fBweeks\fP
 Every time the specified period elapses, Tor uploads any rendezvous
 service descriptors to the directory servers.  This information is also
@@ -1452,6 +1473,8 @@
 .TP
 .B \fIHiddenServiceDirectory\fP/hostname 
 The &lt;base32-encoded-fingerprint&gt;.onion domain name for this hidden service.
+If the hidden service is restricted to authorized clients only, this file
+also contains authorization data for all clients.
 .LP
 .TP
 .B \fIHiddenServiceDirectory\fP/private_key 
@@ -1456,6 +1479,11 @@
 .TP
 .B \fIHiddenServiceDirectory\fP/private_key 
 The private key for this hidden service.
+.LP
+.TP
+.B \fIHiddenServiceDirectory\fP/client_keys 
+Authorization data for a hidden service that is only accessible by authorized
+clients.
 .SH SEE ALSO
 .BR privoxy (1),
 .BR tsocks (1),
Index: /home/karsten/tor/tor-trunk-121-patches/src/or/circuitbuild.c
===================================================================
--- /home/karsten/tor/tor-trunk-121-patches/src/or/circuitbuild.c	(revision 16614)
+++ /home/karsten/tor/tor-trunk-121-patches/src/or/circuitbuild.c	(working copy)
@@ -2933,7 +2933,8 @@
                              1, bridge-&gt;identity,
                              DIR_PURPOSE_FETCH_SERVERDESC,
                              ROUTER_PURPOSE_BRIDGE,
-                             0, "authority.z", NULL, 0, 0);
+                             0, "authority.z", NULL, 0, 0,
+                             NULL, REND_NO_AUTH, NULL);
   tor_free(address);
 }
 
Index: /home/karsten/tor/tor-trunk-121-patches/src/or/circuitlist.c
===================================================================
--- /home/karsten/tor/tor-trunk-121-patches/src/or/circuitlist.c	(revision 16614)
+++ /home/karsten/tor/tor-trunk-121-patches/src/or/circuitlist.c	(working copy)
@@ -1026,7 +1026,8 @@
              safe_str(ocirc-&gt;rend_query),
              safe_str(build_state_get_exit_nickname(ocirc-&gt;build_state)));
     rend_client_remove_intro_point(ocirc-&gt;build_state-&gt;chosen_exit,
-                                   ocirc-&gt;rend_query);
+                                   ocirc-&gt;rend_query, ocirc-&gt;rend_auth_type,
+                                   ocirc-&gt;rend_desc_cookie);
   }
   if (circ-&gt;n_conn)
     connection_or_send_destroy(circ-&gt;n_circ_id, circ-&gt;n_conn, reason);
Index: /home/karsten/tor/tor-trunk-121-patches/src/or/circuituse.c
===================================================================
--- /home/karsten/tor/tor-trunk-121-patches/src/or/circuituse.c	(revision 16614)
+++ /home/karsten/tor/tor-trunk-121-patches/src/or/circuituse.c	(working copy)
@@ -1056,8 +1056,14 @@
         log_info(LD_REND,
                  "No intro points for '%s': refetching service descriptor.",
                  safe_str(conn-&gt;rend_query));
-        rend_client_refetch_renddesc(conn-&gt;rend_query);
-        rend_client_refetch_v2_renddesc(conn-&gt;rend_query);
+        /* Fetch both, v0 and v2 rend descriptors in parallel. Use whichever
+         * arrives first. Exception: When using client authorization, only
+         * fetch v2 descriptors.*/
+        rend_client_refetch_v2_renddesc(conn-&gt;rend_query,
+                                        conn-&gt;rend_auth_type,
+                                        conn-&gt;rend_desc_cookie);
+        if (conn-&gt;rend_auth_type == REND_NO_AUTH)
+          rend_client_refetch_renddesc(conn-&gt;rend_query);
         conn-&gt;_base.state = AP_CONN_STATE_RENDDESC_WAIT;
         return 0;
       }
@@ -1139,6 +1145,11 @@
       if (circ) {
         /* write the service_id into circ */
         strlcpy(circ-&gt;rend_query, conn-&gt;rend_query, sizeof(circ-&gt;rend_query));
+        if (conn-&gt;rend_auth_type != REND_NO_AUTH) {
+          memcpy(circ-&gt;rend_desc_cookie, conn-&gt;rend_desc_cookie,
+                 REND_DESC_COOKIE_LEN);
+          circ-&gt;rend_auth_type = conn-&gt;rend_auth_type;
+        }
         if (circ-&gt;_base.purpose == CIRCUIT_PURPOSE_C_ESTABLISH_REND &amp;&amp;
             circ-&gt;_base.state == CIRCUIT_STATE_OPEN)
           rend_client_rendcirc_has_opened(circ);
Index: /home/karsten/tor/tor-trunk-121-patches/src/or/connection.c
===================================================================
--- /home/karsten/tor/tor-trunk-121-patches/src/or/connection.c	(revision 16614)
+++ /home/karsten/tor/tor-trunk-121-patches/src/or/connection.c	(working copy)
@@ -487,7 +487,9 @@
        if (conn-&gt;purpose == DIR_PURPOSE_FETCH_RENDDESC_V2 &amp;&amp;
            dir_conn-&gt;rend_query &amp;&amp;
            strlen(dir_conn-&gt;rend_query) == REND_SERVICE_ID_LEN_BASE32)
-        rend_client_refetch_v2_renddesc(dir_conn-&gt;rend_query);
+        rend_client_refetch_v2_renddesc(dir_conn-&gt;rend_query,
+                                        dir_conn-&gt;rend_auth_type,
+                                        dir_conn-&gt;rend_desc_cookie);
       break;
     case CONN_TYPE_OR:
       or_conn = TO_OR_CONN(conn);
Index: /home/karsten/tor/tor-trunk-121-patches/src/or/connection_edge.c
===================================================================
--- /home/karsten/tor/tor-trunk-121-patches/src/or/connection_edge.c	(revision 16614)
+++ /home/karsten/tor/tor-trunk-121-patches/src/or/connection_edge.c	(working copy)
@@ -1582,6 +1582,7 @@
     /* it's a hidden-service request */
     rend_cache_entry_t *entry;
     int r;
+    rend_service_authorization_t *client_auth;
     tor_assert(!automap);
     if (SOCKS_COMMAND_IS_RESOLVE(socks-&gt;command)) {
       /* if it's a resolve request, fail it right now, rather than
@@ -1619,6 +1620,15 @@
      * a stable circuit yet, but we know we'll need *something*. */
     rep_hist_note_used_internal(now, 0, 1);
 
+    /* Look up if we have client authorization for it. */
+    client_auth = rend_client_lookup_service_authorization(conn-&gt;rend_query);
+    if (client_auth) {
+      log_info(LD_REND, "Using previously configured client authorization "
+                        "for hidden service request.");
+      memcpy(conn-&gt;rend_desc_cookie, client_auth-&gt;descriptor_cookie,
+             REND_DESC_COOKIE_LEN);
+      conn-&gt;rend_auth_type = client_auth-&gt;auth_type;
+    }
     if (r==0) {
       conn-&gt;_base.state = AP_CONN_STATE_RENDDESC_WAIT;
       log_info(LD_REND, "Unknown descriptor %s. Fetching.",
@@ -1624,9 +1634,13 @@
       log_info(LD_REND, "Unknown descriptor %s. Fetching.",
                safe_str(conn-&gt;rend_query));
       /* Fetch both, v0 and v2 rend descriptors in parallel. Use whichever
-       * arrives first. */
-      rend_client_refetch_v2_renddesc(conn-&gt;rend_query);
-      rend_client_refetch_renddesc(conn-&gt;rend_query);
+       * arrives first. Exception: When using client authorization, only
+       * fetch v2 descriptors.*/
+      rend_client_refetch_v2_renddesc(conn-&gt;rend_query,
+                                      conn-&gt;rend_auth_type,
+                                      conn-&gt;rend_desc_cookie);
+      if (conn-&gt;rend_auth_type == REND_NO_AUTH)
+        rend_client_refetch_renddesc(conn-&gt;rend_query);
     } else { /* r &gt; 0 */
 /** How long after we receive a hidden service descriptor do we consider
  * it valid? */
@@ -1644,9 +1658,13 @@
         log_info(LD_REND, "Stale descriptor %s. Refetching.",
                  safe_str(conn-&gt;rend_query));
         /* Fetch both, v0 and v2 rend descriptors in parallel. Use whichever
-         * arrives first. */
-        rend_client_refetch_v2_renddesc(conn-&gt;rend_query);
-        rend_client_refetch_renddesc(conn-&gt;rend_query);
+         * arrives first. Exception: When using client authorization, only
+         * fetch v2 descriptors.*/
+        rend_client_refetch_v2_renddesc(conn-&gt;rend_query,
+                                        conn-&gt;rend_auth_type,
+                                        conn-&gt;rend_desc_cookie);
+        if (conn-&gt;rend_auth_type == REND_NO_AUTH)
+          rend_client_refetch_renddesc(conn-&gt;rend_query);
       }
     }
     return 0;
Index: /home/karsten/tor/tor-trunk-121-patches/src/or/directory.c
===================================================================
--- /home/karsten/tor/tor-trunk-121-patches/src/or/directory.c	(revision 16614)
+++ /home/karsten/tor/tor-trunk-121-patches/src/or/directory.c	(working copy)
@@ -266,7 +266,8 @@
       directory_initiate_command_routerstatus(rs, dir_purpose,
                                               router_purpose,
                                               post_via_tor,
-                                              NULL, payload, upload_len, 0);
+                                              NULL, payload, upload_len, 0,
+                                              NULL, REND_NO_AUTH, NULL);
   } SMARTLIST_FOREACH_END(ds);
   if (!found) {
     char *s = authority_type_to_string(type);
@@ -353,7 +354,8 @@
                                    1, ri-&gt;cache_info.identity_digest,
                                    dir_purpose,
                                    router_purpose,
-                                   0, resource, NULL, 0, if_modified_since);
+                                   0, resource, NULL, 0, if_modified_since,
+                                   NULL, REND_NO_AUTH, NULL);
       } else
         log_notice(LD_DIR, "Ignoring directory request, since no bridge "
                            "nodes are available yet.");
@@ -396,7 +398,8 @@
                                             router_purpose,
                                             get_via_tor,
                                             resource, NULL, 0,
-                                            if_modified_since);
+                                            if_modified_since,
+                                            NULL, REND_NO_AUTH, NULL);
   else {
     log_notice(LD_DIR,
                "While fetching directory info, "
@@ -430,7 +433,8 @@
         continue;
       rs = &amp;ds-&gt;fake_status;
       directory_initiate_command_routerstatus(rs, dir_purpose, router_purpose,
-                                              0, resource, NULL, 0, 0);
+                                              0, resource, NULL, 0, 0,
+                                              NULL, REND_NO_AUTH, NULL);
     });
 }
 
@@ -456,7 +460,10 @@
                                         const char *resource,
                                         const char *payload,
                                         size_t payload_len,
-                                        time_t if_modified_since)
+                                        time_t if_modified_since,
+                                        const char *rend_query,
+                                        rend_auth_type_t auth_type,
+                                        const char *rend_desc_cookie)
 {
   routerinfo_t *router;
   char address_buf[INET_NTOA_BUF_LEN+1];
@@ -478,7 +485,8 @@
                              status-&gt;identity_digest,
                              dir_purpose, router_purpose,
                              anonymized_connection, resource,
-                             payload, payload_len, if_modified_since);
+                             payload, payload_len, if_modified_since,
+                             rend_query, auth_type, rend_desc_cookie);
 }
 
 /** Return true iff &lt;b&gt;conn&lt;/b&gt; is the client side of a directory connection
@@ -661,7 +669,10 @@
                            uint8_t dir_purpose, uint8_t router_purpose,
                            int anonymized_connection, const char *resource,
                            const char *payload, size_t payload_len,
-                           time_t if_modified_since)
+                           time_t if_modified_since,
+                           const char *rend_query,
+                           rend_auth_type_t auth_type,
+                           const char *rend_desc_cookie)
 {
   dir_connection_t *conn;
   or_options_t *options = get_options();
@@ -700,6 +711,13 @@
   /* decide whether we can learn our IP address from this conn */
   conn-&gt;dirconn_direct = !anonymized_connection;
 
+  /* copy rendezvous data, if any */
+  if (rend_query)
+    strlcpy(conn-&gt;rend_query, rend_query, sizeof(conn-&gt;rend_query));
+  conn-&gt;rend_auth_type = auth_type;
+  if (rend_desc_cookie)
+    memcpy(conn-&gt;rend_desc_cookie, rend_desc_cookie, REND_DESC_COOKIE_LEN);
+
   if (!anonymized_connection &amp;&amp; !use_begindir) {
     /* then we want to connect to dirport directly */
 
@@ -1012,10 +1030,8 @@
     case DIR_PURPOSE_FETCH_RENDDESC_V2:
       tor_assert(resource);
       tor_assert(strlen(resource) &lt;= REND_DESC_ID_V2_LEN_BASE32);
-      /* Remember the query to refer to it when a response arrives. */
-      strlcpy(conn-&gt;rend_query, payload, sizeof(conn-&gt;rend_query));
+      tor_assert(!payload);
       conn-&gt;rend_version = 2;
-      payload = NULL;
       httpcommand = "GET";
       len = strlen(resource) + 32;
       url = tor_malloc(len);
@@ -1912,7 +1928,8 @@
              (int)body_len, status_code, escaped(reason));
     switch (status_code) {
       case 200:
-        switch (rend_cache_store_v2_desc_as_client(body, NULL)) {
+        switch (rend_cache_store_v2_desc_as_client(body,
+                    conn-&gt;rend_auth_type, conn-&gt;rend_desc_cookie)) {
           case -2:
             log_warn(LD_REND,"Fetching v2 rendezvous descriptor failed. "
                      "Retrying at another directory.");
Index: /home/karsten/tor/tor-trunk-121-patches/src/or/networkstatus.c
===================================================================
--- /home/karsten/tor/tor-trunk-121-patches/src/or/networkstatus.c	(revision 16614)
+++ /home/karsten/tor/tor-trunk-121-patches/src/or/networkstatus.c	(working copy)
@@ -1033,7 +1033,8 @@
                0, /* Not private */
                resource,
                NULL, 0 /* No payload. */,
-               0 /* No I-M-S. */);
+               0 /* No I-M-S. */,
+               NULL, REND_NO_AUTH, NULL);
       }
     SMARTLIST_FOREACH_END(ds);
   } else {
Index: /home/karsten/tor/tor-trunk-121-patches/src/or/or.h
===================================================================
--- /home/karsten/tor/tor-trunk-121-patches/src/or/or.h	(revision 16614)
+++ /home/karsten/tor/tor-trunk-121-patches/src/or/or.h	(working copy)
@@ -676,6 +676,18 @@
 /** Maximum length of authorized client names for a hidden service. */
 #define REND_CLIENTNAME_MAX_LEN 16
 
+/** Client authorization type that a hidden service performs. */
+typedef enum rend_auth_type_t {
+  REND_NO_AUTH      = 0,
+  REND_BASIC_AUTH   = 1,
+  REND_STEALTH_AUTH = 2,
+} rend_auth_type_t;
+
+/** Time interval for tracking possible replays of INTRODUCE2 cells.
+ * Incoming cells with timestamps half of this interval in the past or
+ * future are dropped immediately. */
+#define REND_REPLAY_TIME_INTERVAL (60 * 60)
+
 #define CELL_DIRECTION_IN 1
 #define CELL_DIRECTION_OUT 2
 
@@ -1043,6 +1055,15 @@
   /** What rendezvous service are we querying for? (AP only) */
   char rend_query[REND_SERVICE_ID_LEN_BASE32+1];
 
+  /** (Optional) descriptor cookie for requesting v2 hidden service
+   * descriptors, decrypting introduction points, and authenticating at
+   * hidden service. */
+  char rend_desc_cookie[REND_DESC_COOKIE_LEN];
+
+  /** Client authorization type that is used for this hidden-service
+   * request, if any. */
+  rend_auth_type_t rend_auth_type;
+
   /** Number of times we've reassigned this application connection to
    * a new circuit. We keep track because the timeout is longer if we've
    * already retried several times. */
@@ -1100,6 +1121,15 @@
   /** What rendezvous service are we querying for? */
   char rend_query[REND_SERVICE_ID_LEN_BASE32+1];
 
+  /** (Optional) descriptor cookie for requesting v2 hidden service
+   * descriptors, decrypting introduction points, and authenticating at
+   * hidden service. */
+  char rend_desc_cookie[REND_DESC_COOKIE_LEN];
+
+  /** Client authorization type that is used for this hidden-service
+   * request, if any. */
+  rend_auth_type_t rend_auth_type;
+
   char identity_digest[DIGEST_LEN]; /**&lt; Hash of the public RSA key for
                                      * the directory server's signing key. */
 
@@ -1916,6 +1946,15 @@
    */
   char rend_query[REND_SERVICE_ID_LEN_BASE32+1];
 
+  /** (Optional) descriptor cookie for requesting v2 hidden service
+   * descriptors, decrypting introduction points, and authenticating at
+   * hidden service. */
+  char rend_desc_cookie[REND_DESC_COOKIE_LEN];
+
+  /** Client authorization type that is used for this hidden-service
+   * request, if any. */
+  rend_auth_type_t rend_auth_type;
+
   /** Stores the rendezvous descriptor version if purpose is S_*. Used to
    * distinguish introduction and rendezvous points belonging to the same
    * rendezvous service ID, but different descriptor versions.
@@ -3181,7 +3220,10 @@
                                              const char *resource,
                                              const char *payload,
                                              size_t payload_len,
-                                             time_t if_modified_since);
+                                             time_t if_modified_since,
+                                             const char *rend_query,
+                                             rend_auth_type_t auth_type,
+                                             const char *rend_desc_cookie);
 
 int parse_http_response(const char *headers, int *code, time_t *date,
                         compress_method_t *compression, char **response);
@@ -3200,7 +3242,10 @@
                                 int anonymized_connection,
                                 const char *resource,
                                 const char *payload, size_t payload_len,
-                                time_t if_modified_since);
+                                time_t if_modified_since,
+                                const char *rend_query,
+                                rend_auth_type_t auth_type,
+                                const char *rend_desc_cookie);
 
 int dir_split_resource_into_fingerprints(const char *resource,
                                     smartlist_t *fp_out, int *compresseed_out,
@@ -3833,9 +3878,13 @@
 int rend_client_introduction_acked(origin_circuit_t *circ, const char *request,
                                    size_t request_len);
 void rend_client_refetch_renddesc(const char *query);
-void rend_client_refetch_v2_renddesc(const char *query);
+void rend_client_refetch_v2_renddesc(const char *query,
+                                     rend_auth_type_t auth_type,
+                                     const char *descriptor_cookie);
 int rend_client_remove_intro_point(extend_info_t *failed_intro,
-                                   const char *query);
+                                   const char *query,
+                                   rend_auth_type_t auth_type,
+                                   const char *descriptor_cookie);
 int rend_client_rendezvous_acked(origin_circuit_t *circ, const char *request,
                                  size_t request_len);
 int rend_client_receive_rendezvous(origin_circuit_t *circ, const char *request,
@@ -3847,13 +3896,6 @@
 int rend_client_send_introduction(origin_circuit_t *introcirc,
                                   origin_circuit_t *rendcirc);
 
-/** Client authorization type that a hidden service performs. */
-typedef enum rend_auth_type_t {
-  REND_NO_AUTH      = 0,
-  REND_BASIC_AUTH   = 1,
-  REND_STEALTH_AUTH = 2,
-} rend_auth_type_t;
-
 /** Client-side configuration of authorization for a hidden service. */
 typedef struct rend_service_authorization_t {
   char descriptor_cookie[REND_DESC_COOKIE_LEN];
@@ -3938,7 +3980,8 @@
 int rend_cache_lookup_v2_desc_as_dir(const char *query, const char **desc);
 int rend_cache_store(const char *desc, size_t desc_len, int published);
 int rend_cache_store_v2_desc_as_client(const char *desc,
-                               const char *descriptor_cookie);
+                                       rend_auth_type_t auth_type,
+                                       const char *descriptor_cookie);
 int rend_cache_store_v2_desc_as_dir(const char *desc);
 int rend_cache_size(void);
 int rend_encode_v2_descriptors(smartlist_t *descs_out,
Index: /home/karsten/tor/tor-trunk-121-patches/src/or/rendclient.c
===================================================================
--- /home/karsten/tor/tor-trunk-121-patches/src/or/rendclient.c	(revision 16614)
+++ /home/karsten/tor/tor-trunk-121-patches/src/or/rendclient.c	(working copy)
@@ -58,7 +58,7 @@
                               origin_circuit_t *rendcirc)
 {
   size_t payload_len;
-  int r;
+  int r, v3_shift = 0;
   char payload[RELAY_PAYLOAD_SIZE];
   char tmp[RELAY_PAYLOAD_SIZE];
   rend_cache_entry_t *entry;
@@ -117,22 +117,39 @@
     }
   }
 
+  /* If version is 3, write (optional) auth data and timestamp. */
+  if (entry-&gt;parsed-&gt;protocols &amp; (1&lt;&lt;3)) {
+    tmp[0] = 3; /* version 3 of the cell format */
+    tmp[1] = (uint8_t)introcirc-&gt;rend_auth_type; /* auth type, if any */
+    v3_shift = 1;
+    if (introcirc-&gt;rend_auth_type != REND_NO_AUTH) {
+      set_uint16(tmp+2, htons(REND_DESC_COOKIE_LEN));
+      memcpy(tmp+4, introcirc-&gt;rend_desc_cookie, REND_DESC_COOKIE_LEN);
+      v3_shift += 2+REND_DESC_COOKIE_LEN;
+    }
+    set_uint32(tmp+v3_shift+1, htonl(time(NULL)));
+    v3_shift += 4;
+  } /* if version 2 only write version number */
+  else if (entry-&gt;parsed-&gt;protocols &amp; (1&lt;&lt;2)) {
+    tmp[0] = 2; /* version 2 of the cell format */
+  }
+
   /* write the remaining items into tmp */
-  if (entry-&gt;parsed-&gt;protocols &amp; (1&lt;&lt;2)) {
+  if (entry-&gt;parsed-&gt;protocols &amp; (1&lt;&lt;3) || entry-&gt;parsed-&gt;protocols &amp; (1&lt;&lt;2)) {
     /* version 2 format */
     extend_info_t *extend_info = rendcirc-&gt;build_state-&gt;chosen_exit;
     int klen;
-    tmp[0] = 2; /* version 2 of the cell format */
     /* nul pads */
-    set_uint32(tmp+1, tor_addr_to_ipv4h(&amp;extend_info-&gt;addr));
-    set_uint16(tmp+5, htons(extend_info-&gt;port));
-    memcpy(tmp+7, extend_info-&gt;identity_digest, DIGEST_LEN);
-    klen = crypto_pk_asn1_encode(extend_info-&gt;onion_key, tmp+7+DIGEST_LEN+2,
-                                 sizeof(tmp)-(7+DIGEST_LEN+2));
-    set_uint16(tmp+7+DIGEST_LEN, htons(klen));
-    memcpy(tmp+7+DIGEST_LEN+2+klen, rendcirc-&gt;rend_cookie,
+    set_uint32(tmp+v3_shift+1, tor_addr_to_ipv4h(&amp;extend_info-&gt;addr));
+    set_uint16(tmp+v3_shift+5, htons(extend_info-&gt;port));
+    memcpy(tmp+v3_shift+7, extend_info-&gt;identity_digest, DIGEST_LEN);
+    klen = crypto_pk_asn1_encode(extend_info-&gt;onion_key,
+                                 tmp+v3_shift+7+DIGEST_LEN+2,
+                                 sizeof(tmp)-(v3_shift+7+DIGEST_LEN+2));
+    set_uint16(tmp+v3_shift+7+DIGEST_LEN, htons(klen));
+    memcpy(tmp+v3_shift+7+DIGEST_LEN+2+klen, rendcirc-&gt;rend_cookie,
            REND_COOKIE_LEN);
-    dh_offset = 7+DIGEST_LEN+2+klen+REND_COOKIE_LEN;
+    dh_offset = v3_shift+7+DIGEST_LEN+2+klen+REND_COOKIE_LEN;
   } else {
     /* Version 0. */
     strncpy(tmp, rendcirc-&gt;build_state-&gt;chosen_exit-&gt;nickname,
@@ -241,7 +258,9 @@
      * If none remain, refetch the service descriptor.
      */
     if (rend_client_remove_intro_point(circ-&gt;build_state-&gt;chosen_exit,
-                                       circ-&gt;rend_query) &gt; 0) {
+                                       circ-&gt;rend_query,
+                                       circ-&gt;rend_auth_type,
+                                       circ-&gt;rend_desc_cookie) &gt; 0) {
       /* There are introduction points left. Re-extend the circuit to
        * another intro point and try again. */
       extend_info_t *extend_info;
@@ -337,7 +356,9 @@
  * descriptor, return 0, and in case of a failure -1. &lt;b&gt;query&lt;/b&gt; is only
  * passed for pretty log statements. */
 static int
-directory_get_from_hs_dir(const char *desc_id, const char *query)
+directory_get_from_hs_dir(const char *desc_id, const char *query,
+                          rend_auth_type_t auth_type,
+                          const char *descriptor_cookie)
 {
   smartlist_t *responsible_dirs = smartlist_create();
   routerstatus_t *hs_dir;
@@ -343,6 +364,7 @@
   routerstatus_t *hs_dir;
   char desc_id_base32[REND_DESC_ID_V2_LEN_BASE32 + 1];
   time_t now = time(NULL);
+  char descriptor_cookie_base64[3*REND_DESC_COOKIE_LEN_BASE64];
   tor_assert(desc_id);
   tor_assert(query);
   tor_assert(strlen(query) == REND_SERVICE_ID_LEN_BASE32);
@@ -376,17 +398,33 @@
    * directory now. */
   lookup_last_hid_serv_request(hs_dir, desc_id_base32, now, 1);
 
-  /* Send fetch request. (Pass query as payload to write it to the directory
-   * connection so that it can be referred to when the response arrives.) */
+  /* Encode descriptor cookie for logging purposes. */
+  if (descriptor_cookie &amp;&amp;
+      base64_encode(descriptor_cookie_base64, 3*REND_DESC_COOKIE_LEN_BASE64,
+                    descriptor_cookie, REND_DESC_COOKIE_LEN) &lt; 0) {
+    log_warn(LD_BUG, "Could not base64-encode descriptor cookie.");
+    return 0;
+  }
+  /* Remove == signs and newline. */
+  descriptor_cookie_base64[strlen(descriptor_cookie_base64)-3] = '\0';
+
+  /* Send fetch request. (Pass query and possibly descriptor cookie so that
+   * they can be written to the directory connection and be referred to when
+   * the response arrives. */
   directory_initiate_command_routerstatus(hs_dir,
                                           DIR_PURPOSE_FETCH_RENDDESC_V2,
                                           ROUTER_PURPOSE_GENERAL,
-                                          1, desc_id_base32, query, 0, 0);
+                                          1, desc_id_base32, NULL, 0, 0,
+                                          query, auth_type,
+                                          descriptor_cookie);
   log_info(LD_REND, "Sending fetch request for v2 descriptor for "
-                    "service '%s' with descriptor ID '%s' to hidden "
-                    "service directory '%s' on port %d.",
-           safe_str(query), safe_str(desc_id_base32), hs_dir-&gt;nickname,
-           hs_dir-&gt;dir_port);
+                    "service '%s' with descriptor ID '%s', auth type %d, "
+                    "and descriptor cookie '%s' to hidden service "
+                    "directory '%s' on port %d.",
+           query, desc_id_base32, auth_type,
+           (descriptor_cookie == NULL ? "NULL" :
+           escaped_safe_str(descriptor_cookie_base64)),
+           hs_dir-&gt;nickname, hs_dir-&gt;dir_port);
   return 1;
 }
 
@@ -416,7 +454,9 @@
  * &lt;b&gt;query&lt;/b&gt;.
  */
 void
-rend_client_refetch_v2_renddesc(const char *query)
+rend_client_refetch_v2_renddesc(const char *query,
+                                rend_auth_type_t auth_type,
+                                const char *descriptor_cookie)
 {
   char descriptor_id[DIGEST_LEN];
   int replicas_left_to_try[REND_NUMBER_OF_NON_CONSECUTIVE_REPLICAS];
@@ -448,8 +488,10 @@
     int chosen_replica = replicas_left_to_try[rand];
     replicas_left_to_try[rand] = replicas_left_to_try[--tries_left];
 
-    if (rend_compute_v2_desc_id(descriptor_id, query, NULL, time(NULL),
-                                chosen_replica) &lt; 0) {
+    if (rend_compute_v2_desc_id(descriptor_id, query,
+                                auth_type == REND_STEALTH_AUTH ?
+                                    descriptor_cookie : NULL,
+                                time(NULL), chosen_replica) &lt; 0) {
       log_warn(LD_REND, "Internal error: Computing v2 rendezvous "
                         "descriptor ID did not succeed.");
       return;
@@ -454,7 +496,8 @@
                         "descriptor ID did not succeed.");
       return;
     }
-    if (directory_get_from_hs_dir(descriptor_id, query) != 0)
+    if (directory_get_from_hs_dir(descriptor_id, query, auth_type,
+                                  descriptor_cookie) != 0)
       return; /* either success or failure, but we're done */
   }
   /* If we come here, there are no hidden service directories left. */
@@ -471,7 +514,9 @@
  * unrecognized, 1 if recognized and some intro points remain.
  */
 int
-rend_client_remove_intro_point(extend_info_t *failed_intro, const char *query)
+rend_client_remove_intro_point(extend_info_t *failed_intro, const char *query,
+                               rend_auth_type_t auth_type,
+                               const char *descriptor_cookie)
 {
   int i, r;
   rend_cache_entry_t *ent;
@@ -486,9 +531,11 @@
     log_info(LD_REND, "Unknown service %s. Re-fetching descriptor.",
              escaped_safe_str(query));
     /* Fetch both, v0 and v2 rend descriptors in parallel. Use whichever
-     * arrives first. */
-    rend_client_refetch_v2_renddesc(query);
-    rend_client_refetch_renddesc(query);
+     * arrives first. Exception: When using client authorization, only
+     * fetch v2 descriptors.*/
+    rend_client_refetch_v2_renddesc(query, auth_type, descriptor_cookie);
+    if (auth_type == REND_NO_AUTH)
+      rend_client_refetch_renddesc(query);
     return 0;
   }
 
@@ -507,9 +554,11 @@
              "No more intro points remain for %s. Re-fetching descriptor.",
              escaped_safe_str(query));
     /* Fetch both, v0 and v2 rend descriptors in parallel. Use whichever
-     * arrives first. */
-    rend_client_refetch_v2_renddesc(query);
-    rend_client_refetch_renddesc(query);
+     * arrives first. Exception: When using client authorization, only
+     * fetch v2 descriptors.*/
+    rend_client_refetch_v2_renddesc(query, auth_type, descriptor_cookie);
+    if (auth_type == REND_NO_AUTH)
+      rend_client_refetch_renddesc(query);
 
     /* move all pending streams back to renddesc_wait */
     while ((conn = connection_get_by_type_state_rendquery(CONN_TYPE_AP,
Index: /home/karsten/tor/tor-trunk-121-patches/src/or/rendcommon.c
===================================================================
--- /home/karsten/tor/tor-trunk-121-patches/src/or/rendcommon.c	(revision 16614)
+++ /home/karsten/tor/tor-trunk-121-patches/src/or/rendcommon.c	(working copy)
@@ -1236,6 +1236,7 @@
  */
 int
 rend_cache_store_v2_desc_as_client(const char *desc,
+                                   rend_auth_type_t auth_type,
                                    const char *descriptor_cookie)
 {
   /*XXXX this seems to have a bit of duplicate code with
@@ -1265,7 +1266,6 @@
   rend_cache_entry_t *e;
   tor_assert(rend_cache);
   tor_assert(desc);
-  (void) descriptor_cookie; /* We don't use it, yet. */
   /* Parse the descriptor. */
   if (rend_parse_v2_service_descriptor(&amp;parsed, desc_id, &amp;intro_content,
                                        &amp;intro_size, &amp;encoded_size,
@@ -1284,10 +1284,31 @@
   }
   /* Decode/decrypt introduction points. */
   if (intro_content) {
+    if (auth_type != REND_NO_AUTH &amp;&amp; descriptor_cookie) {
+      char *ipos_decrypted;
+      size_t ipos_decrypted_size;
+      if (rend_decrypt_introduction_points(&amp;ipos_decrypted,
+                                           &amp;ipos_decrypted_size,
+                                           descriptor_cookie,
+                                           intro_content,
+                                           intro_size) &lt; 0) {
+        log_warn(LD_REND, "Failed to decrypt introduction points. We are "
+                 "probably unable to parse the encoded introduction points.");
+      } else {
+        /* Replace encrypted with decrypted introduction points. */
+        log_info(LD_REND, "Successfully decrypted introduction points.");
+        tor_free(intro_content);
+        intro_content = ipos_decrypted;
+        intro_size = ipos_decrypted_size;
+      }
+    }
     if (rend_parse_introduction_points(parsed, intro_content,
-                                       intro_size) &lt; 0) {
-      log_warn(LD_PROTOCOL,"Couldn't decode/decrypt introduction points.");
-      rend_service_descriptor_free(parsed);
+                                       intro_size) &lt;= 0) {
+      log_warn(LD_REND, "Failed to parse introduction points. Either the "
+               "service has published a corrupt descriptor or you have "
+               "provided invalid authorization data.");
+      if (parsed)
+        rend_service_descriptor_free(parsed);
       tor_free(intro_content);
       return -2;
     }
@@ -1292,6 +1313,7 @@
       return -2;
     }
   } else {
+    log_info(LD_REND, "Descriptor does not contain any introduction points.");
     parsed-&gt;intro_nodes = smartlist_create();
   }
   /* We don't need the encoded/encrypted introduction points any longer. */
Index: /home/karsten/tor/tor-trunk-121-patches/src/or/rendservice.c
===================================================================
--- /home/karsten/tor/tor-trunk-121-patches/src/or/rendservice.c	(revision 16614)
+++ /home/karsten/tor/tor-trunk-121-patches/src/or/rendservice.c	(working copy)
@@ -69,8 +69,16 @@
                          * up-to-date. */
   time_t next_upload_time; /**&lt; Scheduled next hidden service descriptor
                             * upload time. */
+  smartlist_t *accepted_intros; /**&lt; List of client_access_event_t's for
+                                 * accepted and answered INTRODUCE2 cells. */
 } rend_service_t;
 
+/** The event of a client accessing our hidden service. */
+typedef struct client_access_event_t {
+  time_t access_time;
+  char diffie_hellman_hash[DIGEST_LEN];
+} client_access_event_t;
+
 /** A list of rend_service_t's for services run on this OP.
  */
 static smartlist_t *rend_service_list = NULL;
@@ -360,7 +368,7 @@
       if (smartlist_len(type_names_split) &lt; 2) {
         log_warn(LD_CONFIG, "HiddenServiceAuthorizeClient contains "
                             "auth-type '%s', but no client names.",
-                 service-&gt;auth_type == 1 ? "basic" : "stealth");
+                 service-&gt;auth_type == REND_BASIC_AUTH ? "basic" : "stealth");
         SMARTLIST_FOREACH(type_names_split, char *, cp, tor_free(cp));
         smartlist_free(type_names_split);
         continue;
@@ -423,7 +431,7 @@
                             "authorization type '%s'.",
                  smartlist_len(service-&gt;clients),
                  service-&gt;auth_type == REND_BASIC_AUTH ? 512 : 16,
-                 service-&gt;auth_type == 1 ? "basic" : "stealth");
+                 service-&gt;auth_type == REND_BASIC_AUTH ? "basic" : "stealth");
         rend_service_free(service);
         return -1;
       }
@@ -717,8 +725,10 @@
       tor_free(client_keys_str);
       strmap_free(parsed_clients, rend_authorized_client_strmap_item_free);
       if (r&lt;0) {
-        abort_writing_to_file(open_cfile);
-        abort_writing_to_file(open_hfile);
+        if (open_cfile)
+          abort_writing_to_file(open_cfile);
+        if (open_hfile)
+          abort_writing_to_file(open_hfile);
         return r;
       } else {
         finish_writing_to_file(open_cfile);
@@ -761,6 +771,45 @@
   return 0;
 }
 
+/** Check client authorization of a given &lt;b&gt;descriptor_cookie&lt;/b&gt; for
+ * &lt;b&gt;service&lt;/b&gt;. Return 1 for success and 0 for failure. */
+static int
+rend_check_authorization(rend_service_t *service,
+                         const char *descriptor_cookie)
+{
+  rend_authorized_client_t *auth_client = NULL;
+  tor_assert(service);
+  tor_assert(descriptor_cookie);
+  if (!service-&gt;clients) {
+    log_warn(LD_BUG, "Can't check authorization for a service that has no "
+                     "authorized clients configured.");
+    return 0;
+  }
+
+  /* Look up client authorization by descriptor cookie. */
+  SMARTLIST_FOREACH(service-&gt;clients, rend_authorized_client_t *, client, {
+    if (!memcmp(client-&gt;descriptor_cookie, descriptor_cookie,
+                REND_DESC_COOKIE_LEN)) {
+      auth_client = client;
+      break;
+    }
+  });
+  if (!auth_client) {
+    char descriptor_cookie_base64[3*REND_DESC_COOKIE_LEN_BASE64];
+    base64_encode(descriptor_cookie_base64, sizeof(descriptor_cookie_base64),
+                  descriptor_cookie, REND_DESC_COOKIE_LEN);
+    log_info(LD_REND, "No authorization found for descriptor cookie '%s'! "
+                      "Dropping cell!",
+             descriptor_cookie_base64);
+    return 0;
+  }
+
+  /* Allow the request. */
+  log_info(LD_REND, "Client %s could be identified for service %s.",
+           auth_client-&gt;client_name, service-&gt;service_id);
+  return 1;
+}
+
 /******
  * Handle cells
  ******/
@@ -777,7 +826,7 @@
   char buf[RELAY_PAYLOAD_SIZE];
   char keys[DIGEST_LEN+CPATH_KEY_MATERIAL_LEN]; /* Holds KH, Df, Db, Kf, Kb */
   rend_service_t *service;
-  int r, i;
+  int r, i, v3_shift = 0;
   size_t len, keylen;
   crypto_dh_env_t *dh = NULL;
   origin_circuit_t *launched = NULL;
@@ -788,6 +837,13 @@
   int reason = END_CIRC_REASON_TORPROTOCOL;
   crypto_pk_env_t *intro_key;
   char intro_key_digest[DIGEST_LEN];
+  int auth_type;
+  size_t auth_len = 0;
+  char auth_data[REND_DESC_COOKIE_LEN];
+  crypto_digest_env_t *digest = NULL;
+  time_t now = time(NULL);
+  char diffie_hellman_hash[DIGEST_LEN];
+  client_access_event_t *event = NULL;
 
   base32_encode(serviceid, REND_SERVICE_ID_LEN_BASE32+1,
                 circuit-&gt;rend_pk_digest, REND_SERVICE_ID_LEN);
@@ -851,13 +907,49 @@
     return -1;
   }
   len = r;
-  if (*buf == 2) {
+  if (*buf == 3) {
+    /* Version 3 INTRODUCE2 cell. */
+    time_t ts = 0, now = time(NULL);
+    v3_shift = 1;
+    auth_type = buf[1];
+    switch (auth_type) {
+      case REND_BASIC_AUTH:
+        /* fall through */
+      case REND_STEALTH_AUTH:
+        auth_len = ntohs(get_uint16(buf+2));
+        if (auth_len != REND_DESC_COOKIE_LEN) {
+          log_info(LD_REND, "Wrong auth data size %d, should be %d.",
+                   (int)auth_len, REND_DESC_COOKIE_LEN);
+          return -1;
+        }
+        memcpy(auth_data, buf+4, sizeof(auth_data));
+        v3_shift += 2+REND_DESC_COOKIE_LEN;
+        break;
+      case REND_NO_AUTH:
+        break;
+      default:
+        log_info(LD_REND, "Unknown authorization type '%d'", auth_type);
+    }
+
+    /* Check timestamp. */
+    memcpy((char*)&amp;ts, buf+1+v3_shift, sizeof(uint32_t));
+    v3_shift += 4;
+    ts = ntohl(ts);
+    if ((now - ts) &lt; -1 * REND_REPLAY_TIME_INTERVAL / 2 ||
+        (now - ts) &gt; REND_REPLAY_TIME_INTERVAL / 2) {
+      log_warn(LD_REND, "INTRODUCE2 cell is too %s. Discarding.",
+          (now - ts) &lt; 0 ? "old" : "new");
+      return -1;
+    }
+  }
+  if (*buf == 2 || *buf == 3) {
     /* Version 2 INTRODUCE2 cell. */
     int klen;
     extend_info = tor_malloc_zero(sizeof(extend_info_t));
-    tor_addr_from_ipv4n(&amp;extend_info-&gt;addr, get_uint32(buf+1));
-    extend_info-&gt;port = ntohs(get_uint16(buf+5));
-    memcpy(extend_info-&gt;identity_digest, buf+7, DIGEST_LEN);
+    tor_addr_from_ipv4n(&amp;extend_info-&gt;addr, get_uint32(buf+v3_shift+1));
+    extend_info-&gt;port = ntohs(get_uint16(buf+v3_shift+5));
+    memcpy(extend_info-&gt;identity_digest, buf+v3_shift+7,
+           DIGEST_LEN);
     extend_info-&gt;nickname[0] = '$';
     base16_encode(extend_info-&gt;nickname+1, sizeof(extend_info-&gt;nickname)-1,
                   extend_info-&gt;identity_digest, DIGEST_LEN);
@@ -862,22 +954,23 @@
     base16_encode(extend_info-&gt;nickname+1, sizeof(extend_info-&gt;nickname)-1,
                   extend_info-&gt;identity_digest, DIGEST_LEN);
 
-    klen = ntohs(get_uint16(buf+7+DIGEST_LEN));
-    if ((int)len != 7+DIGEST_LEN+2+klen+20+128) {
-      log_warn(LD_PROTOCOL, "Bad length %u for version 2 INTRODUCE2 cell.",
-               (int)len);
+    klen = ntohs(get_uint16(buf+v3_shift+7+DIGEST_LEN));
+    if ((int)len != v3_shift+7+DIGEST_LEN+2+klen+20+128) {
+      log_warn(LD_PROTOCOL, "Bad length %u for version %d INTRODUCE2 cell.",
+               (int)len, *buf);
       reason = END_CIRC_REASON_TORPROTOCOL;
       goto err;
     }
-    extend_info-&gt;onion_key = crypto_pk_asn1_decode(buf+7+DIGEST_LEN+2, klen);
+    extend_info-&gt;onion_key =
+        crypto_pk_asn1_decode(buf+v3_shift+7+DIGEST_LEN+2, klen);
     if (!extend_info-&gt;onion_key) {
-      log_warn(LD_PROTOCOL,
-               "Error decoding onion key in version 2 INTRODUCE2 cell.");
+      log_warn(LD_PROTOCOL, "Error decoding onion key in version %d "
+                            "INTRODUCE2 cell.", *buf);
       reason = END_CIRC_REASON_TORPROTOCOL;
       goto err;
     }
-    ptr = buf+7+DIGEST_LEN+2+klen;
-    len -= 7+DIGEST_LEN+2+klen;
+    ptr = buf+v3_shift+7+DIGEST_LEN+2+klen;
+    len -= v3_shift+7+DIGEST_LEN+2+klen;
   } else {
     char *rp_nickname;
     size_t nickname_field_len;
@@ -929,6 +1022,58 @@
   r_cookie = ptr;
   base16_encode(hexcookie,9,r_cookie,4);
 
+  /* Determine hash of Diffie-Hellman, part 1 to detect replays. */
+  digest = crypto_new_digest_env();
+  crypto_digest_add_bytes(digest, ptr+REND_COOKIE_LEN, DH_KEY_LEN);
+  crypto_digest_get_digest(digest, diffie_hellman_hash, DIGEST_LEN);
+  crypto_free_digest_env(digest);
+
+  /* Iterate over past requests, remove those which are older than one hour,
+   * and check whether there is one with same Diffie-Hellman, part 1. */
+  if (!service-&gt;accepted_intros)
+    service-&gt;accepted_intros = smartlist_create();
+  SMARTLIST_FOREACH(service-&gt;accepted_intros, client_access_event_t *,
+                    access, {
+    if (access-&gt;access_time + REND_REPLAY_TIME_INTERVAL &lt; now) {
+      tor_free(access);
+      SMARTLIST_DEL_CURRENT(service-&gt;accepted_intros, access);
+    } else if (!memcmp(access-&gt;diffie_hellman_hash, diffie_hellman_hash,
+                       DIGEST_LEN)) {
+      log_warn(LD_REND, "Possible replay detected! We received an "
+                        "INTRODUCE2 cell with same first part of "
+                        "Diffie-Hellman handshake %d seconds ago. Dropping "
+                        "cell.",
+               (uint32_t) (now - access-&gt;access_time));
+      return 0;
+    }
+  });
+
+  /* Add request to access history, including time and hash of
+   * Diffie-Hellman, part 1. */
+  event = tor_malloc_zero(sizeof(client_access_event_t));
+  event-&gt;access_time = now;
+  memcpy(event-&gt;diffie_hellman_hash, diffie_hellman_hash, DIGEST_LEN);
+  smartlist_add(service-&gt;accepted_intros, event);
+
+  /* If the service performs client authorization, check included auth data. */
+  if (service-&gt;clients) {
+    if (auth_len &gt; 0) {
+      if (rend_check_authorization(service, auth_data)) {
+        log_info(LD_REND, "Authorization data in INTRODUCE2 cell are valid.");
+      } else {
+        log_info(LD_REND, "The authorization data that are contained in "
+                 "the INTRODUCE2 cell are invalid. Dropping cell.");
+        reason = END_CIRC_REASON_CONNECTFAILED;
+        goto err;
+      }
+    } else {
+      log_info(LD_REND, "INTRODUCE2 cell does not contain authentication "
+               "data, but we require client authorization. Dropping cell.");
+      reason = END_CIRC_REASON_CONNECTFAILED;
+      goto err;
+    }
+  }
+
   /* Try DH handshake... */
   dh = crypto_dh_new();
   if (!dh || crypto_dh_generate_public(dh)&lt;0) {
@@ -1379,7 +1524,8 @@
                                               DIR_PURPOSE_UPLOAD_RENDDESC_V2,
                                               ROUTER_PURPOSE_GENERAL,
                                               1, NULL, desc-&gt;desc_str,
-                                              strlen(desc-&gt;desc_str), 0);
+                                              strlen(desc-&gt;desc_str), 0,
+                                              NULL, REND_NO_AUTH, NULL);
       base32_encode(desc_id_base32, sizeof(desc_id_base32),
                     desc-&gt;desc_id, DIGEST_LEN);
       log_info(LD_REND, "Sending publish request for v2 descriptor for "
Index: /home/karsten/tor/tor-trunk-121-patches/src/or/router.c
===================================================================
--- /home/karsten/tor/tor-trunk-121-patches/src/or/router.c	(revision 16614)
+++ /home/karsten/tor/tor-trunk-121-patches/src/or/router.c	(working copy)
@@ -763,7 +763,8 @@
                                0, me-&gt;cache_info.identity_digest,
                                DIR_PURPOSE_FETCH_SERVERDESC,
                                ROUTER_PURPOSE_GENERAL,
-                               1, "authority.z", NULL, 0, 0);
+                               1, "authority.z", NULL, 0, 0,
+                               NULL, REND_NO_AUTH, NULL);
 
     control_event_server_status(LOG_NOTICE,
                                 "CHECKING_REACHABILITY DIRADDRESS=%s:%d",
Index: /home/karsten/tor/tor-trunk-121-patches/src/or/routerlist.c
===================================================================
--- /home/karsten/tor/tor-trunk-121-patches/src/or/routerlist.c	(revision 16614)
+++ /home/karsten/tor/tor-trunk-121-patches/src/or/routerlist.c	(working copy)
@@ -3757,7 +3757,8 @@
     directory_initiate_command_routerstatus(source, purpose,
                                             ROUTER_PURPOSE_GENERAL,
                                             0, /* not private */
-                                            resource, NULL, 0, 0);
+                                            resource, NULL, 0, 0,
+                                            NULL, REND_NO_AUTH, NULL);
   } else {
     directory_get_from_dirserver(purpose, ROUTER_PURPOSE_GENERAL, resource, 1);
   }


["patch-121-4.txt.sig" (application/octet-stream)]

</body></email><email><emailId>20080822165803</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-08-22 16:58:03-0400</timestampReceived><subject>Re: Documentation patches for ./configure message</subject><body>

On Thu, Aug 21, 2008 at 09:02:15PM -0600, Dave wrote:
&gt; Hi everyone,
&gt; 
&gt; Sorry if this is the wrong place for this. I searched around and
&gt; 'or-dev' seemed like the best place to submit a documentation patch.
&gt; Let me know if I should send this somewhere else.

Good catch, thanks!

I've fiddled with the patch a little so that --with-ssl-dir will still
work too, in addition to --with-openssl-dir.  That used to be the
right option name, and I don't want to break old build scripts.

yrs,
-- 
Nick
</body></email><email><emailId>20080822223427</emailId><senderName>"Steven J. Murdoch"</senderName><senderEmail>tor+steven.murdoch@cl.cam.ac.uk</senderEmail><timestampReceived>2008-08-22 22:34:27-0400</timestampReceived><subject>Re: Future areas for Tor research</subject><body>

Here are some of my thoughts.

On Thu, Aug 21, 2008 at 03:31:57PM -0400, Roger Dingledine wrote:
&gt; By end of 2008:
&gt; - Paul's NRL project to evaluate path selection under various trust
&gt;   distributions. The idea is to figure out safer/better ways to build
&gt;   paths if we assume some users trust some relays more than others.

I talked to the folks involved in this at PETS, so know roughly the
direction they planned. It sounded like this is on track, but I'd be
happy to hear how things are going.

&gt; - Peter's proposal 141. How to trade off descriptor fetching overhead
&gt;   with circuit-building overhead. Are there even better ways?

One option I think was discussed is to remove the public key of the
server from the directory descriptors. Instead the client would extend
to the server and fetch the key from there, signed by the directory
authorities. This way the client only gets the keys it needs, but
doesn't leak information. As always the devil will be in the detail.

&gt; By end of 2009:
&gt; - Understand the risks from letting people relay traffic through your
&gt;   Tor while you're also being a Tor client. Compare risks from being a
&gt;   bridge relay to risks from being a 'full' relay. Come up with practical
&gt;   ways to mitigate.

The defenses in this paper looked promising:
 http://www-users.cs.umn.edu/~hopper/circuit_clogging_fc08.pdf

&gt; - Take Roger's incentive.pdf design, flesh it out further, and see if we
&gt;   can find solutions to the long-term intersection attack that arises
&gt;   from attackers being able to correlate "that relay is online everytime
&gt;   this anonymous high-priority user does an action." (I need to clean up
&gt;   incentive.pdf and send it to this list.)
&gt; 
&gt; By end of 2010:
&gt; - Better load balancing algorithms, path selection choices, etc.
&gt;   Building on Mike Perry's work and Steven's PETS 2008 paper. Do we
&gt;   do simulations? analysis? How to compare them? Are there cases when
&gt;   we can switch to 2-hop paths, or the variable-hop paths?

The obvious extension to my PETS paper is to optimize the expression I
used for path selection impact on latency. Nothing neat fell out of
doing the optimization, but it should still be possible to come up
with a numerical answer. 

Then the question would be whether this is still the right path
selection parameters when the simplifying assumptions are dropped. Tor
is sufficiently complicated that I think simulation is the only
reliable answer. This would be a big chunk of work, but very useful in
evaluating candidate load balancing algorithms.

&gt; - Evaluate the latency and clogging attacks that are coming out, figure
&gt;   out if they actually work, and produce countermeasures.

Indeed, but even simple end to end traffic analysis is useful to look
at. I feel it will still work great for the common case, but there are
special-case proposals out there which are intended to mix like
traffic with other streams, while not introducing huge overhead.

The problem here is that it's really hard to compare schemes, or to
even give realistic estimates of anonymity and overhead. There's quite
a bit of benchmarking required here.

&gt; - Tor network scalability, the easy version: use several parallel
&gt;   networkstatus documents, have algorithms for clients to pick which to
&gt;   use, for relays to get assigned to one, and make sure new designs like
&gt;   Peter's proposal 141 will be compatible with this.

This paper raising interesting results:
 http://research.microsoft.com/users/gdane/papers/bridge.pdf

The issues are not simple, but it does suggest that partitioning is
the right idea.

&gt; - There's a vulnerability right now where you can enumerate bridges by
&gt;   running a non-guard Tor server and seeing who connects that isn't
&gt;   a known relay. One solution is to use two layers of guards, meaning
&gt;   bridge users use 4-hop paths. Is this the best option we've got? They
&gt;   don't want to be slowed down like that.
&gt; - How many bridges do you need to know to maintain reachability? We
&gt;   should measure the churn in our bridges. If there is lots of churn,
&gt;   are there ways to keep bridge users more likely to stay connected?

I think that the results at the moment will be deceptive, since I
expect the bridge pool to change quite a bit once we are actively
recruiting.

&gt; - Related, more bridge address distribution strategies: Steven and I
&gt;   were talking about a ``bridge loop'' design where bridge identities form
&gt;   a ``loop'' at the bridgeDB , and if you know any bridge in the loop you
&gt;   can learn all the others. This approach will allow Tor clients who know
&gt;   a few bridges to be updated with new bridges as their old ones rotate,
&gt;   without opening up the list to full enumeration.

One other idea (that came from John Gilmore) was how to manage who is
a bridge. Currently it is up to the node operator, so if we realize we
need lots of bridges, we have to ask them and it will take a while.
Another option is for the directory authorities to pick -- that way
there can be a central switch to pull.

Steven.

-- 
w: http://www.cl.cam.ac.uk/users/sjm217/

</body></email><email><emailId>20080831230222</emailId><senderName>"Steven J. Murdoch"</senderName><senderEmail>tor+steven.murdoch@cl.cam.ac.uk</senderEmail><timestampReceived>2008-08-31 23:02:22-0400</timestampReceived><subject>[or-cvs] r16692: {} Initial auto-updater commit: s-expression libray and format (in updater: . trunk</subject><body>

Hi Nick,

&gt;   updater/trunk/lib/sexp/__init__.py

I noticed the Python check-in for the auto-updater. Do you plan on
writing the client in Python? If so, we should first look into how
much overhead this will introduce.

The compressed Python installer for Windows is 11 MB. The Windows API
files (sometimes needed) are another 5 MB. The Tor Browser Bundle is
already raising objections at its 13 MB size, so adding any
significant overhead should be avoided.

If you're just working on a prototype, that's fine, but if you plan on
shipping a Python thing, we should look into how big the overhead will
actually be before we go too far down a blind alley.

Steven.

-- 
w: http://www.cl.cam.ac.uk/users/sjm217/
</body></email><email><emailId>20080702180550</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-07-02 18:05:50-0400</timestampReceived><subject>Proposal 146: Add new flag to reflect long-term stability</subject><body>

Filename: 146-long-term-stability.txt
Title: Add new flag to reflect long-term stability
Version: $Revision: 15606 $
Last-Modified: $Date: 2008-07-02 14:04:01 -0400 (Wed, 02 Jul 2008) $
Author: Nick Mathewson
Created: 19-Jun-2008
Status: Draft

Overview

  This document proposes a new flag to indicate that a router has
  existed at the same address for a long time, describes how to
  implement it, and explains what it's good for.

Motivation

  Tor has had three notions of "stability" for servers.  Older
  directory protocols based a server's stability on its
  (self-reported) uptime: a server that had been running for a day was
  more stable than a server that had been running for five minutes,
  regardless of their past history.  Current directory protocols track
  weighted mean time between failure (WMTBF) and weighted fractional
  uptime (WFU).  WFU is computed as the fraction of time for which the
  server is running, with measurements weighted to exponentially
  decay such that old days count less.  WMTBF is computed as the the
  average length of intervals for which the server runs between
  downtime, with old intervals weighted to count less.

  WMTBF is useful in answering the question: "If a server is running
  now, how long is it likely to stay running?"  This makes it a good
  choice for picking servers for streams that need to be long-lived.
  WFU is useful in answering the question: "If I try connecting to
  this server at an arbitrary time, is it likely to be running?"  This
  makes it an important factor for picking guard nodes, since we want
  guard nodes to be usually-up.

  There are other questions that clients want to answer, however, for
  which the current flags aren't very useful.   The one that this
  proposal addresses is,

       "If I found this server in an old consensus, is it likely to
       still be running at the same address?"

  This one is useful when we're trying to find directory mirrors in a
  fallback-consensus file.  This property is equivalent to,

       "If I find this server in a current consensus, how long is it
       likely to exist on the network?"

  This one is usefule if we're trying to pick introduction points or
  something and care more about churn rate than about whether every IP
  will be up all the time.

Implementation:

  I propose we add a new flag, called "Longterm."  Authorities should
  set this flag for routers if their Longevity is in the upper
  quartile of all routers.  A router's Longevity is computed as the
  total amount of days in the last year or so[*] for which the router has
  been Running at least once at its current IP:orport pair.

  Clients should use directory servers from a fallback-consensus only
  if they have the Longterm flag set.

  Authority ops should be able to mark particular routers as not
  Longterm, regardless of history.  (For instance, it makes sense to
  remove the Longterm flag from a router whose op says that it will
  need to shutdown in a month.)

  [*] This is deliberately vague, to permit efficient implementations.

Compatibility and migration issues:

  The voting protocol already acts gracefully when new flags are
  added, so no change to the voting protocol is needed.

  Tor won't have collected this data, however.  It might be desirable
  to bootstrap it from historical consensuses.  Alternatively, we can
  just let the algorithm run for a month or two.

Issues and future possibilities:

  Longterm is a really awkward name.



</body></email><email><emailId>20080702230347</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2008-07-02 23:03:47-0400</timestampReceived><subject>Proposal 148: Stream end reasons from the client side should be uniform</subject><body>

Filename: 148-uniform-client-end-reason.txt
Title: Stream end reasons from the client side should be uniform
Version: $Revision: 15612 $
Last-Modified: $Date: 2008-07-02 19:00:54 -0400 (Wed, 02 Jul 2008) $
Author: Roger Dingledine
Created: 2-Jul-2008
Status: Open

Overview

  When a stream closes before it's finished, the end relay cell that's
  sent includes an "end stream reason" to tell the other end why it
  closed. It's useful for the exit relay to send a reason to the client,
  so the client can choose a different circuit, inform the user, etc. But
  there's no reason to include it from the client to the exit relay,
  and in some cases it can even harm anonymity.

  We should pick a single reason for the client-to-exit-relay direction
  and always just send that.

Motivation

  Back when I first deployed the Tor network, it was useful to have
  the Tor relays learn why a stream closed, so I could debug both ends
  of the stream at once. Now that streams have worked for many years,
  there's no need to continue telling the exit relay whether the client
  gave up on a stream because of "timeout" or "misc" or what.

  Then in Tor 0.2.0.28-rc, I fixed this bug:
    - Fix a bug where, when we were choosing the 'end stream reason' to
      put in our relay end cell that we send to the exit relay, Tor
      clients on Windows were sometimes sending the wrong 'reason'. The
      anonymity problem is that exit relays may be able to guess whether
      the client is running Windows, thus helping partition the anonymity
      set. Down the road we should stop sending reasons to exit relays,
      or otherwise prevent future versions of this bug.

  It turned out that non-Windows clients were choosing their reason
  correctly, whereas Windows clients were potentially looking at errno
  wrong and so always choosing 'misc'.

  I fixed that particular bug, but I think we should prevent future
  versions of the bug too.

  (We already fixed it so *circuit* end reasons don't get sent from
  the client to the exit relay. But we appear to be have skipped over
  stream end reasons thus far.)

Design:

  One option would be to no longer include any 'reason' field in end
  relay cells. But that would introduce a partitioning attack ("users
  running the old version" vs "users running the new version").

  Instead I suggest that clients all switch to sending the "misc" reason,
  like most of the Windows clients currently do and like the non-Windows
  clients already do sometimes.

</body></email><email><emailId>20080703074059</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2008-07-03 07:40:59-0400</timestampReceived><subject>Re: Proposal 147: Eliminate the need for v2 directories in generating v3 directories</subject><body>

On Wed, Jul 02, 2008 at 03:18:50PM -0400, Nick Mathewson wrote:
&gt;   Authorities don't need to generate more than one opinion document
&gt;   per voting interval, but may.  They should send it to the other
&gt;   authorities they know about, at the regular vote upload URL, before
&gt;   the authorities begin voting,

It seems that this 'push' architecture is fragile. Here are some reasons
to go with 'pull' instead:

A) If we change the publishing interval, then upgraded servers would
learn info at the time they want rather than the time not-yet-upgraded
servers choose.

B) Other people besides the currently known authorities can fetch
opinions too, e.g. for people wanting to run their own
not-yet-recognized authorities, for debugging, etc.

I guess it's a bit of a hassle in that it requires more code in
directory.c; but perhaps it's a good move long-term?

While we're at it, when we pull, does the authority just whip up an
opinion right then and sign it, maybe caching for a minute or so to avoid
signing too many per second? Or said another way, there's no reason why
everybody who asks around a given time needs to get the same opinion,
right?

&gt; so that enough time remains for the
&gt;   authorities to fetch new descriptors.

Let's look at this timing a little bit more. There are two cases for
a new descriptor: a) a new descriptor for a known server at the same
location as before, and b) a brand new one, or an old one but with a new
location. For the second case, we need to both fetch the descriptor and
do our first reachability test before the voting happens.

(For comparison, currently each v3 authority fetches a v2 networkstatus
from each other v2 authority every AUTHORITY_NS_CACHE_INTERVAL, i.e. every
10 minutes.)

Once we know a descriptor, it takes as many as 1280 seconds before the
reachability test happens, since we round-robin over identity digests.
(See comments for dirserv_test_reachability() in dirserv.c.)

So to be certain that we have enough time, we need to push the opinions
at least about 23ish minutes before the votes. That isn't much better
than 60 minutes before the votes, which is what we do already.

Here are options I can imagine to deal with the reachability-test lag:

A) Don't worry about it. If a relay doesn't publish to enough authorities
for them to do their reachability tests in time, that gets fixed within
the hour, and then everything's fine. Not very appealing though.

B) Have authorities trigger a reachability test immediately upon
learning about a new descriptor.

B') Pull opinion documents from each other authority several times an
hour, to reduce the pounding on authorities when they learn a bunch of
new descriptors and launch a new TLS connection for each. Perhaps pull
at :45, :05, and :25?

--Roger

</body></email><email><emailId>20080703170129</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-07-03 17:01:29-0400</timestampReceived><subject>Proposal 149: Using data from NETINFO cells</subject><body>

Filename: 149-using-netinfo-data.txt
Title: Using data from NETINFO cells
Version: $Revision: 15629 $
Last-Modified: $Date: 2008-07-03 13:00:42 -0400 (Thu, 03 Jul 2008) $
Author: Nick Mathewson
Created: 2-Jul-2008
Status: Open

Overview

   Current Tor versions send signed IP and timestamp information in
   NETINFO cells, but don't use them to their fullest.  This proposal
   describes how they should start using this info in 0.2.1.x.

Motivation

   Our directory system relies on clients and routers having
   reasonably accurate clocks to detect replayed directory info, and
   to set accurate timestamps on directory info they publish
   themselves.  NETINFO cells contain timestamps.

   Also, the directory system relies on routers having a reasonable
   idea of their own IP addresses, so they can publish correct
   descriptors.  This is also in NETINFO cells.

Learning the time and IP

   We need to think about attackers here.  Just because a router tells
   us that we have a given IP or a given clock skew doesn't mean that
   it's true.  We believe this information only if we've heard it from
   a majority of the routers we've connected to recently, including at
   least 3 routers.  Routers only believe this information if the
   majority inclues at least one authority.

Avoiding MITM attacks

   Current Tors use the IP addresses published in the other router's
   NETINFO cells to see whether the connection is "canonical".  Right
   now, we prefer to extend circuits over "canonical" connections.  In
   0.2.1.x, we should refuse to extend circuits over non-canonical
   connections without first trying to build a canonical one.


</body></email><email><emailId>20080704144649</emailId><senderName>Karsten Loesing</senderName><senderEmail>karsten.loesing@gmx.net</senderEmail><timestampReceived>2008-07-04 14:46:49-0400</timestampReceived><subject>Re: Proposal: Combine Introduction and Rendezvous Points</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Hi Nick,

| | An idea from the #tor-dev channel: it's probably time to do for the
| | hidden service protocol what we did for the directory protocol, and
| | split the specification into rend-spec-v1.txt and rend-spec.txt, and
| | edit the latter to contain all these proposals once they're a little
| | more discussed.  Doing this for directory stuff helped identify places
| | that hadn't actually gotten specified in our proposals.
|
| I'll write a draft rend-spec-v2.txt containing all the proposals
| including the v2 hidden service directory specification after I have
| sent you the remaining proposals for 0.2.1.x.

Finally, I wrote down a draft version of rendezvous protocol version 3.
(I figured that it would lead to less confusion to call the original
rendezvous protocol version 1, the current extensions with distributed
storage of descriptors version 2, and the one described in the new
proposals version 3.)

https://tor-svn.freehaven.net/svn/tor/branches/121-hs-authorization/doc/spec/rend-spec-v3draft.txt

If you find the time, please have a look at this draft and let me know
if it's what you have expected.

Thanks!
- --Karsten
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFIbjfZ0M+WPffBEmURAhWzAJ4lj6d2128Ga8IQ0VP6A6NVnvh98QCcD8Ov
WoetHFLxWy/tH5Fror6XNJw=
=BQY2
-----END PGP SIGNATURE-----
</body></email><email><emailId>20080705094732</emailId><senderName>"M Fr"</senderName><senderEmail>mfr@misericordia.be</senderEmail><timestampReceived>2008-07-05 09:47:32-0400</timestampReceived><subject>Exclude Exit Nodes from a circuit</subject><body>

Another small proposal.

Best Regards.?
--
Mfr

["150-exclude-exit-nodes.txt" (text/plain)]

Filename: 150-exclude-exit-nodes.txt
Title: Exclude Exit Nodes from a circuit
Version: $Revision: 15607 $
Author: Mfr
Created: 2008-06-15
Status: Draft

Overview

   Right now, Tor user can manually exclude a node of all the part of
			circuits created using the directive ExcludeNodes.  
			This proposal makes this exclusion, less restrictive, allowing to 
			exclude a node only on the exit part of a circuit.

Motivation

   Helping the integration into vidalia (tor exit branch)or other tools,
			of features to exclude a country for exit without reducing 
			circuits possibilites,	an privacy.
			This feature could help people from a country were many sites 
			are blocked	to exclude this country for browsing, giving them a 
			more stable navigation.
			Add the possibility for the user to exclude the current used exit
			node. 
			
			
Implementation

			ExcludeExitNodes is similar to ExcludeNodes except it's only
			the exit node which is excluded for circuit build.
			
			Tor doesn't warn if node from this list is not an exit node.

Security implications:

			Open also possibilities for a future user bad exit reporting.

</body></email><email><emailId>20080707050807</emailId><senderName>coderman</senderName><senderEmail>coderman@gmail.com</senderEmail><timestampReceived>2008-07-07 05:08:07-0400</timestampReceived><subject>Patch: correct configure check for netfilter_ipv4 support on some platforms.</subject><body>

on some systems the transparent proxy support is not enabled because
of a failed check for netfilter_ipv4.h.  this check fails because the
ipv4 include expects some of the structure definitions in
netfilter/in.h which is not included in the check.

this patch includes in.h if present to fix the configure check.

best regards,

["tor-configure-netfilter.patch" (text/x-patch)]

diff -Naur tor-svn-current/configure.in tor-patched/configure.in
--- tor-svn-current/configure.in	2008-07-05 21:17:04.584497000 +0000
+++ tor-patched/configure.in	2008-07-07 05:02:52.832713872 +0000
@@ -349,6 +349,9 @@
 #endif
 #ifdef HAVE_SYS_SOCKET_H
 #include &lt;sys/socket.h&gt;
+#endif
+#ifdef HAVE_NETINET_IN_H
+#include &lt;netinet/in.h&gt;
 #endif])
 
 if test x$transparent = xtrue ; then


</body></email><email><emailId>20080702180515</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-07-02 18:05:15-0400</timestampReceived><subject>Proposal 145: Separate "suitable as a guard" from "suitable as a new guard"</subject><body>

Filename: 145-newguard-flag.txt
Title: Separate "suitable as a guard" from "suitable as a new guard"
Version: $Revision: 15606 $
Last-Modified: $Date: 2008-07-02 14:04:01 -0400 (Wed, 02 Jul 2008) $
Author: Nick Mathewson
Created: 1-Jul-2008
Status: Draft

Overview

   Right now, Tor has one flag that clients use both to tell which
   nodes should be kept as guards, and which nodes should be picked
   when choosing new guards.  This proposal separates this flag into
   two.

Motivation

   Balancing clients amoung guards is not done well by our current
   algorithm.  When a new guard appears, it is chosen by clients
   looking for a new guard with the same probability as all existing
   guards... but new guards are likelier to be under capacity, whereas
   old guards are likelier to be under more use.

Implementation

   We add a new flag, NewGuard.  Clients will change so that when they
   are choosing new guards, they only consider nodes with the NewGuard
   flag set.

   For now, authorities will always set NewGuard if they are setting
   the Guard flag.  Later, it will be easy to migrate authorities to
   set NewGuard for underused guards.

Alternatives

   We might instead have authorities list weights with which nodes
   should be picked as guards.
</body></email><email><emailId>20080706173813</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-07-06 17:38:13-0400</timestampReceived><subject>Re: Proposal 151: Path Selection Improvements</subject><body>

On Sat, Jul 05, 2008 at 06:46:34PM -0700, Fallon wrote:
&gt; Hi everyone,
&gt; 
&gt; Here's a proposal for improving path selection through collecting build time
&gt; statistics. We're still collecting data, so it's quite short. Comments are
&gt; appreciated.


Added as Proposal 151.
</body></email><email><emailId>20080706233856</emailId><senderName>Mike Perry</senderName><senderEmail>mikeperry@fscked.org</senderEmail><timestampReceived>2008-07-06 23:38:56-0400</timestampReceived><subject>Re: Proposal 151: Path Selection Improvements</subject><body>


Thus spake Nick Mathewson (nickm@freehaven.net):

&gt; On Sat, Jul 05, 2008 at 06:46:34PM -0700, Fallon wrote:
&gt; &gt; Hi everyone,
&gt; &gt; 
&gt; &gt; Here's a proposal for improving path selection through collecting build time
&gt; &gt; statistics. We're still collecting data, so it's quite short. Comments are
&gt; &gt; appreciated.
&gt; 
&gt; 
&gt; Added as Proposal 151.

I've updated this proposal in svn to include plans for migrating away
from guards with high failure rates that Fallon and I discussed last
night.

For convenience:
https://tor-svn.freehaven.net/svn/tor/trunk/doc/spec/proposals/151-path-selection-improvements.txt

-- 
Mike Perry
Mad Computer Scientist
fscked.org evil labs

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20080711195354</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-07-11 19:53:54-0400</timestampReceived><subject>Re: Proposal 151: Path Selection Improvements</subject><body>

On Sun, Jul 06, 2008 at 04:38:56PM -0700, Mike Perry wrote:
 [...]
&gt; I've updated this proposal in svn to include plans for migrating away
&gt; from guards with high failure rates that Fallon and I discussed last
&gt; night.
&gt; 
&gt; For convenience:
&gt; https://tor-svn.freehaven.net/svn/tor/trunk/doc/spec/proposals/151-path-selection-improvements.txt
&gt; 

Hi, Mike!  The proposal's too preliminary to accept right now, but I
thought I'd put in some comments and questions wrt the version in svn.
(This doesn't prevent the proposal from getting into 0.2.1.x: Changing
the number of guards and/or the CircuitBuildTimeout should be
relatively easy and low-risk, and the rest doesn't sound too
destabilizing either.)

Something I didn't see in the proposal (forgive me if it's already
there) is: is this a static or dynamic solution?  Is the idea to
examine the network once and pick the right values for NumGuards and
CircuitBuildTimeout [static], or to examine the network continually,
and pick the values based on up-to-date statistics [dynamic]?  A
dynamic approach seems better to me, since it won't get stuck
optimizing parameters for the network of today.

If we're taking a dynamic approach... who is to do the measurements?
Clients, or authorities?  Having authorities do measurements seems
more efficient, and more resiliant to attack where the adversary acts
differently towards different clients in order to change their view of
the network parameters, or make them use different guards, or such.

On CircuitBuildTimeout, a question: for general-purpose circuits,
perhaps the behavior of CircuitBuildTimeout is just plain wrong.
Perhaps the sensible behavior is, instead of discarding the circuit,
launching a new circuit.  This way, if the circuit is just being slow,
it can still get used instead of discarded.

WRT this paragraph:
&gt; In addition, we have noticed that some entry guards are much more
&gt; failure prone than others. In particular, the circuit failure rates for
&gt; the fastest entry guards was approximately 20-25%, where as slower
&gt; guards exhibit failure rates as high as 45-50%.

I'm very curious about the causes and symptoms of these failures.
What makes them happen?  How do they look to the client?  This seems
excessively high, and in addition to responding to these rates (as 151
proposes) we might also do well to look into reducing them.

&gt; In [1], it was
&gt; demonstrated that failing guard nodes can deliberately bias path
&gt; selection to improve their success at capturing traffic. For both these
&gt; reasons, failing guards should be avoided. 
&gt;
&gt; We propose increasing the number of entry guards to five, and gathering
&gt; circuit failure statistics on each entry guard. Any guards that exceed
&gt; the average failure rate of all guards by 10% after we have
&gt; gathered ncircuits_to_observe circuits will be replaced.

If clients make their own measurements on this, there's actually a
neat class of attack that we'd be enabling.  Instead of a malicious
guard failing in response to the client building a circuit through a
non-compromised path, malicious second hops can fail in response to
circuits built through targetted non-compromised guards.  If they
manage to raise failure rates for non-malicious guards high enough,
those guards will stop getting used.

Here's a more interesting attack: Suppose that we have a couple of bad
guards and they're targetting us in particular.  Let's say that they
have the same failure rate as average (based on CPU limits or
connectivity or limited bandwidth or whatever), but that they can
divert their resources towards particular circuits.  These malicious
guards should devote extra resources towards some users, and fail all
the time for the users they aren't targetting.  If they do this, they
may be able to get the target users to abandon other guards in favor
of them.

[As an aside: reputation-like systems on anonymity networks are the
best example I know of the principle in security that when you amend a
design, the attacker gets to make up attacks based on _your_ design,
and isn't restricted to the attacks that worked on the last one.]

yrs,
-- 
Nick
</body></email><email><emailId>20080711164935</emailId><senderName>Peter Palfrader</senderName><senderEmail>peter@palfrader.org</senderEmail><timestampReceived>2008-07-11 16:49:35-0400</timestampReceived><subject>Re: Proposal 145: Separate "suitable as a guard" from "suitable as a new guard"</subject><body>

On Wed, 02 Jul 2008, Nick Mathewson wrote:

&gt;    We might instead have authorities list weights with which nodes
&gt;    should be picked as guards.

That is something I will need to do anyway, I think.  In that case the
guard _flag_ would mean "keep as your guard", and the guard _weight_
would mean "pick with propability $p"?

Peter
-- 
                           |  .''`.  ** Debian GNU/Linux **
      Peter Palfrader      | : :' :      The  universal
 http://www.palfrader.org/ | `. `'      Operating System
                           |   `-    http://www.debian.org/
</body></email><email><emailId>20080711170121</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-07-11 17:01:21-0400</timestampReceived><subject>Re: Proposal 145: Separate "suitable as a guard" from "suitable as a new guard"</subject><body>

On Fri, Jul 11, 2008 at 06:49:35PM +0200, Peter Palfrader wrote:
&gt; On Wed, 02 Jul 2008, Nick Mathewson wrote:
&gt; 
&gt; &gt;    We might instead have authorities list weights with which nodes
&gt; &gt;    should be picked as guards.
&gt; 
&gt; That is something I will need to do anyway, I think.  In that case the
&gt; guard _flag_ would mean "keep as your guard", and the guard _weight_
&gt; would mean "pick with propability $p"?

Good point.  I'm going to defer accepting 145, pending a finished 141.

(I should be sending a proposal status email to the list Really Soon
Now.)
</body></email><email><emailId>20080706014634</emailId><senderName>Fallon</senderName><senderEmail>leftinspace@gmail.com</senderEmail><timestampReceived>2008-07-06 01:46:34-0400</timestampReceived><subject>Proposal: Path Selection Improvements</subject><body>

Hi everyone,

Here's a proposal for improving path selection through collecting build time
statistics. We're still collecting data, so it's quite short. Comments are
appreciated.

Fallon


Filename: path-selection-improvements.txt
Title: Improving Tor Path Selection
Version:
Last-Modified:
Author: Fallon Chen, Mike Perry
Created: 5-Jul-2008
Status: Draft

Overview
  The performance of paths selected can be improved by adjusting the
  CircuitBuildTimeout and the number of guards. This proposal describes
  a method of tracking buildtime statistics, and using those statistics to
adjust the
  CircuitBuildTimeout and the number of guards.

Motivation
  Tor's performance can be improved by excluding those circuits that
  have long buildtimes (and by extension, high latency). For those Tor users
  who require better performance and have lower requirements for anonymity,
  this would be a very useful option to have.

Implementation

  Learning the CircuitBuildTimeout
    Based on studies of build times, we found that the distribution of
    circuit buildtimes appears to be a Pareto distribution. The number of
    circuits to observe (ncircuits_to_observe) before changing the
    CircuitBuildTimeout will be tunable. From our preliminary measurements,
    it is likely that ncircuits_to_observe will be somewhere on the order of

    1000. The values can be represented compactly in Tor in milliseconds as
a
    circular array of 16 bit integers. More compact long-term storage
    representations can be implemented by simply storing a histogram with
    50 millisecond buckets when writing out the statistics to disk.

  Calculating the preferred CircuitBuildTimeout
    Circuits that have longer buildtimes than some x% of the estimated CDF
of
    the Pareto distribution will be excluded. x will be tunable as well.

  Circuit timeouts
    In the event of a timeout, backoff values should include the 100-x% of
    expected CDF of timeouts.
    Also, in the event of network failure, the observation mechanism should
    stop collecting timeout data.

  Other notes
    Since this follows a Pareto distribution, large reductions on the
timeout
    can be achieved without cutting off a great number of the total paths.
    However, hard statistics on which cutoff percentage gives optimal
    performance have not yet been gathered.

Issues
  Impact on anonymity

[Attachment #3 (text/html)]

Hi everyone,&lt;br&gt;&lt;br&gt;Here's a proposal for improving path selection through \
collecting build time statistics. We're still collecting data, so it's quite \
                short. Comments are appreciated. &lt;br&gt;&lt;br&gt;Fallon&lt;br&gt;&lt;br&gt;&lt;br&gt;
Filename: path-selection-improvements.txt&lt;br&gt;Title: Improving Tor Path Selection \
&lt;br&gt;Version:&lt;br&gt;Last-Modified: &lt;br&gt;Author: Fallon Chen, Mike Perry&lt;br&gt;Created: \
5-Jul-2008&lt;br&gt;Status: Draft&lt;br&gt;&lt;br&gt;Overview&lt;br&gt;  The performance of paths \
selected can be improved by adjusting the&lt;br&gt;

  CircuitBuildTimeout and the number of guards. This proposal describes \
&lt;br&gt;  a method of tracking buildtime statistics, and using those statistics to \
adjust the&lt;br&gt;  CircuitBuildTimeout and the number of guards. &lt;br&gt;&lt;br&gt;

Motivation&lt;br&gt;  Tor's performance can be improved by excluding those \
circuits that&lt;br&gt;  have long buildtimes (and by extension, high latency). For \
those Tor users&lt;br&gt;  who require better performance and have lower requirements \
for anonymity,&lt;br&gt;

  this would be a very useful option to have. \
&lt;br&gt;&lt;br&gt;Implementation&lt;br&gt;&lt;br&gt;  Learning the \
CircuitBuildTimeout&lt;br&gt;    Based on studies of build times, we found \
that the distribution of&lt;br&gt;    circuit buildtimes appears to be a \
Pareto distribution. The number of &lt;br&gt;

    circuits to observe (ncircuits_to_observe) before changing \
the&lt;br&gt;    CircuitBuildTimeout will be tunable. From our preliminary \
measurements,&lt;br&gt;    it is likely that ncircuits_to_observe will be \
somewhere on the order of &lt;br&gt;

    1000. The values can be represented compactly in Tor in \
milliseconds as a       &lt;br&gt;    circular \
array of 16 bit integers. More compact long-term storage&lt;br&gt;    \
representations can be implemented by simply storing a histogram with&lt;br&gt;

    50 millisecond buckets when writing out the statistics to \
disk.&lt;br&gt;  &lt;br&gt;  Calculating the preferred \
CircuitBuildTimeout&lt;br&gt;    Circuits that have longer buildtimes than \
some x% of the estimated CDF of&lt;br&gt;    the Pareto distribution will be \
excluded. x will be tunable as well. &lt;br&gt;

 &lt;br&gt;  Circuit timeouts&lt;br&gt;    In the event of a timeout, \
backoff values should include the 100-x% of&lt;br&gt;    expected CDF of \
timeouts.&lt;br&gt;    Also, in the event of network failure, the \
observation mechanism should&lt;br&gt;    stop collecting timeout data.&lt;br&gt;

  &lt;br&gt;  Other notes&lt;br&gt;    Since this follows a Pareto \
distribution, large reductions on the timeout&lt;br&gt;    can be achieved \
without cutting off a great number of the total paths.&lt;br&gt;    However, \
hard statistics on which cutoff percentage gives optimal&lt;br&gt;

    performance have not yet been gathered.&lt;br&gt;&lt;br&gt;Issues&lt;br&gt;  \
Impact on anonymity&lt;br&gt;  &lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;



</body></email><email><emailId>20080713163904</emailId><senderName>Geoffrey Goodell</senderName><senderEmail>goodell@eecs.harvard.edu</senderEmail><timestampReceived>2008-07-13 16:39:04-0400</timestampReceived><subject>Proposal: Optionally allow exit from single-hop circuits</subject><body>

[Attachment #2 (multipart/mixed)]


Please see attached my proposed solution to address Bug 768.

Thanks!

Geoff


["single-hop-circuits.txt" (text/plain)]

Filename: single-hop-circuits.txt
Title: Optionally allow exit from single-hop circuits
Version:
Last-Modified:
Author: Geoff Goodell
Created: 13-Jul-2008
Status: Draft

Overview

    Provide a special configuration option that adds a line to descriptors
    indicating that a router can be used as an exit for one-hop circuits, and allow
    clients to attach streams to one-hop circuits provided that the descriptor for
    the router in the circuit includes this configuration option.

Motivation

    At some point (r9735?), code was added to src/or/control.c that prevents
    controllers from attaching streams to one-hop circuits.  The idea seems to be
    that we can use the cost of forking and maintaining a patch as a lever to
    prevent people from writing controllers that jeopardize the operational
    security of routers and the anonymity properties of the Tor network by creating
    and using one-hop circuits rather than the standard three-hop circuits.  It may
    be, for example, that some users do not actually seek true anonymity but simply
    reachability through network perspectives afforded by the Tor network, and
    since anonymity is stronger in numbers, forcing users to contribute to
    anonymity and decrease the risk to server operators by using full-length paths
    may be reasonable.

    Whether or not we agree that the particular approach of using hardcoded,
    immutable policy in the Tor client to limit self-determinism on the part of
    clients is the right way to address the risks posed by one-hop circuit
    utilization (for example, I think that routers ought to take responsibility for
    ensuring that they are not allowing exit from one-hop circuits), it remains
    true that as presently implemented, the sweeping restriction of one-hop
    circuits for all routers limits the usefulness of Tor as a general-purpose
    technology for building circuits.  In particular, we should allow for
    controllers, such as Blossom, that create and use single-hop circuits involving
    routers that are not part of the Tor network.

Design

    Introduce a configuration option for Tor servers that, when set, indicates that
    a router is willing to provide exit from one-hop circuits.  Routers with this
    policy will not require that a circuit has at least two hops when it is used as
    an exit.

    In addition, routers for which this configuration option has been set will have
    a line in their descriptors, "opt exit-from-single-hop-circuits".  Clients will
    keep track of which routers have this option and allow streams to be attached
    to single-hop circuits including such routers.

Security Considerations

    This approach seems to eliminate the worry about operational router security,
    since server operators will not set the configuraiton option unless they are
    willing to take on such risk.  

    To reduce the impact on anonymity of the network resulting from including such
    "risky" routers in regular Tor path selection, clients may systematically
    exclude routers with "opt exit-from-single-hop-circuits" when choosing random
    paths through the Tor network.


["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20080701231258</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-07-01 23:12:58-0400</timestampReceived><subject>Re: Proposal 144: enforce distinct providers</subject><body>

On Sat, Jun 28, 2008 at 04:28:57PM +0200, M Fr wrote:
&gt; Hello,
&gt; 
&gt; like we've speak on bug
&gt; http://bugs.noreply.org/flyspray/index.php?do=details&amp;id=690
&gt; 
&gt; Here is a proposal to implement this functionality.
&gt; 

Hi!  By request, I'm forwarding this to or-dev and adding it as proposal 144.

I've reformatted it, and included the reformatted version below.

Filename: 144-enforce-distinct-providers.txt
Title: Increase the diversity of circuits by detecting nodes belonging the
same provider
Author: Mfr
Created: 2008-06-15
Status: Draft

Overview:

  Increase network security by reducing the capacity of the relay or
  ISPs monitoring personally or requisition, a large part of traffic
  Tor trying to break circuits privacy.  A way to increase the
  diversity of circuits without killing the network performance.

Motivation:

  Since 2004, Roger an Nick publication about diversity [1], very fast
  relays Tor running are focused among an half dozen of providers,
  controlling traffic of some dozens of routers [2].

  In the same way the generalization of VMs clonables paid by hour,
  allowing starting in few minutes and for a small cost, a set of very
  high-speed relay whose in a few hours can attract a big traffic that
  can be analyzed, increasing the vulnerability of the network.

  Whether ISPs or domU providers, these usually have several groups of
  IP Class B.  Also the restriction in place EnforceDistinctSubnets
  automatically excluding IP subnet class B is only partially
  effective. By contrast a restriction at the class A will be too
  restrictive.

 Therefore it seems necessary to consider another approach.

Proposal:

  Add a provider control based on AS number added by the router on is
  descriptor, controlled by Directories Authorities, and used like the
  declarative family field for circuit creating.

Design:

Step 1 :

 Add to the router descriptor a provider information get request [4]
  by the router itself.

         "provider" name NL

            'names' is the AS number of the router formated like this:
            'ASxxxxxx' where AS is fixed and xxxxxx is the AS number,
            left aligned ( ex: AS98304 , AS4096,AS1 ) or if AS number
            is missing the network A class number is used like that:
            'ANxxx' where AN is fixed and xxx is the first 3 digits of
            the IP (ex: for the IP 1.1.1.2 AN1) or an 'L' value is set
            if it's a local network IP.

            If two ORs list one another in their "provider" entries,
            then OPs should treat them as a single OR for the purpose
            of path selection.

            For example, if node A's descriptor contains "provider B",
            and node B's descriptor contains "provider A", then node A
            and node B should never be used on the same circuit.

    Add the regarding config option in torrc

            EnforceDistinctProviders set to 1 by default.
            Permit building circuits with relays in the same provider
            if set to 0.
            Regarding to proposal 135 if TestingTorNetwork is set
            need to be EnforceDistinctProviders is unset.

    Control by Authorities Directories of the AS numbers

         The Directories Authority control the AS numbers of the new node
         descriptor uploaded.

            If an old version is operated by the node this test is
            bypassed.

            If AS number get by request is different from the
            description, router is flagged as non-Valid by the testing
            Authority for the voting process.

Step 2     When a ' significant number of nodes' of valid routers are
generating descriptor with provider information.

        Add missing provider information get by DNS request
functionality for the circuit user:

                During circuit building, computing, OP apply first
                family check and EnforceDistinctSubnets directives for
                performance, then if provider info is needed and
                missing in router descriptor try to get AS provider
                info by DNS request [4].  This information could be
                DNS cached.  AN ( class A number) is never generated
                during this process to prevent DNS block problems.  If
                DNS request fails ignore and continue building
                circuit.

Step 3 When the 'whole majority' of valid Tor clients are providing
DNS request.

        Older versions are deprecated and mark as no-Valid.

  EnforceDistinctProviders replace EnforceDistinctSubnets functionnality.

        EnforceDistinctSubnets is removed.

        Functionalities deployed in step 2 are removed.

Security implications:

      This providermeasure will increase the number of providers
      addresses that an attacker must use in order to carry out
      traffic analysis.

Compatibility:

        The presented protocol does not raise compatibility issues
        with current Tor versions. The compatibility is preserved by
        implementing this functionality in 3 steps, giving time to
        network users to upgrade clients and routers.

Performance and scalability notes:

        Provider change for all routers could reduce a little
        performance if the circuit to long.

        During step 2 Get missing provider information could increase
        building path time and should have a time out.

Possible Attacks/Open Issues/Some thinking required:

        These proposal seems be compatible with proposal 135 Simplify
        Configuration of Private Tor Networks.

        This proposal does not resolve multiples AS owners and top
        providers traffic monitoring attacks [5].

        Unresolved AS number are treated as a Class A network. Perhaps
        should be marked as invalid.  But there's only fives items on
        last check see [2].

        Need to define what's a 'significant number of nodes' and
        'whole majority' ;-)

References:
[1] Location Diversity in Anonymity Networks by Nick Feamster and Roger
Dingledine.
In the Proceedings of the Workshop on Privacy in the Electronic Society
(WPES 2004), Washington, DC, USA, October 2004
http://freehaven.net/anonbib/#feamster:wpes2004
[2] http://as4jtw5gc6efb267.onion/IPListbyAS.txt
[3] see Goodell Tor Exit Page
http://cassandra.eecs.harvard.edu/cgi-bin/exit.py
[4] see the great IP to ASN DNS Tool
http://www.team-cymru.org/Services/ip-to-asn.html
[5] Sampled Traffic Analysis by Internet-Exchange-Level Adversaries by
Steven J. Murdoch and Piotr Zielinski.
In the Proceedings of the Seventh Workshop on Privacy Enhancing Technologies

(PET 2007), Ottawa, Canada, June 2007.
http://freehaven.net/anonbib/#murdoch-pet2007
[5] http://bugs.noreply.org/flyspray/index.php?do=details&amp;id=690
</body></email><email><emailId>20080710212449</emailId><senderName>Robert Hogan</senderName><senderEmail>robert@roberthogan.net</senderEmail><timestampReceived>2008-07-10 21:24:49-0400</timestampReceived><subject>stream status events</subject><body>


Stream status events for reverse resolve requests for which Tor has a cached 
answer look like this:

650 STREAM 6 NEWRESOLVE 0 64.4.33.7:0
650 STREAM 6 FAILED 0 REVERSE[64.4.33.7]:0
650 STREAM 7 NEWRESOLVE 0 64.4.33.7:0
650 STREAM 7 FAILED 0 REVERSE[64.4.33.7]:0

The stream 'fails' because there is never a need to create it. The spec is a bit 
unclear on this point but I think all streams deserve a CLOSE event. Or 
is 'FAILED' considered sufficient?

I can allow a CLOSE event by doing:

Index: src/or/connection_edge.c
===================================================================
--- src/or/connection_edge.c    (revision 15824)
+++ src/or/connection_edge.c    (working copy)
@@ -1369,8 +1369,7 @@
                                              map_expires);
       connection_mark_unattached_ap(conn,
                                 END_STREAM_REASON_DONE |
-                                END_STREAM_REASON_FLAG_ALREADY_SOCKS_REPLIED |
-                                END_STREAM_REASON_FLAG_ALREADY_SENT_CLOSED);
+                                END_STREAM_REASON_FLAG_ALREADY_SOCKS_REPLIED);
       return 0;
     }
     if (options-&gt;ClientDNSRejectInternalAddresses) {

but maybe it's the spec that needs to be clarified. A short note stating which 
events should be expected for all streams maybe.

["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20080711182255</emailId><senderName>Peter Palfrader</senderName><senderEmail>peter@palfrader.org</senderEmail><timestampReceived>2008-07-11 18:22:55-0400</timestampReceived><subject>proposal 141: download server descriptors on demand</subject><body>

On Mon, 16 Jun 2008, Nick Mathewson wrote:

&gt;  
&gt; &gt; 3.1 Load balancing info in consensus documents
&gt; &gt; 
&gt; &gt;   One of the reasons why clients download all server descriptors is for
&gt; &gt;   doing load proper load balancing as described in 2.1.  In order for
&gt; &gt;   clients to not require all server descriptors this information will
&gt; &gt;   have to move into the network status document.
&gt; &gt; 
&gt; &gt;   [XXX Two open questions here:
&gt; &gt;    a) how do we arrive at a consensus weight?
&gt; 
&gt; Perhaps the vote could contain the node's bandwidth, and this could be
&gt; used to calculate the weights?  It's necessary that the consensus
&gt; remain a deterministic function of the votes.

That's one approach.  It means however that when we want to tweak the
weighting algorithm we have to introduce new consensus methods.

The other approach is that every voter assigns weights for each of the
purposes (Exit, Guard, ..) so that their total sum is some constant X.
When building a consensus we take the median for each purpose for each
router.

&gt; &gt;    b) how to represent weights in the consensus?
&gt; &gt;       Maybe "s Guard=0.13 Exit=0.02 Middle=0.00 Stable.."
&gt; 
&gt; That would break backward compatibility.  Adding a new per-line
&gt; instead would probably be better.  We should play with representations
&gt; here till we wind up with something compressible, and we should figure
&gt; out the space impact of doing this.

How about something like "w Exit=41 Guard=94 Middle=543"


  Consensus documents will have a new line per router similar
  to the "r", "s", and "v" lines that already exist.  This line
  will convey weight information to clients.

   "w Exit=41 Guard=94 Middle=543 ..."

  It starts with the letter w and then contains any number of Key=Value
  pairs.  Values will be non-negative integers.  Clients will pick
  routers with a propability proportional to the number for the intended
  purpose.

  Clients MUST accept sums of all weights for a given purpose over all
  routers in a consensus up to UINT64_max.


&gt; &gt; 3.2 Fetching descriptors on demand
&gt; &gt; 
&gt; &gt;   As described in 2.4 a descriptor lists IP address, OR- and Dir-Port,
&gt; &gt;   and the onion key for a server.
&gt; &gt; 
&gt; &gt;   A client already knows the IP address and the ports from the consensus
&gt; &gt;   documents, but without the onion key it will not be able to send
&gt; &gt;   CREATE/EXTEND cells for that server.  Since the client needs the onion
&gt; &gt;   key it needs the descriptor.
&gt; &gt; 
&gt; &gt;   If a client only downloaded a few descriptors in an observable manner
&gt; &gt;   then that would leak which nodes it was going to use.
&gt; &gt; 
&gt; &gt;   This proposal suggests the following:
&gt; &gt; 
&gt; &gt;   1) when connecting to a guard node for which the client does not
&gt; &gt;      yet have a cached descriptor it requests the descriptor it
&gt; &gt;      expects by hash.  (The consensus document that the client holds
&gt; &gt;      has a hash for the descriptor of this server.  We want exactly
&gt; &gt;      that descriptor, not a different one.)
&gt; &gt;
&gt; &gt;      [XXX: How?  We could either come up with a new cell type,
&gt; &gt;       RELAY_REQUEST_SD that takes only a hash (of the SD), or use
&gt; &gt;       RELAY_BEGIN_DIR.  The former is probably smarter since we will
&gt; &gt;       want to use it later on as well, and there we will require
&gt; &gt;       padding.]
&gt; 
&gt; My first thought was that I'd prefer to avoid multiplying machinery
&gt; here.  When we design RELAY_REQUEST_SD, let's try to keep looking to
&gt; see whether we can add a padding argument to RELAY_BEGIN_DIR rather
&gt; than forcing a new relay cell type?

A new cell type safes on round trip times.  Using BEGIN_DIR means we
send the cell, get a "CONNECTED" back, send the request, get a result.

Using a dedicated cell type will cut that in half.

&gt; Something else to figure out here is migration.  When the first cut of
&gt; this system is done, only new servers will support RELAY_REQUEST_SD.
&gt; This means that clients will still need to pre-download descriptors
&gt; under some circumstances.
&gt; 
&gt; In fact, the rules will be pretty weird here.  If extends are done by
&gt; first asking B for C's descriptor, then clients need to know whether B
&gt; supports RELAY_REQUEST_SD.  If it doesn't, they need to have C's
&gt; descriptor, which means they need to have downloaded it in advance.
&gt; 
&gt; In its final version, this proposal needs a migration plan.

We could fall back to BEGIN_DIR, but that only helps when B is a
directory cache.

One approach is to introduce server support first, and wait with client
use until a significant part of the network is supporting it.  Unless we
can come up with something smarter.


&gt; &gt; 3.4 Exit selection
&gt; &gt; 
&gt; &gt;   Currently finding an appropriate exit node for a user's request is
&gt; &gt;   easy for a client because it has complete knowledge of all the exit
&gt; &gt;   policies of all servers on the network.
&gt; &gt; 
&gt; &gt;   [XXX: I have no finished ideas here yet.
&gt; &gt;     - if clients only rely on the current exit flag they will
&gt; &gt;       a) never use servers for exit purposes that don't have it,
&gt; &gt;       b) will have a hard time finding a suitable exit node for
&gt; &gt;          their weird port that only a few servers allow.
&gt; &gt;     - the authorities could create a new summary document that
&gt; &gt;       lists all the exit policies and their nodes (by fingerprint).
&gt; &gt;       I need to find out how large that document would be.
&gt; &gt;     - can we make the "Exit" flag more useful?  can we come
&gt; &gt;       up with some "standard policies" and have operators pick
&gt; &gt;       one of the standards?
&gt; 
&gt; Generally, most policies should take the form of "Here are the ports I
&gt; allow.  Here are the addresses I disallow."  If we codify a few
&gt; port-sets, we might be in business.

Theory: Most routers use one of a very small set of different exit policies (if
we think of a router's own IP address in its exit policy as a single token
@@IP@@ or whatever).

Maybe the consensus document should include a hash of the (normalized,
i.e. the router's IP replaced with a token) exit policy.

For instance the current consensus has the following exit policies:
    750 ea118b6480d664e6b65363d6330f62d76312309d  -
    606 6c327099a4eb1ff45128d36643d7494d706e1736  -
    200 cc5e5310ca7fc1f22b0ce1d017817934889e424a  -
     38 d640a0b886b61d20f3390f16e68f94bb67ca3e02  -
     34 04e917f4dfa4fde648fa2e64ed450cf078bba22d  -
     22 24317c522385314806403543dbdc8c4d797c412e  -
     16 c6fca3e85a850ab5ebce7e579739c30077b1e967  -
     15 c1ca7a48e410911356a8fc585744fb3ffeab99da  -
     12 cc44ee0df0f2a42868e65150e11d16274f71cd4c  -
      9 5c74594ad9dd4df0bd40e1e2cd3fe7f2906657cf  -
      8 daad277346eac48f247411dc60e2020a767861f4  -
      8 63fa7a8e07fbf314abb52b19c67a6b773052d0d9  -
      7 b2b8e7d147a05258bf375407dc29abeeeda9e25f  -
      6 a5ac5094b4a3fb116fe99cebba0787609d7c99b9  -
      6 a29974dcf97a012726710ced75eab63ff95383dc  -
      6 3c0d8576d935aae8c6c296216ac559ced03a612f  -
      6 20c7b1b0914ce4f5817b58912723d5e26974a373  -
i.e. ea11.. exists 750 times, 6c.. 606 times etc.


Now when a tor client first start it will pick a route based only on the
weights it learns from the consensus.  In the course of building that
circuit it will learn a few exit policies.

Next time it needs to build a circuit it can again generate it only
based on weights.  If it is lucky it already will have the exit
policy (even if not the full SD) of the exit node.  Should that policy
not allow exits to the target that circuit can be abandoned immediately.


We will have a hard time exiting when only very few nodes allow
connections to a specific IP:port.  But maybe that's ok.

&gt; &gt;   This proposal still requires that all servers have the descriptors of
&gt; &gt;   every other node in the network in order to answer RELAY_REQUEST_SD
&gt; &gt;   cells.  These cells are sent when a circuit is extended from ending at
&gt; &gt;   node B to a new node C.  In that case B would have to answer a
&gt; &gt;   RELAY_REQUEST_SD cell that asks for C's server descriptor (by SD digest).
&gt; &gt;
&gt; &gt;   In order to answer that request B obviously needs a copy of C's server
&gt; &gt;   descriptor.  In the future we might amend RELAY_REQUEST_SD cells to
&gt; &gt;   contain also the expected IP address and OR-port of the server C (the
&gt; &gt;   client learns them from the network status document), so that B no
&gt; &gt;   longer needs to know all the descriptors of the entire network but
&gt; &gt;   instead can simply go and ask C for its descriptor before passing it
&gt; &gt;   back to the client.
&gt; 
&gt; We might want to include this information in RELAY_REQUEST_SD anyway
&gt; now, so that when servers start supporting fetch-on-demand, clients
&gt; will already be sending them the info they need to do it.  I think it
&gt; should include an identity fingerprint digest too, so that B can open
&gt; an authenticated OR connection to C as needed.

agreed.

-- 
                           |  .''`.  ** Debian GNU/Linux **
      Peter Palfrader      | : :' :      The  universal
 http://www.palfrader.org/ | `. `'      Operating System
                           |   `-    http://www.debian.org/
</body></email><email><emailId>20080715044431</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-07-15 04:44:31-0400</timestampReceived><subject>Comments on proposals 121, 142, and 143.</subject><body>

Here are some comments on the open hidden service proposals.  As
before, if you're replying about just one, please edit the subject
line in your reply.

PROPOSAL 121: Hidden Service Authentication

Proposal 121 adds generic authorization features to hidden services,
and describes a specific implementation of this authorization feature
for providing password-like authorization to a small set (say, up to
16) of users.

The following changes should be made to section one (the generic part):

 - In 1.2, rather than making two kinds of INTRODUCE1 cells and using
   voodoo and duct tape to tell them apart, introduce a INTRODUCE1V
   relay cell type (the V stands for versioned) and make all new kinds
   of INTRODUCE1 cells use this cell type.  (Proposal 142 already suggests
   something like this.)

 - The replay avoidance approach can be far better.  Instead of the
   approach in the proposal, which still allows a number of replays,
   try including a timestamp and a nonce in the authenticated portion
   of the INTRODUCE2 cell.  Require the timestamp to be no more than T
   seconds in the past or future, and require that the nonce has not
   been used for the last 2*T seconds.  This requires less storage,
   and prevents all replays.  [Instead of a nonce, we can and should
   use a cryptographic hash of the rendezvous cookie, or the g^x data
   from the INTRODUCE2 cell, or the entire introduce2 cell contents.]

Karsten is revising section 2 a bit as well to discuss some motivation
issues, and we're going to figure out (but not necessarily build for
0.2.1.x) an authorization system that scales to more users better than
that of proposal 121's section 2.  Such a system may not provide the
same security as the one in section 2: the goal is to do better than
the status quo for security, and better than section 2 for
scalability.

We'll also want to think here about what to do when we want
interactive authorization protocols, or to support methods requiring
more data than can fit in the space currently available in Tor cells.


PROPOSAL 142: Combine Introduction and Rendezvous Points

Karsten says this won't be ready on an 0.2.1.x timeframe, so I'll
gloss over it here.  I think there is an important insight here, but I
have some questions:

  - Chris -- it would be helpful if you could summarize more detail
    from your thesis about the relevant timing issues.  Since the
    point of this proposal is to reduce latency, we really need to get
    all the measurement we can of its efficacy.  (If you can include a
    URL for the thesis and a page reference, that would help people
    who don't have a copy on hand.)

  - As I read it, I don't see how the proposal results in a separate
    circuit existing from the hidden server ("Bob") to the client.
    When a normal RP gets an RENDEZVOUS2 cells, it splices the two
    *circuits* together so that relay cells sent from Alice eventually
    arrive at Bob, and Alice can send RELAY_BEGIN cells to open
    streams to Bob's hidden service.  The rendezvous point never sees
    the content of these cells; it just passes them from one circuit to
    another. 

    In this proposal, though, it looks like circuits from multiple
    Alices wind up joined to a single circuit from Bob.  (This is
    complicated by the proposal saying "connection" when I think it
    means "circuit". [*]) Tor doesn't work that way!  If two Alices
    send a RELAY_BEGIN cell with the same streamID, how is Bob to tell
    the streams apart?  When Bob sends a data cell back along the
    circuit, which of the Alice circuits should the introduction point
    send it to?  Remember, the rendezvous point can't see the insides
    of these RELAY cells.

    There are possible fixes for this, but none of the ones I can
    think of offhand are too attractive.  For example, Bob could
    pre-build numerous circuits to the introduction point and use one
    of those to send the RENDEZVOUS2 cell.


PROPOSAL 143: Distributed storage improvements

This is an omnibus proposal with 8 separate ideas.  Going one by one:

 1. Report Bad Directory Nodes

    This seems like a fine idea, though the additional complexity is
    not insignificant.

    I worry that a clever adversary could distinguish a publication
    attempt from an HS authority.  After all, hidden services do not
    generally upload the same descriptor twice: if somebody sends you
    a descriptor shortly after you received the same descriptor, and
    it's a descriptor you're trying to censor, you can tell it's the
    authority.

    The "blacklist all nodes in the same /24 or /16" rules seem far
    too harsh: they let an adversary cut out huge swaths of the
    network using only one or two targeted hosts.

    The voting rule listed makes the BadHSDir flag follow different
    rules from all other networkstatus flags.  This would require a
    version bump in the voting method.

 2. Publish Fewer Replicas

    This is worthwhile, but no reason is given to think that the 85.7%
    reliability figure will hold given future networks and network
    conditions. It would be better to look into adaptive solutions
    that will continue to work no matter what the reliability is in
    the future.  See my recent comments on proposal 151: most apply
    here.

 3. Change Default Value of Being Hidden Service Directory

    Seems entirely reasonable.  Overdue, even. :)

    BTW, how many of the numbers in the rest of this proposal are
    derived from the existing HSDir nodes?  If the number of HSDir
    nodes is small, then most of the measurements in the rest of this
    proposal are based on a worryingly small sample set.

 4. Make Descriptors Persistent on Directory Nodes

    Plausible, but measurements are needed to make sure this is a good
    idea.  If a server goes down, how often does it occur that it
    starts up again in time to serve the hidden service descriptors
    it's holding?  If the odds are good, this is a good idea.
    Otherwise, not?

 5. Store and Serve Descriptors Regardless of Responsibility

    Good idea.  We need an answer for DOS attacks here, though.

 6. Avoid periodic descriptor re-publication.

    Good idea.  Seems obviously correct to me.

 7. Discard Expired Descriptors

    Good idea.  Should descriptors contain an expiration time?

 8. Shorten Client-side descriptor fetch history

    I don't understand this one fully, I think.


[*] Long ago, we were saying "connection" to mean "an
    application-level end-to-end connection relayed over Tor"; "a TCP
    connection between two servers"; and "a multi-hop path along Tor
    servers".  This led to confusion until we wound up trying to call
    the first thing a "stream", the second thing a "connection", and
    the third thing a "circuit".

    The original Onion Routing authors went through this too;
    unfortunately, we weren't careful enough to follow their wisdom,
    so we had to learn through experience. :)
</body></email><email><emailId>20080711171407</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-07-11 17:14:07-0400</timestampReceived><subject>Proposal statuses for Tor 0.2.1.x [Part 1]</subject><body>

This will be the first of several emails about statuses of various
proposals for Tor 0.2.1.x.  I'm not going to talk about the hidden
service proposals 121, 142, and 143 here (they get their own email),
or about the proposals 144, 149, 150, and 151 (which need more
discussion).

I've recently made nontrivial updates to proposals 110, 118, and 147:
you should check them out if they interest you.

When replying to this, please try to start a separate thread for each
proposal, with the proposal number and title in the header.

Proposal 110: avoiding infinite length circuits

   Accepted.  Part of this is already in 0.2.0.x, and most of the rest
   can be done in 0.2.1.x.  Since the final phase requires us to
   remove support for versions that don't generate RELAY_EARLY cells,
   we'll need delay the final phase of this proposal until all current
   versions are obsolete.  If feasible, we should backport support for
   generating RELAY_EARLY cells to the 0.2.0.x series once it's
   tested, if we can do so safely.

   (Keeping support for old versions indefinitely isn't an option,
   since doing so would continue to enable the very attacks this
   proposal is meant to prevent..)

Proposal 118: Advertising multiple ORPorts at once.

   Revised; recommendation: accept.  I've revised this proposal based
   on conversation with Roger.  It seems pretty easy to build.

Proposal 117: IPv6 exits

   Accepted.  The changes that needed to be made were all in my head,
   or fixed by the revised 118 (which adds ipv6 entry support).

Proposal 120: Shutdown descriptors when Tor servers stop.

   Dead.  The point of this proposal was to give routers a good way to
   get out of the networkstatus early, but proposal 138 (already
   implemented) has achieved this.

Proposal 127: Relaying dirport requests to Tor download site / website

   This stays as a draft proposal.  It's not a totally crazy idea, and
   we need to make distribution as easy as we can, but it might or
   might not be the best way to do it.  Roger thinks we can do better
   if I understand correctly.

Proposal 128: Families of private bridges

   This proposal is partially implemented, and partially dead.  Roger
   will add a note to it, and merge the finished parts into the spec.

Proposal 131: Help users to verify they are using Tor
Proposal 132: A Tor Web Service For Verifying Correct Browser Configuration

   Draft. These are neat ideas for verifying if a user's browser is
   set up to use to use Tor (correctly), and if a user's Tor is
   running at all.  There are pros and cons to both approaches, and
   more design could be needed.  Nobody on the main Tor team seems
   likely to be free to do these on an 0.2.1.x timeframe, but if
   somebody wants to volunteer to tackle them, that'll be great.
   Leaving as Draft.

Proposal 133:  Incorporate Unreachable ORs into the Tor Network

   This proposal discusses changes to allow hosts that aren't able to
   accept incoming connections to nevertheless add themselves to the
   Tor network.  It changes the Tor topology significantly by
   attaching such ORs to only 1/256 of the network.  This isn't
   best-practice from the research community for restricted topologies
   (sqrt(n) seems to be recommended by most papers), so this proposal
   would need revision in any case.  Before we work on that, though,
   we should see how far we can get towards adding unreachable ORs to
   the network by the simpler approaches of notifying users better,
   giving them better instructions, and getting UPNP support working.
   We could also do measurements of how many ORs believe themselves to
   be unreachable, to see what the benefit of a proposal like this
   would be if we did it.  Leaving as Draft.

Proposal 134: More robust consensus voting with diverse authority sets

   Accept.  Reportedly, adding new authorities or removing old ones is
   such a pain that without something like this proposal, we'll never
   do it.  I'm not sure I belive this myself, but I don't run an
   authority of my own, so I'll defer to others' judgment here.

   Parts of this (related to downloading networkstatuses) are already
   implemented.

Proposal 137: Keep controllers informed as Tor bootstraps

   Finished, actually.  Needs to get merged into specs.

Proposal 140:  Provide diffs between consensuses

   Accept.  We've wanted to do something like this for a while, and
   the approach seems basically sane.  I'm not personally looking
   forward to reimplementing a subset ed, but other approaches are
   worse, harder, or more hackish.

Proposal 141: Download server descriptors on demand

   This proposal is a good start, but there are enough open questions
   in it that I'm not comfortable plunging ahead in hopes that the
   answers will appear.  Leaving as draft.  If we get the hard parts
   figured out --particularly the questions in section 3.4-- this
   might be workable for 0.2.1.x.  Leaving as draft for now.

Proposal 145: Separate "suitable as a guard" from "suitable as a new guard"

   Acceptable, but its functionality could be replaced by 141 as noted
   on or-dev discussion.  Leaving Open for now.

Proposal 146: Add new flag to accept long-term stability

   Roger thinks this is a decent idea too, so accept.

Proposal 147: Eliminate the need for v2 directories in generating v3
   directories

   I've revies this with Roger's recommendations and marked it for
   accept.

Proposal 148: Stream end reasons from the client side should be
   uniform

   This is an obvious and easy one; accept, and possibly backport.

</body></email><email><emailId>20080724152846</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-07-24 15:28:46-0400</timestampReceived><subject>Alex Le Heux on IPv6 proposals [alexlh@funk.org: Re: Links about IPv6 in Tor]</subject><body>

Forwarding with permission; these include general comments on Proposal
117 and Proposal 118 issues.

----- Forwarded message from Alex Le Heux &lt;alexlh@funk.org&gt; -----

From: Alex Le Heux &lt;alexlh@funk.org&gt;
To: Nick Mathewson &lt;nickm@freehaven.net&gt;
Subject: Re: Links about IPv6 in Tor
X-Spam-Level: 

Hi Nick,

The documents look very good. You seem to have covered most things  
very well.

A few comments:

1.2 Router IPv6 exit support

There are cleants that have an IPv6 global unicast address, but have  
broken IPv6 connectivity. The problem used to be worse in the past,  
but once IPv6 deployment gets going, it might get worse for a while.  
Wikipedia is testing for just this, their results are here:

http://ipv6and4.labs.wikimedia.org/

This is not something to really worry about, but more something to  
keep in mind.


3.3. Support for IPv6 only transparent proxy clients

During the transition phase from IPv4 to IPv6, it seems likely that  
there will be wildly varying ways to invent the wheel. Being as  
flexible as possible about what configurations will still work upfront  
seems like a good idea.

Eventually, clients, nodes and destination servers may have any  
combination of v4-only, dual-stack, v6-native-only or any kind of  
transition mechanism like 6to4, etc.


Final remark

I believe Tor makes sure it picks the nodes from different /16s. In  
IPv6 you could employ a similar strategy. The fact that IPv6 address  
policy is a bit more structured and globally co-ordinated could help:

- Minimum allocation size to ISPs is a /32. The vast majority of the  
ISP allocations are /32s.
- End-user assignment sizes are variable, unfortunately, with most  
being a /48 although /56s are now appearing as well.
- Direct End-User assignments (Provider Independent, independently  
routed blocks) are /48 minimum size. There are some larger  
assignments, but most are a /48.

The disadvantage of picking /32 is that all direct end-user  
assignments will then be lumped together, while all these assignments  
to seperate organistions would come from a handfull of /32s.
The disadvantage of picking /48 is that nearly all "normal" end-users  
will be in ISP aggregated space, so you might end up with the entire  
path consisting of nodes living in a single ISP.

You could also do something more fine grained, as the blocks that the  
RIRs make direct end-user assignments from are well known.

I'll have a look at the other documents as well, if I've got more  
comments I'll send them.

Cheers,

Alex

On Jul 24, 2008, at 12:01, Nick Mathewson wrote:

&gt;The current version of the proposal for IPv6 exit support in Tor is  
&gt;here:
&gt;
&gt;  https://www.torproject.org/svn/trunk/doc/spec/proposals/117-ipv6-exits.txt
&gt;
&gt;This proposal has some issues related to IPv6 entries:
&gt;
&gt;  https://www.torproject.org/svn/trunk/doc/spec/proposals/118-multiple-orports.txt
&gt;
&gt;To follow along with some of the details here, it may be necessary to
&gt;look at the main specification documents.  The most relevent ones are
&gt;the core network protocol specification and the directory
&gt;specification.
&gt;
&gt;  https://www.torproject.org/svn/trunk/doc/spec/tor-spec.txt
&gt;  https://www.torproject.org/svn/trunk/doc/spec/dir-spec.txt
&gt;
&gt;If you've got any comments on these, the best place to comment would
&gt;be the or-dev mailing list.  It's subscriber-only, but it's
&gt;theoretically speaking where technical design discussion is supposed
&gt;to be happening.  Also feel free to email the tor-assistants list:
&gt;it's a small list of people who don't mind getting a huge pile of  
&gt;email.
&gt;
&gt;yrs,
&gt;-- 
&gt;Nick

-- 
The Sky is the limit. Let's set it on fire!

----- End forwarded message -----
</body></email><email><emailId>20080731030128</emailId><senderName>Matt Edman</senderName><senderEmail>edmanm@vidalia-project.net</senderEmail><timestampReceived>2008-07-31 03:01:28-0400</timestampReceived><subject>Proposal: Automatic Tor Software Updates</subject><body>


Filename: xxx-automatic-updates.txt
Title: Automatic Software Update Protocol
Version: $Revision$
Last-Modified: $Date$
Author: Matt Edman
Created: 30-July-2008
Status: Open


Scope

  This proposal specifies the method by which an automatic update client can
  determine the most recent recommended Tor installation package for the
  user's platform, download the package, and then verify that the package was
  downloaded successfully. While this proposal focuses on only the Tor
  software, the protocol defined is sufficiently extensible such that other
  components of the Tor bundles, like Vidalia, Polipo, and Torbutton, can be
  managed and updated by the automatic update client as well.

  The initial target platform for the automatic update framework is Windows,
  given that's the platform used by a majority of our users and that it lacks
  a sane package management system that many Linux distributions already have.
  Our second target platform will be Mac OS X, and so the protocol will be
  designed with this near-future direction in mind.

  Other client-side aspects of the automatic update process, such as user
  interaction, the interface presented, and actual package installation
  procedure, are outside the scope of this proposal.


Motivation

  Tor releases new versions frequently, often with important security,
  anonymity, and stability fixes. Thus, it is important for users to be able
  to promptly recognize when new versions are available and to easily
  download, authenticate, and install updated Tor and Tor-related software
  packages.
  
  Tor's control protocol [2] provides a method by which controllers can
  identify when the user's Tor software is obsolete or otherwise no longer
  recommended. Currently, however, no mechanism exists for clients to
  automatically download and install updated Tor and Tor-related software for
  the user.


Design Overview

  The core of the automatic update framework is a well-defined file called a
  "recommended-packages" file. The recommended-packages file is accessible via
  HTTP[S] at one or more well-defined URLs. An example recommended-packages
  URL may be:

    https://updates.torproject.org/recommended-packages

  The recommended-packages document is formatted according to Section 1.2
  below and specifies the most recent recommended installation package
  versions for Tor or Tor-related software, as well as URLs at which the
  packages and their signatures can be downloaded.

  An automatic update client process runs on the Tor user's computer and
  periodically retrieves the recommended-packages file according to the method
  described in Section 2.0. As described further in Section 1.2, the
  recommended-packages file is signed and can be verified by the automatic
  update client with one or more public keys included in the client software.
  Since it is signed, the recommended-packages file can be mirrored by
  multiple hosts (e.g., Tor directory authorities), whose URLs are included in
  the automatic update client's configuration.

  After retrieving and verifying the recommended-packages file, the automatic
  update client compares the versions of the recommended software packages
  listed in the file with those currently installed on the end-user's
  computer. If one or more of the installed packages is determined to be out
  of date, an updated package and its signature will be downloaded from one of
  the package URLs listed in the recommended-packages file as described in
  Section 2.2.

  The automatic update system uses a multilevel signing key scheme for package
  signatures. There are a small number of entities we call "packaging
  authorities" that each have their own signing key. A packaging authority is
  responsible for signing and publishing the recommended-packages file.
  Additionally, each individual packager responsible for producing an
  installation package for one or more platforms has their own signing key.
  Every packager's signing key must be signed by at least one of the packaging
  authority keys.


Specification

  1. recommended-packages Specification

  In this section we formally specify the format of the published
  recommended-packages file.

  1.1. Document Meta-format
  
  The recommended-packages document follows the lightweight extensible
  information format defined in Tor's directory protocol specification [1]. In
  the interest of self-containment, we have reproduced the relevant portions
  of that format's specification in this Section. (Credits to Nick Mathewson
  for much of the original format definition language.)
  
  The highest level object is a Document, which consists of one or more
  Items.  Every Item begins with a KeywordLine, followed by zero or more
  Objects. A KeywordLine begins with a Keyword, optionally followed by
  whitespace and more non-newline characters, and ends with a newline.  A
  Keyword is a sequence of one or more characters in the set [A-Za-z0-9-].
  An Object is a block of encoded data in pseudo-Open-PGP-style
  armor. (cf. RFC 2440)

  More formally:

    Document     ::= (Item | NL)+
    Item         ::= KeywordLine Object*
    KeywordLine  ::= Keyword NL | Keyword WS ArgumentChar+ NL
    Keyword      ::= KeywordChar+
    KeywordChar  ::= 'A' ... 'Z' | 'a' ... 'z' | '0' ... '9' | '-'
    ArgumentChar ::= any printing ASCII character except NL.
    WS           ::= (SP | TAB)+
    Object       ::= BeginLine Base-64-encoded-data EndLine
    BeginLine    ::= "-----BEGIN " Keyword "-----" NL
    EndLine      ::= "-----END " Keyword "-----" NL

    The BeginLine and EndLine of an Object must use the same keyword.
  
  In our Document description below, we also tag Items with a multiplicity in
  brackets. Possible tags are:

    "At start, exactly once": These items MUST occur in every instance of the
    document type, and MUST appear exactly once, and MUST be the first item in
    their documents.
        
    "Exactly once": These items MUST occur exactly one time in every
    instance of the document type.

    "Once or more": These items MUST occur at least once in any instance
    of the document type, and MAY occur more than once.

    "At end, exactly once": These items MUST occur in every instance of
    the document type, and MUST appear exactly once, and MUST be the
    last item in their documents.

  1.2. recommended-packages Document Format

  When interpreting a recommended-packages Document, software MUST ignore
  any KeywordLine that starts with a keyword it doesn't recognize; future
  implementations MUST NOT require current automatic update clients to
  understand any KeywordLine not currently described.

  In lines that take multiple arguments, extra arguments SHOULD be
  accepted and ignored.

  The currently defined Items contained in a recommended-packages document
  are:

    "recommended-packages-format" SP number NL

      [Exactly once]

      This Item specifies the version of the recommended-packages format that
      is contained in the subsequent document. The version defined in this
      proposal is version "1". Subsequent iterations of this protocol MUST
      increment this value if they introduce incompatible changes to the
      document format and MAY increment this value if they only introduce
      additional Keywords.

    "published" SP YYYY-MM-DD SP HH:MM:SS NL

      [Exactly once]

      The time, in GMT, when this recommended-packages document was generated.
      Automatic update clients SHOULD ignore Documents over 60 days old.

    "tor-stable-win32-version" SP TorVersion NL

      [Exactly once]

      This keyword specifies the latest recommended release of Tor's "stable"
      branch for the Windows platform that has an installation package
      available. Note that this version does not necessarily correspond to the
      most recently tagged stable Tor version, since that version may not yet
      have an installer package available, or may have known issues on
      Windows.

      The TorVersion field is formatted according to Section 2 of Tor's 
      version specification [3].

    "tor-stable-win32-package" SP Url NL

      [Once or more]

      This Item specifies the location from which the most recent
      recommended Windows installation package for Tor's stable branch can be
      downloaded.
    
      When this Item appears multiple times within the Document, automatic
      update clients SHOULD select randomly from the available package
      mirrors.

    "tor-dev-win32-version" SP TorVersion NL

      [Exactly once]
    
      This Item specifies the latest recommended release of Tor's
      "development" branch for the Windows platform that has an installation
      package available. The same caveats from the description of
      "tor-stable-win32-version" also apply to this keyword.

      The TorVersion field is formatted according to Section 2 of Tor's
      version specification [3].

    "tor-dev-win32-package" SP Url NL
  
      [Once or more]

      This Item specifies the location from which the most recent recommended
      Windows installation package and its signature for Tor's development
      branch can be downloaded.

      When this Keyword appears multiple times within the Document, automatic
      update clients SHOULD select randomly from the available package
      mirrors.

    "signature" NL SIGNATURE NL

      [At end, exactly once]

      The "SIGNATURE" Object contains a PGP signature (using a packaging
      authority signing key) of the entire document, taken from the beginning
      of the "recommended-packages-format" keyword, through the newline after
      the "signature" Keyword.


  2. Automatic Update Client Behavior

  The client-side component of the automatic update framework is an
  application that runs on the end-user's machine. It is responsible for
  fetching and verifying a recommended-packages document, as well as
  downloading, verifying, and subsequently installing any necessary updated
  software packages.

  2.1. Download and verify a recommended-packages document

  The first step in the automatic update process is for the client to download
  a copy of the recommended-packages file. The automatic update client
  contains a (hardcoded and/or user-configurable) list of URLs from which it
  will attempt to retrieve a recommended-packages file.

  Connections to each of the recommended-packages URLs SHOULD be attempted in
  the following order:

    1) HTTPS over Tor
    2) HTTP over Tor
    3) Direct HTTPS
    4) Direct HTTP

  If the client fails to retrieve a recommended-packages document via any of
  the above connection methods from any of the configured URLs, the client
  SHOULD retry its download attempts following an exponential back-off
  algorithm. After the first failed attempt, the client SHOULD delay one hour
  before attempting again, up to a maximum of 24 hours delay between retry
  attempts.

  After successfully downloading a recommended-packages file, the automatic
  update client will verify the signature using one of the public keys
  distributed with the client software. If more than one recommended-packages
  file is downloaded and verified, the file with the most recent "published"
  date that is verified will be retained and the rest discarded.

  2.2. Download and verify the updated packages

  The automatic update client next compares the latest recommended package
  version from the recommended-packages document with the currently installed
  Tor version. If the user currently has installed a Tor version from Tor's
  "development" branch, then the version specified in "tor-dev-*-version" Item
  is used for comparison. Similarly, if the user currently has installed a Tor
  version from Tor's "stable" branch, then the version specified in the
  "tor-stable-*version" Item is used for comparison. Version comparisons are
  done according to Tor's version specification [3].

  If the automatic update client determines an installation package newer than
  the user's currently installed version is available, it will attempt to
  download a package appropriate for the user's platform and Tor branch from a
  URL specified by a "tor-[branch]-[platform]-package" Item. If more than one
  mirror for the selected package is available, a mirror will be chosen at
  random from all those available.

  The automatic update client must also download a ".asc" signature file for
  the retrieved package. The URL for the package signature is the same as that
  for the package itself, except with the extension ".asc" appended to the
  package URL.

  Connections to download the updated package and its signature SHOULD be
  attempted in the same order described in Section 2.1.

  After completing the steps described in Sections 2.1 and 2.2, the automatic
  update client will have downloaded and verified a copy of the latest Tor
  installation package. It can then take whatever subsequent platform-specific
  steps are necessary to install the downloaded software updates.

  2.3. Periodic checking for updates

  The automatic update client SHOULD maintain a local state file in which it
  records (at a minimum) the timestamp at which it last retrieved a
  recommended-packages file and the timestamp at which the client last
  successfully downloaded and installed a software update.

  Automatic update clients SHOULD check for an updated recommended-packages
  document at most once per day but at least once every 30 days.


  3. Future Extensions

  There are several possible areas for future extensions of this framework.
  The extensions below are merely suggestions and should be the subject of
  their own proposal before being implemented.
  
  3.1. Additional Software Updates
  
  There are several software packages often included in Tor bundles besides
  Tor, such as Vidalia, Privoxy or Polipo, and Torbutton. The versions and
  download locations of updated installation packages for these bundle
  components can be easily added to the recommended-packages document
  specification above.

  3.2. Including ChangeLog Information

  It may be useful for automatic update clients to be able to display for
  users a summary of the changes made in the latest Tor or Tor-related
  software release, before the user chooses to install the update. In the
  future, we can add keywords to the specification in Section 1.2 that specify
  the location of a ChangeLog file for the latest recommended package
  versions. It may also be desirable to allow localized ChangeLog information,
  so that the automatic update client can fetch release notes in the
  end-user's preferred language.

  3.3. Weighted Package Mirror Selection

  We defined in Section 1.2 a method by which automatic update clients can
  select from multiple available package mirrors. We may want to add a Weight
  argument to the "*-package" Items that allows the recommended-packages file
  to suggest to clients the probability with which a package mirror should be
  chosen. This will allow clients to more appropriately distribute package
  downloads across available mirrors proportional to their approximate
  bandwidth.


Implementation

  Implementation of this proposal will consist of two separate components.

  The first component is a small "au-publish" tool that takes as input a
  configuration file specifying the information described in Section 1.2 and a
  private key. The tool is run by a "packaging authority" (someone responsible
  for publishing updated installation packages), who will be prompted to enter
  the passphrase for the private key used to sign the recommended-packages
  document. The output of the tool is a document formatted according to
  Section 1.2, with a signature appended at the end. The resulting document
  can then be published to any of the update mirrors.

  The second component is an "au-client" tool that is run on the end-user's
  machine. It periodically checks for updated installation packages according
  to Section 2 and fetches the packages if necessary. The public keys used
  to sign the recommended-packages file and any of the published packages are
  included in the "au-client" tool.


References
  
  [1] Tor directory protocol (version 3),
  https://tor-svn.freehaven.net/svn/tor/trunk/doc/spec/dir-spec.txt
  
  [2] Tor control protocol (version 2),
  https://tor-svn.freehaven.net/svn/tor/trunk/doc/spec/control-spec.txt

  [3] Tor version specification,
  https://tor-svn.freehaven.net/svn/tor/trunk/doc/spec/version-spec.txt

</body></email><email><emailId>20080731123332</emailId><senderName>Carsten_Krüger</senderName><senderEmail>c.krueger@gmx.org</senderEmail><timestampReceived>2008-07-31 12:33:32-0400</timestampReceived><subject>Re: Proposal: Automatic Tor Software Updates</subject><body>

Hi,

&gt;   The initial target platform for the automatic update framework is Windows,

Have you thought about no admin rights problem?
For example because the user is not member of administrators group or the
user runs windows vista with UAC?
What happens if Tor runs as a windows service?

&gt;  An automatic update client process runs on the Tor user's computer and
&gt;  periodically retrieves the recommended-packages file according to the method
&gt;  described in Section 2.0.

Periodically but with random component.
If a large number of tor clients are switched off and than on at the
same time the updateservers would be DDoSed.

greetings
Carsten

</body></email><email><emailId>20080731132310</emailId><senderName>Matt Edman</senderName><senderEmail>edmanm@vidalia-project.net</senderEmail><timestampReceived>2008-07-31 13:23:10-0400</timestampReceived><subject>Re: Proposal: Automatic Tor Software Updates</subject><body>

On Thu, Jul 31, 2008 at 02:33:32PM +0200, Carsten Krüger wrote:
&gt; &gt;   The initial target platform for the automatic update framework is Windows,
&gt; 
&gt; Have you thought about no admin rights problem?
&gt; For example because the user is not member of administrators group or the
&gt; user runs windows vista with UAC?
&gt; What happens if Tor runs as a windows service?

Those are fine questions, but they are also more of an auto-update client
implementation problem. The scope of the proposal, as stated in the third
paragraph of the proposal itself, does not include the actual package
installation procedure.

All we're defining here currently is how a client running on the end-user's
machine can learn in an authenticated manner that there is an updated
installation package available for the user's platform, how and from where to
download that package, and how to verify that the package downloaded is the
one we intended the user to receive.

--Matt

</body></email><email><emailId>20080731164019</emailId><senderName>Carsten_Krüger</senderName><senderEmail>c.krueger@gmx.org</senderEmail><timestampReceived>2008-07-31 16:40:19-0400</timestampReceived><subject>Re: Proposal: Automatic Tor Software Updates</subject><body>

Hello Matt,

&gt; Those are fine questions, but they are also more of an auto-update client
&gt; implementation problem.

Most people think this way and that's the cause
that nearly every autoupdate for windows software is really bad.

For the proposal itself: an ascending number should be included to
avoid replaying old messages. Otherwise uptodate clients could be
forced to downgrade to an older version.

2 Questions:
Why fetching the updates via Tor network?
Why via https?

greetings
Carsten

</body></email><email><emailId>20080724180037</emailId><senderName>coderman</senderName><senderEmail>coderman@gmail.com</senderEmail><timestampReceived>2008-07-24 18:00:37-0400</timestampReceived><subject>Re: Alex Le Heux on IPv6 proposals [alexlh@funk.org: Re: Links about IPv6 in Tor]</subject><body>

&gt; ----- Forwarded message from Alex Le Heux &lt;alexlh@funk.org&gt; -----
&gt; ...
&gt; Final remark
&gt;
&gt; I believe Tor makes sure it picks the nodes from different /16s. In
&gt; IPv6 you could employ a similar strategy...
&gt;
&gt; The disadvantage of picking /32 is that all direct end-user
&gt; assignments will then be lumped together, while all these assignments
&gt; to seperate organistions would come from a handfull of /32s.
&gt; The disadvantage of picking /48 is that nearly all "normal" end-users
&gt; will be in ISP aggregated space, so you might end up with the entire
&gt; path consisting of nodes living in a single ISP.


this is a situation where classification by AS number would make more
sense.  given the widely varying prefixes used, as Alex points out
above, any prefix selection is going to be less effective than
desired, and probably vary significantly as IPv6 deployment increases
(with new players possibly using longer or shorter prefix for customer
assignment, etc).

a rough look here: http://ipv6.nlsde.buaa.edu.cn/ipv6/210.25.133.26/
seems to support an AS level classification as best suited.
</body></email><email><emailId>20080725083803</emailId><senderName>Marcus Wolschon</senderName><senderEmail>marcus@wolschon.biz</senderEmail><timestampReceived>2008-07-25 08:38:03-0400</timestampReceived><subject>Re: Alex Le Heux on IPv6 proposals [alexlh@funk.org: Re: Links about IPv6</subject><body>





&gt;&gt;The current version of the proposal for IPv6 exit support in Tor is
&gt;&gt;here:
&gt;&gt;
&gt;&gt; 
&gt; https://www.torproject.org/svn/trunk/doc/spec/proposals/117-ipv6-exits.txt


Hello,

a few comments:

 * A Tor-Node needs to check if it not only has a global
   unicast ipv6-address but also that it can reach something
   with this adress (broken ipv6-routing is still common and
   may make the tor-network behave undesireable for users.)

 *  "1.4.2. SOCKSv5 IPv6 client behavior"
   SOCKS-binding to ipv6-adresses is already implemented and testet to work fine.

 * the proposal does not contain hidden services on IPv6
   where we have working and tested code for it. Does it
   only specify the changes that still need to be made?


Marcus

</body></email><email><emailId>20080715212945</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-07-15 21:29:45-0400</timestampReceived><subject>Re: proposal 141: download server descriptors on demand</subject><body>

On Fri, Jul 11, 2008 at 08:22:55PM +0200, Peter Palfrader wrote:
&gt; On Mon, 16 Jun 2008, Nick Mathewson wrote:

     [The proposal sayeth:]
&gt; &gt; &gt; 3.1 Load balancing info in consensus documents
&gt; &gt; &gt; 
&gt; &gt; &gt;   One of the reasons why clients download all server descriptors is for
&gt; &gt; &gt;   doing load proper load balancing as described in 2.1.  In order for
&gt; &gt; &gt;   clients to not require all server descriptors this information will
&gt; &gt; &gt;   have to move into the network status document.
&gt; &gt; &gt; 
&gt; &gt; &gt;   [XXX Two open questions here:
&gt; &gt; &gt;    a) how do we arrive at a consensus weight?
&gt; &gt; 
&gt; &gt; Perhaps the vote could contain the node's bandwidth, and this could be
&gt; &gt; used to calculate the weights?  It's necessary that the consensus
&gt; &gt; remain a deterministic function of the votes.
&gt; 
&gt; That's one approach.  It means however that when we want to tweak the
&gt; weighting algorithm we have to introduce new consensus methods.
&gt;
&gt; The other approach is that every voter assigns weights for each of the
&gt; purposes (Exit, Guard, ..) so that their total sum is some constant X.
&gt; When building a consensus we take the median for each purpose for each
&gt; router.

That latter appraoch seems so reasonable that I can't reconstruct why
I suggested anything else.

If there are an even number of votes, we need to specify that we mean
the low median.

&gt; &gt; &gt;    b) how to represent weights in the consensus?
&gt; &gt; &gt;       Maybe "s Guard=0.13 Exit=0.02 Middle=0.00 Stable.."
&gt; &gt; 
&gt; &gt; That would break backward compatibility.  Adding a new per-line
&gt; &gt; instead would probably be better.  We should play with representations
&gt; &gt; here till we wind up with something compressible, and we should figure
&gt; &gt; out the space impact of doing this.
&gt; 
&gt; How about something like "w Exit=41 Guard=94 Middle=543"

Sure.  Let's have any absent weight default to 0.


 [...]
&gt; &gt; My first thought was that I'd prefer to avoid multiplying machinery
&gt; &gt; here.  When we design RELAY_REQUEST_SD, let's try to keep looking to
&gt; &gt; see whether we can add a padding argument to RELAY_BEGIN_DIR rather
&gt; &gt; than forcing a new relay cell type?
&gt; 
&gt; A new cell type safes on round trip times.  Using BEGIN_DIR means we
&gt; send the cell, get a "CONNECTED" back, send the request, get a result.
&gt; 
&gt; Using a dedicated cell type will cut that in half.

Ok, reasonable.  Though perhaps this means that BEGIN_DIR should
optionally take a body containing the start HTTP request.  But that
may be fodder for another proposal.

&gt; &gt; Something else to figure out here is migration.  When the first cut of
&gt; &gt; this system is done, only new servers will support RELAY_REQUEST_SD.
&gt; &gt; This means that clients will still need to pre-download descriptors
&gt; &gt; under some circumstances.
&gt; &gt; 
&gt; &gt; In fact, the rules will be pretty weird here.  If extends are done by
&gt; &gt; first asking B for C's descriptor, then clients need to know whether B
&gt; &gt; supports RELAY_REQUEST_SD.  If it doesn't, they need to have C's
&gt; &gt; descriptor, which means they need to have downloaded it in advance.
&gt; &gt; 
&gt; &gt; In its final version, this proposal needs a migration plan.
&gt; 
&gt; We could fall back to BEGIN_DIR, but that only helps when B is a
&gt; directory cache.
&gt; 
&gt; One approach is to introduce server support first, and wait with client
&gt; use until a significant part of the network is supporting it.  Unless we
&gt; can come up with something smarter.

This seems fine for now, unless (as you say) we come up with something
smarter.


 [...] 
&gt; Theory: Most routers use one of a very small set of different exit policies (if
&gt; we think of a router's own IP address in its exit policy as a single token
&gt; @@IP@@ or whatever).
&gt; 
&gt; Maybe the consensus document should include a hash of the (normalized,
&gt; i.e. the router's IP replaced with a token) exit policy.
&gt; 
&gt; For instance the current consensus has the following exit policies:
&gt;     750 ea118b6480d664e6b65363d6330f62d76312309d  -
&gt;     606 6c327099a4eb1ff45128d36643d7494d706e1736  -
&gt;     200 cc5e5310ca7fc1f22b0ce1d017817934889e424a  -
&gt;      38 d640a0b886b61d20f3390f16e68f94bb67ca3e02  -
&gt;      34 04e917f4dfa4fde648fa2e64ed450cf078bba22d  -
&gt;      22 24317c522385314806403543dbdc8c4d797c412e  -
&gt;      16 c6fca3e85a850ab5ebce7e579739c30077b1e967  -
&gt;      15 c1ca7a48e410911356a8fc585744fb3ffeab99da  -
&gt;      12 cc44ee0df0f2a42868e65150e11d16274f71cd4c  -
&gt;       9 5c74594ad9dd4df0bd40e1e2cd3fe7f2906657cf  -
&gt;       8 daad277346eac48f247411dc60e2020a767861f4  -
&gt;       8 63fa7a8e07fbf314abb52b19c67a6b773052d0d9  -
&gt;       7 b2b8e7d147a05258bf375407dc29abeeeda9e25f  -
&gt;       6 a5ac5094b4a3fb116fe99cebba0787609d7c99b9  -
&gt;       6 a29974dcf97a012726710ced75eab63ff95383dc  -
&gt;       6 3c0d8576d935aae8c6c296216ac559ced03a612f  -
&gt;       6 20c7b1b0914ce4f5817b58912723d5e26974a373  -
&gt; i.e. ea11.. exists 750 times, 6c.. 606 times etc.
&gt; 
&gt; 
&gt; Now when a tor client first start it will pick a route based only on the
&gt; weights it learns from the consensus.  In the course of building that
&gt; circuit it will learn a few exit policies.
&gt; 
&gt; Next time it needs to build a circuit it can again generate it only
&gt; based on weights.  If it is lucky it already will have the exit
&gt; policy (even if not the full SD) of the exit node.  Should that policy
&gt; not allow exits to the target that circuit can be abandoned immediately.
&gt; 
&gt; 
&gt; We will have a hard time exiting when only very few nodes allow
&gt; connections to a specific IP:port.  But maybe that's ok.

Hmmm.  I need to think about this part more.  I'm in particular
curious whether we can do better than hashed policies with a
ports/addresses list, but I think one of us will need to actually
build a prototype to see how well this works or doesn't.
</body></email><email><emailId>20080715232832</emailId><senderName>Peter Palfrader</senderName><senderEmail>peter@palfrader.org</senderEmail><timestampReceived>2008-07-15 23:28:32-0400</timestampReceived><subject>Re: proposal 141: download server descriptors on demand</subject><body>

On Tue, 15 Jul 2008, Nick Mathewson wrote:

&gt; On Fri, Jul 11, 2008 at 08:22:55PM +0200, Peter Palfrader wrote:
&gt; &gt; On Mon, 16 Jun 2008, Nick Mathewson wrote:
&gt; 
&gt;      [The proposal sayeth:]
&gt; &gt; &gt; &gt; 3.1 Load balancing info in consensus documents
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt;   One of the reasons why clients download all server descriptors is for
&gt; &gt; &gt; &gt;   doing load proper load balancing as described in 2.1.  In order for
&gt; &gt; &gt; &gt;   clients to not require all server descriptors this information will
&gt; &gt; &gt; &gt;   have to move into the network status document.
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt;   [XXX Two open questions here:
&gt; &gt; &gt; &gt;    a) how do we arrive at a consensus weight?
&gt; &gt; &gt; 
&gt; &gt; &gt; Perhaps the vote could contain the node's bandwidth, and this could be
&gt; &gt; &gt; used to calculate the weights?  It's necessary that the consensus
&gt; &gt; &gt; remain a deterministic function of the votes.
&gt; &gt; 
&gt; &gt; That's one approach.  It means however that when we want to tweak the
&gt; &gt; weighting algorithm we have to introduce new consensus methods.
&gt; &gt;
&gt; &gt; The other approach is that every voter assigns weights for each of the
&gt; &gt; purposes (Exit, Guard, ..) so that their total sum is some constant X.
&gt; &gt; When building a consensus we take the median for each purpose for each
&gt; &gt; router.
&gt; 
&gt; That latter appraoch seems so reasonable that I can't reconstruct why
&gt; I suggested anything else.
&gt; 
&gt; If there are an even number of votes, we need to specify that we mean
&gt; the low median.

Roger raised a good point on IRC.  Having highly fluctuating numbers in
the consensus will make diffs [proposal 140] less useful.  So maybe
use the bandwidth number(s) after all?

&gt; &gt; We could fall back to BEGIN_DIR, but that only helps when B is a
&gt; &gt; directory cache.
&gt; &gt; 
&gt; &gt; One approach is to introduce server support first, and wait with client
&gt; &gt; use until a significant part of the network is supporting it.  Unless we
&gt; &gt; can come up with something smarter.
&gt; 
&gt; This seems fine for now, unless (as you say) we come up with something
&gt; smarter.

Once the network has a sufficient number of routers supporting even a
few circuits of this new type we can always anonymously go to directory
servers and selectively pull descriptors from it.  We might have to be
careful to not announce to it that "hey, I'm building a circuit from A
to B to C" by fetching those 3 SDs.  Or maybe it doesn't matter much
since at least B already knows that somebody does this.

-- 
                           |  .''`.  ** Debian GNU/Linux **
      Peter Palfrader      | : :' :      The  universal
 http://www.palfrader.org/ | `. `'      Operating System
                           |   `-    http://www.debian.org/
</body></email><email><emailId>20080715233528</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2008-07-15 23:35:28-0400</timestampReceived><subject>Re: proposal 141: download server descriptors on demand</subject><body>

On Fri, Jul 11, 2008 at 08:22:55PM +0200, Peter Palfrader wrote:
&gt; &gt; &gt;    b) how to represent weights in the consensus?
&gt; &gt; &gt;       Maybe "s Guard=0.13 Exit=0.02 Middle=0.00 Stable.."
&gt; &gt; 
&gt; &gt; That would break backward compatibility.  Adding a new per-line
&gt; &gt; instead would probably be better.  We should play with representations
&gt; &gt; here till we wind up with something compressible, and we should figure
&gt; &gt; out the space impact of doing this.
&gt; 
&gt; How about something like "w Exit=41 Guard=94 Middle=543"

If we specify weights in the consensus, then one new or changed relay will
cause us to recompute most of the weights. These constant minor changes
would pretty much kill proposal 140 ("Provide diffs between consensuses").

Whereas writing the bandwidth number (perhaps rounded) in the consensus
would mean that the number only changes when the descriptor changes. (It
also simplifies constructing the consensus, since there should only be
one number associated with a given descriptor.)

Another advantage is that if clients learn about relays through some
other way, and they want to weight those relays into the decision, they
will know how to do it. If the weights are all computed in the consensus,
it will be tough to balance over new relays.

Now, the downside of just putting the naked bandwidth number is that we
can't change how we compute weights on the directory authorities (e.g.
if we want to raise DEFAULT_MAX_BELIEVABLE_BANDWIDTH) and have all the
clients magically move to the new algorithm.

Did I miss any pros / cons?

&gt; Theory: Most routers use one of a very small set of different exit policies (if
&gt; we think of a router's own IP address in its exit policy as a single token
&gt; @@IP@@ or whatever).
&gt; 
&gt; Maybe the consensus document should include a hash of the (normalized,
&gt; i.e. the router's IP replaced with a token) exit policy.

I like this theory. It's already the case that Vidalia gives you a set
of 6 checkboxes for your exit policy, so the set of exit policies that
ordinary users pick is already constrained.

There do seem to be a lot of edge cases that need more analysis though.

--Roger

</body></email><email><emailId>20080715072500</emailId><senderName>Mike Perry</senderName><senderEmail>mikeperry@fscked.org</senderEmail><timestampReceived>2008-07-15 07:25:00-0400</timestampReceived><subject>Re: stream status events</subject><body>


Thus spake Robert Hogan (robert@roberthogan.net):

&gt; Stream status events for reverse resolve requests for which Tor has a cached 
&gt; answer look like this:
&gt; 
&gt; 650 STREAM 6 NEWRESOLVE 0 64.4.33.7:0
&gt; 650 STREAM 6 FAILED 0 REVERSE[64.4.33.7]:0
&gt; 650 STREAM 7 NEWRESOLVE 0 64.4.33.7:0
&gt; 650 STREAM 7 FAILED 0 REVERSE[64.4.33.7]:0
&gt; 
&gt; The stream 'fails' because there is never a need to create it. The spec is a bit 
&gt; unclear on this point but I think all streams deserve a CLOSE event. Or 
&gt; is 'FAILED' considered sufficient?
&gt; 
&gt; I can allow a CLOSE event by doing:
&gt; [snip]
&gt;  
&gt; but maybe it's the spec that needs to be clarified. A short note stating which 
&gt; events should be expected for all streams maybe.

I agree that all streams should get CLOSEs. In fact, I don't think it
makes any sense at all to call a stream FAILED simply because we
handled it locally.. 

My vote is that the FAILED message should be dropped entirely here,
because it will mess with TorFlows ability to gather accurate
statistics on stream reliability.

Do you happen to know if there are other cases where this sort of
thing can occur?


-- 
Mike Perry
Mad Computer Scientist
fscked.org evil labs

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20080702091005</emailId><senderName>Cat Okita</senderName><senderEmail>cat@reptiles.org</senderEmail><timestampReceived>2008-07-02 09:10:05-0400</timestampReceived><subject>Re: Proposal 144: enforce distinct providers</subject><body>


I don't believe that this will have the intended effect.  If anything, I'd 
expect to see this increase latency, and push more traffic towards exchange 
points, where (depending on the structure of the exchange), an attacker could
easily monitor many providers at once, 'cheaply'.

Further, without correlation of leaf nodes that are partially or completely 
subsumbed in a given AS, changing AS numbers isn't really indicative of any
useful characteristic.  For that matter, without correlating all of the AS
numbers owned by a given entity (an interesting challenge, to be polite), 
there's no guarantee at all that a changing AS reflects anything at all.

Beyond that, if you're still talking about classful address space in this day
and age, I'd suggest that some consideration of modern networking might well
be in order...

cheers!

On Tue, 1 Jul 2008, Nick Mathewson wrote:
&gt; Filename: 144-enforce-distinct-providers.txt
&gt; Title: Increase the diversity of circuits by detecting nodes belonging the
&gt; same provider
&gt; Author: Mfr
&gt; Created: 2008-06-15
&gt; Status: Draft
&gt;
&gt; Overview:
&gt;
&gt;  Increase network security by reducing the capacity of the relay or
&gt;  ISPs monitoring personally or requisition, a large part of traffic
&gt;  Tor trying to break circuits privacy.  A way to increase the
&gt;  diversity of circuits without killing the network performance.
&gt;
&gt; Motivation:
&gt;
&gt;  Since 2004, Roger an Nick publication about diversity [1], very fast
&gt;  relays Tor running are focused among an half dozen of providers,
&gt;  controlling traffic of some dozens of routers [2].
&gt;
&gt;  In the same way the generalization of VMs clonables paid by hour,
&gt;  allowing starting in few minutes and for a small cost, a set of very
&gt;  high-speed relay whose in a few hours can attract a big traffic that
&gt;  can be analyzed, increasing the vulnerability of the network.
&gt;
&gt;  Whether ISPs or domU providers, these usually have several groups of
&gt;  IP Class B.  Also the restriction in place EnforceDistinctSubnets
&gt;  automatically excluding IP subnet class B is only partially
&gt;  effective. By contrast a restriction at the class A will be too
&gt;  restrictive.
&gt;
&gt; Therefore it seems necessary to consider another approach.
&gt;
&gt; Proposal:
&gt;
&gt;  Add a provider control based on AS number added by the router on is
&gt;  descriptor, controlled by Directories Authorities, and used like the
&gt;  declarative family field for circuit creating.
&gt;
&gt; Design:
&gt;
&gt; Step 1 :
&gt;
&gt; Add to the router descriptor a provider information get request [4]
&gt;  by the router itself.
&gt;
&gt;         "provider" name NL
&gt;
&gt;            'names' is the AS number of the router formated like this:
&gt;            'ASxxxxxx' where AS is fixed and xxxxxx is the AS number,
&gt;            left aligned ( ex: AS98304 , AS4096,AS1 ) or if AS number
&gt;            is missing the network A class number is used like that:
&gt;            'ANxxx' where AN is fixed and xxx is the first 3 digits of
&gt;            the IP (ex: for the IP 1.1.1.2 AN1) or an 'L' value is set
&gt;            if it's a local network IP.
&gt;
&gt;            If two ORs list one another in their "provider" entries,
&gt;            then OPs should treat them as a single OR for the purpose
&gt;            of path selection.
&gt;
&gt;            For example, if node A's descriptor contains "provider B",
&gt;            and node B's descriptor contains "provider A", then node A
&gt;            and node B should never be used on the same circuit.
&gt;
&gt;    Add the regarding config option in torrc
&gt;
&gt;            EnforceDistinctProviders set to 1 by default.
&gt;            Permit building circuits with relays in the same provider
&gt;            if set to 0.
&gt;            Regarding to proposal 135 if TestingTorNetwork is set
&gt;            need to be EnforceDistinctProviders is unset.
&gt;
&gt;    Control by Authorities Directories of the AS numbers
&gt;
&gt;         The Directories Authority control the AS numbers of the new node
&gt;         descriptor uploaded.
&gt;
&gt;            If an old version is operated by the node this test is
&gt;            bypassed.
&gt;
&gt;            If AS number get by request is different from the
&gt;            description, router is flagged as non-Valid by the testing
&gt;            Authority for the voting process.
&gt;
&gt; Step 2     When a ' significant number of nodes' of valid routers are
&gt; generating descriptor with provider information.
&gt;
&gt;        Add missing provider information get by DNS request
&gt; functionality for the circuit user:
&gt;
&gt;                During circuit building, computing, OP apply first
&gt;                family check and EnforceDistinctSubnets directives for
&gt;                performance, then if provider info is needed and
&gt;                missing in router descriptor try to get AS provider
&gt;                info by DNS request [4].  This information could be
&gt;                DNS cached.  AN ( class A number) is never generated
&gt;                during this process to prevent DNS block problems.  If
&gt;                DNS request fails ignore and continue building
&gt;                circuit.
&gt;
&gt; Step 3 When the 'whole majority' of valid Tor clients are providing
&gt; DNS request.
&gt;
&gt;        Older versions are deprecated and mark as no-Valid.
&gt;
&gt;  EnforceDistinctProviders replace EnforceDistinctSubnets functionnality.
&gt;
&gt;        EnforceDistinctSubnets is removed.
&gt;
&gt;        Functionalities deployed in step 2 are removed.
&gt;
&gt; Security implications:
&gt;
&gt;      This providermeasure will increase the number of providers
&gt;      addresses that an attacker must use in order to carry out
&gt;      traffic analysis.
&gt;
&gt; Compatibility:
&gt;
&gt;        The presented protocol does not raise compatibility issues
&gt;        with current Tor versions. The compatibility is preserved by
&gt;        implementing this functionality in 3 steps, giving time to
&gt;        network users to upgrade clients and routers.
&gt;
&gt; Performance and scalability notes:
&gt;
&gt;        Provider change for all routers could reduce a little
&gt;        performance if the circuit to long.
&gt;
&gt;        During step 2 Get missing provider information could increase
&gt;        building path time and should have a time out.
&gt;
&gt; Possible Attacks/Open Issues/Some thinking required:
&gt;
&gt;        These proposal seems be compatible with proposal 135 Simplify
&gt;        Configuration of Private Tor Networks.
&gt;
&gt;        This proposal does not resolve multiples AS owners and top
&gt;        providers traffic monitoring attacks [5].
&gt;
&gt;        Unresolved AS number are treated as a Class A network. Perhaps
&gt;        should be marked as invalid.  But there's only fives items on
&gt;        last check see [2].
&gt;
&gt;        Need to define what's a 'significant number of nodes' and
&gt;        'whole majority' ;-)
&gt;
&gt; References:
&gt; [1] Location Diversity in Anonymity Networks by Nick Feamster and Roger
&gt; Dingledine.
&gt; In the Proceedings of the Workshop on Privacy in the Electronic Society
&gt; (WPES 2004), Washington, DC, USA, October 2004
&gt; http://freehaven.net/anonbib/#feamster:wpes2004
&gt; [2] http://as4jtw5gc6efb267.onion/IPListbyAS.txt
&gt; [3] see Goodell Tor Exit Page
&gt; http://cassandra.eecs.harvard.edu/cgi-bin/exit.py
&gt; [4] see the great IP to ASN DNS Tool
&gt; http://www.team-cymru.org/Services/ip-to-asn.html
&gt; [5] Sampled Traffic Analysis by Internet-Exchange-Level Adversaries by
&gt; Steven J. Murdoch and Piotr Zielinski.
&gt; In the Proceedings of the Seventh Workshop on Privacy Enhancing Technologies
&gt;
&gt; (PET 2007), Ottawa, Canada, June 2007.
&gt; http://freehaven.net/anonbib/#murdoch-pet2007
&gt; [5] http://bugs.noreply.org/flyspray/index.php?do=details&amp;id=690
&gt;

==========================================================================
"A cat spends her life conflicted between a deep, passionate and profound
desire for fish and an equally deep, passionate and profound desire to
avoid getting wet.  This is the defining metaphor of my life right now."
</body></email><email><emailId>20080703121033</emailId><senderName>"M Fr"</senderName><senderEmail>mfr@misericordia.be</senderEmail><timestampReceived>2008-07-03 12:10:33-0400</timestampReceived><subject>Re: Proposal 144: enforce distinct providers</subject><body>

Hello,

On Wed, Jul 2, 2008 at 11:10 AM, Cat Okita &lt;cat@reptiles.org&gt; wrote:
&gt;
&gt; I don't believe that this will have the intended effect.  If anything, I'd
&gt; expect to see this increase latency,
I don't expect that because there is already the /16 subnet exclusion.
Perhaps we can go faster in some cases.
&gt; and push more traffic towards exchange
&gt; points, where (depending on the structure of the exchange), an attacker
&gt; could
&gt; easily monitor many providers at once, 'cheaply'.
The main objective of the proposal is not to prevent exchange point monitoring.
First, because this excellent paper
http://freehaven.net/anonbib/#feamster:wpes2004 as already
demonstrated that it's not necessary because of the BGP logic of
traffic repartition between peering and providers.
The objective is to prevent people observing a circuit with all
routers in the same provider area.

&gt;
&gt; Further, without correlation of leaf nodes that are partially or completely
&gt; subsumbed in a given AS, changing AS numbers isn't really indicative of any
&gt; useful characteristic.  For that matter, without correlating all of the AS
&gt; numbers owned by a given entity (an interesting challenge, to be polite),
&gt; there's no guarantee at all that a changing AS reflects anything at all.
&gt;
Please check the list referenced
http://as4jtw5gc6efb267.onion/IPListbyAS.txt if you find many
redundant providers. I've not found many cases in fact two (Road
Runner and one chinese operator)
For more than 90% of nodes it's efficient.
Perhaps as i've said the proposal could be improved making AS family
but cos i've no ideas on circuit build in china, i've not added any
restrictive proposal.
And also I don't  want to increase network latency.
This proposal is supposed to be iso-latency.

&gt; Beyond that, if you're still talking about classful address space in this
&gt; day
&gt; and age, I'd suggest that some consideration of modern networking might well
&gt; be in order...
&gt;
Sorry English is not my mother langage, sometimes i use the more
simple language for me.

How can you improve this proposal ?

&gt; cheers!
&gt;
Regards

&gt; On Tue, 1 Jul 2008, Nick Mathewson wrote:
&gt;&gt;
&gt;&gt; Filename: 144-enforce-distinct-providers.txt
&gt;&gt; Title: Increase the diversity of circuits by detecting nodes belonging the
&gt;&gt; same provider
&gt;&gt; Author: Mfr
&gt;&gt; Created: 2008-06-15
&gt;&gt; Status: Draft
</body></email><email><emailId>20080713194413</emailId><senderName>Cat Okita</senderName><senderEmail>cat@reptiles.org</senderEmail><timestampReceived>2008-07-13 19:44:13-0400</timestampReceived><subject>Re: Proposal 144: enforce distinct providers</subject><body>

On Thu, 3 Jul 2008, M Fr wrote:
&gt; First, because this excellent paper
&gt; http://freehaven.net/anonbib/#feamster:wpes2004 as already
&gt; demonstrated that it's not necessary because of the BGP logic of
&gt; traffic repartition between peering and providers.

That paper doesn't address the question of how exchanges fit into the global
routing structure, and also makes naive assumptions about how traffic is
repartitioned.

&gt; The objective is to prevent people observing a circuit with all
&gt; routers in the same provider area.

&gt;&gt; Further, without correlation of leaf nodes that are partially or completely
&gt;&gt; subsumbed in a given AS, changing AS numbers isn't really indicative of any
&gt;&gt; useful characteristic.  For that matter, without correlating all of the AS
&gt;&gt; numbers owned by a given entity (an interesting challenge, to be polite),
&gt;&gt; there's no guarantee at all that a changing AS reflects anything at all.
&gt;&gt;
&gt; Please check the list referenced
&gt; http://as4jtw5gc6efb267.onion/IPListbyAS.txt if you find many
&gt; redundant providers. I've not found many cases in fact two (Road
&gt; Runner and one chinese operator)
&gt; For more than 90% of nodes it's efficient.

I'm looking at that file, and need some clarification.  It looks like the
file consists of a list of tor nodes and their associated AS -- is that 
correct?  Also - over what time period was this information collected?

&gt; Perhaps as i've said the proposal could be improved making AS family
&gt; but cos i've no ideas on circuit build in china, i've not added any
&gt; restrictive proposal.
&gt; And also I don't  want to increase network latency.
&gt; This proposal is supposed to be iso-latency.

To spell it out - even looking at the list that you've provided, I can
see multiple cases where you have a node that's on an AS which hangs off
of one or two entities already listed, so you've immediately got an overlap.

There's also a notable lack of some of the tier-1 ISPs -- and that's before
even considering the question of physical vs virtual circuits.

&gt;&gt; Beyond that, if you're still talking about classful address space in this
&gt;&gt; day
&gt;&gt; and age, I'd suggest that some consideration of modern networking might well
&gt;&gt; be in order...
&gt; Sorry English is not my mother langage, sometimes i use the more
&gt; simple language for me.

FYI:  http://en.wikipedia.org/wiki/CIDR

&gt; How can you improve this proposal ?

I'm honestly not certain that I can think of a way that this proposal can be
improved enough to be a help, rather than a hinderance.

cheers!

&gt;&gt; On Tue, 1 Jul 2008, Nick Mathewson wrote:
&gt;&gt;&gt;
&gt;&gt;&gt; Filename: 144-enforce-distinct-providers.txt
&gt;&gt;&gt; Title: Increase the diversity of circuits by detecting nodes belonging the
&gt;&gt;&gt; same provider
&gt;&gt;&gt; Author: Mfr
&gt;&gt;&gt; Created: 2008-06-15
&gt;&gt;&gt; Status: Draft
&gt;

==========================================================================
"A cat spends her life conflicted between a deep, passionate and profound
desire for fish and an equally deep, passionate and profound desire to
avoid getting wet.  This is the defining metaphor of my life right now."
</body></email><email><emailId>20080713164730</emailId><senderName>Geoffrey Goodell</senderName><senderEmail>goodell@eecs.harvard.edu</senderEmail><timestampReceived>2008-07-13 16:47:30-0400</timestampReceived><subject>Re: Proposal: Optionally allow exit from single-hop circuits</subject><body>

[Attachment #2 (multipart/mixed)]


Resending, since the lines seemed to be wrapped poorly.

On Sun, Jul 13, 2008 at 12:39:04PM -0400, Geoffrey Goodell wrote:
&gt; Please see attached my proposed solution to address Bug 768.
&gt; 
&gt; Thanks!
&gt; 
&gt; Geoff
&gt; 

&gt; Filename: single-hop-circuits.txt
&gt; Title: Optionally allow exit from single-hop circuits
&gt; Version:
&gt; Last-Modified:
&gt; Author: Geoff Goodell
&gt; Created: 13-Jul-2008
&gt; Status: Draft
&gt; 
&gt; Overview
&gt; 
&gt;     Provide a special configuration option that adds a line to descriptors
&gt;     indicating that a router can be used as an exit for one-hop circuits, and allow
&gt;     clients to attach streams to one-hop circuits provided that the descriptor for
&gt;     the router in the circuit includes this configuration option.
&gt; 
&gt; Motivation
&gt; 
&gt;     At some point (r9735?), code was added to src/or/control.c that prevents
&gt;     controllers from attaching streams to one-hop circuits.  The idea seems to be
&gt;     that we can use the cost of forking and maintaining a patch as a lever to
&gt;     prevent people from writing controllers that jeopardize the operational
&gt;     security of routers and the anonymity properties of the Tor network by creating
&gt;     and using one-hop circuits rather than the standard three-hop circuits.  It may
&gt;     be, for example, that some users do not actually seek true anonymity but simply
&gt;     reachability through network perspectives afforded by the Tor network, and
&gt;     since anonymity is stronger in numbers, forcing users to contribute to
&gt;     anonymity and decrease the risk to server operators by using full-length paths
&gt;     may be reasonable.
&gt; 
&gt;     Whether or not we agree that the particular approach of using hardcoded,
&gt;     immutable policy in the Tor client to limit self-determinism on the part of
&gt;     clients is the right way to address the risks posed by one-hop circuit
&gt;     utilization (for example, I think that routers ought to take responsibility for
&gt;     ensuring that they are not allowing exit from one-hop circuits), it remains
&gt;     true that as presently implemented, the sweeping restriction of one-hop
&gt;     circuits for all routers limits the usefulness of Tor as a general-purpose
&gt;     technology for building circuits.  In particular, we should allow for
&gt;     controllers, such as Blossom, that create and use single-hop circuits involving
&gt;     routers that are not part of the Tor network.
&gt; 
&gt; Design
&gt; 
&gt;     Introduce a configuration option for Tor servers that, when set, indicates that
&gt;     a router is willing to provide exit from one-hop circuits.  Routers with this
&gt;     policy will not require that a circuit has at least two hops when it is used as
&gt;     an exit.
&gt; 
&gt;     In addition, routers for which this configuration option has been set will have
&gt;     a line in their descriptors, "opt exit-from-single-hop-circuits".  Clients will
&gt;     keep track of which routers have this option and allow streams to be attached
&gt;     to single-hop circuits including such routers.
&gt; 
&gt; Security Considerations
&gt; 
&gt;     This approach seems to eliminate the worry about operational router security,
&gt;     since server operators will not set the configuraiton option unless they are
&gt;     willing to take on such risk.  
&gt; 
&gt;     To reduce the impact on anonymity of the network resulting from including such
&gt;     "risky" routers in regular Tor path selection, clients may systematically
&gt;     exclude routers with "opt exit-from-single-hop-circuits" when choosing random
&gt;     paths through the Tor network.
&gt; 




["single-hop-circuits.txt" (text/plain)]

Filename: single-hop-circuits.txt
Title: Optionally allow exit from single-hop circuits=20
Version:
Last-Modified:
Author: Geoff Goodell
Created: 13-Jul-2008
Status: Draft

Overview

    Provide a special configuration option that adds a line to descriptors
    indicating that a router can be used as an exit for one-hop circuits,
    and allow clients to attach streams to one-hop circuits provided
    that the descriptor for the router in the circuit includes this
    configuration option.

Motivation

    At some point (r9735?), code was added to src/or/control.c that
    prevents controllers from attaching streams to one-hop circuits.
    The idea seems to be that we can use the cost of forking and
    maintaining a patch as a lever to prevent people from writing
    controllers that jeopardize the operational security of routers
    and the anonymity properties of the Tor network by creating and
    using one-hop circuits rather than the standard three-hop circuits.
    It may be, for example, that some users do not actually seek true
    anonymity but simply reachability through network perspectives
    afforded by the Tor network, and since anonymity is stronger in
    numbers, forcing users to contribute to anonymity and decrease the
    risk to server operators by using full-length paths may be reasonable.

    Whether or not we agree that the particular approach of
    using hardcoded, immutable policy in the Tor client to limit
    self-determinism on the part of clients is the right way to address
    the risks posed by one-hop circuit utilization (for example, I think
    that routers ought to take responsibility for ensuring that they are
    not allowing exit from one-hop circuits), it remains true that as
    presently implemented, the sweeping restriction of one-hop circuits
    for all routers limits the usefulness of Tor as a general-purpose
    technology for building circuits.  In particular, we should allow
    for controllers, such as Blossom, that create and use single-hop
    circuits involving routers that are not part of the Tor network.

Design

    Introduce a configuration option for Tor servers that, when set,
    indicates that a router is willing to provide exit from one-hop
    circuits.  Routers with this policy will not require that a circuit
    has at least two hops when it is used as an exit.

    In addition, routers for which this configuration option
    has been set will have a line in their descriptors, "opt
    exit-from-single-hop-circuits".  Clients will keep track of which
    routers have this option and allow streams to be attached to
    single-hop circuits that include such routers.

Security Considerations

    This approach seems to eliminate the worry about operational router
    security, since server operators will not set the configuraiton
    option unless they are willing to take on such risk.

    To reduce the impact on anonymity of the network resulting
    from including such "risky" routers in regular Tor path
    selection, clients may systematically exclude routers with "opt
    exit-from-single-hop-circuits" when choosing random paths through
    the Tor network.


["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20080713172455</emailId><senderName>Geoffrey Goodell</senderName><senderEmail>goodell@eecs.harvard.edu</senderEmail><timestampReceived>2008-07-13 17:24:55-0400</timestampReceived><subject>Re: Proposal: Optionally allow exit from single-hop circuits</subject><body>

[Attachment #2 (multipart/mixed)]


Correcting some factual errors in the motivation.



["single-hop-circuits.txt" (text/plain)]

Filename: single-hop-circuits.txt
Title: Optionally allow exit from single-hop circuits=20
Version:
Last-Modified:
Author: Geoff Goodell
Created: 13-Jul-2008
Status: Draft

Overview

    Provide a special configuration option that adds a line to descriptors
    indicating that a router can be used as an exit for one-hop circuits,
    and allow clients to attach streams to one-hop circuits provided
    that the descriptor for the router in the circuit includes this
    configuration option.

Motivation

    At some point, code was added to restrict the attachment of streams
    to one-hop circuits.

    The idea seems to be that we can use the cost of forking and
    maintaining a patch as a lever to prevent people from writing
    controllers that jeopardize the operational security of routers
    and the anonymity properties of the Tor network by creating and
    using one-hop circuits rather than the standard three-hop circuits.
    It may be, for example, that some users do not actually seek true
    anonymity but simply reachability through network perspectives
    afforded by the Tor network, and since anonymity is stronger in
    numbers, forcing users to contribute to anonymity and decrease the
    risk to server operators by using full-length paths may be reasonable.

    As presently implemented, the sweeping restriction of one-hop circuits
    for all routers limits the usefulness of Tor as a general-purpose
    technology for building circuits.  In particular, we should allow
    for controllers, such as Blossom, that create and use single-hop
    circuits involving routers that are not part of the Tor network.

Design

    Introduce a configuration option for Tor servers that, when set,
    indicates that a router is willing to provide exit from one-hop
    circuits.  Routers with this policy will not require that a circuit
    has at least two hops when it is used as an exit.

    In addition, routers for which this configuration option
    has been set will have a line in their descriptors, "opt
    exit-from-single-hop-circuits".  Clients will keep track of which
    routers have this option and allow streams to be attached to
    single-hop circuits that include such routers.

Security Considerations

    This approach seems to eliminate the worry about operational router
    security, since server operators will not set the configuraiton
    option unless they are willing to take on such risk.

    To reduce the impact on anonymity of the network resulting
    from including such "risky" routers in regular Tor path
    selection, clients may systematically exclude routers with "opt
    exit-from-single-hop-circuits" when choosing random paths through
    the Tor network.


["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20080706173745</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-07-06 17:37:45-0400</timestampReceived><subject>Proposal 150 Re: Exclude Exit Nodes from a circuit</subject><body>

On Sat, Jul 05, 2008 at 11:47:32AM +0200, M Fr wrote:
&gt; Another small proposal.

Added as Proposal 150.

yrs,
-- 
Nick
</body></email><email><emailId>20080707154742</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-07-07 15:47:42-0400</timestampReceived><subject>Re: Patch: correct configure check for netfilter_ipv4 support on some platforms.</subject><body>

On Sun, Jul 06, 2008 at 10:08:07PM -0700, coderman wrote:
&gt; on some systems the transparent proxy support is not enabled because
&gt; of a failed check for netfilter_ipv4.h.  this check fails because the
&gt; ipv4 include expects some of the structure definitions in
&gt; netfilter/in.h which is not included in the check.
&gt; 
&gt; this patch includes in.h if present to fix the configure check.
&gt; 
&gt; best regards,

&gt; diff -Naur tor-svn-current/configure.in tor-patched/configure.in
&gt; --- tor-svn-current/configure.in	2008-07-05 21:17:04.584497000 +0000
&gt; +++ tor-patched/configure.in	2008-07-07 05:02:52.832713872 +0000
&gt; @@ -349,6 +349,9 @@
&gt;  #endif
&gt;  #ifdef HAVE_SYS_SOCKET_H
&gt;  #include &lt;sys/socket.h&gt;
&gt; +#endif
&gt; +#ifdef HAVE_NETINET_IN_H
&gt; +#include &lt;netinet/in.h&gt;
&gt;  #endif])
&gt;  
&gt;  if test x$transparent = xtrue ; then

Thanks; I've applied this in trunk and in the 0.2.0.x branch.
</body></email><email><emailId>20080711170149</emailId><senderName>Peter Palfrader</senderName><senderEmail>peter@palfrader.org</senderEmail><timestampReceived>2008-07-11 17:01:49-0400</timestampReceived><subject>Re: Proposal 145: Separate "suitable as a guard" from "suitable as a new guard"</subject><body>

On Fri, 11 Jul 2008, Peter Palfrader wrote:

&gt; On Wed, 02 Jul 2008, Nick Mathewson wrote:
&gt; 
&gt; &gt;    We might instead have authorities list weights with which nodes
&gt; &gt;    should be picked as guards.
&gt; 
&gt; That is something I will need to do anyway, I think.  In that case the
&gt; guard _flag_ would mean "keep as your guard", and the guard _weight_
&gt; would mean "pick with propability $p"?

The weight probably also should be used for "among the guards you have,
use them by this weight".

-- 
                           |  .''`.  ** Debian GNU/Linux **
      Peter Palfrader      | : :' :      The  universal
 http://www.palfrader.org/ | `. `'      Operating System
                           |   `-    http://www.debian.org/
</body></email><email><emailId>20080711191230</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-07-11 19:12:30-0400</timestampReceived><subject>Re: Proposal 150: Exclude Exit Nodes from a circuit</subject><body>

On Sat, Jul 05, 2008 at 11:47:32AM +0200, M Fr wrote:
 [as reformatted in svn.]
&gt; 
&gt; Filename: 150-exclude-exit-nodes.txt
&gt; Title: Exclude Exit Nodes from a circuit
&gt; Version: $Revision: 15695 $
&gt; Author: Mfr
&gt; Created: 2008-06-15
&gt; Status: Draft
&gt; 
&gt; Overview
&gt; 
&gt;    Right now, Tor user can manually exclude a node of all the part of
&gt;    circuits created using the directive ExcludeNodes.  
&gt;    This proposal makes this exclusion, less restrictive, allowing to 
&gt;    exclude a node only on the exit part of a circuit.

This has decent applications, and a number of people seem to want it.
There are some risks to using the feature badly, but they don't seem
overwhelming.

I'm going to mark this proposal accepted, clean up the english a
little, and add a new Risks section at the bottom, as follows:

Risks:

   Use of this option can make users partitionable under certain attak
   assumptions.  However, ExitNodes already creates this possibility,
   so there isn't much increased risk in ExcludeExitNods.

   We should still encourage people who exclude an exit node because
   of bad behavior to report it instead of just adding it to their
   ExcludeExit list.  It would be unfortunate if we didn't find out
   about broken exits because of this option.  This issue can probably
   be addressed sufficiently with documentation.


yrs,
-- 
Nick
</body></email><email><emailId>20080711231947</emailId><senderName>Mike Perry</senderName><senderEmail>mikeperry@fscked.org</senderEmail><timestampReceived>2008-07-11 23:19:47-0400</timestampReceived><subject>Re: Proposal 151: Path Selection Improvements</subject><body>


Thus spake Nick Mathewson (nickm@freehaven.net):

&gt; On Sun, Jul 06, 2008 at 04:38:56PM -0700, Mike Perry wrote:
&gt;  [...]
&gt; &gt; I've updated this proposal in svn to include plans for migrating away
&gt; &gt; from guards with high failure rates that Fallon and I discussed last
&gt; &gt; night.
&gt; &gt; 
&gt; &gt; For convenience:
&gt; &gt; https://tor-svn.freehaven.net/svn/tor/trunk/doc/spec/proposals/151-path-selection-improvements.txt
&gt; &gt; 
&gt; 
&gt; If we're taking a dynamic approach... who is to do the measurements?
&gt; Clients, or authorities?  Having authorities do measurements seems
&gt; more efficient, and more resiliant to attack where the adversary acts
&gt; differently towards different clients in order to change their view of
&gt; the network parameters, or make them use different guards, or such.

The variables in the proposal refer to client parameters and client
storage.  We chose dynamic approach by the clients, because the
timeout will vary depending upon the types connections of the clients.
If we set the timeout high enough for really fast authorities (for
example, my node has ping times under 10ms to most places in the US),
it may get set too low for modem users in iran, and they will churn
creating tons more circuits than they should. If we have the clients
set it, we can be sure that we are excluding exactly n% of the paths
of the network for that particular client.

&gt; On CircuitBuildTimeout, a question: for general-purpose circuits,
&gt; perhaps the behavior of CircuitBuildTimeout is just plain wrong.
&gt; Perhaps the sensible behavior is, instead of discarding the circuit,
&gt; launching a new circuit.  This way, if the circuit is just being slow,
&gt; it can still get used instead of discarded.

Get used when though? Once it is built, it will still likely be
unbearably slow for normal client traffic.

&gt; WRT this paragraph:
&gt; &gt; In addition, we have noticed that some entry guards are much more
&gt; &gt; failure prone than others. In particular, the circuit failure rates for
&gt; &gt; the fastest entry guards was approximately 20-25%, where as slower
&gt; &gt; guards exhibit failure rates as high as 45-50%.
&gt; 
&gt; I'm very curious about the causes and symptoms of these failures.
&gt; What makes them happen?  How do they look to the client?  This seems
&gt; excessively high, and in addition to responding to these rates (as 151
&gt; proposes) we might also do well to look into reducing them.

By far the most common failure is unspecified timeout, especially for
the slower guards. I suspect this is due to stream balancing issues
with people abusing the Tor network for connection heavy protocols
such as bittorrent, which saturate their guards when they happen to
pick a slow one. The next common failure is DESTROYED with reason
OR_CONN_CLOSED. This also seems correlated to load.

We can produce more detailed results as soon as we work out a couple
bugs with the graphing script.

&gt; &gt; In [1], it was
&gt; &gt; demonstrated that failing guard nodes can deliberately bias path
&gt; &gt; selection to improve their success at capturing traffic. For both these
&gt; &gt; reasons, failing guards should be avoided. 
&gt; &gt;
&gt; &gt; We propose increasing the number of entry guards to five, and gathering
&gt; &gt; circuit failure statistics on each entry guard. Any guards that exceed
&gt; &gt; the average failure rate of all guards by 10% after we have
&gt; &gt; gathered ncircuits_to_observe circuits will be replaced.
&gt; 
&gt; If clients make their own measurements on this, there's actually a
&gt; neat class of attack that we'd be enabling.  Instead of a malicious
&gt; guard failing in response to the client building a circuit through a
&gt; non-compromised path, malicious second hops can fail in response to
&gt; circuits built through targetted non-compromised guards.  If they
&gt; manage to raise failure rates for non-malicious guards high enough,
&gt; those guards will stop getting used.

Hrmm. That's true. As soon as the adversary obtains 10% +
.10*natural_failure_rate% of the middle-node network bandwidth, they
would be able to do this. 

The problem is that malicious guard nodes can provide good service to
centralized scanners, so as far as trying to prevent any sort of
failure-based circuit biasing, centralized scanning won't work either.
With a side channel to detect a colluding adversary at the exit node,
failure attacks can get quite damaging, esp in combination with lying
about bandwidth in combination with failing circuits for which they
don't detect their peer on the other end.

Centralized measurement of failures would detect the overloaded
condition though, but it would also not give us the finer-grained
balancing control that would still allow us to use those guards as
guards.

Do you think there might be any way to salvage this part of the
proposal, or should it just be cut out?

I do think in general we should increase the number of guards, so that
the user has a better chance of selecting some non-overloaded guard
nodes as their guards...

&gt; Here's a more interesting attack: Suppose that we have a couple of bad
&gt; guards and they're targetting us in particular.  Let's say that they
&gt; have the same failure rate as average (based on CPU limits or
&gt; connectivity or limited bandwidth or whatever), but that they can
&gt; divert their resources towards particular circuits.  These malicious
&gt; guards should devote extra resources towards some users, and fail all
&gt; the time for the users they aren't targetting.  If they do this, they
&gt; may be able to get the target users to abandon other guards in favor
&gt; of them.

Why does this proposal enable this attack? I was under the impression
this was always possible.

&gt; [As an aside: reputation-like systems on anonymity networks are the
&gt; best example I know of the principle in security that when you amend a
&gt; design, the attacker gets to make up attacks based on _your_ design,
&gt; and isn't restricted to the attacks that worked on the last one.]
&gt; 
&gt; yrs,
&gt; -- 
&gt; Nick

-- 
Mike Perry
Mad Computer Scientist
fscked.org evil labs

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20080714195342</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-07-14 19:53:42-0400</timestampReceived><subject>Re: Proposal: Optionally allow exit from single-hop circuits</subject><body>

On Sun, Jul 13, 2008 at 01:24:55PM -0400, Geoffrey Lewis Goodell wrote:
&gt; Correcting some factual errors in the motivation.

Added as proposal 152.
</body></email><email><emailId>20080715052942</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-07-15 05:29:42-0400</timestampReceived><subject>Re: Proposal 144: enforce distinct providers</subject><body>

On Tue, Jul 01, 2008 at 07:12:58PM -0400, Nick Mathewson wrote:
 [...]
&gt; Hi!  By request, I'm forwarding this to or-dev and adding it as proposal 144.
&gt; 
&gt; I've reformatted it, and included the reformatted version below.
&gt; 
&gt; Filename: 144-enforce-distinct-providers.txt
&gt; Title: Increase the diversity of circuits by detecting nodes belonging the
&gt; same provider
&gt; Author: Mfr
&gt; Created: 2008-06-15
&gt; Status: Draft
&gt; 
&gt; Overview:
&gt; 
&gt;   Increase network security by reducing the capacity of the relay or
&gt;   ISPs monitoring personally or requisition, a large part of traffic
&gt;   Tor trying to break circuits privacy.  A way to increase the
&gt;   diversity of circuits without killing the network performance.
&gt; 
&gt; Motivation:
&gt; 
&gt;   Since 2004, Roger an Nick publication about diversity [1], very fast

To be clear, the Nick on this paper is Nick Feamster, not me.

I generally agree with Cat's concerns on this one. It's good that we
have this proposal, since this is probably the simplest design
response to the Dingledine &amp; Feamster paper that one could make, and
so analyzing how well it would or would not work is likely to be of
benefit.

Unfortunately, it is not at all clear that this proposal would make
the network more secure.  In summary, it would change the rules such
that the nodes in a circuit must occupy distinct ASs.  But making
circuits cross multiple ASs will not necessarily improve their
resistance to the IX-monitoring attacks of [5], and may even make such
attacks stronger by spreading the traffic against a larger subset of
the internet at large.  Without analysis, we can't be sure that this
routing algorithm would actually help.

Also, the client-&gt;Tor and Tor-&gt;destination links aren't considered
here, but they're just about the two most important links for a
traffic analysis discussion.

So for at least a 0.2.1.x timeframe, I'm inclined to leave this
proposal as a Draft.  It is conceivable that AS-based routing might
turn out to be a reasonable and tractable proxy for IX-aware routing
(or something even better), but it's not reasonable to assume that it
will be a win without more thorough analysis.

yrs,
-- 
Nick


</body></email><email><emailId>20080715121829</emailId><senderName>Karsten Loesing</senderName><senderEmail>karsten.loesing@gmx.net</senderEmail><timestampReceived>2008-07-15 12:18:29-0400</timestampReceived><subject>Possible design changes to improve hidden service performance</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Hi list,

Christian Wilms and I have finished a document describing 7 possible
design changes to make the hidden service protocol faster. Some of those
ideas have implications on network load or anonymity which are mentioned
in that document, too. Our intention is to discuss these ideas here
until, say, beginning of August and write a proposal including the ideas
that have survived the discussion process until mid of August.

http://freehaven.net/~karsten/hidserv/discussion-2008-07-15.pdf

This report is part of the NLnet Project: Speed Up Tor Hidden Services
(https://www.torproject.org/projects/hidserv)

As always, comments are most welcome!

- --Karsten
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFIfJWV0M+WPffBEmURAvxwAKDU/BXd0yaDZDi3n9Yq0h1voFZFIgCfQnLs
2A8Yl+2zP/NF7FrRKWa/hq0=
=BAfn
-----END PGP SIGNATURE-----
</body></email><email><emailId>20080715225323</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2008-07-15 22:53:23-0400</timestampReceived><subject>Re: draft proposal: download server descriptors on demand [141]</subject><body>

On Mon, Jun 16, 2008 at 12:06:44AM +0200, Peter Palfrader wrote:
&gt; 3.3 Protocol versions
&gt; 
&gt;   [XXX: find out where we need "opt protocols Link 1 2 Circuit 1"
&gt;   information described in 2.3 above.  If we need it, it might have
&gt;   to go into the consensus document.]

Currently, we don't even parse the "opt protocols" line out of the
descriptor, nor do we put it in the consensus. But the plan eventually
is to put it in the consensus, appended to the "v Tor 0.2.0.30" line.
Once we bump the Circuit protocol number, clients will need to be able
to predict what circuit protocol the relays in their path can handle,
and they'll use the consensus to learn that.

Check out e.g. http://archives.seul.org/or/dev/Mar-2007/msg00041.html
for all the gory details.

&gt;   In order to answer that request B obviously needs a copy of C's server
&gt;   descriptor.  In the future we might amend RELAY_REQUEST_SD cells to
&gt;   contain also the expected IP address and OR-port of the server C (the
&gt;   client learns them from the network status document), so that B no
&gt;   longer needs to know all the descriptors of the entire network but
&gt;   instead can simply go and ask C for its descriptor before passing it
&gt;   back to the client.

This seems like a great move -- it means that we can still be compatible
with having a larger network, though if we don't have the descriptor
cached yet it'll slow down those connections.

--Roger

</body></email><email><emailId>20080716190411</emailId><senderName>Robert Hogan</senderName><senderEmail>robert@roberthogan.net</senderEmail><timestampReceived>2008-07-16 19:04:11-0400</timestampReceived><subject>Re: stream status events</subject><body>


On Tuesday 15 July 2008 08:25:00 Mike Perry wrote:
..
&gt;
&gt; My vote is that the FAILED message should be dropped entirely here,
&gt; because it will mess with TorFlows ability to gather accurate
&gt; statistics on stream reliability.
&gt;
&gt; Do you happen to know if there are other cases where this sort of
&gt; thing can occur?

I'm pretty sure this is the only one. TorK removes a given stream from its 
interface when it sees a CLOSE event and this stream is the only type that 
sticks around after expiry.

["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20080717063856</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-07-17 06:38:56-0400</timestampReceived><subject>Re: proposal 141: download server descriptors on demand</subject><body>

On Tue, Jul 15, 2008 at 05:29:45PM -0400, Nick Mathewson wrote:
&gt; On Fri, Jul 11, 2008 at 08:22:55PM +0200, Peter Palfrader wrote:
&gt;  [...] 
&gt; &gt; Theory: Most routers use one of a very small set of different exit policies (if
&gt; &gt; we think of a router's own IP address in its exit policy as a single token
&gt; &gt; @@IP@@ or whatever).
&gt; &gt; 
&gt; &gt; Maybe the consensus document should include a hash of the (normalized,
&gt; &gt; i.e. the router's IP replaced with a token) exit policy.
 [...]
&gt; Hmmm.  I need to think about this part more.  I'm in particular
&gt; curious whether we can do better than hashed policies with a
&gt; ports/addresses list, but I think one of us will need to actually
&gt; build a prototype to see how well this works or doesn't.


I tried to dig deeper to evaluate this, based on post-processing the
contents of my client's cached-consensus file.  Here's what I got:

Our of 1057 servers, there were only 564 distinct policies.  If I
ignored policy lines that referred only to a single IP (these were
mostly "reject myip:*", then I got only 174 distinct policies.

The good news is that the top 10 policies (taken ignoring single-IP
exceptions) cover most of the descriptors (about 82%).  The bad news
is that the long tail is pretty long: of the 213 descriptors whose
exit policies aren't in the top 10, nearly all of them have a policy
unique to themselves.

Another good thing: The overwhelming majority of descriptors (96%)
have exit policies that of the form

    maybe accept some port ranges and reject others.
    maybe reject private:*
    accept some port ranges, reject others.
    accept *:* or reject *:*

So these exit policies could be compressed to a list of port ranges that
the server accepts or denies.

Of the servers have exit policies more complex than this, I'm looking
into the distribution of policy lines that don't fall under this
format.  Such lines (which I'll call 'bogons' since that's what my
analysis code calls them) seem mostly to be network or IP-specific
exceptions to broader rules.  Broadly, these bogons fall into two categories:
single-ip exceptions and subnet exceptions.  To a first approximation,
they can be ignored when you're trying to figure out what a router
supports.

(There are a few exceptions: there are exactly 7 routers that have
more than 9 bogons, including the winner, che, which also wins the
"most complex exit policy" award.)

What this implies for proposal 141, I'm afraid I've forgotten.
Perhaps, "Maybe most our exit policies can be summarized as a list of
port-ranges for which connections to most non-private IPs are
allowed."

yrs,
-- 
Nick
</body></email><email><emailId>20080719135424</emailId><senderName>Karsten Loesing</senderName><senderEmail>karsten.loesing@gmx.net</senderEmail><timestampReceived>2008-07-19 13:54:24-0400</timestampReceived><subject>Re: Comments on proposals 121, 142, and 143.</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Hi Nick,

thank you very much for your detailed comments!

Let's see if I can answer at least some of them.

| PROPOSAL 121: Hidden Service Authentication
|
| [...]
|
|  - In 1.2, rather than making two kinds of INTRODUCE1 cells and using
|    voodoo and duct tape to tell them apart, introduce a INTRODUCE1V
|    relay cell type [...]

Added in the last revision of proposal 121 (together with the other
changes described here). See changes in Section 1.2.

|  - The replay avoidance approach can be far better.  Instead of the
|    approach in the proposal, which still allows a number of replays,
|    try including a timestamp and a nonce in the authenticated portion
|    of the INTRODUCE2 cell.  Require the timestamp to be no more than T
|    seconds in the past or future, and require that the nonce has not
|    been used for the last 2*T seconds.  This requires less storage,
|    and prevents all replays.  [Instead of a nonce, we can and should
|    use a cryptographic hash of the rendezvous cookie, or the g^x data
|    from the INTRODUCE2 cell, or the entire introduce2 cell contents.]

The rendezvous cookie itself seems to make most sense here. It's already
20 octets long, so that there is no reason to apply a hash function on
it. See section 1.3 for the improved replay prevention that is now based
on your suggestion.

(On a second thought I'm not 100% sure that there are no situations in
which the same rendezvous cookie can be re-sent in a correct protocol
run. So, there is a slight chance that the above changes to H(g^x)
instead of RC.)

| Karsten is revising section 2 a bit as well to discuss some motivation
| issues, and we're going to figure out (but not necessarily build for
| 0.2.1.x) an authorization system that scales to more users better than
| that of proposal 121's section 2.  Such a system may not provide the
| same security as the one in section 2: the goal is to do better than
| the status quo for security, and better than section 2 for
| scalability.

Yeah, and while revising Section 2 I had this idea of adding a third
protocol that does not make use of any client authorization but that
prevents the introduction point from accessing the service. This was
also described in proposal 142, but it makes sense to include this idea
already in 0.2.1.x without the combination of introduction and
rendezvous point. It adds a new security feature for common hidden
services without client authorization at almost no costs: The
introduction point won't be able to access the service and decide
whether it wants to serve it or not. The earlier we introduce this
feature, the earlier we can shut down hidden services without this
feature. The additional complexity is minimal. See Section 2.1 for
details about the protocol.

I also added a more scalable version of an authorization protocol in
Section 2.2. As discussed, it lacks the nice security feature of hiding
service activity, but therefore it scales. There is just one thing I'm
still unsure about: The protocol requires encryption of
introduction-point data to multiple symmetric keys. Most things I found
on the Net were hybrid approaches, so I conveiced some crypto magic to
handle it. You probably want to have a look at this part. If it's just
crap, maybe consider it an informal description of properties we might
want to have and tell me which existing crypto approach I have missed. :)

If there are no big conceptual issues (like encrypting introduction
points to multiple descriptor cookies), my plan is to implement all
three protocols as hidden service protocol version 3. IMHO it makes more
sense to get this all done in 0.2.1.x. The two authorization protocols
are really alternatives that can both be justified. And if we should
implement proposal 142 in 0.2.2.x, it would be compatible to all three
authorization types of this proposal.

| We'll also want to think here about what to do when we want
| interactive authorization protocols, or to support methods requiring
| more data than can fit in the space currently available in Tor cells.

The only ideas that came to my mind are "add new cell types" and "split
data among multiple cells". Both seem achievable, and as soon as we
conceive a protocol that requires to exceed either of the two
limitations, these extensions can be implemented. If you don't mind I'd
rather spend my time on implementing the stuff for 0.2.1.x and shift the
exact specification of these two items to a proposal that describes such
a protocol. I added a short description of these limitations as Section
1.6 together with an idea how to work around them.

| PROPOSAL 142: Combine Introduction and Rendezvous Points
|
| [...]
|
|   - Chris -- it would be helpful if you could summarize more detail
|     from your thesis about the relevant timing issues.  Since the
|     point of this proposal is to reduce latency, we really need to get
|     all the measurement we can of its efficacy.  (If you can include a
|     URL for the thesis and a page reference, that would help people
|     who don't have a copy on hand.)

The measurements you are looking for are included in the NLnet mid-July
report in Section 1:

http://freehaven.net/~karsten/hidserv/discussion-2008-07-15.pdf

Christian might also make his diploma thesis with a more detailed
description of his changes available somewhere. We haven't talked about
that so far, but will do so next week.

|   - As I read it, I don't see how the proposal results in a separate
|     circuit existing from the hidden server ("Bob") to the client. [...]

You raise an important point here that we weren't aware of before.
Christian implemented the protocol described in proposal 142 only to
measure the performance of single requests. AFAIK the hidden-server-side
introduction circuit was thrown away after a single use and rebuilt.
This needs to change for proposal 142, of course.

The only efficient solution that comes to my mind is to tunnel multiple
"inner circuits" through the circuit between introduction point and
hidden service. That might add a fourth layer in the terminology of
connection, circuit, and stream, though.

I'm afraid of the additional code complexity for this one. So, it might
turn out that we can't handle it within the NLnet project and have to
concentrate on other design changes to make hidden services faster.
We'll have to decide that until mid of August. Maybe there will be new
insights until then.

| PROPOSAL 143: Distributed storage improvements
|
| This is an omnibus proposal with 8 separate ideas.  Going one by one:
|
|  1. Report Bad Directory Nodes
|
|     This seems like a fine idea, though the additional complexity is
|     not insignificant.
|
|     I worry that a clever adversary could distinguish a publication
|     attempt from an HS authority.  After all, hidden services do not
|     generally upload the same descriptor twice: if somebody sends you
|     a descriptor shortly after you received the same descriptor, and
|     it's a descriptor you're trying to censor, you can tell it's the
|     authority.

Agreed, the adversary might tell publication attempts from a DA apart.
The question is whether this matters so much. The adversary still can't
tell *fetch* requests from the DA apart from those coming from real
clients. What should the adversary do? Deny existence of the descriptor
to perform its attack or return it to satisfy the DA? That's quite of a
gamble. If the consequence is that the rogue hidden service directory
serves the descriptor afterwards this is all we wanted to achieve. We
might not have confirmed that the directory is bad, but the service is
not blocked.

After all, this measure was designed to defend against adversaries
trying to block a specific hidden service, not just all descriptors. An
adversary doing the latter is an annoyance, but that's part of the
reason we have replication. What is more dangerous is an adversary that
starts a number of hidden service directories 24+ hours in advance with
the appropriate IDs to become responsible for all descriptors of a
hidden service and block those descriptors. Sounds like a huge effort,
but if you can then block a popular hidden service, why not try it?

The original reason for the re-publication performed by the DA was that
a rogue hidden service can't blame a correct hidden service directory.
Therefore the DA needs to publish the descriptor itself to be sure that
it was published. Maybe we should even drop the 30-minutes delay in
re-publishing the descriptor by the DA. Then the (potentially rogue)
hidden service directory will know what the DAs are up to, but so be it.

|     The "blacklist all nodes in the same /24 or /16" rules seem far
|     too harsh: they let an adversary cut out huge swaths of the
|     network using only one or two targeted hosts.

Heh, maybe that was just me imagining that the average adversary
controls a /16 net. ;) Okay, what would be better numbers here? /28 and /24?

|     The voting rule listed makes the BadHSDir flag follow different
|     rules from all other networkstatus flags.  This would require a
|     version bump in the voting method.

Okay, are there any reasons not to bump the voting method version?

|  2. Publish Fewer Replicas
|
|     This is worthwhile, but no reason is given to think that the 85.7%
|     reliability figure will hold given future networks and network
|     conditions. It would be better to look into adaptive solutions
|     that will continue to work no matter what the reliability is in
|     the future.  See my recent comments on proposal 151: most apply
|     here.

That's a fine idea! The directory authorities could vote on a currently
required replication rate and put that number in the consensus. That way
hidden services and clients would learn how many replicas should exist.

What about the following plan: We skip the actual process to determine
the replication rate and put in the fixed number 4 in the consensus
which works for the data from Jan to Mar 2008. Hidden services and
clients start using this value beginning with the hidden service
protocol 3. At a later time we teach the DAs some smart way to calculate
the optimal replication rate and include it instead of the static number
4. That could well be in 0.2.2.x, though, but it would be recognized by
0.2.1.x hidden services and clients as well.

|  3. Change Default Value of Being Hidden Service Directory
|
|     Seems entirely reasonable.  Overdue, even. :)

Great! Maybe we can convince some more 0.2.0.x relay operators to enable
that option, too.

|     BTW, how many of the numbers in the rest of this proposal are
|     derived from the existing HSDir nodes?  If the number of HSDir
|     nodes is small, then most of the measurements in the rest of this
|     proposal are based on a worryingly small sample set.

None of the measurements are based on the current situation of hidden
service directories. The measurements I have performed are based on the
assumption that all relays with open dir port and 24+ hours uptime are
hidden service directories.

|  4. Make Descriptors Persistent on Directory Nodes
|
|     Plausible, but measurements are needed to make sure this is a good
|     idea.  If a server goes down, how often does it occur that it
|     starts up again in time to serve the hidden service descriptors
|     it's holding?  If the odds are good, this is a good idea.
|     Otherwise, not?

I can only guess here, but don't you think that a certain share of
relays will be restarted within 3 hours after going down? Maybe it's for
updating to a new kernel, a short power outage, or something like that?

Are there reasons to avoid making descriptors persistent, despite the
necessary implementation? I could evaluate these measurements to tell
you that x% of all servers going down are back within three hours. But
if we don't care about the descriptors being persistent or not, I'd
simply implement it. :)

|  5. Store and Serve Descriptors Regardless of Responsibility
|
|     Good idea.  We need an answer for DOS attacks here, though.

Hmm, you mean an adversary generating arbitrary valid descriptors to
overload a hidden service directory? That's quite an expensive DoS
attack, because generating descriptors requires some public key
operations, and descriptors need to contain an up-to-date timestamp in
order to get accepted.

What we can do is introduce an upper limit for stored descriptors, like
5,000. With every descriptor requiring slightly above 2K of storage, a
hidden service directory would never spend more than, say, 12M on
descriptors. And if the hidden service directory would then fail the
"bad directory node"-test, so be it.

On the other hand I'm never sure whether such DoS protections do more
good or more harm. It would mean that an adversary would have a better
defined target. She would need to send 5K descriptors to every directory
node and all hidden services would be offline. That's not what we
wanted, either.

Or did you mean something different as DoS protection?

|  6. Avoid periodic descriptor re-publication.
|
|     Good idea.  Seems obviously correct to me.

Yay!

|  7. Discard Expired Descriptors
|
|     Good idea.  Should descriptors contain an expiration time?

No, that's not required. There is a function get_seconds_valid() that
enables a directory node to easily compute the validity of a descriptor
while parsing and validating it.

|  8. Shorten Client-side descriptor fetch history
|
|     I don't understand this one fully, I think.

Hmm, let me rephrase: The current logic of clients to try to fetch all
replicas of a descriptor is to memorize a) which descriptor ID they have
requested at b) which directory node and c) when. If a fetch request
fails, and they are looking for another replica of the descriptor, they
know that they don't have to try the first directory node again.

However, the 15 minutes to memorize this information that we conceived
back then can really be a long time. If a service is started 6 minutes
after the client has asked, that service will appear unavailable for the
client for another 9 minutes. This mostly affects testing situations,
like when people try to access their own or their friend's service to
see if it's working. That's why these 15 minutes should be reduced to 5
minutes. This should still be reasonably long to avoid ending up in an
infinite request loop.

This item does not have top priority, though. So, if you say you don't
understand this one fully, because you don't see the clear benefit in
it, we can leave it out, too.


Phew, I think that's it. Thanks again for your feedback, Nick! My
feeling is that all three proposals are a lot more sophisticated now.
That's great! :)

- --Karsten


-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFIgfIQ0M+WPffBEmURAtTLAKC2lMl2ZbMIBv6Zr4hfpvqubsvq7wCfZ07A
RBcWLaoznsu+IDs9QoyuuYA=
=Dzju
-----END PGP SIGNATURE-----
</body></email><email><emailId>20080721085243</emailId><senderName>Fabian Keil</senderName><senderEmail>freebsd-listen@fabiankeil.de</senderEmail><timestampReceived>2008-07-21 08:52:43-0400</timestampReceived><subject>Re: Bug: buffers.c:1688: assert_buf_ok: Assertion ch-&gt;data &gt;=</subject><body>


Fabian Keil &lt;freebsd-listen@fabiankeil.de&gt; wrote:

&gt; Nick Mathewson &lt;nickm@freehaven.net&gt; wrote:
&gt; 
&gt; &gt; On Fri, Apr 18, 2008 at 07:33:32AM +0200, Fabian Keil wrote:
&gt; &gt; &gt; A few days ago one of my servers triggered:
&gt; &gt; &gt; 
&gt; &gt; &gt; Apr 10 17:07:45.728 [notice] Tor 0.2.0.23-rc (r14173) opening log file.
&gt; 
&gt; &gt; &gt; Apr 10 17:08:18.375 [notice] Performing bandwidth self-test...done.
&gt; &gt; &gt; Apr 11 12:25:25.848 [err] Bug: buffers.c:1688: assert_buf_ok: Assertion \
&gt; &gt; &gt; ch-&gt;data &gt;= &amp;ch-&gt;mem[0] failed; aborting. 
&gt; &gt; &gt; Unfortunately it doesn't look like a core dump has been created.
&gt; &gt; 
&gt; &gt; Hm. Unfortunately, this looks like one we're not going to be able to
&gt; &gt; trace down without at least a stack trace.  If you like, you can
&gt; &gt; submit it to the bugtracker so we don't forget about it.
&gt; 
&gt; I'll wait for it to happen again first. Thanks.

There's a fair chance that this has been caused by faulty memory.
I'm sorry for wasting your time.

Fabian


["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20080721180349</emailId><senderName>Robert Hogan</senderName><senderEmail>robert@roberthogan.net</senderEmail><timestampReceived>2008-07-21 18:03:49-0400</timestampReceived><subject>Re: Proposal statuses for Tor 0.2.1.x [Part 1]</subject><body>


On Friday 11 July 2008 18:14:07 Nick Mathewson wrote:
&gt;
&gt; Proposal 131: Help users to verify they are using Tor
&gt; Proposal 132: A Tor Web Service For Verifying Correct Browser Configuration
&gt;
&gt;    Draft. These are neat ideas for verifying if a user's browser is
&gt;    set up to use to use Tor (correctly), and if a user's Tor is
&gt;    running at all.  There are pros and cons to both approaches, and
&gt;    more design could be needed.  Nobody on the main Tor team seems
&gt;    likely to be free to do these on an 0.2.1.x timeframe, but if
&gt;    somebody wants to volunteer to tackle them, that'll be great.
&gt;    Leaving as Draft.
&gt;

I've started on 132.

["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20080725132832</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-07-25 13:28:32-0400</timestampReceived><subject>Re: Alex Le Heux on IPv6 proposals [alexlh@funk.org: Re: Links about IPv6 in Tor]</subject><body>

On Fri, Jul 25, 2008 at 10:38:03AM +0200, Marcus Wolschon wrote:
 [...]
&gt;  * the proposal does not contain hidden services on IPv6
&gt;    where we have working and tested code for it. Does it
&gt;    only specify the changes that still need to be made?

I'm pretty sure that no changes to the spec are required for hidden
services to work with IPv6.  The only changes that are necessary are
all on the hidden service side, where you connect to an IPv6 target
rather than an IPv6 target.  Am I missing something there?

BTW, I'm working on IPv6, looking at Marcus's original patch as I go
along, incorporating my comments from 4 dec and 5 dec last year, and
trying to make it all more compliant with proposals 107 and 108.  With
luck, this should get merged in soon.  Many thanks to everybody who's
helped with this.

peace,
-- 
Nick
</body></email><email><emailId>20080731212416</emailId><senderName>coderman</senderName><senderEmail>coderman@gmail.com</senderEmail><timestampReceived>2008-07-31 21:24:16-0400</timestampReceived><subject>Re: Proposal: Automatic Tor Software Updates</subject><body>

there was some discussion in channel on this; i've added some comments
based on this discussion:

On Thu, Jul 31, 2008 at 9:40 AM, Carsten Krüger &lt;C.Krueger@gmx.org&gt; wrote:
&gt; ...
&gt; For the proposal itself: an ascending number should be included to
&gt; avoid replaying old messages. Otherwise uptodate clients could be
&gt; forced to downgrade to an older version.

this still leaves the clients in the dark if an adversary wants to
prevent an update from being known (and perhaps induce a client to use
a vulnerable implementation to attack).

some possible mitigation strategies:

- include most recent version number (like svn rev) in the published
descriptors; no clients would join the Tor network with an out of date
version and not know about it.  Drawbacks: changing this is a pain and
should be avoided if at all possible.

- publish updated version information daily and encourage Tor users to
be aware of and verify the current version regularly.  an absence of
authenticated version information would then be detected by the
clients themselves and handled accordingly.


&gt; 2 Questions:
&gt; Why fetching the updates via Tor network?

if the site is blocked directly, this would allow updates over an
existing working client installation. (among other reasons)


&gt; Why via https?

why not?  (https is to be encouraged! :)


best regards,

</body></email><email><emailId>20080611173931</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-06-11 17:39:31-0400</timestampReceived><subject>RAM improvements in Tor 0.2.0.x and OpenSSL 0.9.9</subject><body>

Hi, folks.  Roger asked me to type up a description of what we've been
doing recently to reign in memory usage.  I figured that some of
or-dev might be interested too, so here goes:
--------------------
There have been a bunch of RAM improvements to Tor over the last
months.  Two of them are in 0.2.0.x; some others are in; and one big
one is in the current OpenSSL development series, which will
eventually become OpenSSL 0.9.9.

- We ship an improved allocator for Linux.

  Some of Tor's memory woes on Linux are due to bad performance by the
  memory allocator in GNU Libc in dealing with memory fragmentation.
  This is a problem, since the fragmentation can lead Tor processes to
  grow over time without bound, and since many of Tor's
  best-performing servers are on Linux (which uses GNU Libc), and
  making them run out of memory annoys their operators.

  Tor now includes the so-called "opensbsd malloc" allocator for use
  on Linux-like systems.  This is included by default in the Linux
  packages we ship.  Linux hosts using this allocator no longer seem
  to grow in memory size without bound.

  If the issue persists on other platforms, we may follow Firefox 3's
  lead and include jemalloc as our allocator with 0.2.1.x

- Tor's buffer implementation is greatly improved.

  Much of Tor's allocated memory is used  in I/O buffers.
  Previously, each of Tor's buffers was a large block of memory,
  potentially 4 times the size of the data it needed to store.  (It's
  necessary to allow some slack in the buffer size, since expanding
  buffers to hold more information is expensive.)  For large amounts
  of data, this could be very wasteful.

  As of 0.2.0.x, Tor ships with a new buffer implementation based on
  the classic Unix kernel's mbuf strategy: now, each buffer is a
  linked list of small chunks.  The overhead on each buffer is now
  on the order of 1-4k, no matter how large the buffer size is.

- We wrote an OpenSSL patch to improve OpenSSL's memory performance.

  Ordinarily, OpenSSL keeps a read buffer and a write buffer for each
  connection.  Together, these buffers come to 34k per connection.  On
  a busy Tor server, this can add to hundreds of megabytes.  We
  investigated the usage patterns of these buffers, and found that
  most buffered data in OpenSSL tend to be very short lived: at any
  given time, on the servers we measured, well over 90% of the OpenSSL
  buffers were completely empty.  This amounts to hundreds of wasted
  MB on a busy server.

  We wrote a patch for OpenSSL to release not-in-use buffer memory
  onto a freelist, and avoid allocating more memory than is necessary.
  After 18 revisions, the patch was accepted by the OpenSSL
  development team, and will be included in OpenSSL 0.9.9.
  Preliminary testing shows the patch to indeed save about 34k per
  connection; even on a small, short-lived server this amounts to over
  30% savings in memory usage.  On high-volume nodes, it seems to be
  significantly higher.

  Since OpenSSL 0.9.9 has not yet been released, we're not going to
  recommend that average users run development snapshots of it.
  Instead, once the patch has seen more testing, if OpenSSL 0.9.9
  still isn't out, we may backport our patch to the 0.9.8 series of
  OpenSSL, and encourage either the OpenSSL dev team to apply it, or
  encourage server operators to apply it on their own.

  Serindipitously, it seems that using this feature do not suffer much
  (or maybe at all) from the memory fragmentation problem described
  above, even when they're using the GNU Libc allocator.  We're trying
  to investigate why this is, or whether it's some kind of
  inexplicable measurement error.

-- 
Nick
</body></email><email><emailId>20080612232648</emailId><senderName>Mike Perry</senderName><senderEmail>mikeperry@fscked.org</senderEmail><timestampReceived>2008-06-12 23:26:48-0400</timestampReceived><subject>Re: SPD talk: "Simulating a Global Passive Adversary for Attacking Tor-like Anonymity Systems"?</subject><body>


Thus spake gojosan@mailhaven.com (gojosan@mailhaven.com):

&gt; I just noticed this talk at the Security and Privacy Day from May 2008. 
&gt; While I understand that Tor's thread model does not defend against a GPA
&gt; I am still curious what effect this attack can have against the current,
&gt; real Tor network?  
&gt; 
&gt; Simulating a Global Passive Adversary for Attacking Tor-like Anonymity
&gt; Systems
&gt; http://web.crypto.cs.sunysb.edu/spday/

A handful of comments about the paper (many of these they themselves
brought up, but some they did not):

0. They are really an active adversary here. They need to be
controlling a website in order to unmask users, or have control of
some exit nodes or their upstream routers, and must modulate the
bandwidth of TCP connections considerably (+/- 30-40KB/sec or more,
for a period of 10 minutes).

1. Their results for path recognition (25% false negatives, 10% false
positives) are based on their limited sample set of only 13 trial
circuits via a small set of nodes that must be geographically close to
and well-peered with their pinging 'vantage point(s)'. I suspect
reality is a lot less forgiving than this limited sample size
indicates when more nodes and trials are involved using the real Tor
path selection algorithm.

2. The bandwidth estimation technique they utilized (based on TCP
Westwood/CapProbe/PacketPair) is very sensitive to any queuing and
congestion that occurs between the target and the 'vantage point(s)'.
As soon as congestion happens along the path, these types of estimates
report a large amount of excess capacity (rather than no capacity) due
to the acks/responses getting compressed together in queues. The way
this has been 'fixed' in TCP Westwood+ is to filter out the high
estimates and perform weighted averaging to smooth fluctuations
(precisely what they are trying to measure). It would have been nice
if they provided some more realistic testing of their bandwidth
estimation consistency using real world nodes as opposed to the lab
results on half-duplex ethernet.

3. Based on my measurements last year, only the top ~5-10% nodes are
capable of transmitting this much data in an individual stream, and
only if all of the nodes in your path are from this set. Furthermore,
as load balancing improves (and we still have more work to do here
beyond my initial improvements last year), these averages should in
theory come down for these nodes (but increase for slower nodes). So
how they will fair once we figure out the bottlenecks of the network
is unknown. They could do better in this case, but it is probably more
likely the average stream capacity for most nodes will drop below
their detection threshold.

4. Right now these few fast nodes carry about 60% of the network
traffic. A rough back of the envelope calculation based on our
selection algorithm means that only ~22% (.6*.6*.6) of the paths of
the network have this property for normal traffic, and only ~4.5% of
hidden service paths (which are 6 hops).

5. Their error rates do get pretty high once they've begun
trying to trace the stream back to its ISP (on top of the rates for
just path recognition). Any other fluctuations in traffic are going to
add error to this ability, and I imagine traffic fluctuates like crazy
along these paths. They also assume full a-priori knowledge of these
routes which in practice means a full map of all of the peering
agreements of the Internet, and 'vantage point(s)' that have no
queuing delay to all of them..


A couple countermeasures that are possible:

1. Nodes that block ICMP and filter closed TCP ports are less
susceptible to this attack, since they would force the adversary to
measure the capacity changes at upstream routers instead (which will
have other noise introduced due to peers utilizing the link as well). I
am wondering if this means we should scan the network to see how many of
these top nodes allow ICMP and send TCP resets, and if it is feasible to
notify their operators that they may want to consider improving their
firewalls, since we're only talking about 100-150 IPs here. There are a
lot more critical things to scan for though, so this is probably lower
priority.

2. Roger pointed out that clients can potentially protect themselves
by setting 'BandwidthRate 25KB' and setting 'BandwidthBurst' to some
high value, so that short lived streams will still get high capacity
if it is available, but once streams approach the 10-20minute lifetime
needed for this attack to work, they should be below the detectable
threshold. I think this is a somewhat ugly hack, and should probably
be governed by a "High Security Mode" setting that would be
specifically tuned to this purpose (and be a catching point for other
hacks that protect against various attacks but at the expense of
performance/usability).


All this aside, this is a very clever attack, and further evidence
that we should more closely study capacity properties, reliability
properties, queuing properties, and general balancing properties of
the network.


-- 
Mike Perry
Mad Computer Scientist
fscked.org evil labs

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20080613140130</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-06-13 14:01:30-0400</timestampReceived><subject>Re: Proposal: remove down routers from consensus</subject><body>

On Fri, Jun 13, 2008 at 10:11:02AM +0200, Peter Palfrader wrote:
 [...]
&gt; &gt;   - It's dumb how v3 the v3 directory protocol still depends on the
&gt; &gt;     existence of v2 directories.  We should fix that.
&gt; 
&gt; Agreed.  I wonder if we should just use the vote documents to learn
&gt; about new servers, or if we need a new type of document.

Using the vote _format_ makes sense, but I don't think we want to just
look at the vote documents that we're exchanging now.  Otherwise, it
takes two cycles for authorities to agree.  Here's a timeline of what
would happen if we just looked at the vote documents:

  0:10: A router uploads a descriptor to authority A, but not
        authority B or C.

  0:15: [A starts putting information about the router in its v2
        descriptor, but B and C aren't looking at that.]

  0:50: Voting time!  A, B, and C exchange votes.  A's vote reflects
        the new descriptor, but B and C's votes don't.  B and C
        finally learn about the new descriptor, but since they already
        voted, they can't go back and change their votes to include
        it, even if they did have time to test the new router.

  1:50: Voting time again.  This time, all the authorities now about
        the new router, and things go well.


Perhaps we can have a new value for the vote-status field, for interim
network opinions that authorities can exchange in advance of the
actual voting.

yrs,
-- 
Nick
</body></email><email><emailId>20080614030031</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-06-14 03:00:31-0400</timestampReceived><subject>Notes on TLS unobservability</subject><body>

Hi, all.  Roger needed a write-up on recent progress here, too, and
suggested it might be of general interest.

Remember, it *is not* a goal to make Tor steganographic.  For the
actual threat model, see proposal 124, and see also the blocking
resistance design document.


TLS NORMALIZATION
-----------------
The first round of TLS normalization is now done.  The most recent
changes involved poking at the internals of OpenSSL's ssl_st structure,
and moving ciphers around to get the right result.  Remember, we're
aiming to emulate Firefox's choice of ciphersuites... but Firefox lists
some suites that old OpenSSL versions (like 0.9.7) don't support at all,
and one suite that was never actually standardized, and therefore no
OpenSSL version has ever supported.


The code was pretty interesting to write.  For each SSL object, OpenSSL
keeps two lists of ciphersuites.  One list is sorted by preference (and
is used by clients to advertise which ciphers they support), and one is
sorted by ID and used to look up the suite when the server sends its
choice back to the client.  When Tor is as a client, it now changes the
first list before SSL negotiation so it can advertise the same suites as
Firefox does.  Tor servers never select these dummy ciphersuites.

As for extensions, Setting a desired hostname and picking some ECC
suites is enough to make recent OpenSSLs choose the extensions we want.

HOW TO TEST THIS
----------------
I've looked at the packet dump, and it looks okay to me.  But from a
red-team POV, I'm going to ask Steven and Jacob to act as a red team and
see what they can do to reliably distinguish Tor-to-Tor traffic from
Firefox-to-webserver traffic without resources beyond what a typical
firewall can do.  Looking at traffic patterns should work, but I don't
think you can do this without expending more RAM per connection than
big firewalls can afford.

SSL PASSTHROUGH
---------------
For rudimentary scanning resistance, it might be interesting to support
some kind of authentication, so that clients who come to a bridge
without authenticating are passed on to a local service (like a
webserver) so that the host seems to be an ordinary encrypted webserver.

Implementing this in Tor would not be difficult, but it would be One
More Darned Feature To Do and would take time from other stuff, so we
need to consider it judiciously.  Implementation/Design issues include:
  - We'd need support for having the server's SSL certificate seem like
    a plausible certificate for the website, or for using an external
    key/certificate for SSL connections.  Both seem a bit problematic.
  - We'll need to refactor the code; right now, "this connection speaks
    Tor cells" is synonymous with "this connection is using SSL."
  - Having Tor pass connections off to another server as needed is only
    one option.  Alternatively, we could have an external program
    multiplex a appropriate.

Fundamental issues include:
  - Would it really work?  A clever probing adversary might be able to
    pull off some kind of timing attack.  To answer this, we should get
    intuitions from the academics we know who work on fingerprinting.
  - What's the threat model?  An adversary with the resources to probe a
    large number of IP/port combinations for possible Tor bridges, most
    likely.  Are the resources needed to do this really less than the
    resources needed to mount a really effective attack against the
    bridge distributor?

</body></email><email><emailId>20080614161151</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-06-14 16:11:51-0400</timestampReceived><subject>Re: [proposal 136] Re: Proposal: Simplify Configuration of Private Tor Networks</subject><body>

On Fri, May 30, 2008 at 02:17:15AM +0200, Karsten Loesing wrote:
&gt; -----BEGIN PGP SIGNED MESSAGE-----
&gt; Hash: SHA1
&gt; 
&gt; Hi Nick,
&gt; 
&gt; | This looks pretty good to me.  There are a few
&gt; | issues remaining; let me know if you'd like me to fix them
&gt; | myself, or if you'd like to do it.
&gt; 
&gt; I tried to address these issues with the attached patch.

Thanks!  I've checked it in, and added a few comments in a subsequent
commit.

yrs,
-- 
Nick
</body></email><email><emailId>20080615230040</emailId><senderName>Peter Palfrader</senderName><senderEmail>peter@palfrader.org</senderEmail><timestampReceived>2008-06-15 23:00:40-0400</timestampReceived><subject>Re: Proposal: Download consensus documents only when it will be trusted</subject><body>

On Sun, 13 Apr 2008, Peter Palfrader wrote:

&gt; This came up in the More robust consensus voting with diverse authority
&gt; sets thread but is a different issue.

&gt; Title: Download consensus documents only when it will be trusted

While long implemented and merged into the spec proper this proposal has
been given number 139, so it's not lost.

</body></email><email><emailId>20080615232449</emailId><senderName>Karsten Loesing</senderName><senderEmail>karsten.loesing@gmx.net</senderEmail><timestampReceived>2008-06-15 23:24:49-0400</timestampReceived><subject>Ever wondered why Tor Hidden Services are so slow?</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Hi everybody,

in case you are interested in knowing why Tor Hidden Services are so
slow, we have a 22-page report on this question available now:

http://freehaven.net/~karsten/hidserv/perfanalysis-2008-06-15.pdf

The abstract reads:

"This document describes a performance analysis of setting up and
accessing a Tor Hidden Service. The objective is to spot performance
bottlenecks in the hidden service protocol and suggest which parts
should be changed in order to improve the overall performance of Tor
Hidden Services."

This report is part of the NLnet Project: Speed Up Tor Hidden Services
(https://www.torproject.org/projects/hidserv)

As for the credits (if there are such for this report): Most of this was
written by Christian Wilms and me, I have provided at least two of the
bugs we could fix now :(, Steven J. Murdoch has compiled most of the
statistics, and Roger Dingledine has proposed a good share of the
suggested improvements.

Please let us know if you have any questions or comments.

Thanks!
- --Karsten
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFIVaTB0M+WPffBEmURAu2DAJ9t08xJqcNmHqcn2v+hh+MK2ePCRACeOcQo
I33IQHVOZZJO/RgAbH2rUD8=
=KvNk
-----END PGP SIGNATURE-----
</body></email><email><emailId>20080616173113</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-06-16 17:31:13-0400</timestampReceived><subject>Re: draft proposal: download server descriptors on demand</subject><body>

On Mon, Jun 16, 2008 at 12:06:44AM +0200, Peter Palfrader wrote:
 [...]

(By request, added as 141.)

Good start on a proposal.  It would be good to get the directory
bandwidth down on this one.  Also, if clients don't need to download
so many descriptors, they will save lots of RAM formerly used to hold
routerinfo_t objects.

I've made some initial comments below.

 [...]
&gt;   Furthermore the server descriptor also contains the exact version of
&gt;   the Tor software that the server is running and some decisions are
&gt;   made based on the server version number (for instance a Tor client
&gt;   will only make conditional consensus requests [proposal from 13 Apr
&gt;   2008 that never got a number] when talking to Tor servers version
&gt;   0.2.1.1-alpha or later).

This part doesn't need to come from the descriptor; the consensus also
reports client versions.

 [...]
&gt; 3. Doing away with the need for all SDs

I was confused by this heading until I realized that you meant, "Doing
away with the need to hold all SDs." rather than "Doing away with all
need for SDs."
 
&gt; 3.1 Load balancing info in consensus documents
&gt; 
&gt;   One of the reasons why clients download all server descriptors is for
&gt;   doing load proper load balancing as described in 2.1.  In order for
&gt;   clients to not require all server descriptors this information will
&gt;   have to move into the network status document.
&gt; 
&gt;   [XXX Two open questions here:
&gt;    a) how do we arrive at a consensus weight?

Perhaps the vote could contain the node's bandwidth, and this could be
used to calculate the weights?  It's necessary that the consensus
remain a deterministic function of the votes.

&gt;    b) how to represent weights in the consensus?
&gt;       Maybe "s Guard=0.13 Exit=0.02 Middle=0.00 Stable.."

That would break backward compatibility.  Adding a new per-line
instead would probably be better.  We should play with representations
here till we wind up with something compressible, and we should figure
out the space impact of doing this.

&gt; ]
&gt;
&gt; 3.2 Fetching descriptors on demand
&gt; 
&gt;   As described in 2.4 a descriptor lists IP address, OR- and Dir-Port,
&gt;   and the onion key for a server.
&gt; 
&gt;   A client already knows the IP address and the ports from the consensus
&gt;   documents, but without the onion key it will not be able to send
&gt;   CREATE/EXTEND cells for that server.  Since the client needs the onion
&gt;   key it needs the descriptor.
&gt; 
&gt;   If a client only downloaded a few descriptors in an observable manner
&gt;   then that would leak which nodes it was going to use.
&gt; 
&gt;   This proposal suggests the following:
&gt; 
&gt;   1) when connecting to a guard node for which the client does not
&gt;      yet have a cached descriptor it requests the descriptor it
&gt;      expects by hash.  (The consensus document that the client holds
&gt;      has a hash for the descriptor of this server.  We want exactly
&gt;      that descriptor, not a different one.)
&gt;
&gt;      [XXX: How?  We could either come up with a new cell type,
&gt;       RELAY_REQUEST_SD that takes only a hash (of the SD), or use
&gt;       RELAY_BEGIN_DIR.  The former is probably smarter since we will
&gt;       want to use it later on as well, and there we will require
&gt;       padding.]

My first thought was that I'd prefer to avoid multiplying machinery
here.  When we design RELAY_REQUEST_SD, let's try to keep looking to
see whether we can add a padding argument to RELAY_BEGIN_DIR rather
than forcing a new relay cell type?

But now I think that for nodes that don't want to be full-on directory
mirrors, I think a separate mechanism here might be a good idea.

&gt;      A client MAY cache the descriptor of the guard node so that it does
&gt;      not need to request it every single time it contacts the guard.
&gt; 
&gt;   2) when a client wants to extend a circuit that currently ends in
&gt;      server B to a new next server C, the client will send a
&gt;      RELAY_REQUEST_SD cell to server B.  This cell contains in its
&gt;      payload the hash of a server descriptor the client would like
&gt;      to obtain (C's server descriptor).  The server sends back the
&gt;      descriptor and the client can now form a valid EXTEND/CREATE cell
&gt;      encrypted to C's onion key.
&gt; 
&gt;      Clients MUST NOT cache such descriptors.  If they did they might
&gt;      leak that they already extended to that server at least once
&gt;      before.
&gt;
&gt;   Replies to RELAY_REQUEST_SD requests need to be padded to some
&gt;   constant upper limit in order to conceal a client's destination
&gt;   from anybody who might be counting cells/bytes.
&gt; 
&gt;   [XXX: detailed spec of RELAY_REQUEST_SD cell and its reply]
&gt;   [XXX: figure out a decent padding size]

Something else to figure out here is migration.  When the first cut of
this system is done, only new servers will support RELAY_REQUEST_SD.
This means that clients will still need to pre-download descriptors
under some circumstances.

In fact, the rules will be pretty weird here.  If extends are done by
first asking B for C's descriptor, then clients need to know whether B
supports RELAY_REQUEST_SD.  If it doesn't, they need to have C's
descriptor, which means they need to have downloaded it in advance.

In its final version, this proposal needs a migration plan.

&gt; 3.3 Protocol versions
&gt; 
&gt;   [XXX: find out where we need "opt protocols Link 1 2 Circuit 1"
&gt;   information described in 2.3 above.  If we need it, it might have
&gt;   to go into the consensus document.]

We don't use it much as-is, but the hope is for it to eventually take
the place of most calculations we currently do using version numbers.
On the bright side, adding it immediately after the version numbers
will cost us approximately nothing in the compressed document size.
 
&gt;   [XXX: Similarly find out where we need the version number of a
&gt;   remote tor server.  This information is in the consensus, but
&gt;   maybe we use it in some place where having it signed by the
&gt;   server in question is really important?]

I don't believe so.

&gt; 3.4 Exit selection
&gt; 
&gt;   Currently finding an appropriate exit node for a user's request is
&gt;   easy for a client because it has complete knowledge of all the exit
&gt;   policies of all servers on the network.
&gt; 
&gt;   [XXX: I have no finished ideas here yet.
&gt;     - if clients only rely on the current exit flag they will
&gt;       a) never use servers for exit purposes that don't have it,
&gt;       b) will have a hard time finding a suitable exit node for
&gt;          their weird port that only a few servers allow.
&gt;     - the authorities could create a new summary document that
&gt;       lists all the exit policies and their nodes (by fingerprint).
&gt;       I need to find out how large that document would be.
&gt;     - can we make the "Exit" flag more useful?  can we come
&gt;       up with some "standard policies" and have operators pick
&gt;       one of the standards?

Generally, most policies should take the form of "Here are the ports I
allow.  Here are the addresses I disallow."  If we codify a few
port-sets, we might be in business.

&gt; 4. Future possibilities
&gt; 
&gt;   This proposal still requires that all servers have the descriptors of
&gt;   every other node in the network in order to answer RELAY_REQUEST_SD
&gt;   cells.  These cells are sent when a circuit is extended from ending at
&gt;   node B to a new node C.  In that case B would have to answer a
&gt;   RELAY_REQUEST_SD cell that asks for C's server descriptor (by SD digest).
&gt;
&gt;   In order to answer that request B obviously needs a copy of C's server
&gt;   descriptor.  In the future we might amend RELAY_REQUEST_SD cells to
&gt;   contain also the expected IP address and OR-port of the server C (the
&gt;   client learns them from the network status document), so that B no
&gt;   longer needs to know all the descriptors of the entire network but
&gt;   instead can simply go and ask C for its descriptor before passing it
&gt;   back to the client.

We might want to include this information in RELAY_REQUEST_SD anyway
now, so that when servers start supporting fetch-on-demand, clients
will already be sending them the info they need to do it.  I think it
should include an identity fingerprint digest too, so that B can open
an authenticated OR connection to C as needed.

(These issues also complicate any eventual p2p-Tor designs, if every
B needs to know every C's descriptor.  We'd also need to keep the
client cache and the server cache separate, so that it's not so easy
to probe about whether B already knows C.)

-- 
Nick
</body></email><email><emailId>20080616201842</emailId><senderName>Peter Palfrader</senderName><senderEmail>peter@palfrader.org</senderEmail><timestampReceived>2008-06-16 20:18:42-0400</timestampReceived><subject>Re: draft proposal 141: download server descriptors on demand</subject><body>

On Mon, 16 Jun 2008, Nick Mathewson wrote:

&gt; &gt;   1) when connecting to a guard node for which the client does not
&gt; &gt;      yet have a cached descriptor it requests the descriptor it
&gt; &gt;      expects by hash.  (The consensus document that the client holds
&gt; &gt;      has a hash for the descriptor of this server.  We want exactly
&gt; &gt;      that descriptor, not a different one.)
&gt; &gt;
&gt; &gt;      [XXX: How?  We could either come up with a new cell type,
&gt; &gt;       RELAY_REQUEST_SD that takes only a hash (of the SD), or use
&gt; &gt;       RELAY_BEGIN_DIR.  The former is probably smarter since we will
&gt; &gt;       want to use it later on as well, and there we will require
&gt; &gt;       padding.]
&gt; 
&gt; My first thought was that I'd prefer to avoid multiplying machinery
&gt; here.  When we design RELAY_REQUEST_SD, let's try to keep looking to
&gt; see whether we can add a padding argument to RELAY_BEGIN_DIR rather
&gt; than forcing a new relay cell type?

Using RELAY_BEGIN_DIR does have a drawback tho.  Since it's just a BEGIN
cell, it will mean the client sends the RELAY_BEGIN_DIR to the server,
and then has to waits for the CONNECTED(?) cell before it can send its
URL.  That's one extra roundtrip.


&gt; Something else to figure out here is migration.  When the first cut of
&gt; this system is done, only new servers will support RELAY_REQUEST_SD.
&gt; This means that clients will still need to pre-download descriptors
&gt; under some circumstances.
&gt; 
&gt; In fact, the rules will be pretty weird here.  If extends are done by
&gt; first asking B for C's descriptor, then clients need to know whether B
&gt; supports RELAY_REQUEST_SD.  If it doesn't, they need to have C's
&gt; descriptor, which means they need to have downloaded it in advance.

One approach is to download individual SDs via a fully anonymized 3-hop
circuit.  This still requires some subset of the network to already
support the new cell type.  But maybe that's fine.


&gt; &gt; 4. Future possibilities
&gt; &gt; 
&gt; &gt;   This proposal still requires that all servers have the descriptors of
&gt; &gt;   every other node in the network in order to answer RELAY_REQUEST_SD
&gt; &gt;   cells.  These cells are sent when a circuit is extended from ending at
&gt; &gt;   node B to a new node C.  In that case B would have to answer a
&gt; &gt;   RELAY_REQUEST_SD cell that asks for C's server descriptor (by SD digest).
&gt; &gt;
&gt; &gt;   In order to answer that request B obviously needs a copy of C's server
&gt; &gt;   descriptor.  In the future we might amend RELAY_REQUEST_SD cells to
&gt; &gt;   contain also the expected IP address and OR-port of the server C (the
&gt; &gt;   client learns them from the network status document), so that B no
&gt; &gt;   longer needs to know all the descriptors of the entire network but
&gt; &gt;   instead can simply go and ask C for its descriptor before passing it
&gt; &gt;   back to the client.
&gt; 
&gt; We might want to include this information in RELAY_REQUEST_SD anyway
&gt; now, so that when servers start supporting fetch-on-demand, clients
&gt; will already be sending them the info they need to do it.  I think it
&gt; should include an identity fingerprint digest too, so that B can open
&gt; an authenticated OR connection to C as needed.

Agreed.


&gt; (These issues also complicate any eventual p2p-Tor designs, if every
&gt; B needs to know every C's descriptor.  We'd also need to keep the
&gt; client cache and the server cache separate, so that it's not so easy
&gt; to probe about whether B already knows C.)

Without checking how feasible this is in the code my first idea was to
keep SDs for client purposes attached to the circuit that fetches and
uses them, and not in a global routerlist.

A client cache might still be useful for the SDs of our guards, and if
we need it for exit stuff.

-- 
weasel
</body></email><email><emailId>20080616220131</emailId><senderName>Peter Palfrader</senderName><senderEmail>peter@palfrader.org</senderEmail><timestampReceived>2008-06-16 22:01:31-0400</timestampReceived><subject>instrumenting client downloads</subject><body>

Hi,

in order to confirm our idea of how much a Tor client needs to download
to work, and what it spends these bytes on we have added code to the
Tor client that lets us learn real numbers.

To enable this code you have to build the current 0.2.1.x tree in svn
with --enable-instrument-downloads passed to the configure script.

This makes the Tor process keep track of, among other things, how many
download requests it completed for each of certs, server descriptors and
consensuses and how large they were in total.  It also keeps track of
how many EXTEND and how many CREATE (FAST) cells it sends.

If your Tor is built with this support enabled you can get the numbers
via Tor's control port with doing a "GETINFO dir-usage", or, if your
Tor process has an open DirPort, at /tor/bytes.txt.

The data you'll get there looks like this:
| cell: create fast  271  271
| cell: extend  347  347
| dl/cert.z  9804  1
| dl/consensus  1865179  13
| dl/server  4285272  84

This Tor client sent, up to this point, 271 CREATE_FAST cells, 347 EXTEND
cells and it downloaded 9804 bytes of certificates in one request,
1865179 consensus documents in 13 requests, and 4285272 bytes of server
descriptors in 84 requests.  The number of bytes includes only the size
of the actual document bodies, it does not include any protocol overhead
at any level (tor/http/tcp/ip).


http://asteria.noreply.org/~weasel/Tor/louise-stats-1.gz has some
numbers for a 0.1.2.1-trunk (around June 9th) Tor client, on a fast
network. The Tor client was busy fetching a website every 5 minutes.

http://asteria.noreply.org/~weasel/Tor/tor-client-download-stats-longterm-cells.jpg
http://asteria.noreply.org/~weasel/Tor/tor-client-download-stats-startup-cells.jpg
http://asteria.noreply.org/~weasel/Tor/tor-client-download-stats-longterm-dl.jpg
http://asteria.noreply.org/~weasel/Tor/tor-client-download-stats-startup-dl.jpg

visualize them somehow.

The data shows that in the 19 hours the Tor client has run it fetched a
consensus 13 times, and that each consensus fetch was followed by a
download of all the referenced descriptors.  Each consensus was around
140kb in size (implemented proposal 138 shrinks them to ~90kb, and
proposal 140 will, once implemented, bring updates to the consensus down
to 13kb per hour).  Very roughly 150 kilobytes of server descriptors
had to be downloaded per hour on average to keep up with changes.

In its 19 hour lifetime this particular client sent 271 create fast
cells and 347 extend cells.  An average server descriptor currently
appears to be a bit over 2 kilobytes in size.  Even if we had downloaded
a 4kb descriptor for every single extend cell we sent we would only have
used about 1.4 megabytes, or roughly the capacity of one of those
ancient 3.5" high density floppy disks.

(Create_fast cells are most often used when doing encrypted dir
requests are done and in that case we wouldn't need to download a server
descriptor for the dirserver (also, we would probably not make that many
requests with proposal 141 anyway).   They are also used for the first
hop of a tor circuit, i.e. when connecting to our Guard node.  In those
cases we'd have to request the descriptor once but could then cache it.)


Yours,
weasel

PS: Attached is the script I used for dumping the data every 5 seconds.
It expects to read the controller password from a file called
"controller-password" in its working directory, and will dump the stats
to the file given as its first and only argument.  Control port number
is hardcoded to 19051, easy to change in the source.


#!/usr/bin/ruby

# Copyright (c) 2005, 2006, 2007, 2008 Peter Palfrader

require 'socket'
require 'yaml'
require 'thread'

Thread.abort_on_exception = true;

PASSWORD = File.new("controller-password").read.chop
outfile = File.new(ARGV[0], mode="a")
tor = TCPSocket.new('localhost', 19051)

def ctrl_read(fd)
	line = fd.readline.chop
	throw "short reply" if line.length &lt;= 3

	code = line[0..2]
	spec = line[3..3]
	rest = line[4..line.length-1]

	if spec == " "
		msg = rest
		return { 'code' =&gt; code, 'msg' =&gt; msg };
	elsif spec == "-"
		(key,value) = rest.split('=', 2)
		return { 'code' =&gt; code, 'key' =&gt; key, 'value' =&gt; value };
	elsif spec == "+"
		throw "In line #{line} I epexcted the last char to be a =" unless \
rest[rest.length-1..rest.length-1] == '='  key = rest[0..rest.length-2]
		value = []
		while line = fd.readline.chop
			break if line == "."
			line = [1..line.length-1] if line[0..0] == "."
			value &lt;&lt; line
		end
		line = fd.readline.chop
		endcode = line[0..2]
		endspec = line[3..3]
		endmsg = line[4..line.length-1]
		throw "Expected line #{line} to be an EndReplyLine with status=#{code} after \
DataReplyLine(s)" unless endcode == code  throw "Expected line #{line} to be an \
EndReplyLine with spec=' ' after DataReplyLine(s)" unless endspec == ' '  return { \
'code' =&gt; code, 'key' =&gt; key, 'value' =&gt; value, 'msg' =&gt; endmsg };  end
end

tor.print "AUTHENTICATE \"#{PASSWORD}\"\r\n"
reply = ctrl_read(tor)
throw "Unexpected reply #{reply.to_yaml}" unless reply['code'] == '250'

Thread.new do
	detailed = 100
	while true do
		tor.print "GETINFO dir-usage\r\n"
		if detailed &gt; 0
			sleep 1
			detailed = detailed - 1
		else
			sleep 5
		end
	end
end

while true do
	r = ctrl_read(tor)
	if r['code'] == '250' and r['key'] == 'dir-usage'
		now = Time.now
		v = r['value'].kind_of?(Array) ? r['value'].join("\n") : r['value'].to_s
		s = now.utc.strftime("%s  %Y-%m-%d %H:%M:%S\n") + v + "\n\n"
		puts s
		outfile.puts s
		outfile.flush
	else
		STDERR.puts("Cannot handle XX\n" + r.to_yaml+"\nXXXX\n");
	end
end


tor.print "QUIT\r\n"
reply = ctrl_read(tor)
throw "Unexpected reply #{reply.to_yaml}" unless reply['code'] == '250'



</body></email><email><emailId>20080618071700</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2008-06-18 07:17:00-0400</timestampReceived><subject>Re: Proposal 137: Keep controllers informed as Tor bootstraps</subject><body>

On Sun, Jun 15, 2008 at 01:41:24PM -0400, Nick Mathewson wrote:
&gt; &gt;   So in this case we send
&gt; &gt;   650 STATUS_CLIENT NOTICE/WARN BOOTSTRAP \
&gt; &gt;   PROGRESS=num TAG=string SUMMARY=string WARNING=string REASON=string
&gt;
&gt; Are the strings quoted?  They should be.

SUMMARY and WARNING are quoted. The rest aren't, because they can only
be a word, not arbitrary strings.

&gt;  But if this is so, I think
&gt; maybe REASON should be an identifier-like thing rather than a string:
&gt; using an identifier will discourage us from making cosmetic
&gt; compatibility-breaking improvements to reasons in the future.

Yes, REASON is an identifier, not an arbitrary string. It is one of the
same set of words that REASON can be in the ORCONN failure status events.

&gt; Question: are bootstrapping events meant to be sent only during the
&gt; initial setup phase, or might they appear later if Tor needs to
&gt; bootstrap again?  In other words, should controllers expect to see
&gt; only a monotonically increasing series of phase numbers, or should
&gt; they be ready for a Tor to tell them, "I am no longer a bootstrapped
&gt; Tor; I'm back at phase X"?

Currently they only appear at initial bootstrap, and they only increase.

We might change either of those in the future though. I haven't really
figured out an intuitive way to let the bootstrapping progress bar move
backward though; I've heard many complaints about Microsoft progress
bars that zip around so much that you can't make any guesses about how
much progress you've made.

&gt; &gt;   Phase 0:
&gt; &gt;   tag=starting summary="starting"
&gt; &gt; 
&gt; &gt;   Tor starts out in this phase. It doesn't actually send a status event
&gt; &gt;   to say so.
&gt; 
&gt; What's it for, then?  

It's basically just an internal state. We won't ever actually send the
event in practice, because there will never be a controller attached at
the point when the event happens.

In any case, now that I've added "getinfo status/bootstrap-phase", which
the controller can use to get up to speed on Tor's current situation when
it connects, we initialize to the Starting state and the controller can
learn about it with the getinfo.
http://archives.seul.org/or/cvs/Jun-2008/msg00438.html

&gt; &gt;   Tor will stay at this phase until it has successfully established
&gt; &gt;   a TCP connection with some directory mirror. Problems in this phase
&gt; &gt;   generally happen because Tor doesn't have a network connection, or
&gt; &gt;   because the local firewall is dropping SYN packets.
&gt; &gt; 
&gt; &gt;   Phase 10
&gt; &gt;   tag=handshake_dir summary="Finishing handshake with directory mirror"
&gt; &gt; 
&gt; &gt;   This event occurs when Tor establishes a TCP connection with a relay
&gt; &gt;   (or its https proxy if it's using one). Tor remains in this phase until
&gt; &gt;   the TLS handshake with the relay is finished.
&gt; 
&gt; Do you mean to say "relay" here?  I know all directories are relays,
&gt; but it might be more reasonable to call the server in question a
&gt; "directory".

Ah. This is a terminology question that goes broader than this proposal.
To me, a directory is a signed string. There are directory servers that
serve the directory.

In any case, here I really do mean relay, since we're connecting to
a relay's ORPort and doing a Tor handshake with it. We could imagine
having Tors that allow Tor handshakes but don't actually relay traffic;
but we don't have those currently so it seems a moot point.

(Bootstrapping phases for folks not using PreferTunneledDirConns are not
well-defined yet. It seems like an edge case that isn't urgent to tackle.)

&gt;  [...]
&gt; &gt;   Phase 25:
&gt; &gt;   tag=loading_status summary="Loading networkstatus consensus"
&gt; &gt; 
&gt; &gt;   Once we've established a directory connection, we will start fetching
&gt; &gt;   the networkstatus consensus document. This could take a while; this
&gt; &gt;   phase is a good opportunity for using the "progress" keyword to indicate
&gt; &gt;   partial progress.
&gt; &gt; 
&gt; &gt;   This phase could stall if the directory mirror we picked doesn't
&gt; &gt;   have a copy of the networkstatus consensus so we have to ask another,
&gt; &gt;   or it does give us a copy but we don't find it valid.
&gt; 
&gt; If we fall back to another directory, do we go back to phase 5?  It
&gt; would seem reasonable...

Not currently. I've been more treating the bootstrapping phases as "things
Tor managed to successfully do", rather than what Tor is actually up
to at the time. That way when it's been sitting in the same phase for
a while, you can start being concerned that Tor is having a hard time
doing whatever phase it's stuck on.

&gt; We should also say what the scope of reason strings are.  Does a
&gt; reason always mean the same thing with tag X as it does with tag Y?

I don't think we've thought that far ahead. Currently I think the answer
is yes, insofar as the tags are things like "NOROUTE" and that has pretty
general meaning. But I'd like to leave their exact meaning vague for now,
until we have a better sense of what we want to do with them.

&gt; &gt;   Currently Tor ignores the first nine bootstrap problem reports for
&gt; &gt;   a given phase, reports the tenth to the controller, and then ignores
&gt; &gt;   further problems at that phase. Hopefully this is a good balance between
&gt; &gt;   tolerating occasional errors and reporting serious problems quickly. (We
&gt; &gt;   will want to revisit this approach if there are many different 'reason'
&gt; &gt;   values being reported among the first ten problem reports, since in
&gt; &gt;   this case the controller will only hear one of them.)
&gt; 
&gt; This is ugly and fragile.  Instead of suppressing N failures and
&gt; reporting the N+1th, we should report all the failures, perhaps with a
&gt; count of how many have occurred so far or an indication of when we'll
&gt; next retry.  We should also offer advice to controller developers
&gt; about when they should report failures.  (Perhaps: "Wait for X
&gt; failures in any phase before deciding the phase is hopeless."  Or
&gt; perhaps: "After a failure, wait X seconds to see if Tor recovers and
&gt; the phase advances before deciding the phase is stalled.  Wait Y
&gt; seconds longer before deciding the phase is hopeless."  Or perhaps:
&gt; "If the retry time on any failure is 'now' or under 30 seconds from
&gt; now, Tor believes it can fix the problem itself.")

Actually, it turns out that it's more complex than this: while waiting
for 10 connect failures before complaining may be reasonable for a normal
relay, a bridge user may be totally screwed after just one failure,
e.g. if he only has one bridge. Similarly, a Tor client in a private
network may not have 10 different relays to try. So I think you're right
that we should report every potential problem, but I think we also need
to give the controller some hint about which problem we think is the
final straw and it's time to get the user involved.

Maybe we should report them all, and include a
RECOMMENDATION=WARN when we hit a threshold (and the threshold will vary
depending on Tor's internal config).

The problem with giving advice to controller operators like "blindly wait
X seconds and then you'll know there's a problem" is that Tor takes a
hugely different amount of time to bootstrap, and thus to encounter a
threshold of problems, on a tiny modem vs a university connection. 30
seconds might be enough to try only a few connections on a really crappy
line. Tor is the one that knows what's going on internally, so it would
seem that it should be the one to call the shots, right?

&gt; &gt;   Controllers should also have some mechanism to alert their user when
&gt; &gt;   bootstrapping problems are reported. Perhaps we should gather a set of
&gt; &gt;   help texts and the controller can send the user to the right anchor in a
&gt; &gt;   "bootstrapping problems" help page?
&gt; 
&gt; This brings up an interesting issue.  There are lots of pieces of
&gt; translatable text that could reasonably used across different UIs.
&gt; We'd prefer not to stick them in Tor, since Tor doesn't get
&gt; internationalized.  But making each tool maintain their own lists is
&gt; also a little sad, since it results in a bit much duplication of
&gt; effort.  Thoughts?

No thoughts, other than that you're right that my Warning strings won't
get used much in practice. I had figured Vidalia would just grab them
and use them, but Matt needed to make his own Qt strings so the Vidalia
translators could translate them. So now the Warning strings are there to
help Tor debugging, and in case somebody wants to make a really trivial
controller and not have to worry about strings.

In the future it might be that the Warning strings are not simply the
output of strerror, but rather they speculate about what exact problem
your Tor is having. But even then, that should be resolved by making up
more Tags, not by trying to show a carefully crafted English string to a
user who only knows Italian. Should we just get rid of the Warning string?

--Roger

</body></email><email><emailId>20080615220644</emailId><senderName>Peter Palfrader</senderName><senderEmail>peter@palfrader.org</senderEmail><timestampReceived>2008-06-15 22:06:44-0400</timestampReceived><subject>draft proposal: download server descriptors on demand</subject><body>

Hi,

this is my working draft for the just in time download of SDs proposal.
It's still rough, it has a few easier things not speced out, like how we
want to convey load balancing weights in the consensus, and doesn't yet
contain much useful about how we will do exit selection.

Nick, if I could get a proposal number for this I could edit it in svn.

-- 
weasel


Filename: xxx-jit-sd-downloads
Title: Download server descriptors on demand
Version: $Revision$
Last-Modified: $Date$
Author: Peter Palfrader
Created: 15-Jun-2008
Status: Draft

1. Overview

  Downloading all server descriptors is the most expensive part
  of bootstrapping a Tor client.  These server descriptors currently
  amount to about 1.5 Megabytes of data, and this size will grow
  linearly with network size.

  Fetching all these server descriptors takes a long while for people
  behind slow network connections.  It is also a considerable load on
  our network of directory mirrors.

  This document describes proposed changes to the Tor network and
  directory protocol so that clients will no longer need to download
  all server descriptors.

  These changes consist of moving load balancing information into
  network status documents, implementing a means to download server
  descriptors on demand in an anonymity-preserving way, and dealing
  with exit node selection.

2. What is in a server descriptor

  When a Tor client starts the first thing it will try to get is a
  current network status document, a consensus signed by a majority
  of directory authorities.  This document is currently about 100
  Kilobytes in size, tho it will grow linearly with network size.
  This document lists all servers currently running on the network.
  The Tor client will then try to get a server descriptor for each
  of the running servers.  All server descriptors currently amount
  to about 1.5 Metabytes of downloads.

  A Tor client learns several things about a server from its descriptor.
  Some of these it already learned from the network status document
  published by the authorities, but the server descriptor contains it
  again in a single statement signed by the server itself, not just by
  the directory authorities.

  Tor clients use the information from server descriptors for
  different purposes, which are considered in the following sections.

  #three ways:  One, to determine if a server will be able to handle
  #this client's request; two, to actually communicate or use the server;
  #three, for load balancing decisions.
  #
  #These three points are considered in the following subsections.

2.1 Load balancing

  The Tor load balancing mechanism is quite complex in its details, but
  it has a simple goal: The more traffic a server can handle the more
  traffic it should get.  That means the more traffic a server can
  handle the more likely a client will use it.

  For this purpose each server descriptor has bandwidth information
  which tries to convey a server's capacity to clients.

  Currently we weigh servers differently for different purposes.  There
  is a weigh for when we use a server as a guard node (our entry to the
  Tor network), there is one weigh we assign servers for exit duties,
  and a third for when we need intermediate (middle) nodes.

2.2 Exit information

  When a Tor wants to exit to some resource on the internet it will
  build a circuit to an exit node that allows access to that resource's
  IP address and TCP Port.

  When building that circuit the client can make sure that the circuit
  ends at a server that will be able to fulfill the request because the
  client already learned of all the servers' exit policies from their
  descriptors.

2.3 Capability information

  Server descriptors contain information about the specific version or
  the Tor protocol they understand [proposal 105].

  Furthermore the server descriptor also contains the exact version of
  the Tor software that the server is running and some decisions are
  made based on the server version number (for instance a Tor client
  will only make conditional consensus requests [proposal from 13 Apr
  2008 that never got a number] when talking to Tor servers version
  0.2.1.1-alpha or later).

2.4 Contact/key information

  A server descriptor lists a server's IP address and TCP ports on which
  it accepts onion and directory connections.  Furthermore it contains
  the onion key, a short lived RSA key to which clients encrypt CREATE
  cells.

2.5 Identity information

  A Tor client learns the digest of a server's key from the network
  status document.  Once it has a server descriptor this descriptor
  contains the full RSA identity key of the server.  Clients verify
  that 1) the digest of the identity key matches the expected digest
  it got from the consensus, and 2) that the signature on the descriptor
  from that key is valid.


3. Doing away with the need for all SDs

3.1 Load balancing info in consensus documents

  One of the reasons why clients download all server descriptors is for
  doing load proper load balancing as described in 2.1.  In order for
  clients to not require all server descriptors this information will
  have to move into the network status document.

  [XXX Two open questions here:
   a) how do we arrive at a consensus weight?
   b) how to represent weights in the consensus?
      Maybe "s Guard=0.13 Exit=0.02 Middle=0.00 Stable.."
  ]

3.2 Fetching descriptors on demand

  As described in 2.4 a descriptor lists IP address, OR- and Dir-Port,
  and the onion key for a server.

  A client already knows the IP address and the ports from the consensus
  documents, but without the onion key it will not be able to send
  CREATE/EXTEND cells for that server.  Since the client needs the onion
  key it needs the descriptor.

  If a client only downloaded a few descriptors in an observable manner
  then that would leak which nodes it was going to use.

  This proposal suggests the following:

  1) when connecting to a guard node for which the client does not
     yet have a cached descriptor it requests the descriptor it
     expects by hash.  (The consensus document that the client holds
     has a hash for the descriptor of this server.  We want exactly
     that descriptor, not a different one.)

     [XXX: How?  We could either come up with a new cell type,
      RELAY_REQUEST_SD that takes only a hash (of the SD), or use
      RELAY_BEGIN_DIR.  The former is probably smarter since we will
      want to use it later on as well, and there we will require
      padding.]

     A client MAY cache the descriptor of the guard node so that it does
     not need to request it every single time it contacts the guard.

  2) when a client wants to extend a circuit that currently ends in
     server B to a new next server C, the client will send a
     RELAY_REQUEST_SD cell to server B.  This cell contains in its
     payload the hash of a server descriptor the client would like
     to obtain (C's server descriptor).  The server sends back the
     descriptor and the client can now form a valid EXTEND/CREATE cell
     encrypted to C's onion key.

     Clients MUST NOT cache such descriptors.  If they did they might
     leak that they already extended to that server at least once
     before.

  Replies to RELAY_REQUEST_SD requests need to be padded to some
  constant upper limit in order to conceal a client's destination
  from anybody who might be counting cells/bytes.

  [XXX: detailed spec of RELAY_REQUEST_SD cell and its reply]
  [XXX: figure out a decent padding size]

3.3 Protocol versions

  [XXX: find out where we need "opt protocols Link 1 2 Circuit 1"
  information described in 2.3 above.  If we need it, it might have
  to go into the consensus document.]

  [XXX: Similarly find out where we need the version number of a
  remote tor server.  This information is in the consensus, but
  maybe we use it in some place where having it signed by the
  server in question is really important?]

3.4 Exit selection

  Currently finding an appropriate exit node for a user's request is
  easy for a client because it has complete knowledge of all the exit
  policies of all servers on the network.

  [XXX: I have no finished ideas here yet.
    - if clients only rely on the current exit flag they will
      a) never use servers for exit purposes that don't have it,
      b) will have a hard time finding a suitable exit node for
         their weird port that only a few servers allow.
    - the authorities could create a new summary document that
      lists all the exit policies and their nodes (by fingerprint).
      I need to find out how large that document would be.
    - can we make the "Exit" flag more useful?  can we come
      up with some "standard policies" and have operators pick
      one of the standards?
  ]

4. Future possibilities

  This proposal still requires that all servers have the descriptors of
  every other node in the network in order to answer RELAY_REQUEST_SD
  cells.  These cells are sent when a circuit is extended from ending at
  node B to a new node C.  In that case B would have to answer a
  RELAY_REQUEST_SD cell that asks for C's server descriptor (by SD digest).

  In order to answer that request B obviously needs a copy of C's server
  descriptor.  In the future we might amend RELAY_REQUEST_SD cells to
  contain also the expected IP address and OR-port of the server C (the
  client learns them from the network status document), so that B no
  longer needs to know all the descriptors of the entire network but
  instead can simply go and ask C for its descriptor before passing it
  back to the client.


</body></email><email><emailId>20080616011559</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-06-16 01:15:59-0400</timestampReceived><subject>Re: draft proposal: download server descriptors on demand</subject><body>

On Mon, Jun 16, 2008 at 12:06:44AM +0200, Peter Palfrader wrote:
&gt; Hi,
&gt; 
&gt; this is my working draft for the just in time download of SDs proposal.
&gt; It's still rough, it has a few easier things not speced out, like how we
&gt; want to convey load balancing weights in the consensus, and doesn't yet
&gt; contain much useful about how we will do exit selection.
&gt; 
&gt; Nick, if I could get a proposal number for this I could edit it in svn.

Hi, Peter!  For working drafts that you don't want to actually propose
yet, please use the ideas directory in proposals.  If you want it to
be a proposal, though, ping me for a number.

yrs,
-- 
Nick
</body></email><email><emailId>20081110122400</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2008-11-10 12:24:00-0400</timestampReceived><subject>Re: draft proposal: download server descriptors on demand</subject><body>

On Mon, Jun 16, 2008 at 12:06:44AM +0200, Peter Palfrader wrote:
&gt;   Tor clients use the information from server descriptors for
&gt;   different purposes, which are considered in the following sections.
&gt; 
&gt;   #three ways:  One, to determine if a server will be able to handle
&gt;   #this client's request; two, to actually communicate or use the server;
&gt;   #three, for load balancing decisions.
&gt;   #
&gt;   #These three points are considered in the following subsections.
[snip]
&gt; 2.4 Contact/key information
&gt; 
&gt;   A server descriptor lists a server's IP address and TCP ports on which
&gt;   it accepts onion and directory connections.  Furthermore it contains
&gt;   the onion key, a short lived RSA key to which clients encrypt CREATE
&gt;   cells.
&gt; 
&gt; 3.2 Fetching descriptors on demand
&gt; 
&gt;   As described in 2.4 a descriptor lists IP address, OR- and Dir-Port,
&gt;   and the onion key for a server.
&gt; 
&gt;   A client already knows the IP address and the ports from the consensus
&gt;   documents, but without the onion key it will not be able to send
&gt;   CREATE/EXTEND cells for that server.  Since the client needs the onion
&gt;   key it needs the descriptor.
[snip]

I've been brainstorming with weasel. We hashed out some more details
about how to proceed if we want to finish this piece of proposal 141.

The next step is to spec out a new RELAY_REQUEST_SD relay cell. For
example:

  version        [1 byte]
  stream_id      [2 bytes]
  padding length [2 bytes]
  SD fingerprint [20 bytes]

We use a new relay cell type, since begin_dir introduces extra roundtrips,
and worse, doesn't support descriptor padding so it leaks to an observer
how big a descriptor we just fetched.

Replies to RELAY_REQUEST_SD requests need to be padded to some constant
upper limit in order to conceal a client's destination from anybody who
might be counting cells/bytes. The recommended padding size should be
a public parameter in the consensus. (That means we can tell which dir
the client is using when we just changed that value, but that shouldn't
happen often.)

For starters, a suitable padding length is 4KB. Current biggest
descriptors are:
  3640 server-descriptor/1/e/1e2c860f76be78b03bf7d2a4fb7f9fbef726c43f
  3655 server-descriptor/b/e/bea2ce2c31a00046c2e9700b2338eb8c48b148b2
  4069 server-descriptor/9/c/9c116b33ae4c117c07d61815428027a4ba3287ed
  7850 server-descriptor/5/e/5ed3ee0b6f151652ddc0bda6822729c1918c9201
and if we compress the answers, that 7850 byte one compresses to 2362
bytes. (Large descriptors generally have large exit policies, which
compress well.)

The authorities need to stop accepting SDs that don't fit in
the padding. Right now authorities reject SDs that are over 20KB
uncompressed. Should they compress them on the fly when deciding whether
to accept them or send back an error? That seems like a DoS attack waiting
to happen. Should we get relays to compress them before uploading? No,
because then they could upload compression bombs. Conclusion is a) relays
should test-compress them first and decline to upload if they're over the
current published padding size; b) authorities should try compressing them
at their leisure before putting them into a consensus vote, and drop if
too big; and c) the 4KB limit should be enough overhead that most relays
will have upgraded to the test-compress-first code before it bites them.

Since the client specifies the padding in the RELAY_REQUEST_SD cell, it
also can tell when the response is finished: it's done when the correct
number of relay cells come back.

(We could have picked a lower default padding cap, like 2KB, on the
theory that all reasonable descriptors fit in it. But I figured 4KB
doesn't hurt too much, first so we can have the breathing room above,
and second because Tor isn't bad at pushing n+1 cells when it's already
pushing n -- it's the round trips that kill us, not the throughput.)

How relays answer the request is easy: they just stick the answers
split over a series of RELAY_ANSWER_SD relay cells, and the client
pieces them together.

How do we build it on the client code-wise? Probably one of those 'linked'
connections like we use for begindir requests is the right move, since
then it'll have a buf already set up that accumulates bytes until the
stream is finished.

So the plan would be a) teach relays how to answer the request, b) teach
clients how to ask it so we can test, c) wait until lots of relays support
it, d) teach clients to ask when the relay is of a sufficient version,
e) teach clients to stop fetching descriptors the normal way.

Somewhere in there, we'd also want to make sure that every relay that
supports this feature mirrors all the descriptors, so they're present
when requested.

Ok. So those are my notes on how to proceed in the current direction. In
my next post I will describe a radical departure that is much easier
to build.

--Roger

</body></email><email><emailId>20081110133959</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2008-11-10 13:39:59-0400</timestampReceived><subject>Re: draft proposal: download server descriptors on demand</subject><body>

On Mon, Nov 10, 2008 at 07:24:00AM -0500, Roger Dingledine wrote:
&gt; &gt; 2.4 Contact/key information
&gt; &gt; 
&gt; &gt;   A server descriptor lists a server's IP address and TCP ports on which
&gt; &gt;   it accepts onion and directory connections.  Furthermore it contains
&gt; &gt;   the onion key, a short lived RSA key to which clients encrypt CREATE
&gt; &gt;   cells.
&gt; 
&gt; So the plan would be a) teach relays how to answer the request, b) teach
&gt; clients how to ask it so we can test, c) wait until lots of relays support
&gt; it, d) teach clients to ask when the relay is of a sufficient version,
&gt; e) teach clients to stop fetching descriptors the normal way.
&gt; 
&gt; Somewhere in there, we'd also want to make sure that every relay that
&gt; supports this feature mirrors all the descriptors, so they're present
&gt; when requested.
&gt; 
&gt; Ok. So those are my notes on how to proceed in the current direction. In
&gt; my next post I will describe a radical departure that is much easier
&gt; to build.

The new crazy variant is to make clients, and eventually relays, never
see server descriptors at all.

Basically the only thing that clients need that isn't in the consensus now
is the onion key. (They only need identity keys for their entry guards,
and in that case they learn the identity key from the TLS handshake.)

One option is just to stick onion keys in the consensus.
  265090 2008-11-10-10:00:00-consensus
  220223 Okeys
  485313 together
  241365 together.gz
   89874 2008-11-10-10:00:00-consensus.gz
Ok, so that represents a serious increase in the consensus size. Keys
are huge and don't compress very well.

So instead we should do like proposal 141, but fetch the onion key on
demand, rather than the descriptor. The new RELAY_REQUEST_OKEY relay
cell just sends back the onion key. It fits in one cell, so there's no
need to mess with this global padding parameter thing, or compressing
descriptors on the fly, or teaching relays to test if their descriptor
is too big, etc.

Clients never learn exact exit policies now. That means we need to
make exit policies snap-to-fit better into the summaries we put in the
consensus document. But that's true with the old approach to proposal
141 too. The only difference is that now we just try the BEGIN request,
and get end-reason-exit-policy if we guessed wrong and then try elsewhere.

We actually want RELAY_REQUEST_OKEY to be more general, in case there
are other items we want to communicate that we only summarize in the
consensus. RELAY_REQUEST_DETAILS, maybe.

How do the mirrors learn the onion keys? Authorities now produce both a
"mirror consensus" and a "client consensus". They differ in that the
mirror consensus includes the SD hash, descriptor timestamp, and the
onion key; and the client consensus has the OKey hash.

(I worry about consensus synchronization questions. One easy way to
generate them safely is for the authorities to only run their consensus
algorithm on the mirror consensus, generate signatures on that, and then
have a deterministic transform from mirror consensus to client consensus,
and then they generate signatures on that too. Then they ship the blob
with both types of signatures, and mirrors can serve whichever they like.)

With these changes, the client-consensus takes a bit less space than the
current consensus (we basically replace the SD hash and timestamp with
the OKey hash). Even better, consensus diffs (proposal 140) become much
much smaller, since we remove the primary sources of change between one
consensus and the next.

In this model, the authorities still serve the real server descriptors,
so people with esoteric interests (like for torstatus) can fetch them.

Downsides for my crazy idea?

Well, first, it makes it even more starkly clear how much clients trust
the threshold of directory authorities. I would argue that the actual
control clients have over their security doesn't actually change,
though. Also note that since the real server descriptors still exist,
we don't preclude other more decentralized directory mechanisms in
the future or alongside this one. For example, clients are welcome to
continue fetching and caching server descriptors from their bridges,
so they can know bandwidth estimates and other load balancing info.

Another downside is that we have to restrict exit policies pretty
thoroughly. It looks like we were already heading in that direction for
the original proposal 141 too though.

Any other downsides? :)

Now, time to consider some optimizations:

Optimization one: I could be convinced that with consensus diffs,
putting the onion key in the consensus wouldn't be so bad. Or we can put
OKey hashes in the consensus, and then let clients fetch and cache the
onion keys they're missing. They don't change very often at all. Either
way, now we wouldn't have to introduce any new relay cells, and no new
round-trips during circuit generation, and relays don't need a global
view of anything unless they want one. Sure is tempting.

Optimization two is that we could cut out the separate round-trip for
the RELAY_REQUEST_DETAILS relay cell if we wrap it into the CREATE cell.
That is, we could bump the circuit protocol version, and cram more
stuff into the CREATE cell like we've been meaning to, and one of the
new items would be the fingerprint for the intended next hop. Then
the relay can send back a CREATED followed directly by a (series of)
RELAY_HERE'S_YOUR_DETAILS relay cell(s). This step shouldn't be taken
lightly though, a) because it requires bumping the circuit protocol
version (an all-syrup super squishy? such a thing has never been done!),
b) because Ian showed up our create cells are darn fragile already,
so let's be careful putting anything else in them, and c) because the
fingerprint of the next hop is only encrypted to the onion key, and thus
isn't covered by the PFS you'd get if you wait for the CREATED cell first.

--Roger

</body></email><email><emailId>20080611053824</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2008-06-11 05:38:24-0400</timestampReceived><subject>Proposal 137: Keep controllers informed as Tor bootstraps</subject><body>

I've implemented all the Tor side of this proposal in Tor svn trunk. I'd
love to have some controllers implement their side of it, and let me
know how it goes and what is too klunky to handle well.

Thanks!
--Roger

Filename: 137-bootstrap-phases.txt
Title: Keep controllers informed as Tor bootstraps
Version: $Revision: 15122 $
Last-Modified: $Date: 2008-06-11 01:34:07 -0400 (Wed, 11 Jun 2008) $
Author: Roger Dingledine
Created: 07-Jun-2008
Status: Open

1. Overview.

  Tor has many steps to bootstrapping directory information and
  initial circuits, but from the controller's perspective we just have
  a coarse-grained "CIRCUIT_ESTABLISHED" status event. Tor users with
  slow connections or with connectivity problems can wait a long time
  staring at the yellow onion, wondering if it will ever change color.

  This proposal describes a new client status event so Tor can give
  more details to the controller. Section 2 describes the changes to the
  controller protocol; Section 3 describes Tor's internal bootstrapping
  phases when everything is going correctly; Section 4 describes when
  Tor detects a problem and issues a bootstrap warning; Section 5 covers
  suggestions for how controllers should display the results.

2. Controller event syntax.

  The generic status event is:

    "650" SP StatusType SP StatusSeverity SP StatusAction
                                        [SP StatusArguments] CRLF

  So in this case we send
  650 STATUS_CLIENT NOTICE/WARN BOOTSTRAP \
  PROGRESS=num TAG=string SUMMARY=string WARNING=string REASON=string

  "Progress" gives a number between 0 and 100 for how far through
  the bootstrapping process we are. "Summary" is a string that can be
  displayed to the user to describe the *next* task that Tor will tackle,
  i.e., the task it is working on after sending the status event. "Tag"
  is an optional string that controllers can use to recognize bootstrap
  phases from Section 3, if they want to do something smarter than just
  blindly displaying the summary string.

  The severity describes whether this is a normal bootstrap phase
  (severity notice) or an indication of a bootstrapping problem
  (severity warn). If severity warn, it should also include a "warning"
  argument string with any hints Tor has to offer about why it's having
  troubles bootstrapping, and a "reason" string that lists of the reasons
  allowed in the ORConn event.

3. The bootstrap phases.

  This section describes the various phases currently reported by
  Tor. Controllers should not assume that the percentages and tags listed
  here will continue to match up, or even that the tags will stay in
  the same order. Some phases might also be skipped (not reported) if the
  associated bootstrap step is already complete.

  Phase 0:
  tag=starting summary="starting"

  Tor starts out in this phase. It doesn't actually send a status event
  to say so.

  Phase 5:
  tag=conn_dir summary="Connecting to directory mirror"

  Tor sends this event as soon as Tor has chosen a directory mirror ---
  one of the authorities if bootstrapping for the first time or after
  a long downtime, or one of the relays listed in its cached directory
  information otherwise.

  Tor will stay at this phase until it has successfully established
  a TCP connection with some directory mirror. Problems in this phase
  generally happen because Tor doesn't have a network connection, or
  because the local firewall is dropping SYN packets.

  Phase 10
  tag=handshake_dir summary="Finishing handshake with directory mirror"

  This event occurs when Tor establishes a TCP connection with a relay
  (or its https proxy if it's using one). Tor remains in this phase until
  the TLS handshake with the relay is finished.

  Problems in this phase generally happen because Tor's firewall is
  doing more sophisticated MITM attacks on it, or doing packet-level
  keyword recognition of Tor's handshake.

  Phase 15:
  tag=onehop_create summary="Establishing one-hop circuit for dir info"

  Once TLS is finished with a relay, Tor will send a CREATE_FAST cell
  to establish a one-hop circuit for retrieving directory information.
  It will remain in this phase until it receives the CREATED_FAST cell
  back, indicating that the circuit is ready.

  Phase 20:
  tag=requesting_status summary="Asking for networkstatus consensus"

  Once we've finished our one-hop circuit, we will start a new stream
  for fetching the networkstatus consensus. We'll stay in this phase
  until we get the 'connected' relay cell back, indicating that we've
  established a directory connection.

  Phase 25:
  tag=loading_status summary="Loading networkstatus consensus"

  Once we've established a directory connection, we will start fetching
  the networkstatus consensus document. This could take a while; this
  phase is a good opportunity for using the "progress" keyword to indicate
  partial progress.

  This phase could stall if the directory mirror we picked doesn't
  have a copy of the networkstatus consensus so we have to ask another,
  or it does give us a copy but we don't find it valid.

  Phase 40:
  tag=loading_keys summary="Loading authority key certs"

  Sometimes when we've finished loading the networkstatus consensus,
  we find that we don't have all the authority key certificates for the
  keys that signed the consensus. At that point we put the consensus we
  fetched on hold and fetch the keys so we can verify the signatures.

  Phase 45
  tag=requesting_descriptors summary="Asking for relay descriptors"

  Once we have a valid networkstatus consensus and we've checked all
  its signatures, we start asking for relay descriptors. We stay in this
  phase until we have received a 'connected' relay cell in response to
  a request for descriptors.

  Phase 50:
  tag=loading_descriptors summary="Loading relay descriptors"

  We will ask for relay descriptors from several different locations,
  so this step will probably make up the bulk of the bootstrapping,
  especially for users with slow connections. We stay in this phase until
  we have descriptors for at least 1/4 of the usable relays listed in
  the networkstatus consensus. This phase is also a good opportunity to
  use the "progress" keyword to indicate partial steps.

  Phase 80:
  tag=conn_or summary="Connecting to entry guard"

  Once we have a valid consensus and enough relay descriptors, we choose
  some entry guards and start trying to build some circuits. This step
  is similar to the "conn_dir" phase above; the only difference is
  the context.

  If a Tor starts with enough recent cached directory information,
  its first bootstrap status event will be for the conn_or phase.

  Phase 85:
  tag=handshake_or summary="Finishing handshake with entry guard"

  This phase is similar to the "handshake_dir" phase, but it gets reached
  if we finish a TCP connection to a Tor relay and we have already reached
  the "conn_or" phase. We'll stay in this phase until we complete a TLS
  handshake with a Tor relay.

  Phase 90:
  tag=circuit_create "Establishing circuits"

  Once we've finished our TLS handshake with an entry guard, we will
  set about trying to make some 3-hop circuits in case we need them soon.

  Phase 100:
  tag=done summary="Done"

  A full 3-hop circuit has been established. Tor is ready to handle
  application connections now.

4. Bootstrap problem events.

  When an OR Conn fails, we send a "bootstrap problem" status event, which
  is like the standard bootstrap status event except with severity warn.
  We include the same progress, tag, and summary values as we would for
  a normal bootstrap event, but we also include 'warning' and 'reason'
  strings.

  The reason string is the same argument as the reason string for ORCONN
  failure events; the controller can recognize the various reasons
  and help the user accordingly. The warning string currently tries to
  provide the equivalent of strerror() -- this isn't very useful if the
  controller can recognize reason tags and be smarter, but for a very
  simple controller it should be better than nothing.

  Currently Tor ignores the first nine bootstrap problem reports for
  a given phase, reports the tenth to the controller, and then ignores
  further problems at that phase. Hopefully this is a good balance between
  tolerating occasional errors and reporting serious problems quickly. (We
  will want to revisit this approach if there are many different 'reason'
  values being reported among the first ten problem reports, since in
  this case the controller will only hear one of them.)

5. Suggested controller behavior.

  Controllers should start out with a yellow onion or the equivalent
  ("starting"), and then watch for either a bootstrap status event
  (meaning the Tor they're using is sufficiently new to produce them,
  and they should load up the progress bar or whatever they plan to use
  to indicate progress) or a circuit_established status event (meaning
  bootstrapping is finished).

  In addition to a progress bar in the display, controllers should also
  have some way to indicate progress even when no controller window is
  open. For example, folks using Tor Browser Bundle in hostile Internet
  cafes don't want a big splashy screen up. One way to let the user keep
  informed of progress in a more subtle way is to change the task tray
  icon and/or tooltip string as more bootstrap events come in.

  Controllers should also have some mechanism to alert their user when
  bootstrapping problems are reported. Perhaps we should gather a set of
  help texts and the controller can send the user to the right anchor in a
  "bootstrapping problems" help page?

</body></email><email><emailId>20080613224403</emailId><senderName>Peter Palfrader</senderName><senderEmail>peter@palfrader.org</senderEmail><timestampReceived>2008-06-13 22:44:03-0400</timestampReceived><subject>Proposal: Provide diffs between consensuses</subject><body>

Questions:

  - How old can a consensus be for us to try to fetch a diff.
    We could of course always try to fetch a diff, but how smart
    is it to let a dirserver know that we were last online 3.8 days
    ago?
  - Do we agree on using the ed patch format?
  - What to do when the client already has the latest consensus


Filename: xxx-consensus-diffs
Title: Provide diffs between consensuses
Version: $Revision$
Last-Modified: $Date$
Author: Peter Palfrader
Created: 13-Jun-2008
Status: Open

1. Overview.

  Tor clients and servers need a list of which relays are on the
  network.  This list, the consensus, is created by authorities
  hourly and clients fetch a copy of it, with some delay, hourly.

  This proposal suggests that clients download diffs of consensuses
  once they have a consensus instead of hourly downloading a full
  consensus.

2. Numbers

  After implementing proposal 138 which removes nodes that are not
  running from the list a consensus document is about 92 kilobytes
  in size after compression.

  The diff between two consecutive consensus, in ed format, is on
  average 13 kilobytes compressed.

3. Proposal

3.1 Clients

  If a client has a consensus that is recent enough it SHOULD
  try to download a diff to get the latest consensus rather than
  fetching a full one.

  [XXX: what is recent enough?
	time delta in hours / size of compressed diff
	 0	20
	 1	9650
	 2	17011
	 3	23150
	 4	29813
	 5	36079
	 6	39455
	 7	43903
	 8	48907
	 9	54549
	10	60057
	11	67810
	12	71171
	13	73863
	14	76048
	15	80031
	16	84686
	17	89862
	18	94760
	19	94868
	20	94223
	21	93921
	22	92144
	23	90228
	[ size of gzip compressed "diff -e" between the consensus on
	  2008-06-01-00:00:00 and the following consensuses that day.
	  Consensuses have been modified to exclude down routers per
	  proposal 138. ]

   Data suggests that for the first few hours diffs are very useful,
   saving about 60% for the first three hours, 30% for the first 10,
   and almost nothing once we are past 16 hours.
  ]

3.2 Servers

  Directory authorities and servers need to keep up to X [XXX: depends
  on how long clients try to download diffs per above] old consensus
  documents so they can build diffs.  They should offer a diff to the
  most recent consensus at the URL

  http://tor.noreply.org/tor/status-vote/current/consensus/diff/&lt;HASH&gt;/&lt;FPRLIST&gt;

  where hash is the full digest of the consensus the client currently
  has, and FPRLIST is a list of (abbreviated) fingerprints of
  authorities the client trusts.

  Servers will only return a consensus if more than half of the requested
  authorities have signed the document, otherwise a 404 error will be sent
  back.  The fingerprints can be shortened to a length of any multiple of
  two, using only the leftmost part of the encoded fingerprint.  Tor uses
  3 bytes (6 hex characters) of the fingerprint.  (This is just like the
  conditional consensus downloads that Tor supports starting with
  0.1.2.1-alpha.)

  If a server cannot offer a diff from the consensus identified by the
  hash but has a current consensus it MUST return the full consensus.

  [XXX: what should we do when the client already has the latest
  consensus?  I can think of the following options:
    - send back 3xx not modified
    - send back 200 ok and an empty diff
    - send back 404 nothing newer here.

    I currently lean towards the empty diff.]

4. Diff Format

  Diffs start with the token "network-status-diff-version" followed by a
  space and the version number, currently "1".

  If a document does not start with network-status-diff it is assumed
  to be a full consensus download and would therefore currently start
  with "network-status-version 3".

  Following the network-status-diff header line is a diff, or patch, in
  limited ed format.  We choose this format because it is easy to create
  and process with standard tools (patch, diff -e, ed).  This will help
  us in developing and testing this proposal and it should make future
  debugging easier.

  [ If at one point in the future we decide that the space benefits from
    a custom diff format outweighs these benefits we can always
    introduce a new diff format and offer it at for instance
    ../diff2/... ]

  We support the following ed commands, each on a line by itself:
   - "&lt;n1&gt;d"          Delete line n1
   - "&lt;n1&gt;,&lt;n2&gt;d"     Delete lines n1 through n2, including
   - "&lt;n1&gt;c"          Replace line n1 with the following block
   - "&lt;n1&gt;,&lt;n2&gt;c"     Replace lines n1 through n2, including, with the
                      following block.
   - "&lt;n1&gt;a"          Append the following block after line n1.
   - "a"              Append the following block after the current line.
   - "s/.//"          Remove the first character in the current line.

  Note that line numbers always apply to the file after all previous
  commands have already been applied.

  The "current line" is either the first line of the file, if this is
  the first command, the last line of a block we added in an append or
  change command, or the line immediate following a set of lines we just
  deleted (or the last line of the file if there are no lines after
  that).

  The replace and append command take blocks.  These blocks are simply
  appended to the diff after the line with the command.  A line with
  just a period (".") ends the block (and is not part of the lines
  to add).  Note that it is impossible to insert a line with just
  a single dot.  Recommended procedure is to insert a line with
  two dots, then remove the first character of that line using s/.//.

</body></email><email><emailId>20080616011432</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-06-16 01:14:32-0400</timestampReceived><subject>Re: Proposal: Provide diffs between consensuses</subject><body>

On Sat, Jun 14, 2008 at 12:44:03AM +0200, Peter Palfrader wrote:
&gt; Filename: xxx-consensus-diffs
&gt; Title: Provide diffs between consensuses
&gt; Version: $Revision$
&gt; Last-Modified: $Date$
&gt; Author: Peter Palfrader
&gt; Created: 13-Jun-2008
&gt; Status: Open

Added as proposal 140.
</body></email><email><emailId>20080623150248</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-06-23 15:02:48-0400</timestampReceived><subject>Re: Proposal: Provide diffs between consensuses</subject><body>

On Sat, Jun 14, 2008 at 12:44:03AM +0200, Peter Palfrader wrote:
 [...]
&gt;   - Do we agree on using the ed patch format?

I finally figured out what questions I wanted to answer this question
with. :)

There are two things we want in a patch format:

  1. There needs to be a spec for generating and applying patches.
     The spec for generating them needs to be deterministic (or have a
     deterministic variant) so that authorities can all generate the
     same patch.

  2. There should be a good Free Software library (3BSD-like license,
     ideally) to generate and apply patches.  We'll be way happier if
     we don't have to write this code ourselves, I think: string
     processing like this can get really grungy.  In a pinch, we might
     get away with shelling out for generating patches (since only
     authorities need to do that), but clients need to be able to do
     it themselves safely, and we'll be in luck if we don't have to 
     reinvent the wheel here.

thoughts?  How do ed patches stack up in these areas?
-- 
Nick
</body></email><email><emailId>20080625063009</emailId><senderName>Peter Palfrader</senderName><senderEmail>peter@palfrader.org</senderEmail><timestampReceived>2008-06-25 06:30:09-0400</timestampReceived><subject>Re: Proposal: Provide diffs between consensuses</subject><body>

On Mon, 23 Jun 2008, Nick Mathewson wrote:

&gt; &gt;   - Do we agree on using the ed patch format?
&gt; 
&gt; I finally figured out what questions I wanted to answer this question
&gt; with. :)
&gt; 
&gt; There are two things we want in a patch format:
&gt; 
&gt;   1. There needs to be a spec for generating and applying patches.
&gt;      The spec for generating them needs to be deterministic (or have a
&gt;      deterministic variant) so that authorities can all generate the
&gt;      same patch.

Why?  Nobody needs to sign patches.  Even directory caches can create
the patches if we want.  If all works out the end result will be a
properly signed consensus.


&gt;   2. There should be a good Free Software library (3BSD-like license,
&gt;      ideally) to generate and apply patches.

Not that I have found one yet, but I didn't look too closely.
</body></email><email><emailId>20080622120319</emailId><senderName>Robert Hogan</senderName><senderEmail>robert@roberthogan.net</senderEmail><timestampReceived>2008-06-22 12:03:19-0400</timestampReceived><subject>Tsocks with Tor patches</subject><body>


Hi there,

Ruben Garcia, who maintains the patched-for-Tor version of tsocks available at 
https://giig.ugr.es/~rgarcia/tsocks/ suggested to me that we merge his branch 
with my own patched version of tsocks bundled with Tork and maintain it in one 
place.

This seemed a good idea to me. My own patches mainly addressed compiler warnings 
but also made the SOCKS defaults sensible for a Tor user, while Ruben's version 
had some patches from weasel that I wasn't aware of.

I have created a CVS module on Tork's SF repository that will hopefully serve as 
the basis for all future Tor-related patching:

cvs -z3 -d:pserver:anonymous@tork.cvs.sourceforge.net:/cvsroot/tork co -P 
torsocks

This module contains all the patches listed at:

http://tork.cvs.sourceforge.net/tork/torsocks/patches/

It also contains the following additional improvements:

- Support for gethostbyaddr. 
- Ported to an automake-based build system.
- A history of all applied patches.
- Various documentation/packaging related fixes suggested by Patrick Matthei.

The following are items I hope to add in the near future:

- Fully update the documentation to reflect the fact that this is a new fork of 
tsocks and is maintained separately.
- More support for isc library calls.
- Make thread-safe with --enable-threads.
- Modify tsocks further to play nicely with tor.  For  example, prevent nonlocal 
UDP traffic from being sent at all.

This is nice little side-project which I'm happy to maintain. The objective is to 
make torsocks the definitive fork for transparent socks use with Tor. I don't 
intend to advertise or distribute source bundles of torsocks myself (so the name 
is a statement of intended purpose only). I will keep it in the TorK repository 
until it's fit for the Tor project to host on svn (and distibute) and hopefully 
continue to maintain it there with anyone else who is interested. If it's not 
deemed suitable for the project to host I'll just continue to use it as a basis 
for the torksocks bundled with TorK.

Please let me know if there are items you would like to see added to the TODO 
list (http://tork.cvs.sourceforge.net/tork/torsocks/TODO), or anything else that 
needs to be addressed.



["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20080615174124</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-06-15 17:41:24-0400</timestampReceived><subject>Re: Proposal 137: Keep controllers informed as Tor bootstraps</subject><body>

On Wed, Jun 11, 2008 at 01:38:24AM -0400, Roger Dingledine wrote:
 [...]

All notes are based on latest version from svn.

&gt; 
&gt;   The generic status event is:
&gt; 
&gt;     "650" SP StatusType SP StatusSeverity SP StatusAction
&gt;                                         [SP StatusArguments] CRLF
&gt; 
&gt;   So in this case we send
&gt;   650 STATUS_CLIENT NOTICE/WARN BOOTSTRAP \
&gt;   PROGRESS=num TAG=string SUMMARY=string WARNING=string REASON=string
&gt; 
&gt;   "Progress" gives a number between 0 and 100 for how far through
&gt;   the bootstrapping process we are. "Summary" is a string that can be
&gt;   displayed to the user to describe the *next* task that Tor will tackle,
&gt;   i.e., the task it is working on after sending the status event. "Tag"
&gt;   is an optional string that controllers can use to recognize bootstrap
&gt;   phases from Section 3, if they want to do something smarter than just
&gt;   blindly displaying the summary string.

&gt;From a spec POV, you should put the optional aruments into square
brackets to indicate that they're optional.  There should also be the
standard line that controllers MUST ignore arguments they don't
recognize.

Are the strings quoted?  They should be.  But if this is so, I think
maybe REASON should be an identifier-like thing rather than a string:
using an identifier will discourage us from making cosmetic
compatibility-breaking improvements to reasons in the future.

 [...]
&gt; 3. The bootstrap phases.
&gt; 
&gt;   This section describes the various phases currently reported by
&gt;   Tor. Controllers should not assume that the percentages and tags listed
&gt;   here will continue to match up, or even that the tags will stay in
&gt;   the same order. Some phases might also be skipped (not reported) if the
&gt;   associated bootstrap step is already complete.

Or if the associated bootstrap step is no longer done by some future
Tor version.  Step 50's future, for instance, seems to be threatened
by the pre-proposal-ideas in xxx-grand-scaling-plan.txt

Also, future Tor versions may use tags not listed now; controllers
MUST tolerate this.

Question: are bootstrapping events meant to be sent only during the
initial setup phase, or might they appear later if Tor needs to
bootstrap again?  In other words, should controllers expect to see
only a monotonically increasing series of phase numbers, or should
they be ready for a Tor to tell them, "I am no longer a bootstrapped
Tor; I'm back at phase X"?

&gt;   Phase 0:
&gt;   tag=starting summary="starting"
&gt; 
&gt;   Tor starts out in this phase. It doesn't actually send a status event
&gt;   to say so.

What's it for, then?  

&gt;   Phase 5:
&gt;   tag=conn_dir summary="Connecting to directory mirror"
&gt; 
&gt;   Tor sends this event as soon as Tor has chosen a directory mirror ---
&gt;   one of the authorities if bootstrapping for the first time or after
&gt;   a long downtime, or one of the relays listed in its cached directory
&gt;   information otherwise.

(This will not be so once/if the fallback-consensus feature is working
and emabled: Tors will try long-lived directory mirrors before falling
back to the authorities.)

&gt;   Tor will stay at this phase until it has successfully established
&gt;   a TCP connection with some directory mirror. Problems in this phase
&gt;   generally happen because Tor doesn't have a network connection, or
&gt;   because the local firewall is dropping SYN packets.
&gt; 
&gt;   Phase 10
&gt;   tag=handshake_dir summary="Finishing handshake with directory mirror"
&gt; 
&gt;   This event occurs when Tor establishes a TCP connection with a relay
&gt;   (or its https proxy if it's using one). Tor remains in this phase until
&gt;   the TLS handshake with the relay is finished.

Do you mean to say "relay" here?  I know all directories are relays,
but it might be more reasonable to call the server in question a
"directory".
 
 [...]
&gt;   Phase 25:
&gt;   tag=loading_status summary="Loading networkstatus consensus"
&gt; 
&gt;   Once we've established a directory connection, we will start fetching
&gt;   the networkstatus consensus document. This could take a while; this
&gt;   phase is a good opportunity for using the "progress" keyword to indicate
&gt;   partial progress.
&gt; 
&gt;   This phase could stall if the directory mirror we picked doesn't
&gt;   have a copy of the networkstatus consensus so we have to ask another,
&gt;   or it does give us a copy but we don't find it valid.

If we fall back to another directory, do we go back to phase 5?  It
would seem reasonable...

 [...]
&gt;   The reason string is the same argument as the reason string for ORCONN
&gt;   failure events; the controller can recognize the various reasons
&gt;   and help the user accordingly. The warning string currently tries to
&gt;   provide the equivalent of strerror() -- this isn't very useful if the
&gt;   controller can recognize reason tags and be smarter, but for a very
&gt;   simple controller it should be better than nothing.

When this is merged into the spec, you'll want to phrase this part
more specishly.  Something like:

   The reason strings are long-term-stable controller-facing tags to
   identify particular issues in a bootstrapping step.  The warning
   strings, on the other hand, are human-readable.  Controllers SHOULD
   NOT rely on the format of any warning string. 

We should also say what the scope of reason strings are.  Does a
reason always mean the same thing with tag X as it does with tag Y?

&gt;   Currently Tor ignores the first nine bootstrap problem reports for
&gt;   a given phase, reports the tenth to the controller, and then ignores
&gt;   further problems at that phase. Hopefully this is a good balance between
&gt;   tolerating occasional errors and reporting serious problems quickly. (We
&gt;   will want to revisit this approach if there are many different 'reason'
&gt;   values being reported among the first ten problem reports, since in
&gt;   this case the controller will only hear one of them.)

This is ugly and fragile.  Instead of suppressing N failures and
reporting the N+1th, we should report all the failures, perhaps with a
count of how many have occurred so far or an indication of when we'll
next retry.  We should also offer advice to controller developers
about when they should report failures.  (Perhaps: "Wait for X
failures in any phase before deciding the phase is hopeless."  Or
perhaps: "After a failure, wait X seconds to see if Tor recovers and
the phase advances before deciding the phase is stalled.  Wait Y
seconds longer before deciding the phase is hopeless."  Or perhaps:
"If the retry time on any failure is 'now' or under 30 seconds from
now, Tor believes it can fix the problem itself.")

 [...]
&gt;   Controllers should also have some mechanism to alert their user when
&gt;   bootstrapping problems are reported. Perhaps we should gather a set of
&gt;   help texts and the controller can send the user to the right anchor in a
&gt;   "bootstrapping problems" help page?

This brings up an interesting issue.  There are lots of pieces of
translatable text that could reasonably used across different UIs.
We'd prefer not to stick them in Tor, since Tor doesn't get
internationalized.  But making each tool maintain their own lists is
also a little sad, since it results in a bit much duplication of
effort.  Thoughts?

-- 
Nick



</body></email><email><emailId>20081111213544</emailId><senderName>Christian Fromme</senderName><senderEmail>kaner@strace.org</senderEmail><timestampReceived>2008-11-11 21:35:44-0400</timestampReceived><subject>Re: draft proposal: download server descriptors on demand</subject><body>

Hi,

On 10.11. 08:39, Roger Dingledine wrote:

&gt; So instead we should do like proposal 141, but fetch the onion key on
&gt; demand, rather than the descriptor. The new RELAY_REQUEST_OKEY relay
&gt; cell just sends back the onion key. It fits in one cell, so there's no
&gt; need to mess with this global padding parameter thing, or compressing
&gt; descriptors on the fly, or teaching relays to test if their descriptor
&gt; is too big, etc.
&gt; 
&gt; Clients never learn exact exit policies now. That means we need to
&gt; make exit policies snap-to-fit better into the summaries we put in the
&gt; consensus document. But that's true with the old approach to proposal
&gt; 141 too. The only difference is that now we just try the BEGIN request,
&gt; and get end-reason-exit-policy if we guessed wrong and then try elsewhere.
&gt; 
&gt; We actually want RELAY_REQUEST_OKEY to be more general, in case there
&gt; are other items we want to communicate that we only summarize in the
&gt; consensus. RELAY_REQUEST_DETAILS, maybe.
&gt; 
&gt; How do the mirrors learn the onion keys? Authorities now produce both a
&gt; "mirror consensus" and a "client consensus". They differ in that the
&gt; mirror consensus includes the SD hash, descriptor timestamp, and the
&gt; onion key; and the client consensus has the OKey hash.

&gt; Now, time to consider some optimizations:
&gt; 
&gt; Optimization one: I could be convinced that with consensus diffs,
&gt; putting the onion key in the consensus wouldn't be so bad. Or we can put
&gt; OKey hashes in the consensus, and then let clients fetch and cache the
&gt; onion keys they're missing. They don't change very often at all. Either
&gt; way, now we wouldn't have to introduce any new relay cells, and no new
&gt; round-trips during circuit generation, and relays don't need a global
&gt; view of anything unless they want one. Sure is tempting.
&gt; 
&gt; Optimization two is that we could cut out the separate round-trip for
&gt; the RELAY_REQUEST_DETAILS relay cell if we wrap it into the CREATE cell.
&gt; That is, we could bump the circuit protocol version, and cram more
&gt; stuff into the CREATE cell like we've been meaning to, and one of the
&gt; new items would be the fingerprint for the intended next hop. Then
&gt; the relay can send back a CREATED followed directly by a (series of)
&gt; RELAY_HERE'S_YOUR_DETAILS relay cell(s). This step shouldn't be taken
&gt; lightly though, a) because it requires bumping the circuit protocol
&gt; version (an all-syrup super squishy? such a thing has never been done!),
&gt; b) because Ian showed up our create cells are darn fragile already,
&gt; so let's be careful putting anything else in them, and c) because the
&gt; fingerprint of the next hop is only encrypted to the onion key, and thus
&gt; isn't covered by the PFS you'd get if you wait for the CREATED cell first.

So, to sum this up:

1) Everything a client needs to build a circuit will be found in the new
   client consensus, except (maybe) the onion keys

2) The onion keys will be available to the client in one of the following
   ways:
   a) Part of the concensus, hoping that sizes won't increase too badly 
      over time. With consensus diffs in mind this means for a client to
      fetch about 200KB (I think Roger came up with that number on IRC)
      once and from then on only the diffs, which are naturally less
      + No change in circuit-building
      + No new relay cells
      + Easier to migrate
      - Mightn't scale well in the future
   b) Fetch them via a new RELAY_REQUEST_OKEY/RELAY_REQUEST_DETAILS cell
      + Scales well for the client if network sizes grow
      + Doesn't change circuit building
      - Somewhat more difficult to migrate
      - Increases latency (round-trip!)
   c) Fetch them via a new extented CREATE cell
      + Scales well
      + Doesn't really increase latency
      - Requires bumping the circ protocol version
      - CREATE cells already seem to be fragile
      - PFS at risk
      - Migration more difficult

3) Clients or others can still fetch full router descriptors from the
   authorities anytime they want

The original idea of propsal 141 falls somewhere near 2b).

I hope I got all the facts right. Please correct me if not. Assuming I 
have, why not say we implement 2a) first and see how far we get with 
that. Maybe with consensus diffs it'll be good enough. If it prooves to
have been the wrong way, we still can think about 2b) or 2c). Maybe some
other proposal in the future will make it necessary to change circuit 
building algorithms anyway and we'd have an easier time doing so then.

Best,
    Christian
</body></email><email><emailId>20081112045744</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2008-11-12 04:57:44-0400</timestampReceived><subject>Re: draft proposal: download server descriptors on demand</subject><body>

Hi Christian,

Thanks for keeping this discussion moving.

On Tue, Nov 11, 2008 at 10:35:44PM +0100, Christian Fromme wrote:
&gt; So, to sum this up:
&gt; 
&gt; 1) Everything a client needs to build a circuit will be found in the new
&gt;    client consensus, except (maybe) the onion keys

Yep. Going forward, the more general version of this is
  "Everything a client needs to build a circuit should either be in the
  consensus networkstatus, or in a small per-relay document called a
  microdescriptor."

Currently the only thing we expect for the microdescriptor is the onion
key, but down the road we might imagine putting other things in it if
they're too big to put in the consensus.

&gt; 2) The onion keys will be available to the client in one of the following
&gt;    ways:
&gt;    a) Part of the concensus, hoping that sizes won't increase too badly 
&gt;       over time. With consensus diffs in mind this means for a client to
&gt;       fetch about 200KB (I think Roger came up with that number on IRC)
&gt;       once and from then on only the diffs, which are naturally less
&gt;       + No change in circuit-building
&gt;       + No new relay cells
&gt;       + Easier to migrate
&gt;       - Mightn't scale well in the future

According to weasel's numbers, the compressed consensus size would change
from 90KB to 241KB if we add onion keys directly.

Here's how I would organize our options:

1) Add the onion key to the consensus, same as option 2a above.
   + No change in circuit-building
   + No new relay cells
   + Easy to migrate
   - Doesn't scale so well (the size of the consensus grows with number
     of relays).
   - consensus diffs get a lot bigger, since whenever a relay gets
     added to the consensus (e.g. if we mark it Running again) we add
     in its whole onion key.
   - if we find a second big thing we want clients to also know, we have
     to either add that to the consensus too (which could double its
     size again) or make clients start fetching descriptors again or
     move to one of these other plans.

2) Put a hash of the microdescriptor in the consensus, and have clients
   fetch and cache microdescriptors preemptively from dir mirrors
   when starting up, like they currently fetch descriptors. (Dir
   mirrors fetch them from the authorities and cache them.) This means
   a compressed consensus of about 100KB, and a microdescriptor set of
   about 128*1500=200KB. After bootstrapping, clients only need to fetch
   the microdescriptors that have changed. If they have only an onion key
   in them, they will change once a week -- so after bootstrapping clients
   spend very little bandwidth to maintain the microdescriptor cache.
   + No change in circuit-building
   + No new relay cells
   + Still pretty easy to migrate
   + Consensus diffs won't be overly huge
   - Bootstrapping cost still somewhat high, and goes up as the network
     grows.

3) Put a hash of the microdescriptor in the consensus, and have clients
   fetch a copy of the next microdescriptor on every circuit-extend
   operation. So long as the microdescriptors stay smallish, they fit
   in oneish cell, and we don't have to worry about that awful "router
   descriptor padding" question.
   + Scales well for the client if network sizes grow.
   + Also scales well if the microdescriptor size grows. If we discover
     other big things we want the clients to know, this approach becomes
     increasingly appealing.
   - We have to modify circuit-building at the client side, since we're
     adding more steps.
   - We either add an extra round-trip of latency (if we use a separate
     RELAY_FETCH_MDESC cell to fetch it), or we do the even more complex
     approach of a hybrid CREATE_AND_FETCH_MDESC design.
   - We now force all relays to know microdescriptors for all relays,
     which may hurt potential future plans to get away from a clique
     topology.

Now, note in all these variations that there's still extra stuff
in the consensus that clients don't need: we could take out the
hash-of-descriptor and the timestamp. Since these items change
daily-per-relay, consensus diffs will get way smaller. (Nobody's done
the math yet on how much smaller but I'm optimistic.) For the sake of
migration, we shouldn't drop them until 0.2.1.x is obsolete. (Otherwise
mirrors can't fetch them for old clients, and old clients can't know
which ones to fetch.) (Sites like the torstatus page can still fetch all
the original signed server descriptors, if we make the votes available
that list the hash-of-descriptor that each authority voted on.)

I think which choice we take depends on the properties of the
microdescriptor:
  Option 1 is the best choice if it stays small and changes often (at
    least daily), since caching it separately from the consensus doesn't
    save us much bandwidth.
  Option 2 is the best choice if it stays small and changes seldom.
  Option 3 is the best choice if it grows large.

For the current situation -- onion keys that rotate weekly -- I think
option 2 is the winner. But if we later add something that changes often,
then option 2 is going to feel like a hassle compared to the simpler
and just as efficient option 1. And if we ever add a lot more bytes,
then we're going to want to move to option 3.

Does that mean we should go with option 2, and keep this discussion in
mind next time we want to add more items to the consensus?

While I'm at it, what's a good way to version the microdescriptor? We
could just stick a version byte at the front, but what does a client do
if it encounters a version it doesn't recognize? About the only plan
I can come up with is to put a version byte in front, and if we want
to add things just add them, and clients ignore stuff beyond what they
know to look for in a given version. If we need to change the version,
we teach clients about both while still using the old one, and once
all the clients have upgraded we switch to the new one (at which point
clients can then forget how to understand the old one). Slow process.

Another point to ponder: nickm was talking about having relays generate
their own microdescriptors and sign them, and then maybe saving space
by not including the signature when clients fetch it. I think the
microdescriptor should be a straight transform from the 'real' descriptor,
and so it doesn't need any signature or timestamp. Relays don't even
need to know that they exist, except as opaque blobs that they mirror.

--Roger

</body></email><email><emailId>20081113222652</emailId><senderName>Christian Fromme</senderName><senderEmail>kaner@strace.org</senderEmail><timestampReceived>2008-11-13 22:26:52-0400</timestampReceived><subject>Re: draft proposal: download server descriptors on demand</subject><body>

Hi,

thanks for clearing things up!

On 11.11. 23:57, Roger Dingledine wrote:

&gt; I think which choice we take depends on the properties of the
&gt; microdescriptor:
&gt;   Option 1 is the best choice if it stays small and changes often (at
&gt;     least daily), since caching it separately from the consensus doesn't
&gt;     save us much bandwidth.
&gt;   Option 2 is the best choice if it stays small and changes seldom.
&gt;   Option 3 is the best choice if it grows large.
&gt; 
&gt; For the current situation -- onion keys that rotate weekly -- I think
&gt; option 2 is the winner. But if we later add something that changes often,
&gt; then option 2 is going to feel like a hassle compared to the simpler
&gt; and just as efficient option 1. And if we ever add a lot more bytes,
&gt; then we're going to want to move to option 3.
&gt; 
&gt; Does that mean we should go with option 2, and keep this discussion in
&gt; mind next time we want to add more items to the consensus?

Maybe it really does. It's probably the most practical approach we could
choose for now. Does anybody else have some points here? If nothing
critical comes up, I'd opt for it.

&gt; While I'm at it, what's a good way to version the microdescriptor? We
&gt; could just stick a version byte at the front, but what does a client do
&gt; if it encounters a version it doesn't recognize? About the only plan
&gt; I can come up with is to put a version byte in front, and if we want
&gt; to add things just add them, and clients ignore stuff beyond what they
&gt; know to look for in a given version. If we need to change the version,
&gt; we teach clients about both while still using the old one, and once
&gt; all the clients have upgraded we switch to the new one (at which point
&gt; clients can then forget how to understand the old one). Slow process.

Why do we need a slow upgrade process when microdescriptors are, as you
describe, backward compatible? I am missing something I guess. ;) 
Apart from that I think a byte in front for the versioning is fine.

&gt; Another point to ponder: nickm was talking about having relays generate
&gt; their own microdescriptors and sign them, and then maybe saving space
&gt; by not including the signature when clients fetch it. I think the
&gt; microdescriptor should be a straight transform from the 'real' descriptor,
&gt; and so it doesn't need any signature or timestamp. Relays don't even
&gt; need to know that they exist, except as opaque blobs that they mirror.

Is there a good reason for signing the descriptors? From a security
perspective, since the current descriptors aren't signed, why signing
the new microdescriptors? Again, I might be missing something here. In
option #2, if this is the one we'll implement, relays don't mirror the
descriptors anyway, they come straight from the trusted dirservers.


Best,
Christian
</body></email><email><emailId>20080627135459</emailId><senderName>Karsten Loesing</senderName><senderEmail>karsten.loesing@gmx.net</senderEmail><timestampReceived>2008-06-27 13:54:59-0400</timestampReceived><subject>Proposal: Combine Introduction and Rendezvous Points</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Hi Nick, Roger, Lasse, Paul, and list,

Nick, you wanted to have the new proposals for 0.2.1.x in until end of
June. This is the first out of three proposals that I think are worth
considering for 0.2.1.x. This proposal is also quite important for the
NLnet project, because it exhibits the potential for major performance
improvements. Certainly, it needs some discussion of anonymity and
security issues. If you think that there is too little time for this
discussion, we should schedule this proposal for 0.2.2.x. However, this
would be a pity as it wouldn't go with the NLnet project schedule. The
other two proposals that I plan to submit this week-end are minor
extensions of proposals 114 and 121. Sorry for the delay in sending you
these proposals; be assured that it's not just soccer that kept me from
working on them. ;)

Roger, are there any security/anonymity concerns about having separate
introduction points that are not covered here? You once said there are
issues that need to be better understood. Which are that?

Lasse and Paul, I'd be particularly interested in how you like the idea
of having your protocol simplification specified/implemented without
valet nodes. The main reason is that valet nodes increase both protocol
and implementation complexity, which inevitably leads to more bugs (as
shown before...). Therefore, I'd rather leave that concept out if possible.

As always, comments are highly appreciated!

- --Karsten
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFIZPEv0M+WPffBEmURAoFDAJ46d35ylw6GlOrbRNVFNsvOYAoEfACgyK5J
jYuEahTZuvKuc3sBNvI5lX0=
=shlr
-----END PGP SIGNATURE-----

["xxx-combine-intro-and-rend-points.txt" (text/plain)]

Filename: xxx-combine-intro-and-rend-points.txt
Title: Combine Introduction and Rendezvous Points
Version: $Revision$
Last-Modified: $Date$
Author: Karsten Loesing, Christian Wilms
Created: 27-Jun-2008
Status: Open

Change history:

  27-Jun-2008  Initial proposal for or-dev

Overview:

  Establishing a connection to a hidden service currently involves two Tor
  relays, introduction and rendezvous point, and 10 more relays distributed
  over four circuits to connect to them. The introduction point is
  established in the mid-term by a hidden service to transfer introduction
  requests from client to the hidden service. The rendezvous point is set
  up by the client for a single hidden service request and actually
  transfers end-to-end encrypted application data between client and hidden
  service.

  There are some reasons for separating the two roles of introduction and
  rendezvous point: (1) Plausible deniability: A relay shall not be made
  responsible that it relays data for a certain hidden service; in the
  original design as described in [1] an introduction point relays no
  application data, and a rendezvous points neither knows the hidden
  service nor can it decrypt the data. (2) Scalability: The hidden service
  shall not have to maintain a number of open circuits proportional to the
  expected number of client requests. (3) Attack resistance: The effect of
  an attack on the only visible parts of a hidden service, its introduction
  points, shall be as small as possible.

  However, elimination of a separate rendezvous connection as proposed by
  Øverlier and Syverson [2] is the most promising approach to improve the
  delay in connection establishment. From all substeps of connection
  establishment extending a circuit by only a single hop is responsible for
  a major part of delay. Reducing on-demand circuit extensions from two to
  one results in a decrease of mean connection establishment times from 39
  to 29 seconds [3]. Particularly, eliminating the delay on hidden-service
  side allows the client to better observe progress of connection
  establishment, thus allowing it to use smaller timeouts. Proposal 114
  introduced new introduction keys for introduction points and provides for
  user authorization data in hidden service descriptors; it will be shown
  in this proposal that introduction keys in combination with new
  introduction cookies provide for the first security property of plausible
  deniability. Further, eliminating the need for a separate introduction
  connection benefits the overall network load by decreasing the number of
  circuit extensions. After all, having only one connection between client
  and hidden service reduces the overall protocol complexity.

Design:

  1. Hidden Service Configuration

  Hidden services should be able to choose whether they would like to use
  this protocol. This might be opt-in for 0.2.1.x and opt-out for later
  major releases.

  2. Contact Point Establishment

  When preparing a hidden service, a Tor client selects a set of relays to
  act as contact points instead of introduction points. The contact point
  combines both roles of introduction and rendezvous point as proposed in
  [2]. The only requirement for a relay to be picked as contact point is
  its capability of performing this role. This can be determined from the
  Tor version number that needs to be equal or higher than the first
  version that implements this proposal.

  The easiest way to implement establishment of contact points is to
  introduce v2 ESTABLISH_INTRO cells and use the currently unused auth type
  number 1 for contact points.

     V      Format byte: set to 255               [1 octet]
     V      Version byte: set to 2                [1 octet]
     KLEN   Key length                           [2 octets]
     PK     Bob's public key                  [KLEN octets]
     HS     Hash of session info                [20 octets]
     AUTHT  The auth type that is supported       [1 octet]
     AUTHL  Length of auth data                  [2 octets]
     AUTHD  Auth data                            [variable]
     SIG    Signature of above information       [variable]

  The hidden service does not create a fixed number of contact points, like
  3 in the current protocol. It uses a minimum of 3 contact points, but
  increases this number depending on the history of client requests within
  the last hour. The hidden service also increases this number depending on
  the frequency of failing contact points in order to defend against
  attacks on its contact points. When client authorization as described in
  proposal 121 is used, a hidden service can also use the number of
  authorized clients as first estimate for the required number of contact
  points.

  3. Hidden Service Descriptor Creation

  A hidden service needs to issue a fresh introduction cookie for each
  established introduction point. By requiring clients to use this cookie
  in a later connection establishment, an introduction point cannot access
  the hidden service that it works for. Together with the fresh
  introduction key that was introduced in proposal 114, this results in
  plausible deniability for the contact point.

  The v2 hidden service descriptor format contains an
  "intro-authentication" field that may contain introduction-point specific
  keys. The hidden service creates a random string, comparable to the
  rendezvous cookie, and includes it in the descriptor as introduction
  cookie. Existing clients that do not understand this new protocol simply
  ignore that cookie. Further, the hidden service lists in the
  "protocol-versions" field that it supports this protocol.

  4. Connection Establishment

  When establishing a connection to a hidden service a client learns about
  the capability of using the new protocol from the hidden service
  descriptor. It may choose whether to use this new protocol or not,
  whereas older clients cannot understand the new capability and can only
  use the current protocol. Client using version 0.2.1.x should be able to
  opt-in for using the new protocol, which should change to opt-out for
  later major releases.

  When using the new capability the client creates a v2 INTRODUCE1 cell
  that extends an unversioned INTRODUCE1 cell by adding the content of an
  ESTABLISH_RENDEZVOUS cell. Further, the client sends this cell using the
  new cell type 41 RELAY_INTRODUCE1_VERSIONED to the introduction point,
  because unversioned and versioned INTRODUCE1 cells are indistinguishable:

  Cleartext
     V      Version byte: set to 2                [1 octet]
     PK_ID  Identifier for Bob's PK             [20 octets]
     AUTHT  The auth type that is supported       [1 octet]
     AUTHL  Length of auth data                  [2 octets]
     AUTHD  Auth data                            [variable]
  Encrypted to Bob's PK:
     VER    Version byte: set to 3.               [1 octet]
     AUTHT  The auth type that is supported       [1 octet]
     AUTHL  Length of auth data                  [2 octets]
     AUTHD  Auth data                            [variable]
     IP     Rendezvous point's address           [4 octets]
     PORT   Rendezvous point's OR port           [2 octets]
     ID     Rendezvous point identity ID        [20 octets]
     KLEN   Length of onion key                  [2 octets]
     KEY    Rendezvous point onion key        [KLEN octets]
     RC     Rendezvous cookie                   [20 octets]
     g^x    Diffie-Hellman data, part 1        [128 octets]

  The cleartext part contains the rendezvous cookie as auth data for the
  currently unused auth type 1. The contact point remembers the rendezvous
  cookie just as a rendezvous point would do.

  The encrypted part contains the introduction cookie as auth data for the
  likewise unused auth type 1. The rendezvous cookie is contained as
  before, but the remaining rendezvous point information is left empty, as
  there is no separate rendezvous point.

  5. Rendezvous Establishment

  The contact point recognizes a v2 INTRODUCE1 cell with auth type 1 as a
  request to be used in the new protocol. It remembers the contained
  rendezvous cookie, replies to the client with an INTRODUCE_ACK cell
  (omitting the RENDEZVOUS_ESTABLISHED cell), and forwards the encrypted
  part of the INTRODUCE1 cell as INTRODUCE2 cell to the hidden service.

  6. Introduction at Hidden Service

  The hidden services recognizes an INTRODUCE2 cell containing an
  introduction cookie as authorization data. In this case, it does not
  extend a circuit to a rendezvous point, but sends a RENDEZVOUS1 cell
  directly back to its contact point as usual.

  7. Rendezvous at Contact Point

  The contact point processes a RENDEZVOUS1 cell just as a rendezvous point
  does. The only difference is that the hidden-service-side circuit is not
  exclusive for the client connection, but shared among multiple client
  connections.

Security Implications:

  (1) Plausible deniability

  One of the original reasons for the separation of introduction and
  rendezvous points is that a relay shall not be made responsible that it
  relays data for a certain hidden service. In the current design an
  introduction point relays no application data and a rendezvous points
  neither knows the hidden service nor can it decrypt the data.

  This property is also fulfilled in this new design. A contact point only
  learns a fresh introduction key instead of the hidden service key, so
  that it cannot recognize a hidden service. Further, the introduction
  cookie, which is unknown to the contact point, prevents it from accessing
  the hidden service itself. The only way for a contact point to access a
  hidden service is to look up whether it is contained in the descriptors
  of known hidden services. A contact point can plausibly deny knowledge of
  any hidden services, so that it cannot know for which hidden service it
  is working. In addition to that, it cannot learn the data that it
  transfers, because all communication between client and hidden service
  are end-to-end encrypted.

  (2) Scalability

  Another goal of the existing hidden service protocol is that a hidden
  service does not have to maintain a number of open circuits proportional
  to the expected number of client requests. The rationale behind this is
  better scalability.

  The new protocol eliminates the need for a hidden service to extend
  circuits on demand, which has a positive effect circuits establishment
  times and overall network load. The solution presented here to establish
  a number of contact points proportional to the history of connection
  requests reduces the number of circuits to a minimum number that fits the
  hidden service's needs.

  (3) Attack resistance

  The third goal of separating introduction and rendezvous points is to
  limit the effect of an attack on the only visible parts of a hidden
  service which are the contact points in this protocol.

  In theory, the new protocol is more vulnerable to this attack. An
  attacker who can take down a contact point does not only eliminate an
  access point to the hidden service, but also breaks current client
  connections to the hidden service using that contact point.

  Øverlier and Syverson proposed the concept of valet nodes as additional
  safeguard for introduction/contact points [4]. Unfortunately, this
  increases hidden service protocol complexity conceptually and from an
  implementation point of view. Therefore, it is not included in this
  proposal.

  However, in practice attacking a contact point (or introduction point) is
  not as rewarding as it might appear. The cost for a hidden service to set
  up a new contact point and publish a new hidden service descriptor is
  minimal compared to the efforts necessary for an attacker to take a Tor
  relay down. As a countermeasure to further frustrate this attack, the
  hidden service raises the number of contact points as a function of
  previous contact point failures.

  Further, the probability of breaking client connections due to attacking
  a contact point is minimal. It can be assumed that the probability of one
  of the other five involved relays in a hidden service connection failing
  or being shut down is higher than that of a successful attack on a
  contact point.

  (4) Resistance against Locating Attacks

  Clients are no longer able to force a hidden service to create or extend
  circuits. This further reduces an attacker's capabilities of locating a
  hidden server as described by Øverlier and Syverson [5].

Compatibility:

  The presented protocol does not raise compatibility issues with current
  Tor versions. New relay versions support both, the existing and the
  proposed protocol as introduction/rendezvous/contact points. A contact
  point acts as introduction point simultaneously. Hidden services and
  clients can opt-in to use the new protocol which might change to opt-out
  some time in the future.

References:

  [1] Roger Dingledine, Nick Mathewson, and Paul Syverson, Tor: The
  Second-Generation Onion Router. In the Proceedings of the 13th USENIX
  Security Symposium, August 2004.

  [2] Lasse Øverlier and Paul Syverson, Improving Efficiency and Simplicity
  of Tor Circuit Establishment and Hidden Services. In the Proceedings of
  the Seventh Workshop on Privacy Enhancing Technologies (PET 2007),
  Ottawa, Canada, June 2007.

  [3] Christian Wilms, Improving the Tor Hidden Service Protocol Aiming at
  Better Performance, diploma thesis, June 2008, University of Bamberg.

  [4] Lasse Øverlier and Paul Syverson, Valet Services: Improving Hidden
  Servers with a Personal Touch. In the Proceedings of the Sixth Workshop
  on Privacy Enhancing Technologies (PET 2006), Cambridge, UK, June 2006.

  [5] Lasse Øverlier and Paul Syverson, Locating Hidden Servers. In the
  Proceedings of the 2006 IEEE Symposium on Security and Privacy, May 2006.


["xxx-combine-intro-and-rend-points.txt.sig" (application/octet-stream)]

</body></email><email><emailId>20080628174130</emailId><senderName>Karsten Loesing</senderName><senderEmail>karsten.loesing@gmx.net</senderEmail><timestampReceived>2008-06-28 17:41:30-0400</timestampReceived><subject>Proposal: Improvements of Distributed Storage for Tor Hidden Service</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Hi Nick and list,

and here comes number two. This proposal is a follow-up of proposal 114.
Some of the improvements result from a statistical analysis of network
consensuses from January to March 2008. Others come from writing up the
results and discussing them. And the remaining items were still on my
TODO list waiting to be included at the next opportunity. All stated
improvements are backwards compatible to the current implementation.

Again, comments are highly appreciated!

- --Karsten
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFIZnfJ0M+WPffBEmURAtCUAJ4ikKmVWc1WDrSod4kg8OwW+ez21QCcC66i
QQrm56zT71In8NTfui8AWzI=
=biLv
-----END PGP SIGNATURE-----

["xxx-distributed-storage-improvements.txt" (text/plain)]

Filename: xxx-distributed-storage-improvements.txt
Title: Improvements of Distributed Storage for Tor Hidden Service Descriptors
Version: $Revision$
Last-Modified: $Date$
Author: Karsten Loesing
Created: 28-Jun-2008
Status: Open

Change history:

  28-Jun-2008  Initial proposal for or-dev

Overview:

  An evaluation of the distributed storage for Tor hidden service
  descriptors and subsequent discussions have brought up a few improvements
  to proposal 114. All improvements are backwards compatible to the
  implementation of proposal 114.

Design:

  1. Report Bad Directory Nodes

  Bad hidden service directory nodes could deny existence of previously
  stored descriptors. A bad directory node that does this with all stored
  descriptors causes harm to the distributed storage in general, but
  replication will cope with this problem in most cases. However, an
  adversary that attempts to make a specific hidden service unavailable by
  running relays that become responsible for all of a service's
  descriptors poses a more serious threat. The distributed storage needs to
  defend against this attack by detecting and removing bad directory nodes.

  As a countermeasure hidden services try to download their descriptors
  every hour at random times from the hidden service directories that are
  responsible for storing it. If a directory node replies with 404 (Not
  found), the hidden service reports the supposedly bad directory node to
  a random selection of half of the directory authorities (with version
  numbers equal to or higher than the first version that implements this
  proposal). The hidden service posts a complaint message using HTTP 'POST'
  to a URL "/tor/rendezvous/complain" with the following message format:

    "hidden-service-directory-complaint" identifier NL

      [At start, exactly once]

      The identifier of the hidden service directory node to be
      investigated.

    "rendezvous-service-descriptor" descriptor NL

      [At end, Excatly once]

      The hidden service descriptor that the supposedly bad directory node
      does not serve.

  The directory authority checks if the descriptor is valid and the hidden
  service directory responsible for storing it. It waits for a random time
  of up to 30 minutes before posting the descriptor to the hidden service
  directory. If the publication is acknowledged, the directory authority
  waits another random time of up to 30 minutes before attempting to
  request the descriptor that it has posted. If the directory node replies
  with 404 (Not found), it will be blacklisted for being a hidden service
  directory node for the next 48 hours.

  A blacklisted hidden service directory is assigned the new flag BadHSDir
  instead of the HSDir flag in the vote that a directory authority creates.
  In a consensus a relay is only assigned a HSDir flag if the majority of
  votes contains a HSDir flag and no more than one third of votes contains
  a BadHSDir flag. As a result, clients do not have to learn about the
  BadHSDir flag. A blacklisted directory node will simply not be assigned
  the HSDir flag in the consensus.

  In order to prevent an attacker from setting up new nodes as replacement
  for blacklisted directory nodes, all directory nodes in the same /24
  subnet are blacklisted, too. Furthermore, if two or more directory nodes
  are blacklisted in the same /16 subnet concurrently, all other directory
  nodes in that /16 subnet are blacklisted, too. Blacklisting holds for at
  most 48 hours.

  2. Publish Fewer Replicas

  The evaluation has shown that the probability of a directory node to
  serve a previously stored descriptor is 85.7% (more precisely, this is
  the 0.001-quantile of the empirical distribution with the rationale that
  it holds for 99.9% of all empirical cases). If descriptors are replicated
  to x directory nodes, the probability of at least one of the replicas to
  be available for clients is 1 - (1 - 85.7%) ^ x. In order to achieve an
  overall availability of 99.9%, x = 3.55 replicas need to be stored. From
  this follows that 4 replicas are sufficient, rather than the currently
  stored 6 replicas.

  Further, the current design stores 2 sets of descriptors on 3 directory
  nodes with consecutive identities. Originally, this was meant to
  facilitate replication between directory nodes, which has not been and
  will not be implemented (the selection criterion of 24 hours uptime does
  not make it necessary). As a result, storing descriptors on directory
  nodes with consecutive identities is not required. In fact it should be
  avoided to enable an attacker to create "black holes" in the identifier
  ring.

  Hidden services should store their descriptors on 4 non-consecutive
  directory nodes, and clients should request descriptors from these
  directory nodes only. For compatibility reasons, hidden services also
  store their descriptors on 2 consecutive directory nodes. Hence, 0.2.0.x
  clients will be able to retrieve 4 out of 6 descriptors, but will fail
  for the remaining 2 descriptors, which is sufficient for reliability. As
  soon as 0.2.0.x is deprecated, hidden services can stop publishing the
  additional 2 replicas.

  3. Change Default Value of Being Hidden Service Directory

  The requirements for becoming a hidden service directory node are an open
  directory port and an uptime of at least 24 hours. The evaluation has
  shown that there are 300 hidden service directory candidates in the mean,
  but only 6 of them are configured to act as hidden service directories.
  This is bad, because those 6 nodes need to serve a large share of all
  hidden service descriptors. Optimally, there should be hundreds of hidden
  service directories. Having a large number of 0.2.1.x directory nodes
  also has a positive effect on 0.2.0.x hidden services and clients.

  Therefore, the new default of HidServDirectoryV2 should be 1, so that a
  Tor relay that has an open directory port automatically accepts and
  serves v2 hidden service descriptors. A relay operator can still opt-out
  running a hidden service directory by changing HidServDirectoryV2 to 0.
  The additional bandwidth requirements for running a hidden service
  directory node in addition to being a directory cache are negligible.

  4. Make Descriptors Persistent on Directory Nodes

  Hidden service directories that are restarted by their operators or after
  a failure will not be selected as hidden service directories within the
  next 24 hours. However, some clients might still think that these nodes
  are responsible for certain descriptors, because they work on the basis
  of network consensuses that are up to three hours old. The directory
  nodes should be able to serve the previously received descriptors to
  these clients. Therefore, directory nodes make all received descriptors
  persistent and load previously received descriptors on startup.

  5. Store and Serve Descriptors Regardless of Responsibility

  Currently, directory nodes only accept descriptors for which they think
  they are responsible. This may lead to problems when a directory node
  uses an older or newer network consensus than hidden service or client
  or when a directory node has been restarted recently. In fact, there are
  no security issues in storing or serving descriptors for which a
  directory node thinks it is not responsible. To the contrary, doing so
  may improve reliability in border cases. As a result, a directory node
  does not pay attention to responsibilty when receiving a publication or
  fetch request, but stores or serves the requested descriptor. Likewise,
  the directory node does not remove descriptors when it thinks it is not
  responsible for them any more.

  6. Avoid Periodic Descriptor Re-Publication

  In the current implementation a hidden service re-publishes its
  descriptor either when its content changes or an hour elapses. However,
  the evaluation has shown that failures of hidden service directory nodes,
  i.e. of nodes that have not failed within the last 24 hours, are very
  rare. Together with making descriptors persistent on directory nodes,
  there is no necessity to re-publish descriptors hourly.

  The only two events leading to descriptor re-publication should be a
  change of the descriptor content and a new directory node becoming
  responsible for the descriptor. Hidden services should therefore consider
  re-publication every time they learn about a new network consensus
  instead of hourly.

  7. Discard Expired Descriptors

  The current implementation lets directory nodes keep a descriptor for two
  days before discarding it. However, with the v2 design, descriptors are
  only valid for at most one day. Directory nodes should determine the
  validity of stored descriptors and discard them one hour after they have
  expired (to compensate wrong clocks on clients).

  8. Shorten Client-Side Descriptor Fetch History

  When clients try to download a hidden service descriptor, they memorize
  fetch requests to directory nodes for up to 15 minutes. This allows them
  to request all replicas of a descriptor to avoid bad or failing directory
  nodes, but without querying the same directory node twice.

  The downside is that a client that has requested a descriptor without
  success, will not be able to find a hidden service that has been started
  during the following 15 minutes after the client's last request.

  This can be improved by shortening the fetch history to only 5 minutes.
  This time should be sufficient to complete requests for all replicas of a
  descriptor, but without ending in an infinite request loop.

Compatibility:

  All proposed improvements are compatible to the currently implemented
  design as described in proposal 114.


["xxx-distributed-storage-improvements.txt.sig" (application/octet-stream)]

</body></email><email><emailId>20080628034451</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@alum.mit.edu</senderEmail><timestampReceived>2008-06-28 03:44:51-0400</timestampReceived><subject>Re: Proposal: Combine Introduction and Rendezvous Points</subject><body>

On Fri, Jun 27, 2008 at 03:54:59PM +0200, Karsten Loesing wrote:
&gt; -----BEGIN PGP SIGNED MESSAGE-----
&gt; Hash: SHA1
&gt; 
&gt; Hi Nick, Roger, Lasse, Paul, and list,
&gt; 
&gt; Nick, you wanted to have the new proposals for 0.2.1.x in until end of
&gt; June. This is the first out of three proposals that I think are worth
&gt; considering for 0.2.1.x. This proposal is also quite important for the
&gt; NLnet project, because it exhibits the potential for major performance
&gt; improvements.

Added as proposal 142.

[As for getting this reviewed in time to get it merged into 0.2.1.x:
I'm not going to merge code for features without security analysis.
This analysis doesn't need to be done today or even by June 30, but it
needs to be done before the code hits trunk.]


&gt;  There are some reasons for separating the two roles of introduction and
&gt;  rendezvous point: (1) Plausible deniability: A relay shall not be made
&gt;  responsible that it relays data for a certain hidden service; in the
&gt;  original design as described in [1] an introduction point relays no
&gt;  application data, and a rendezvous points neither knows the hidden
&gt;  service nor can it decrypt the data.

This isn't "plausible deniability", and we certainly didn't use that
term in the paper.  It's originally from govermental agencies, and
meant something like, "lots of people will guess it was us, but there
had better not be any solid proof."  When it *is* used in security, it
means something pretty vague; usually along the lines of "just because
I've got this here steganography software doesn't mean I've actually
used it to hide anything in this here random-looking bitstream."

But this isn't what the IP/RP separation was meant to do.  The
security idea mentioned in [1] was to resist smear attacks (run a
really offensive service to make trouble for a given node for relaying
bits that service).  We thought it was important at the time; who
knows.

The property you're talking about above is that no relay is easily
linked with any with any particular hidden service.  This property
probably needs a name, but plausible deniability isn't it.

&gt; (2) Scalability: The hidden service shall not have to maintain a
&gt; number of open circuits proportional to the expected number of
&gt; client requests. (3) Attack resistance: The effect of an attack on
&gt; the only visible parts of a hidden service, its introduction points,
&gt; shall be as small as possible.

(4) Separation of node properties.  Introduction points need to be up
a lot, but don't need much bandwidth.  Rendezvous points need
bandwidth, but are relatively ephemeral.  Likewise, we thought this
was important.  We should analyze whether it is.


... I've just given  the rest of the proposal a skim, and I think I
need to have another look once I've re-read proposal 121.

An idea from the #tor-dev channel: it's probably time to do for the
hidden service protocol what we did for the directory protocol, and
split the specification into rend-spec-v1.txt and rend-spec.txt, and
edit the latter to contain all these proposals once they're a little
more discussed.  Doing this for directory stuff helped identify places
that hadn't actually gotten specified in our proposals.

yrs,
-- 
Nick
</body></email><email><emailId>20081114011336</emailId><senderName>Mike Perry</senderName><senderEmail>mikeperry@fscked.org</senderEmail><timestampReceived>2008-11-14 01:13:36-0400</timestampReceived><subject>Re: draft proposal: download server descriptors on demand</subject><body>


Thus spake Roger Dingledine (arma@mit.edu):

&gt; I think which choice we take depends on the properties of the
&gt; microdescriptor:
&gt;   Option 1 is the best choice if it stays small and changes often (at
&gt;     least daily), since caching it separately from the consensus doesn't
&gt;     save us much bandwidth.
&gt;   Option 2 is the best choice if it stays small and changes seldom.
&gt;   Option 3 is the best choice if it grows large.
&gt; 
&gt; For the current situation -- onion keys that rotate weekly -- I think
&gt; option 2 is the winner. But if we later add something that changes often,
&gt; then option 2 is going to feel like a hassle compared to the simpler
&gt; and just as efficient option 1. And if we ever add a lot more bytes,
&gt; then we're going to want to move to option 3.

It would seem to me that we should just start thinking of the
microdescriptor as the repository for time-insensitive,
longer-duration information about a node. It appears that 141 has
already moved load balancing/bandwidth information to the network
status consensus document. Is there any reason why we couldn't persue
option 2, and if anything comes up that needs to be added that changes
frequently, we can add it to the network status, otherwise we add it
to the microdescriptor?

It also seems like the loss of PFS in the single-roundtrip version of
option 3 is pretty bad given that it would allow malicious or coerced
guard nodes to record circuit creation and then potentially harass
middle nodes for their onion key for full path information at a later
date.. Sad.

-- 
Mike Perry
Mad Computer Scientist
fscked.org evil labs

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20080628042629</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-06-28 04:26:29-0400</timestampReceived><subject>Re: Proposal: Provide diffs between consensuses</subject><body>

On Wed, Jun 25, 2008 at 08:30:09AM +0200, Peter Palfrader wrote:
 [...]
&gt; &gt;   1. There needs to be a spec for generating and applying patches.
&gt; &gt;      The spec for generating them needs to be deterministic (or have a
&gt; &gt;      deterministic variant) so that authorities can all generate the
&gt; &gt;      same patch.
&gt; 
&gt; Why?  Nobody needs to sign patches.  Even directory caches can create
&gt; the patches if we want.  If all works out the end result will be a
&gt; properly signed consensus.

Ah, you're right.  I had assumed a signed-patch thing rather than a
patch-from-signed-to-signed thing.  I take back the "deterministic"
part, but still mean the "specified" part. :)

&gt; &gt;   2. There should be a good Free Software library (3BSD-like license,
&gt; &gt;      ideally) to generate and apply patches.
&gt; 
&gt; Not that I have found one yet, but I didn't look too closely.

There are libraries for diff-related things in at least Python and
Perl, but I haven't yet turned up a C library with a license Tor can
use.  I suppose we could extract the relevant parts of a 3BSD-licensed
"patch" implementation, but that way lies maintenance hell.

yrs,
-- 
Nick
</body></email><email><emailId>20080628043941</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-06-28 04:39:41-0400</timestampReceived><subject>Re: Tsocks with Tor patches</subject><body>

On Sun, Jun 22, 2008 at 01:03:19PM +0100, Robert Hogan wrote:
 [...]
&gt; This seemed a good idea to me. My own patches mainly addressed
&gt; compiler warnings but also made the SOCKS defaults sensible for a
&gt; Tor user, while Ruben's version had some patches from weasel that I
&gt; wasn't aware of.
&gt;
&gt;  I have created a CVS module on Tork's SF repository that will
&gt; hopefully serve as the basis for all future Tor-related patching:
&gt;
&gt; cvs -z3 -d:pserver:anonymous@tork.cvs.sourceforge.net:/cvsroot/tork co -P 
&gt; torsocks
&gt; 
&gt; This module contains all the patches listed at:
&gt; 
&gt; http://tork.cvs.sourceforge.net/tork/torsocks/patches/

Thanks for picking up the ball on this one, Robert!  

Feel free to update the wiki to point to this version.  I assume
you've seen the list of patches at
https://wiki.torproject.org/noreply/TheOnionRouter/TSocksPatches ?

One thought: Maybe the name should change, or the version number
format should change, or something like that?  This would :
  - indicate that this is not the stock tsocks
  - give people something easy to google for when they want to find 
    the tsock that works with Tor.

 [...]
&gt; I will keep it in the TorK repository until it's fit for the Tor
&gt; project to host on svn (and distibute) and hopefully continue to
&gt; maintain it there with anyone else who is interested. If it's not
&gt; deemed suitable for the project to host I'll just continue to use it
&gt; as a basis for the torksocks bundled with TorK.

I don't see a reason why it couldn't be added to the Tor svn repo;
just drop a line when you think it's ready.


yrs,
-- 
Nick
</body></email><email><emailId>20080628172950</emailId><senderName>Karsten Loesing</senderName><senderEmail>karsten.loesing@gmx.net</senderEmail><timestampReceived>2008-06-28 17:29:50-0400</timestampReceived><subject>Re: Proposal: Combine Introduction and Rendezvous Points</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Hi Nick,

| Added as proposal 142.

Thanks!

| [As for getting this reviewed in time to get it merged into 0.2.1.x:
| I'm not going to merge code for features without security analysis.
| This analysis doesn't need to be done today or even by June 30, but it
| needs to be done before the code hits trunk.]

Agreed!

What kind of security analysis would you expect here? What I usually do
is think about all kinds of attacks and argue whether or not they are
possible and what efforts it takes to conduct them. I can imagine that
this has little to do with what you would call a security analysis. So,
I'd like to learn more about this. Can you give me some pointers?

| This isn't "plausible deniability" [...]

Whoops. Did we call it plausible deniability?

The property behind it is a combination of two properties that Lasse and
Paul described in their PET 2007 paper. But the new property had no
name, so we gave it one, and this one appeared... well, plausible.

Sorry for the confusion, we can change that name. :)

| (4) Separation of node properties.  Introduction points need to be up
| a lot, but don't need much bandwidth.  Rendezvous points need
| bandwidth, but are relatively ephemeral.  Likewise, we thought this
| was important.  We should analyze whether it is.

Good point. We'll analyze this one.

Maybe it's okay here to require a contact point to have both, high
uptime and bandwidth. I guess that there are so many relays out there
which are good candidates for contact points that we can be more picky
without risking to end up at the same relays all the time.

But that's just what I would expect, the statistics will tell us more.

| ... I've just given  the rest of the proposal a skim, and I think I
| need to have another look once I've re-read proposal 121.

Hmm, I don't want to keep you from re-reading proposal 121. However, the
combination of introduction and rendezvous points (proposal 142) should
not be specific to hidden services with client authorization (proposal
121), but should benefit all hidden services.

| An idea from the #tor-dev channel: it's probably time to do for the
| hidden service protocol what we did for the directory protocol, and
| split the specification into rend-spec-v1.txt and rend-spec.txt, and
| edit the latter to contain all these proposals once they're a little
| more discussed.  Doing this for directory stuff helped identify places
| that hadn't actually gotten specified in our proposals.

I'll write a draft rend-spec-v2.txt containing all the proposals
including the v2 hidden service directory specification after I have
sent you the remaining proposals for 0.2.1.x.

Thanks, Nick, for your comments---and your patience! :)

- --Karsten
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFIZnUN0M+WPffBEmURAnmRAKCFkHcaJdFVxRp39EZt/J9y0TH4pgCeIxZ1
wvkQ1uBFV41t+gU+mkL5tqQ=
=2W6k
-----END PGP SIGNATURE-----
</body></email><email><emailId>20080628192604</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@alum.mit.edu</senderEmail><timestampReceived>2008-06-28 19:26:04-0400</timestampReceived><subject>Re: Proposal: Improvements of Distributed Storage for Tor Hidden Service Descriptors</subject><body>

On Sat, Jun 28, 2008 at 07:41:30PM +0200, Karsten Loesing wrote:
&gt; -----BEGIN PGP SIGNED MESSAGE-----
&gt; Hash: SHA1
&gt; 
&gt; Hi Nick and list,
&gt; 
&gt; and here comes number two. This proposal is a follow-up of proposal 114.
&gt; Some of the improvements result from a statistical analysis of network
&gt; consensuses from January to March 2008. Others come from writing up the
&gt; results and discussing them. And the remaining items were still on my
&gt; TODO list waiting to be included at the next opportunity. All stated
&gt; improvements are backwards compatible to the current implementation.


Added as proposal 143.
</body></email><email><emailId>20080630042225</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-06-30 04:22:25-0400</timestampReceived><subject>Proposal deadline for 0.2.1.x delayed until 5 Jun 2008</subject><body>


See the subject line.  I'd still prefer as many proposals as possible
to be in by the 30th of June, but I'm busy enough with wedding
planning that I probably won't have mine in then, and it's not fair to
make everybody else follow the procedure and flout it myself.

I'll send an email with a summary of active proposals and my thoughts
on them tomorrow, I hope.

yrs,
-- 
Nick
</body></email><email><emailId>20080630081613</emailId><senderName>Kyle Williams</senderName><senderEmail>kyle.kwilliams@gmail.com</senderEmail><timestampReceived>2008-06-30 08:16:13-0400</timestampReceived><subject>JanusVM Update</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Hello all,

JanusVM has been updated to Tor 0.2.0.28-rc.
The main site now supports https.
Downloads are now available.

Enjoy!

- - Kyle Williams
https://www.janusvm.com
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.8 (MingW32)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iEYEARECAAYFAkholk0ACgkQwwh7z/GJWhF7dgCbBpAhqnz1nr/2rr9FU65mg7Aj
OsUAnAmINJi99v7u1sZkL6AfX5dbCw/s
=rxX5
-----END PGP SIGNATURE-----
</body></email><email><emailId>20080502041443</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-05-02 04:14:43-0400</timestampReceived><subject>Re: Parallelizing (some of) Tor's AES Operations</subject><body>

On Fri, May 02, 2008 at 12:05:11AM -0400, Matt Edman wrote:
  [...]
&gt; &gt; Alternatively, you could give each circuit _two_ cell queues for each
&gt; &gt; direction: one for cells that need to be crypted, and one for cells
&gt; &gt; that are already crypted and are ready to transmit.  All you'd need to
&gt; &gt; tell the workers about is which circuits have to be processed; all
&gt; &gt; you'd need to tell the main thread about is which circuits now have
&gt; &gt; more data.  I like this approach a little better because it doesn't
&gt; &gt; require quite so much bookkeeping to tell the workers about what keys
&gt; &gt; to use to crypt what, or to tell the main thread where to put cells.
&gt; 
&gt; I like this approach better too. Separate cell queues definitely seems like
&gt; the way to go.
&gt; 
&gt; &gt; It will definitely take some thinking to figure out exactly what kind
&gt; &gt; of locking and notification mechanisms you'd want to use here.  If you
&gt; &gt; have any questions about waking the main thread, or what kind of
&gt; &gt; integrity Tor's data structures need, just ask.
&gt; 
&gt; In terms of locking and notification mechanisms, is it reasonable to assume a
&gt; threaded environment? I notice CPU workers are typically threads, but may be
&gt; fork()ed processes on some platforms. If TOR_IS_MULTITHREADED is not defined,
&gt; though, we don't get to use the handy locking constructs that already exist in
&gt; compat.h. Are there really many platforms that don't handle threads very well?

There are a couple.  IMO, for the timeframe and use-cases you're
thinking of, I'd suggest you write your code with the assumption that
TOR_IS_MULTITHREADED is always defined.  On platforms without good
threading, we can just not have separate threads to handle AES.

&gt; It also looks like compat.h already has wrappers for thread
&gt; signaling, but are just '#if 0'ed out right now. I assume that's
&gt; simply because they're not currently used anywhere in Tor though
&gt; (rather than because it's broken).

Right.  Be aware however that they're as-yet untested; use at your own
risk.

yrs,
-- 
Nick
</body></email><email><emailId>20080502190433</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-05-02 19:04:33-0400</timestampReceived><subject>Re: Proposal: More robust consensus voting with diverse authority sets</subject><body>

On Fri, May 02, 2008 at 10:42:41AM +0200, Peter Palfrader wrote:
 [...]
&gt; Then we no longer need to solve maxclique() over the entire graph, but
&gt; we only need to solve maxclique_that_has_point_A_in_it() with A being
&gt; each of the authorities we trust.
&gt; 
&gt; Now maxclique_that_has_point_P_in_it() in itself hard also*, however we
&gt; can make our live easier by limiting the number of authorities that one
&gt; may list.  If we discard votes with too many neighbors early we
&gt; effectively have created a reasonable upper bound for the amount of work
&gt; we have to do while clique finding.

This is quite plausible.  Let's revise the proposal to say this, and
then think about it for a bit to look for more flaws and/or
opportunities.

yrs,
-- 
Nick
</body></email><email><emailId>20080511221755</emailId><senderName>Wesley Kenzie</senderName><senderEmail>wkenzie@shaw.ca</senderEmail><timestampReceived>2008-05-11 22:17:55-0400</timestampReceived><subject>RE: ExitNodes config use fingerprint rather than nickname</subject><body>


&gt; -----Original Message-----
&gt; From: owner-or-dev@freehaven.net 
&gt; [mailto:owner-or-dev@freehaven.net] On Behalf Of Nick Mathewson
&gt; Sent: May 7, 2008 5:21 PM
&gt; To: or-dev@freehaven.net
&gt; Subject: Re: ExitNodes config use fingerprint rather than nickname
&gt; 
&gt; 
&gt; On Wed, May 07, 2008 at 02:54:19PM -0700, Wesley Kenzie wrote:
&gt; &gt; I am considering trying my hand at a patch to allow 
&gt; fingerprints to be 
&gt; &gt; used in place of nicknames for ExitNodes and EntryNodes config 
&gt; &gt; variables.  (There are quite a few duplicate nicknames 
&gt; floating around 
&gt; &gt; which are not immediately obvious. I added a list of them 
&gt; yesterday to 
&gt; &gt; http://www.pickaproxy.com/?speak=tor so they can be easily 
&gt; &gt; identified.)  The problem currently is that duplicate 
&gt; nicknames cannot 
&gt; &gt; be used as specified exit or entry nodes.
&gt; 
&gt; This feature already exists.  Just stick a $ before the 
&gt; fingerprint, as in:
&gt; 
&gt; EntryNodes $70A08C76BCB9ADE55907029B83DB6891957AC92C
&gt; 
&gt; If you want to force a given name binding, you can use the format
&gt;   $70A08C76BCB9ADE55907029B83DB6891957AC92C=peacetime
&gt; to only match a "Named" server with the given nickname and key, or
&gt;   $70A08C76BCB9ADE55907029B83DB6891957AC92C~peacetime
&gt; to match any server with the given nickname and key.
&gt; 
&gt; This feature could be better documented, though, and I'd love 
&gt; to get a documentation patch to explain all of this better. :)
&gt; 

Nick, I would be glad to take a stab at this.  What tool(s) should I use to
create the patch file?  Or where can I read up on how to do this?

Wesley


</body></email><email><emailId>200805112217550</emailId><senderName>Wesley Kenzie</senderName><senderEmail>wkenzie@shaw.ca</senderEmail><timestampReceived>2008-05-11 22:17:55-0400</timestampReceived><subject>patch to enable accounting for clients?</subject><body>

[Attachment #2 (multipart/alternative)]


I need to have (some of?  all of?) the existing accounting functionality
enabled for clients, not just for servers.  Can someone give me some
pointers on where changes would have to be made?  Or is this in fact =
already
enabled and not documented?

Wesley

[Attachment #5 (text/html)]

&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"&gt;
&lt;HTML&gt;&lt;HEAD&gt;
&lt;META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=us-ascii"&gt;
&lt;TITLE id=ridTitle&gt;Message&lt;/TITLE&gt;

&lt;STYLE&gt;&lt;!-- body  { font-family: Arial, Helvetica; font-size: 10pt; color: #000000; \
margin-top: 25px; margin-left: 25px; } P.msoNormal, LI.msoNormal  { font-family: \
Helvetica, "Times New Roman"; font-size: 10pt; margin-top: 0px; margin-left: 0px; \
color: "#ffffcc"; } --&gt;&lt;/STYLE&gt;

&lt;META content="MSHTML 6.00.6000.16640" name=GENERATOR&gt;&lt;/HEAD&gt;
&lt;BODY id=ridBody background=cid:546331322@11052008-005F&gt;
&lt;P&gt;&lt;SPAN class=546331322-11052008&gt;&lt;FONT face=Verdana&gt;I need to have (some 
of?  all of?) the existing accounting functionality enabled for clients, 
not just for servers.  Can someone give me some pointers on where changes 
would have to be made?  Or is this in fact already enabled and not 
documented?&lt;/FONT&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;DIV&gt;&lt;FONT face=Verdana&gt;Wesley&lt;/FONT&gt;&lt;/DIV&gt;&lt;/BODY&gt;&lt;/HTML&gt;


["Blank Bkgrd.gif" (image/gif)]

</body></email><email><emailId>20080515190200</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-05-15 19:02:00-0400</timestampReceived><subject>Re: udp transport PoC</subject><body>

On Tue, May 13, 2008 at 10:31:21PM -0700, coderman wrote:
&gt; On Tue, May 13, 2008 at 3:11 PM, Adam Langley &lt;agl@imperialviolet.org&gt; wrote:
 [...]
&gt; &gt;  Your flow control should probably be based on[2]. The description in
&gt; &gt;  the TCP RFC now bares no relation to reality.
&gt; 
&gt; the problem with trying for true tcp fairness in a datagram transport
&gt; used among many peers in userspace is going to be timer resolution
&gt; (especially on win32, but still problematic in *nix).
&gt; 
&gt; i'd much prefer to see a robust fractional bandwidth allocation
&gt; specified for the datagram stack as a whole, than watch the poor
&gt; behavior of another attempted TCP over UDP in userspace.
&gt; 
&gt; (i admit a general bias against TCP fairness in userspace, so a grain
&gt; of salt with this $0.02..)

For the record, I'm pretty agnostic about which protocol to actually
use for reliable in-order delivery inside packets in a hypothetical
UDP Tor design.  I'd be surprised if the loss and latency
characteristics didn't turn out to have differences from those
typically encountered on the net at large, so it's quite possible that
something other than TCP will turn out to be the right choice.

This is going to be an exciting year for this topic, given the number
of people who seem to be interested in working on it: two currently
working on implementations that I'm aware of, plus the people on this
list taking an active interest.  It'll be neat when some of the
proof-of-concept implementations get to the stage where people can try
out different userspace protocols with them.  (It'll also be neat when
somebody actually writes up a detailed specification for their
protocol design in terms of a Proposal document. ;) )

yrs,
-- 
Nick
</body></email><email><emailId>20080515200340</emailId><senderName>Wesley Kenzie</senderName><senderEmail>wkenzie@shaw.ca</senderEmail><timestampReceived>2008-05-15 20:03:40-0400</timestampReceived><subject>RE: Nickname list includes 'xyz' which isn't a known router</subject><body>

[Attachment #2 (multipart/alternative)]


Here's another example: nickname "anonion".  It seems to be a valid exit
node as per GETINFO desc/all-recent and GETINFO ns/all scans I just ran (and
http://www.showmyip.com/?node=anonion shows it to have been up and regularly
running over the past week) and yet immediately after starting a new client
with this nickname listed in --ExitNodes with --StrictExitNodes 1, I get
"[warn] Nickname list includes 'anonion' which isn't a known router" showing
in log.
 
I then started up a new controller session and did a GETINFO ns/name/anonion
but got "551 Internal Error" as the result.
 
So I tried it's fingerprint with GETINFO
ns/id/23B59BABD548E1FB2865183165B8A619728F0016 and this time got the
expected "r" and "s" records.
 
Seems GETINFO ns/name/nickname is buggy in some instances?
 
Wesley
 

 
I keep getting the above [warn] messages when starting up a client session
with fresh nicknames just selected from a controller interface.  There are
usually between 1 and 5 of these messages, listing different nicknames.
This is on version 0.2.0.26-rc but has been on previous versions as well.

Is this a bug or am I missing something?  My best guess is that some
nicknames are not (yet) in the local cached-* files but they are (should
be?) good because I just found them using GETINFO desc/all-recent and
GETINFO ns/all.

I just checked Nickname "Freaky" and found it is listed in
cached-descriptors, but is not listed in cached-extrainfo.

. . . . .
Wesley


[Attachment #5 (text/html)]

&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"&gt;
&lt;HTML&gt;&lt;HEAD&gt;
&lt;META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=us-ascii"&gt;
&lt;TITLE id=ridTitle&gt;Message&lt;/TITLE&gt;

&lt;STYLE&gt;&lt;!-- body  { font-family: Arial, Helvetica; font-size: 10pt; color: #000000; \
margin-top: 25px; margin-left: 25px; } P.msoNormal, LI.msoNormal  { font-family: \
Helvetica, "Times New Roman"; font-size: 10pt; margin-top: 0px; margin-left: 0px; \
color: "#ffffcc"; } --&gt;&lt;/STYLE&gt;

&lt;META content="MSHTML 6.00.6000.16640" name=GENERATOR&gt;&lt;/HEAD&gt;
&lt;BODY id=ridBody background=cid:905454319@15052008-3397&gt;
&lt;DIV&gt;&lt;SPAN class=905454319-15052008&gt;&lt;FONT face=Verdana color=#0000ff&gt;Here's 
another example: nickname "anonion".  It seems to be a valid exit node as 
per GETINFO desc/all-recent and GETINFO ns/all scans I just ran 
(and &lt;A 
href="http://www.showmyip.com/?node=anonion"&gt;http://www.showmyip.com/?node=anonion&lt;/A&gt; shows \
 it to have been up and regularly running over the past week) and yet 
immediately after starting a new client with this nickname listed in 
--ExitNodes with --StrictExitNodes 1, I get "[warn] Nickname list includes 
'anonion' which isn't a known router" showing in log.&lt;/FONT&gt;&lt;/SPAN&gt;&lt;/DIV&gt;
&lt;DIV&gt;&lt;SPAN class=905454319-15052008&gt;&lt;FONT face=Verdana 
color=#0000ff&gt;&lt;/FONT&gt;&lt;/SPAN&gt; &lt;/DIV&gt;
&lt;DIV&gt;&lt;SPAN class=905454319-15052008&gt;&lt;FONT face=Verdana color=#0000ff&gt;I then 
started up a new controller session and did a GETINFO ns/name/anonion but got 
"551 Internal Error" as the result.&lt;/FONT&gt;&lt;/SPAN&gt;&lt;/DIV&gt;
&lt;DIV&gt;&lt;SPAN class=905454319-15052008&gt;&lt;FONT face=Verdana 
color=#0000ff&gt;&lt;/FONT&gt;&lt;/SPAN&gt; &lt;/DIV&gt;
&lt;DIV&gt;&lt;SPAN class=905454319-15052008&gt;&lt;FONT face=Verdana color=#0000ff&gt;So I tried 
it's fingerprint with GETINFO ns/id/23B59BABD548E1FB2865183165B8A619728F0016 and 
this time got the expected "r" and "s" records.&lt;/FONT&gt;&lt;/SPAN&gt;&lt;/DIV&gt;
&lt;DIV&gt;&lt;SPAN class=905454319-15052008&gt;&lt;FONT face=Verdana 
color=#0000ff&gt;&lt;/FONT&gt;&lt;/SPAN&gt; &lt;/DIV&gt;
&lt;DIV&gt;&lt;SPAN class=905454319-15052008&gt;&lt;FONT face=Verdana 
color=#0000ff&gt;Seems GETINFO ns/name/nickname is buggy in some 
instances?&lt;/FONT&gt;&lt;/SPAN&gt;&lt;/DIV&gt;
&lt;DIV&gt;&lt;SPAN class=905454319-15052008&gt;&lt;FONT face=Verdana 
color=#0000ff&gt;&lt;/FONT&gt;&lt;/SPAN&gt; &lt;/DIV&gt;
&lt;DIV&gt;&lt;SPAN class=905454319-15052008&gt;&lt;FONT face=Verdana 
color=#0000ff&gt;Wesley&lt;/FONT&gt;&lt;/SPAN&gt;&lt;/DIV&gt;
&lt;DIV&gt;&lt;SPAN class=905454319-15052008&gt;&lt;FONT face=Verdana 
color=#0000ff&gt;&lt;/FONT&gt;&lt;/SPAN&gt; &lt;/DIV&gt;
&lt;BLOCKQUOTE dir=ltr 
style="PADDING-LEFT: 5px; MARGIN-LEFT: 5px; BORDER-LEFT: #0000ff 2px solid; \
MARGIN-RIGHT: 0px"&gt;  &lt;DIV&gt;&lt;/DIV&gt;
  &lt;DIV class=OutlookMessageHeader lang=en-us dir=ltr align=left&gt;&lt;FONT 
  face=Tahoma&gt;&lt;SPAN class=905454319-15052008&gt;&lt;FONT face=Verdana 
  color=#0000ff&gt; &lt;/FONT&gt;&lt;/SPAN&gt;&lt;/FONT&gt;&lt;/DIV&gt;
  &lt;DIV class=OutlookMessageHeader lang=en-us dir=ltr align=left&gt;&lt;SPAN 
  class=249565616-14052008&gt;&lt;FONT face=Verdana&gt;&lt;SPAN 
  class=905454319-15052008&gt;&lt;FONT color=#0000ff&gt;I &lt;/FONT&gt;&lt;/SPAN&gt;keep getting 
  the above [warn] messages when starting up a client session with fresh 
  nicknames just selected from a controller interface.  There 
  are usually between 1 and 5 of these messages, listing different 
  nicknames.  This is on version 0.2.0.26-rc but has been on previous 
  versions as well.&lt;/FONT&gt;&lt;/SPAN&gt;&lt;/DIV&gt;
  &lt;P&gt;&lt;SPAN class=249565616-14052008&gt;&lt;FONT face=Verdana&gt;Is this a bug or am I 
  missing something?  My best guess is that some nicknames are not 
  (yet) in the local cached-* files but they are (should be?) good because 
  I just found them using GETINFO desc/all-recent and GETINFO 
  ns/all.&lt;/FONT&gt;&lt;/SPAN&gt;&lt;/P&gt;
  &lt;P&gt;&lt;SPAN class=249565616-14052008&gt;&lt;FONT face=Verdana&gt;I just checked Nickname 
  "Freaky" and found it is listed in cached-descriptors, but is 
  not listed in cached-extrainfo.&lt;/FONT&gt;&lt;/SPAN&gt;&lt;/P&gt;
  &lt;DIV align=left&gt;&lt;FONT face=Verdana&gt;. . . . .&lt;/FONT&gt;&lt;/DIV&gt;
  &lt;DIV align=left&gt;&lt;FONT 
face=Verdana&gt;Wesley&lt;/FONT&gt;&lt;/DIV&gt;&lt;/BLOCKQUOTE&gt;&lt;/BODY&gt;&lt;/HTML&gt;


["Blank Bkgrd.gif" (image/gif)]

</body></email><email><emailId>20080520195840</emailId><senderName></senderName><senderEmail>phobos</senderEmail><timestampReceived>2008-05-20 19:58:40-0400</timestampReceived><subject>Re: Auto-Update -Feature - Was: Draft schedule for Tor 0.2.1.x.</subject><body>

On Tue, May 20, 2008 at 10:16:24AM -0700, kyle.kwilliams@gmail.com wrote 5.1K bytes in 114 lines about:
: I was referring to the 200,000+ users that are using Tor as a client.  Most
: of the users are using Tor on a desktop or laptop.
: I would put this 'in your face' alert on the shoulders of Vidalia, since
: it's what most people use to control Tor.

Vidalia currently pops up a dialog box when Tor logs that your version
is not reccomended.  As for headless servers, there is a notice level
entry that states this Tor isn't recommended.

Setting up a good framework for auto-update of Tor is on the to do list
for late August.

-- 
Andrew
</body></email><email><emailId>20080524040121</emailId><senderName>Wesley Kenzie</senderName><senderEmail>wkenzie@shaw.ca</senderEmail><timestampReceived>2008-05-24 04:01:21-0400</timestampReceived><subject>RE: moria1 and moria2 still on 0.2.0.25?</subject><body>

&gt; On Sat, May 17, 2008 at 09:57:41AM -0700, Wesley Kenzie wrote:
&gt; &gt; &gt; Answer two: moria2 isn't a v3 directory authority (though it
&gt; &gt; &gt; is a v1, v2, and hidserv directory authority).
&gt; &gt; 
&gt; &gt; GETINFO ns/name/moria2 shows the following:
&gt; &gt; r moria2 cZvkXeIktgfFNwfQ4hQ+LUI+dM8 HyFqGCieCCKJvznJ2/Y03Clqu9E
2008-05-17 07:53:20 128.31.0.34 9002 9032 
&gt; &gt; s Authority Fast HSDir Named Running Stable V2Dir Valid
&gt; &gt; 
&gt; &gt; So where and how can I determine that moria2 is not a v3 directory 
&gt; &gt; authority?
&gt; 
&gt; Take a look at add_default_trusted_dir_authorities() in 
&gt; src/or/config.c

Huh?  It's hard coded!?  Still, I would think the "Authority" flag would
indicate it's v3.  It does this correctly for all the others as best I can
tell.

&gt; 
&gt; I wonder if we should make a way to do it that doesn't 
&gt; require looking at the code. Would a "tor --list-authorities" 
&gt; help perhaps? Nick/others, any better suggestions (preferably 
&gt; ones that don't involve trying to maintain another file in 
&gt; sync with the code)?
&gt; 
&gt; &gt; &gt; Answer three: questions like this should probably be on
&gt; &gt; &gt; or-talk in the future.
&gt; &gt; 
&gt; &gt; Sorry for my misunderstanding, but this seems clearly like a 
&gt; &gt; developer-related question/issue.
&gt; 
&gt; Ah, true, but it wasn't develop*ment*-related. Everybody on 
&gt; or-talk wants the developers to answer their question, but 
&gt; that doesn't mean they should all move to or-dev. :)
&gt; 
&gt; --Roger
&gt; 

Now I've got it!  Thanks for this clarification.

Wesley


</body></email><email><emailId>20080530001715</emailId><senderName>Karsten Loesing</senderName><senderEmail>karsten.loesing@gmx.net</senderEmail><timestampReceived>2008-05-30 00:17:15-0400</timestampReceived><subject>Re: [proposal 136] Re: Proposal: Simplify Configuration of Private</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Hi Nick,

| This looks pretty good to me.  There are a few
| issues remaining; let me know if you'd like me to fix them
| myself, or if you'd like to do it.

I tried to address these issues with the attached patch.

| The biggest issue is that there's no documentation for these new
| options in the manpage.  They probably want a new section of their
| own, since they're only useful for testing.

Done. I also fixed some minor issues in the existing manpage---mostly
formattings and not worth a separate patch.

|&gt; +  if (options-&gt;V3AuthInitialVotingInterval != 30*60 &amp;&amp;
|&gt; +      !options-&gt;TestingTorNetwork) {
|
| Hmmm.  I don't like encoding the default explicitly in two places.
| It's not obvious above that if somebody changes the default from "30
| minutes" they also need to change the test here.  The long-term fix is
| probably a more general config_is_default() function, but for now I
| don't see a trivial fix.

Hmm, true, this could get nasty if someone changes one place, but misses
the other. I added comments at both places. The third place is the
manpage that needs to be kept synchronous, too.

|&gt; +  } else if (options-&gt;V3AuthInitialVotingInterval &gt; 24*60*60) {
|&gt; +    REJECT("V3AuthInitialVotingInterval is insanely high.");
|
| This test is redundant with the test below; there isn't much reason to
| say "too high" for everything over a day, and "doesn't divide 30
| minutes evenly" for everything between 31 minutes and a day.
|
|&gt; +  } else if (((30*60) % options-&gt;V3AuthInitialVotingInterval) != 0) {
|&gt; +    REJECT("V3AuthInitialVotingInterval does not divide evenly into "
|&gt; +           "30 minutes.");
|&gt; +  }

Heh. Removed the first test.

| Wow.  This whole "parse it twice" business is a little hackish, but I
| don't see a better way to do it offhand, so I'll not argue.

Hmm, I don't see a better solution here, either. :/

- --Karsten
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFIP0eL0M+WPffBEmURAg+yAKC/MKx8fdhkGAhNVovvyFkRzB1oPwCgnWv1
2WMNI54rP7twM1OyaRn0Ezw=
=IKC3
-----END PGP SIGNATURE-----

["patch4.txt" (text/plain)]

Index: /home/karsten/tor/tor-trunk-private-network/doc/tor.1.in
===================================================================
--- /home/karsten/tor/tor-trunk-private-network/doc/tor.1.in	(revision 14830)
+++ /home/karsten/tor/tor-trunk-private-network/doc/tor.1.in	(working copy)
@@ -220,7 +220,11 @@
 .LP
 .TP
 \fBAlternateDirAuthority \fR[\fInickname\fR] [\fBflags\fR] \fIaddress\fR\fB:\fIport fingerprint\fP
+.LP
+.TP
 \fBAlternateHSAuthority \fR[\fInickname\fR] [\fBflags\fR] \fIaddress\fR\fB:\fIport fingerprint\fP
+.LP
+.TP
 \fBAlternateBridgeAuthority \fR[\fInickname\fR] [\fBflags\fR] \fIaddress\fR\fB:\fIport fingerprint\fP
 As DirServer, but replaces less of the default directory authorities.
 Using AlternateDirAuthority replaces the default Tor directory
@@ -228,7 +232,8 @@
 authorities in place.  Similarly, Using AlternateHSAuthority replaces
 the default hidden service authorities, but not the directory or
 bridge authorities.
-
+.LP
+.TP
 \fBFetchDirInfoEarly \fR\fB0\fR|\fB1\fR\fP
 If set to 1, Tor will always fetch directory information like other
 directory caches, even if you don't meet the normal criteria for
@@ -765,8 +770,6 @@
 Tor will instead refuse to make the connection.
 (Default: None).
 
-.LP
-.TP
 .SH SERVER OPTIONS
 .PP
 The following options are useful only for servers (that is, if \fBORPort\fP is non-zero):
@@ -1111,11 +1114,11 @@
 Set an entrance policy for this server, to limit who can connect to the
 directory ports.
 The policies have the same form as exit policies above.
-.LP
-.TP
 
 .SH DIRECTORY AUTHORITY SERVER OPTIONS
 .PP
+.LP
+.TP
 \fBRecommendedVersions \fR\fISTRING\fP
 STRING is a comma-separated list of Tor versions currently believed
 to be safe. The list is included in each directory, and nodes which
@@ -1215,7 +1218,7 @@
 intervals.  This time SHOULD divide evenly into a day. (Default: 1 hour)
 .LP
 .TP
-\fBV3AuthVoteDelay\fR \fINUM\fP
+\fBV3AuthVoteDelay\fR \fR\fIN\fR \fBminutes\fR|\fBhours\fP
 V3 authoritative directories only.  Configures the server's preferred
 delay between publishing its vote and assuming it has all the votes
 from all the other authorities.  Note that the actual time used is not
@@ -1223,7 +1226,7 @@
 (Default: 5 minutes.)
 .LP
 .TP
-\fBV3AuthDistDelay\fR \fINUM\fP
+\fBV3AuthDistDelay\fR \fR\fIN\fR \fBminutes\fR|\fBhours\fP
 V3 authoritative directories only.  Configures the server's preferred
 delay between publishing its consensus and signature and assuming it
 has all the signatures from all the other authorities.  Note that the
@@ -1291,6 +1294,67 @@
 service descriptors to the directory servers.  This information is also
 uploaded whenever it changes.  (Default: 20 minutes)
 
+.SH TESTING NETWORK OPTIONS
+.PP
+The following options are used for running a testing Tor network.
+.LP
+.TP
+\fBTestingTorNetwork \fR\fB0\fR|\fB1\fR\fP
+If set to 1, Tor adjusts default values of the configuration options below,
+so that it is easier to set up a testing Tor network. May only be set if
+non-default set of DirServers is set. Cannot be unset while Tor is running.
+(Default: 0)
+
+.PD 0
+.RS 12
+.IP "ServerDNSAllowBrokenResolvConf 1"
+.IP "DirAllowPrivateAddresses 1"
+.IP "EnforceDistinctSubnets 0"
+.IP "AssumeReachable 1"
+.IP "AuthDirMaxServersPerAddr 0"
+.IP "AuthDirMaxServersPerAuthAddr 0"
+.IP "ClientDNSRejectInternalAddresses 0"
+.IP "ExitPolicyRejectPrivate 0"
+.IP "V3AuthVotingInterval 5 minutes"
+.IP "V3AuthVoteDelay 20 seconds"
+.IP "V3AuthDistDelay 20 seconds"
+.IP "V3AuthInitialVotingInterval 5 minutes"
+.IP "V3AuthInitialVoteDelay 20 seconds"
+.IP "V3AuthInitialDistDelay 20 seconds"
+.IP "DirTimeToLearnReachability 0 minutes"
+.IP "EstimatedDescriptorPropagationTime 0 minutes"
+.RE
+.PD
+.LP
+.TP
+\fBV3AuthInitialVotingInterval\fR \fR\fIN\fR \fBminutes\fR|\fBhours\fP
+Like \fBV3AuthVotingInterval\fR, but for initial voting interval before the
+first consensus has been created. Changing this requires that
+\fBTestingTorNetwork\fR is set. (Default: 30 minutes)
+.LP
+.TP
+\fBV3AuthInitialVoteDelay\fR \fR\fIN\fR \fBminutes\fR|\fBhours\fP
+Like \fBV3AuthInitialVoteDelay\fR, but for initial voting interval before
+the first consensus has been created. Changing this requires that
+\fBTestingTorNetwork\fR is set. (Default: 5 minutes)
+.LP
+.TP
+\fBV3AuthInitialDistDelay\fR \fR\fIN\fR \fBminutes\fR|\fBhours\fP
+Like \fBV3AuthInitialDistDelay\fR, but for initial voting interval before
+the first consensus has been created. Changing this requires that
+\fBTestingTorNetwork\fR is set. (Default: 5 minutes)
+.LP
+.TP
+\fBDirTimeToLearnReachability\fR \fR\fIN\fR \fBminutes\fR|\fBhours\fP
+Consider routers as Running this time after starting an authority.
+(Default: 30 minutes)
+.LP
+.TP
+\fBEstimatedDescriptorPropagationTime\fR \fR\fIN\fR \fBminutes\fR|\fBhours\fP
+Clients try downloading router descriptors from directory caches after this
+time. Changing this requires that \fBTestingTorNetwork\fR is set.
+(Default: 10 minutes)
+
 .\" UNDOCUMENTED
 .\" ignoreversion
 
Index: /home/karsten/tor/tor-trunk-private-network/src/or/config.c
===================================================================
--- /home/karsten/tor/tor-trunk-private-network/src/or/config.c	(revision 14830)
+++ /home/karsten/tor/tor-trunk-private-network/src/or/config.c	(working copy)
@@ -174,6 +174,7 @@
   V(DataDirectory,               STRING,   NULL),
   OBSOLETE("DebugLogFile"),
   V(DirAllowPrivateAddresses,    BOOL,     NULL),
+  V(DirTimeToLearnReachability,  INTERVAL, "30 minutes"),
   V(DirListenAddress,            LINELIST, NULL),
   OBSOLETE("DirFetchPeriod"),
   V(DirPolicy,                   LINELIST, NULL),
@@ -188,6 +189,7 @@
   V(DownloadExtraInfo,           BOOL,     "0"),
   V(EnforceDistinctSubnets,      BOOL,     "1"),
   V(EntryNodes,                  STRING,   NULL),
+  V(EstimatedDescriptorPropagationTime, INTERVAL, "10 minutes"),
   V(ExcludeNodes,                STRING,   NULL),
   V(ExitNodes,                   STRING,   NULL),
   V(ExitPolicy,                  LINELIST, NULL),
@@ -252,6 +254,7 @@
   V(OutboundBindAddress,         STRING,   NULL),
   OBSOLETE("PathlenCoinWeight"),
   V(PidFile,                     STRING,   NULL),
+  V(TestingTorNetwork,           BOOL,     "0"),
   V(PreferTunneledDirConns,      BOOL,     "1"),
   V(ProtocolWarnings,            BOOL,     "0"),
   V(PublishServerDescriptor,     CSV,      "1"),
@@ -306,6 +309,9 @@
   VAR("V1AuthoritativeDirectory",BOOL, V1AuthoritativeDir,   "0"),
   VAR("V2AuthoritativeDirectory",BOOL, V2AuthoritativeDir,   "0"),
   VAR("V3AuthoritativeDirectory",BOOL, V3AuthoritativeDir,   "0"),
+  V(V3AuthInitialVotingInterval, INTERVAL, "30 minutes"),
+  V(V3AuthInitialVoteDelay,      INTERVAL, "5 minutes"),
+  V(V3AuthInitialDistDelay,      INTERVAL, "5 minutes"),
   V(V3AuthVotingInterval,        INTERVAL, "1 hour"),
   V(V3AuthVoteDelay,             INTERVAL, "5 minutes"),
   V(V3AuthDistDelay,             INTERVAL, "5 minutes"),
@@ -322,6 +328,27 @@
   V(MinUptimeHidServDirectoryV2, INTERVAL, "24 hours"),
   { NULL, CONFIG_TYPE_OBSOLETE, 0, NULL }
 };
+
+/* Keep defaults synchronous with man page and config value check. */
+static config_var_t testing_tor_network_defaults[] = {
+  V(ServerDNSAllowBrokenResolvConf, BOOL,  "1"),
+  V(DirAllowPrivateAddresses,    BOOL,     "1"),
+  V(EnforceDistinctSubnets,      BOOL,     "0"),
+  V(AssumeReachable,             BOOL,     "1"),
+  V(AuthDirMaxServersPerAddr,    UINT,     "0"),
+  V(AuthDirMaxServersPerAuthAddr,UINT,     "0"),
+  V(ClientDNSRejectInternalAddresses, BOOL,"0"),
+  V(ExitPolicyRejectPrivate,     BOOL,     "0"),
+  V(V3AuthVotingInterval,        INTERVAL, "5 minutes"),
+  V(V3AuthVoteDelay,             INTERVAL, "20 seconds"),
+  V(V3AuthDistDelay,             INTERVAL, "20 seconds"),
+  V(V3AuthInitialVotingInterval, INTERVAL, "5 minutes"),
+  V(V3AuthInitialVoteDelay,      INTERVAL, "20 seconds"),
+  V(V3AuthInitialDistDelay,      INTERVAL, "20 seconds"),
+  V(DirTimeToLearnReachability,  INTERVAL, "0 minutes"),
+  V(EstimatedDescriptorPropagationTime, INTERVAL, "0 minutes"),
+  { NULL, CONFIG_TYPE_OBSOLETE, 0, NULL }
+};
 #undef VAR
 
 #define VAR(name,conftype,member,initvalue)                             \
@@ -3347,6 +3374,73 @@
     });
   }
 
+  if (options-&gt;TestingTorNetwork &amp;&amp; !options-&gt;DirServers) {
+    REJECT("TestingTorNetwork may only be configured in combination with "
+           "a non-default set of DirServers.");
+  }
+
+  /* Keep changes to hard-coded values synchronous to man page and default
+   * values table. */
+  if (options-&gt;V3AuthInitialVotingInterval != 30*60 &amp;&amp;
+      !options-&gt;TestingTorNetwork) {
+    REJECT("V3AuthInitialVotingInterval may only be changed in testing "
+           "Tor networks!");
+  } else if (options-&gt;V3AuthInitialVotingInterval &lt; MIN_VOTE_INTERVAL) {
+    REJECT("V3AuthInitialVotingInterval is insanely low.");
+  } else if (((30*60) % options-&gt;V3AuthInitialVotingInterval) != 0) {
+    REJECT("V3AuthInitialVotingInterval does not divide evenly into "
+           "30 minutes.");
+  }
+
+  if (options-&gt;V3AuthInitialVoteDelay != 5*60 &amp;&amp;
+      !options-&gt;TestingTorNetwork) {
+    REJECT("V3AuthInitialVoteDelay may only be changed in testing "
+           "Tor networks!");
+  } else if (options-&gt;V3AuthInitialVoteDelay &lt; MIN_VOTE_SECONDS) {
+    REJECT("V3AuthInitialVoteDelay is way too low.");
+  }
+
+  if (options-&gt;V3AuthInitialDistDelay != 5*60 &amp;&amp;
+      !options-&gt;TestingTorNetwork) {
+    REJECT("V3AuthInitialDistDelay may only be changed in testing "
+           "Tor networks!");
+  } else if (options-&gt;V3AuthInitialDistDelay &lt; MIN_DIST_SECONDS) {
+    REJECT("V3AuthInitialDistDelay is way too low.");
+  }
+
+  if (options-&gt;V3AuthInitialVoteDelay + options-&gt;V3AuthInitialDistDelay &gt;=
+      options-&gt;V3AuthInitialVotingInterval/2) {
+    REJECT("V3AuthInitialVoteDelay plus V3AuthInitialDistDelay must be "
+           "less than half V3AuthInitialVotingInterval");
+  }
+
+  if (options-&gt;DirTimeToLearnReachability != 30*60 &amp;&amp;
+      !options-&gt;TestingTorNetwork) {
+    REJECT("DirTimeToLearnReachability may only be changed in testing "
+           "Tor networks!");
+  } else if (options-&gt;DirTimeToLearnReachability &lt; 0) {
+    REJECT("DirTimeToLearnReachability must be non-negative.");
+  } else if (options-&gt;DirTimeToLearnReachability &gt; 2*60*60) {
+    COMPLAIN("DirTimeToLearnReachability is insanely high.");
+  }
+
+  if (options-&gt;EstimatedDescriptorPropagationTime != 10*60 &amp;&amp;
+      !options-&gt;TestingTorNetwork) {
+    REJECT("EstimatedDescriptorPropagationTime may only be changed in "
+           "testing Tor networks!");
+  } else if (options-&gt;EstimatedDescriptorPropagationTime &lt; 0) {
+    REJECT("EstimatedDescriptorPropagationTime must be non-negative.");
+  } else if (options-&gt;EstimatedDescriptorPropagationTime &gt; 60*60) {
+    COMPLAIN("EstimatedDescriptorPropagationTime is insanely high.");
+  }
+
+  if (options-&gt;TestingTorNetwork) {
+    log_warn(LD_CONFIG, "TestingTorNetwork is set. This will make your node "
+                        "almost unusable in the public Tor network, and is "
+                        "therefore only advised if you are building a "
+                        "testing Tor network!");
+  }
+
   return 0;
 #undef REJECT
 #undef COMPLAIN
@@ -3410,6 +3504,12 @@
     return -1;
   }
 
+  if (old-&gt;TestingTorNetwork != new_val-&gt;TestingTorNetwork) {
+    *msg = tor_strdup("While Tor is running, changing TestingTorNetwork "
+                      "is not allowed.");
+    return -1;
+  }
+
   return 0;
 }
 
@@ -3778,6 +3878,50 @@
     goto err;
   }
 
+  /* If this is a testing network configuration, change defaults
+   * for a list of dependent config options, re-initialize newoptions
+   * with the new defaults, and assign all options to it second time. */
+  if (newoptions-&gt;TestingTorNetwork) {
+
+    /* Change defaults. */
+    int i;
+    for (i = 0; testing_tor_network_defaults[i].name; ++i) {
+      config_var_t *new_var = &amp;testing_tor_network_defaults[i];
+      config_var_t *old_var =
+          config_find_option(&amp;options_format, new_var-&gt;name);
+      tor_assert(new_var);
+      tor_assert(old_var);
+      old_var-&gt;initvalue = new_var-&gt;initvalue;
+    }
+
+    /* Clear newoptions and re-initialize them with new defaults. */
+    config_free(&amp;options_format, newoptions);
+    newoptions = tor_malloc_zero(sizeof(or_options_t));
+    newoptions-&gt;_magic = OR_OPTIONS_MAGIC;
+    options_init(newoptions);
+    newoptions-&gt;command = command;
+    newoptions-&gt;command_arg = command_arg;
+
+    /* Assign all options a second time. */
+    retval = config_get_lines(cf, &amp;cl);
+    if (retval &lt; 0) {
+      err = SETOPT_ERR_PARSE;
+      goto err;
+    }
+    retval = config_assign(&amp;options_format, newoptions, cl, 0, 0, msg);
+    config_free_lines(cl);
+    if (retval &lt; 0) {
+      err = SETOPT_ERR_PARSE;
+      goto err;
+    }
+    retval = config_assign(&amp;options_format, newoptions,
+                           global_cmdline_options, 0, 0, msg);
+    if (retval &lt; 0) {
+      err = SETOPT_ERR_PARSE;
+      goto err;
+    }
+  }
+
   /* Validate newoptions */
   if (options_validate(oldoptions, newoptions, 0, msg) &lt; 0) {
     err = SETOPT_ERR_PARSE; /*XXX021 make this separate.*/
Index: /home/karsten/tor/tor-trunk-private-network/src/or/dirserv.c
===================================================================
--- /home/karsten/tor/tor-trunk-private-network/src/or/dirserv.c	(revision 14830)
+++ /home/karsten/tor/tor-trunk-private-network/src/or/dirserv.c	(working copy)
@@ -2122,10 +2122,6 @@
     router-&gt;is_bad_exit = router-&gt;is_bad_directory = 0;
 }
 
-/** If we've been around for less than this amount of time, our reachability
- * information is not accurate. */
-#define DIRSERV_TIME_TO_GET_REACHABILITY_INFO (30*60)
-
 /** Return a new networkstatus_t* containing our current opinion. (For v3
  * authorities) */
 networkstatus_t *
@@ -2155,7 +2151,7 @@
   tor_assert(private_key);
   tor_assert(cert);
 
-  if (now - time_of_process_start &lt; DIRSERV_TIME_TO_GET_REACHABILITY_INFO)
+  if (now - time_of_process_start &lt; options-&gt;DirTimeToLearnReachability)
     vote_on_reachability = 0;
 
   if (resolve_my_address(LOG_WARN, options, &amp;addr, &amp;hostname)&lt;0) {
@@ -2241,7 +2237,7 @@
       last_consensus_interval = current_consensus-&gt;fresh_until -
         current_consensus-&gt;valid_after;
     else
-      last_consensus_interval = DEFAULT_VOTING_INTERVAL_WHEN_NO_CONSENSUS;
+      last_consensus_interval = options-&gt;V3AuthInitialVotingInterval;
     v3_out-&gt;valid_after =
       dirvote_get_start_of_next_interval(now, (int)last_consensus_interval);
     format_iso_time(tbuf, v3_out-&gt;valid_after);
Index: /home/karsten/tor/tor-trunk-private-network/src/or/dirvote.c
===================================================================
--- /home/karsten/tor/tor-trunk-private-network/src/or/dirvote.c	(revision 14830)
+++ /home/karsten/tor/tor-trunk-private-network/src/or/dirvote.c	(working copy)
@@ -1300,8 +1300,9 @@
     vote_delay = consensus-&gt;vote_seconds;
     dist_delay = consensus-&gt;dist_seconds;
   } else {
-    interval = DEFAULT_VOTING_INTERVAL_WHEN_NO_CONSENSUS;
-    vote_delay = dist_delay = 300;
+    interval = options-&gt;V3AuthInitialVotingInterval;
+    vote_delay = options-&gt;V3AuthInitialVoteDelay;
+    dist_delay = options-&gt;V3AuthInitialDistDelay;
   }
 
   tor_assert(interval &gt; 0);
Index: /home/karsten/tor/tor-trunk-private-network/src/or/or.h
===================================================================
--- /home/karsten/tor/tor-trunk-private-network/src/or/or.h	(revision 14830)
+++ /home/karsten/tor/tor-trunk-private-network/src/or/or.h	(working copy)
@@ -2350,6 +2350,31 @@
    * migration purposes? */
   int V3AuthUseLegacyKey;
 
+  /** The length of time that we think an initial consensus should be
+   * fresh. */
+  int V3AuthInitialVotingInterval;
+
+  /** The length of time we think it will take to distribute initial
+   * votes. */
+  int V3AuthInitialVoteDelay;
+
+  /** The length of time we think it will take to distribute initial
+   * signatures. */
+  int V3AuthInitialDistDelay;
+
+  /** If an authority has been around for less than this amount of time,
+   * its reachability information is not accurate. */
+  int DirTimeToLearnReachability;
+
+  /** Clients don't download any descriptor this recent, since it will
+   * probably not have propagated to enough caches. */
+  int EstimatedDescriptorPropagationTime;
+
+  /** If true, we take part in a testing network. Change the defaults of a
+   * couple of other configuration options and allow to change the values
+   * of certain configuration options. */
+  int TestingTorNetwork;
+
   /** File to check for a consensus networkstatus, if we don't have one
    * cached. */
   char *FallbackNetworkstatusFile;
@@ -3196,9 +3221,6 @@
 /** Smallest allowable voting interval. */
 #define MIN_VOTE_INTERVAL 300
 
-/** If there is no consensus, what interval do we default to? */
-#define DEFAULT_VOTING_INTERVAL_WHEN_NO_CONSENSUS (30*60)
-
 void dirvote_free_all(void);
 
 /* vote manipulation */
Index: /home/karsten/tor/tor-trunk-private-network/src/or/routerlist.c
===================================================================
--- /home/karsten/tor/tor-trunk-private-network/src/or/routerlist.c	(revision 14830)
+++ /home/karsten/tor/tor-trunk-private-network/src/or/routerlist.c	(working copy)
@@ -3680,10 +3680,6 @@
   tor_free(resource);
 }
 
-/** Clients don't download any descriptor this recent, since it will probably
- * not have propagated to enough caches. */
-#define ESTIMATED_PROPAGATION_TIME (10*60)
-
 /** Return 0 if this routerstatus is obsolete, too new, isn't
  * running, or otherwise not a descriptor that we would make any
  * use of even if we had it. Else return 1. */
@@ -3695,7 +3691,7 @@
      * But, if we want to have a complete list, fetch it anyway. */
     return 0;
   }
-  if (rs-&gt;published_on + ESTIMATED_PROPAGATION_TIME &gt; now) {
+  if (rs-&gt;published_on + options-&gt;EstimatedDescriptorPropagationTime &gt; now) {
     /* Most caches probably don't have this descriptor yet. */
     return 0;
   }


["patch4.txt.sig" (application/octet-stream)]

</body></email><email><emailId>20080401150213</emailId><senderName>Peter Palfrader</senderName><senderEmail>peter@palfrader.org</senderEmail><timestampReceived>2008-04-01 15:02:13-0400</timestampReceived><subject>Proposal: More robust consensus voting with diverse authority sets</subject><body>

Filename: xxx-robust-voting.txt
Title: More robust consensus voting with diverse authority sets
Author: Peter Palfrader
Created: 2008-04-01
Status: Draft

Overview:

  A means to arrive at a valid directory consensus even when voters
  disagree on who is an authority.


Motivation:

  Right now there are about five authoritative directory servers in the
  Tor network, tho this number is expected to rise to about 15 eventually.

  Adding a new authority requires synchronized action from all operators of
  directory authorities so that at any time during the update at least half of
  all authorities are running and agree on who is an authority.  The latter
  requirement is there so that the authorities can arrive at a common
  consensus:  Each authority builds the consensus based on the votes from
  all authorities it recognizes, and so a different set of recognized
  authorities will lead to a different consensus document.


Objective:

  The modified voting procedure outlined in this proposal obsoletes the
  requirement for most authorities to exactly agree on the list of
  authorities.


Proposal:

  The vote document each authority generates contains a list of 
  authorities recognized by the generating authority.  This will be 
  a list of authority identity fingerprints.

  Authorities will accept votes from and serve/mirror votes also for
  authorities they do not recognize.  (Votes contain the signing,
  authority key, and the certificate linking them so they can be 
  verified even without knowing the authority beforehand.)

  Before building the consensus we will check which votes to use for
  building:

   1) We build a directed graph of which authority/vote recognizes
      whom.
   2) (Parts of the graph that aren't reachable, directly or
      indirectly, from any authorities we recognize can be discarded
      immediately.)
   3) We find the largest fully connected subgraph.
      (Should there be more than one subgraph of the same size there
      needs to be some arbitrary ordering so we always pick the same.
      E.g. pick the one who has the smaller (XOR of all votes' digests)
      or something.)
   4) If we are part of that subgraph, great.  This is the list of 
      votes we build our consensus with.
   5) If we are not part of that subgraph, remove all the nodes that
      are part of it and go to 3.

  Using this procedure authorities that are updated to recognize a
  new authority will continue voting with the old group until a
  sufficient number has been updated to arrive at a consensus with
  the recently added authority.

  In fact, the old set of authorities will probably be voting among
  themselves until all but one has been updated to recognize the
  new authority.  Then which set of votes is used for consensus 
  building depends on which of the two equally large sets gets 
  ordered before the other in step (3) above.

  It is necessary to continue with the process in (5) even if we
  are not in the largest subgraph.  Otherwise one rogue authority
  could create a number of extra votes (by new authorities) so that
  everybody stops at 5 and no consensus is built, even tho it would
  be trusted by all clients.


Anonymity Implications:

  The author does not believe this proposal to have anonymity
  implications.


Possible Attacks/Open Issues/Some thinking required:

 Q: Can a number (less or exactly half) of the authorities cause an honest
    authority to vote for "their" consensus rather than the one that would
    result were all authorities taken into account?


 Q: Can a set of votes from external authorities, i.e of whom we trust either
    none or at least not all, cause us to change the set of consensus makers we
    pick?
 A: Yes, if other authorities decide they rather build a consensus with them
    then they'll be thrown out in step 3.  But that's ok since those other
    authorities will never vote with us anyway.
    If we trust none of them then we throw them out even sooner, so no harm done.

 Q: Can this ever force us to build a consensus with authorities we do not
    recognize?
 A: No, we can never build a fully connected set with them in step 3.


</body></email><email><emailId>20080507215419</emailId><senderName>Wesley Kenzie</senderName><senderEmail>wkenzie@shaw.ca</senderEmail><timestampReceived>2008-05-07 21:54:19-0400</timestampReceived><subject>ExitNodes config use fingerprint rather than nickname</subject><body>

[Attachment #2 (multipart/alternative)]


I am considering trying my hand at a patch to allow fingerprints to be used
in place of nicknames for ExitNodes and EntryNodes config variables.  (There
are quite a few duplicate nicknames floating around which are not
immediately obvious. I added a list of them yesterday to
http://www.pickaproxy.com/?speak=tor so they can be easily identified.)  The
problem currently is that duplicate nicknames cannot be used as specified
exit or entry nodes.

Can someone (Nick?) give me some pointers to start, with respect to how
nicknames are used to select exit and entry nodes?  Or is this going to
require significant changes?  I do not see any functions defining a direct
relationship between a nickname and a fingerprint but suspect there is one
somewhere.

Wesley

 


[Attachment #5 (text/html)]

&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"&gt;
&lt;HTML&gt;&lt;HEAD&gt;
&lt;META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=us-ascii"&gt;
&lt;TITLE id=ridTitle&gt;Message&lt;/TITLE&gt;

&lt;STYLE&gt;&lt;!-- body  { font-family: Arial, Helvetica; font-size: 10pt; color: #000000; \
margin-top: 25px; margin-left: 25px; } P.msoNormal, LI.msoNormal  { font-family: \
Helvetica, "Times New Roman"; font-size: 10pt; margin-top: 0px; margin-left: 0px; \
color: "#ffffcc"; } --&gt;&lt;/STYLE&gt;

&lt;META content="MSHTML 6.00.6000.16640" name=GENERATOR&gt;&lt;/HEAD&gt;
&lt;BODY id=ridBody background=cid:343294021@07052008-0B6A&gt;
&lt;P&gt;&lt;SPAN class=343294021-07052008&gt;&lt;FONT face=Verdana&gt;I am considering trying 
my hand at a patch to allow fingerprints to be used in place of nicknames 
for ExitNodes and EntryNodes config variables.  (There are quite a few 
duplicate nicknames floating around which are not immediately obvious. I added a 
list of them yesterday to &lt;A 
href="http://www.pickaproxy.com/?speak=tor"&gt;http://www.pickaproxy.com/?speak=tor&lt;/A&gt; 
so they can be easily identified.)  The problem currently is that duplicate 
nicknames cannot be used as specified exit or entry nodes.&lt;/FONT&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P&gt;&lt;SPAN class=343294021-07052008&gt;&lt;FONT face=Verdana&gt;Can someone 
(Nick?) give me some pointers to start, with respect to how nicknames are 
used to select exit and entry nodes?  Or is this going to require 
significant changes?  I do not see any functions defining a direct 
relationship between a nickname and a fingerprint but suspect there is one 
somewhere.&lt;/FONT&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P&gt;&lt;SPAN class=343294021-07052008&gt;&lt;FONT face=Verdana&gt;Wesley&lt;/FONT&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P&gt;&lt;FONT face=Verdana&gt;&lt;/FONT&gt; &lt;/P&gt;&lt;/BODY&gt;&lt;/HTML&gt;


["Blank Bkgrd.gif" (image/gif)]

</body></email><email><emailId>20080514170533</emailId><senderName>Wesley Kenzie</senderName><senderEmail>wkenzie@shaw.ca</senderEmail><timestampReceived>2008-05-14 17:05:33-0400</timestampReceived><subject>Nickname list includes 'xyz' which isn't a known router</subject><body>

[Attachment #2 (multipart/alternative)]


I keep getting the above [warn] messages when starting up a client session
with fresh nicknames just selected from a controller interface.  There are
usually between 1 and 5 of these messages, listing different nicknames.
This is on version 0.2.0.26-rc but has been on previous versions as well.

Is this a bug or am I missing something?  My best guess is that some
nicknames are not (yet) in the local cached-* files but they are (should
be?) good because I just found them using GETINFO desc/all-recent and
GETINFO ns/all.

I just checked Nickname "Freaky" and found it is listed in
cached-descriptors, but is not listed in cached-extrainfo.

. . . . .
Wesley

[Attachment #5 (text/html)]

&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"&gt;
&lt;HTML&gt;&lt;HEAD&gt;
&lt;META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=us-ascii"&gt;
&lt;TITLE id=ridTitle&gt;Message&lt;/TITLE&gt;

&lt;STYLE&gt;&lt;!-- body  { font-family: Arial, Helvetica; font-size: 10pt; color: #000000; \
margin-top: 25px; margin-left: 25px; } P.msoNormal, LI.msoNormal  { font-family: \
Helvetica, "Times New Roman"; font-size: 10pt; margin-top: 0px; margin-left: 0px; \
color: "#ffffcc"; } --&gt;&lt;/STYLE&gt;

&lt;META content="MSHTML 6.00.6000.16640" name=GENERATOR&gt;&lt;/HEAD&gt;
&lt;BODY id=ridBody background=cid:249565616@14052008-34A9&gt;
&lt;P&gt;&lt;SPAN class=249565616-14052008&gt;&lt;FONT face=Verdana&gt;I keep getting the above 
[warn] messages when starting up a client session with fresh nicknames just 
selected from a controller interface.  There are usually between 1 and 
5 of these messages, listing different nicknames.  This is on version 
0.2.0.26-rc but has been on previous versions as well.&lt;/FONT&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P&gt;&lt;SPAN class=249565616-14052008&gt;&lt;FONT face=Verdana&gt;Is this a bug or am I 
missing something?  My best guess is that some nicknames are not 
(yet) in the local cached-* files but they are (should be?) good because I 
just found them using GETINFO desc/all-recent and GETINFO 
ns/all.&lt;/FONT&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;P&gt;&lt;SPAN class=249565616-14052008&gt;&lt;FONT face=Verdana&gt;I just checked Nickname 
"Freaky" and found it is listed in cached-descriptors, but is not 
listed in cached-extrainfo.&lt;/FONT&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;DIV align=left&gt;&lt;FONT face=Verdana&gt;. . . . .&lt;/FONT&gt;&lt;/DIV&gt;
&lt;DIV align=left&gt;&lt;FONT face=Verdana&gt;Wesley&lt;/FONT&gt;&lt;/DIV&gt;&lt;/BODY&gt;&lt;/HTML&gt;


["Blank Bkgrd.gif" (image/gif)]

</body></email><email><emailId>20080520055043</emailId><senderName>Marcus Wolschon</senderName><senderEmail>marcus@wolschon.biz</senderEmail><timestampReceived>2008-05-20 05:50:43-0400</timestampReceived><subject>Auto-Update -Feature - Was: Draft schedule for Tor 0.2.1.x.</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1



Hello Kyle,

so what is your proposal exactly?
How do you suppose a background-service
on a very possibly headless and unattended
machine in a data-center should issue such
a message to the administrator?

Marcus

Kyle Williams schrieb:
| Nick,
|
| I have a suggestion.  Automatic updates.
| Here is my reason as to why I feel this is probably the most important
| feature you need to implement.
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFIMmazf1hPnk3Z0cQRAvCVAKCIB6B3m/UmQfg0liObSLElA0uBDgCg1fJe
M6e6o7CzN1oxPBEEUM2cXak=
=lkkw
-----END PGP SIGNATURE-----
</body></email><email><emailId>20080517002147</emailId><senderName>Wesley Kenzie</senderName><senderEmail>wkenzie@shaw.ca</senderEmail><timestampReceived>2008-05-17 00:21:47-0400</timestampReceived><subject>moria1 and moria2 still on 0.2.0.25?</subject><body>

[Attachment #2 (multipart/alternative)]


Why is it that 2 of the v3 directory authorities (moria1 and moria2 at
mit.edu running on the same IP address 128.31.0.34) are still running
version 0.2.0.25?  I see that all the other 6 v3 directory authorities have
upgraded, but not these 2 ...

Wesley 

[Attachment #5 (text/html)]

&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"&gt;
&lt;HTML&gt;&lt;HEAD&gt;
&lt;META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=us-ascii"&gt;
&lt;TITLE id=ridTitle&gt;Message&lt;/TITLE&gt;

&lt;STYLE&gt;&lt;!-- body  { font-family: Arial, Helvetica; font-size: 10pt; color: #000000; \
margin-top: 25px; margin-left: 25px; } P.msoNormal, LI.msoNormal  { font-family: \
Helvetica, "Times New Roman"; font-size: 10pt; margin-top: 0px; margin-left: 0px; \
color: "#ffffcc"; } --&gt;&lt;/STYLE&gt;

&lt;META content="MSHTML 6.00.6000.16640" name=GENERATOR&gt;&lt;/HEAD&gt;
&lt;BODY id=ridBody background=cid:406451621@16052008-1E38&gt;
&lt;P&gt;&lt;SPAN class=406451621-16052008&gt;&lt;FONT face=Verdana&gt;Why is it that 2 of the v3 
directory authorities (moria1 and moria2 at mit.edu running on the same IP 
address 128.31.0.34) are still running version 0.2.0.25?  I see that 
all the other 6 v3 directory authorities have upgraded, but not these 2 
...&lt;/FONT&gt;&lt;/SPAN&gt;&lt;/P&gt;
&lt;DIV align=left&gt;&lt;FONT face=Verdana&gt;Wesley &lt;/FONT&gt;&lt;/DIV&gt;&lt;/BODY&gt;&lt;/HTML&gt;


["Blank Bkgrd.gif" (image/gif)]

</body></email><email><emailId>20080515185117</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-05-15 18:51:17-0400</timestampReceived><subject>[proposal 136] Re: Proposal: Simplify Configuration of Private Tor Networks</subject><body>

On Tue, Apr 29, 2008 at 10:19:57PM +0200, Karsten Loesing wrote:
[...]
&gt; Filename: xxx-private-tor-networks.txt
&gt; Title: Simplify Configuration of Private Tor Networks
&gt; Version: $LastChangedRevision$
&gt; Last-Modified: $LastChangedDate$
&gt; Author: Karsten Loesing
&gt; Created: 29-Apr-2008
&gt; Status: Open
&gt; 
&gt; Change history:
&gt; 
&gt;   29-Apr-2008  Initial proposal for or-dev
&gt; 
&gt; Overview:
&gt; 
&gt;   Configuring a private Tor network has become a time-consuming and
&gt;   error-prone task with the introduction of the v3 directory protocol. In
&gt;   addition to that, operators of private Tor networks need to set an
&gt;   increasing number of non-trivial configuration options, and it is hard
&gt;   to keep FAQ entries describing this task up-to-date. In this proposal we
&gt;   (1) suggest to (optionally) accelerate timing of the v3 directory voting
&gt;   process and (2) introduce an umbrella config option specifically aimed at
&gt;   creating private Tor networks.

Sounds plausible, especially with the "make a single option required
to control all the sub-options that shouldn't be run on the main
network" feature.  I say we do it.

 [...]
&gt;   As first safeguards, Tor should only accept configuration values for
&gt;   V3AuthInitialVotingInterval that divide evenly into the default value of
&gt;   30 minutes. The effect is that even if people misconfigured their
&gt;   directory authorities, they would meet at the default values at the
&gt;   latest. The second safeguard is to allow configuration only when the
&gt;   umbrella configuration option PrivateTorNetwork is set.

Is PrivateTorNetwork for directory authorities only?  If so, it should
be prefixed with V3Auth*.  In fact, maybe all options that can only be
adjusted in a private network should share.

Also, do we mean "Private" or "Testing"?  (This is a bikeshed, I know.)

Also, as a safeguard for the system as a whole, perhaps it should be
an error to specify PrivateTorNetwork without configuring a
non-default set of dirservers.  [ISTR we once did something a little
like this.  Arma: did it end well? :) ]

&gt;   1.2. Immediately Provide Reachability Information (Running flag)
&gt; 
&gt;   The default behavior of a directory authority is to provide the Running
&gt;   flag only after the authority is available for at least 30 minutes. The
&gt;   rationale is that before that time, an authority simply cannot deliver
&gt;   useful information about other running nodes. But for private Tor
&gt;   networks this may be different. This is currently implemented in the code
&gt;   as:
&gt; 
&gt;   /** If we've been around for less than this amount of time, our
&gt;    * reachability information is not accurate. */
&gt;   #define DIRSERV_TIME_TO_GET_REACHABILITY_INFO (30*60)
&gt; 
&gt;   There should be another configuration option DirAssumeRunningDelay with
&gt;   a default value of 30 minutes that can be changed when running private
&gt;   Tor networks, e.g. to 0 minutes. The configuration value would simply
&gt;   replace the quoted constant. Again, changing this option could be
&gt;   safeguarded by requiring the umbrella configuration option
&gt;   PrivateTorNetwork to be set.

Sounds good, but DirTimeToLearnReachability would probably be a better
name.  I don't think that it needs to be conditioned on
PrivateTorNetwork, though: the affect of an authority setting it badly
is not "voting fails" but "the authority gets confused and outvoted."

&gt;   1.3. Reduce Estimated Descriptor Propagation Time
&gt; 
&gt;   Tor currently assumes that it takes up to 10 minutes until router
&gt;   descriptors are propagated from the authorities to directory caches.
&gt;   This is not very useful for private Tor networks, and we want to be able
&gt;   to reduce this time, so that clients can download router descriptors in a
&gt;   timely manner.
&gt; 
&gt;   /** Clients don't download any descriptor this recent, since it will
&gt;    * probably not have propagated to enough caches. */
&gt;   #define ESTIMATED_PROPAGATION_TIME (10*60)
&gt; 
&gt;   We suggest to introduce a new config option
&gt;   EstimatedDescriptorPropagationTime which defaults to 10 minutes, but that
&gt;   can be set to any lower non-negative value, e.g. 0 minutes. The same
&gt;   safeguards as in 1.2 could be used here, too.

Right.  This one is potentially dangerous for clients to use in the
mainstream network (because of the partitioning issues), and doesn't
provide any benefit other than faster network bootstrapping, so making
it conditional on the umbrella option is a good idea.
 
&gt;   2. Umbrella Option for Setting Up Private Tor Networks
&gt; 
&gt;   Setting up a private Tor network requires a number of specific settings
&gt;   that are not required or useful when running Tor in the public Tor
&gt;   network. Instead of writing down these options in a FAQ entry, there
&gt;   should be a single configuration option, e.g. PrivateTorNetwork, that
&gt;   changes all required settings at once. Newer Tor versions would keep the
&gt;   set of configuration options up-to-date. It should still remain possible
&gt;   to manually overwrite the settings that the umbrella configuration option
&gt;   affects.
&gt; 
&gt;   The following configuration options are set by PrivateTorNetwork:

If the option is going to do all this, it should definitely be called
TestingTorNetwork.  Also, you should define the semantics for
specifying TestingTorNetwork *and* a specifying a value for one of
these options, as in:
   TestingTorNetwork 1
   DirAllowPrivateAddresses 0
I think that the more specific option should take precedence.

Another interesting issue is: what happens when a controller is used
to change TestingTorNetwork to 0, or when to reset (say)
DirAllowPrivateAddresses to its default.

Thoughts?

yrs,
-- 
Nick
</body></email><email><emailId>20080515192405</emailId><senderName>Karsten Loesing</senderName><senderEmail>karsten.loesing@gmx.net</senderEmail><timestampReceived>2008-05-15 19:24:05-0400</timestampReceived><subject>Re: [proposal 136] Re: Proposal: Simplify Configuration of Private</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Hey Nick,

thanks for your comments! Let me see if I can answer them:

|&gt;   As first safeguards, Tor should only accept configuration values for
|&gt;   V3AuthInitialVotingInterval that divide evenly into the default
value of
|&gt;   30 minutes. The effect is that even if people misconfigured their
|&gt;   directory authorities, they would meet at the default values at the
|&gt;   latest. The second safeguard is to allow configuration only when the
|&gt;   umbrella configuration option PrivateTorNetwork is set.
|
| Is PrivateTorNetwork for directory authorities only?  If so, it should
| be prefixed with V3Auth*.  In fact, maybe all options that can only be
| adjusted in a private network should share.

Hmm, no, you need to set PrivateTorNetwork (or however it's called) on
all nodes that are part of your private testing network. Only some
config options are directory-specific, others aren't.

| Also, do we mean "Private" or "Testing"?  (This is a bikeshed, I know.)

TestingTorNetwork is okay for me.

| Also, as a safeguard for the system as a whole, perhaps it should be
| an error to specify PrivateTorNetwork without configuring a
| non-default set of dirservers.  [ISTR we once did something a little
| like this.  Arma: did it end well? :) ]

Ha, good idea! I'll add that.

|&gt;   There should be another configuration option DirAssumeRunningDelay with
|&gt;   a default value of 30 minutes that can be changed when running private
|&gt;   Tor networks, e.g. to 0 minutes. The configuration value would simply
|&gt;   replace the quoted constant. Again, changing this option could be
|&gt;   safeguarded by requiring the umbrella configuration option
|&gt;   PrivateTorNetwork to be set.
|
| Sounds good, but DirTimeToLearnReachability would probably be a better
| name.  I don't think that it needs to be conditioned on
| PrivateTorNetwork, though: the affect of an authority setting it badly
| is not "voting fails" but "the authority gets confused and outvoted."

Sure, I can change the name. But is it useful to change this value on a
directory authority in the public network?

| If the option is going to do all this, it should definitely be called
| TestingTorNetwork.

Doing.

| Also, you should define the semantics for
| specifying TestingTorNetwork *and* a specifying a value for one of
| these options, as in:
|    TestingTorNetwork 1
|    DirAllowPrivateAddresses 0
| I think that the more specific option should take precedence.

Right. The implementation might require some code magic as I mentioned
in the patch:

/* TODO It should be possible to override those values that are set by
~ * "PrivateTorNetwork 1" with the original default values (or even some
~ * other value). Idea: Change default values of these configuration
~ * options to invalid value, e.g. -1, in order to distinguish default
~ * values (then -1) from overridden values, e.g. 0. Requires to safely
~ * change all -1 values back to the actual default values afterwards! Is
~ * this a hack? Well, of course it is, but is there a better way to
~ * achieve the same goal? -KL */

| Another interesting issue is: what happens when a controller is used
| to change TestingTorNetwork to 0, or when to reset (say)
| DirAllowPrivateAddresses to its default.

When a controller changes some of Tor's configuration values they are
re-checked just as if Tor had loaded a new configuration, right? In that
case the same rules apply as above, i.e. it's illegal to change
TestingTorNetwork back to 0 but leave depending configuration values
unchanged. This might require some testing to get it right, but the
behavior should (hopefully) be straightforward.


I'll update the proposal and create a new patch these days (probably
this weekend).

- --Karsten
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFILI3U0M+WPffBEmURAqVyAKCXz9IvoaupEYI7OGPW4M0/gqVMwACgpkLu
2tFC9Zl6n6JtP3smSC3VR1Y=
=uotE
-----END PGP SIGNATURE-----
</body></email><email><emailId>20080515211714</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-05-15 21:17:14-0400</timestampReceived><subject>Re: [proposal 136] Re: Proposal: Simplify Configuration of Private Tor Networks</subject><body>

On Thu, May 15, 2008 at 09:24:05PM +0200, Karsten Loesing wrote:
  [...]
&gt; | Sounds good, but DirTimeToLearnReachability would probably be a better
&gt; | name.  I don't think that it needs to be conditioned on
&gt; | PrivateTorNetwork, though: the affect of an authority setting it badly
&gt; | is not "voting fails" but "the authority gets confused and outvoted."
&gt; 
&gt; Sure, I can change the name. But is it useful to change this value on a
&gt; directory authority in the public network?

Hm. I think what we really want to do is instrument an authority to
figure out how long it *really* takes to converge on a view of
routers' statuses; the 30 minute figure was never more than an
estimate that happened to work okay: it may be that a longer or
shorter window would be more reasonable.

But yeah, point taken.  No reason to expose this for non-testing cases.

&gt; | Also, you should define the semantics for
&gt; | specifying TestingTorNetwork *and* a specifying a value for one of
&gt; | these options, as in:
&gt; |    TestingTorNetwork 1
&gt; |    DirAllowPrivateAddresses 0
&gt; | I think that the more specific option should take precedence.
&gt; 
&gt; Right. The implementation might require some code magic as I mentioned
&gt; in the patch:
&gt; 
&gt; /* TODO It should be possible to override those values that are set by
&gt; ~ * "PrivateTorNetwork 1" with the original default values (or even some
&gt; ~ * other value). Idea: Change default values of these configuration
&gt; ~ * options to invalid value, e.g. -1, in order to distinguish default
&gt; ~ * values (then -1) from overridden values, e.g. 0. Requires to safely
&gt; ~ * change all -1 values back to the actual default values afterwards! Is
&gt; ~ * this a hack? Well, of course it is, but is there a better way to
&gt; ~ * achieve the same goal? -KL */

It's kind of an ugly hack too.

What about having a preprocessing step on the options list that
expands PrivateTorNetwork 1 into the entire list of options it
implies? It's not an error to specify an option twice; when you do,
the second takes precedence.

This would mean that RESETCONF wouldn't do the right thing, though.
Perhaps a hack like the one in weasel's debian-tor user patch would
handle that better.  It's still a hack, but not a totally insane hack.
More elegant (maybe) would be a more generic default mechanism that
supported stuff like this by design.

yrs,
-- 
Nick
</body></email><email><emailId>20080519215312</emailId><senderName>Karsten Loesing</senderName><senderEmail>karsten.loesing@gmx.net</senderEmail><timestampReceived>2008-05-19 21:53:12-0400</timestampReceived><subject>Re: [proposal 136] Re: Proposal: Simplify Configuration of Private</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Hi Nick,

| What about having a preprocessing step on the options list that
| expands PrivateTorNetwork 1 into the entire list of options it
| implies? It's not an error to specify an option twice; when you do,
| the second takes precedence.

Hmm, I couldn't find the right place in the code to implement your idea.
I now solved it differently: When reading configurations from torrc and
the console, Tor checks if TestingTorNetwork was configured. If so,
default values for dependent options are changed and the configuration
is read in again. See lines 3835--3892 in config.c.

I also added a hook that prevents TestingTorNetwork from being changed
after Tor is started. I could not imagine why this would be useful, and
therefore excluded this possibility to prevent unforeseen errors. See
lines 3463--3468 in config.c.

| This would mean that RESETCONF wouldn't do the right thing, though.
| Perhaps a hack like the one in weasel's debian-tor user patch would
| handle that better.  It's still a hack, but not a totally insane hack.

Right, that's what I've done now.


In the proposal I added a section with test cases. These include all
those scenarios about changing configurations that came to my mind.
These tests succeeded in a patched Tor and worked fine with a patched
PuppeTor using v3 directories.

- --Karsten
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFIMfbI0M+WPffBEmURAkHJAJ4pr9yyJ0I9p/iyGbMtHn0cCz3pnACfYy6h
UNzjTYAbHyq4l25rd654+dM=
=PYOt
-----END PGP SIGNATURE-----

["patch2.txt" (text/plain)]

Index: /home/karsten/tor/tor-trunk-private-network/src/or/config.c
===================================================================
--- /home/karsten/tor/tor-trunk-private-network/src/or/config.c	(revision 14671)
+++ /home/karsten/tor/tor-trunk-private-network/src/or/config.c	(working copy)
@@ -174,6 +174,7 @@
   V(DataDirectory,               STRING,   NULL),
   OBSOLETE("DebugLogFile"),
   V(DirAllowPrivateAddresses,    BOOL,     NULL),
+  V(DirTimeToLearnReachability,  INTERVAL, "30 minutes"),
   V(DirListenAddress,            LINELIST, NULL),
   OBSOLETE("DirFetchPeriod"),
   V(DirPolicy,                   LINELIST, NULL),
@@ -185,6 +186,7 @@
   V(DownloadExtraInfo,           BOOL,     "0"),
   V(EnforceDistinctSubnets,      BOOL,     "1"),
   V(EntryNodes,                  STRING,   NULL),
+  V(EstimatedDescriptorPropagationTime, INTERVAL, "10 minutes"),
   V(ExcludeNodes,                STRING,   NULL),
   V(ExitNodes,                   STRING,   NULL),
   V(ExitPolicy,                  LINELIST, NULL),
@@ -243,6 +245,7 @@
   V(OutboundBindAddress,         STRING,   NULL),
   OBSOLETE("PathlenCoinWeight"),
   V(PidFile,                     STRING,   NULL),
+  V(TestingTorNetwork,           BOOL,     "0"),
   V(PreferTunneledDirConns,      BOOL,     "1"),
   V(ProtocolWarnings,            BOOL,     "0"),
   V(PublishServerDescriptor,     CSV,      "1"),
@@ -297,6 +300,9 @@
   VAR("V1AuthoritativeDirectory",BOOL, V1AuthoritativeDir,   "0"),
   VAR("V2AuthoritativeDirectory",BOOL, V2AuthoritativeDir,   "0"),
   VAR("V3AuthoritativeDirectory",BOOL, V3AuthoritativeDir,   "0"),
+  V(V3AuthInitialVotingInterval, INTERVAL, "30 minutes"),
+  V(V3AuthInitialVoteDelay,      INTERVAL, "5 minutes"),
+  V(V3AuthInitialDistDelay,      INTERVAL, "5 minutes"),
   V(V3AuthVotingInterval,        INTERVAL, "1 hour"),
   V(V3AuthVoteDelay,             INTERVAL, "5 minutes"),
   V(V3AuthDistDelay,             INTERVAL, "5 minutes"),
@@ -3325,6 +3331,72 @@
     });
   }
 
+  if (options-&gt;TestingTorNetwork &amp;&amp; !options-&gt;DirServers) {
+    REJECT("TestingTorNetwork may only be configured in combination with "
+           "a non-default set of DirServers.");
+  }
+
+  if (options-&gt;V3AuthInitialVotingInterval != 30*60 &amp;&amp;
+      !options-&gt;TestingTorNetwork) {
+    REJECT("V3AuthInitialVotingInterval may only be changed in testing "
+           "Tor networks!");
+  } else if (options-&gt;V3AuthInitialVotingInterval &lt; MIN_VOTE_INTERVAL) {
+    REJECT("V3AuthInitialVotingInterval is insanely low.");
+  } else if (options-&gt;V3AuthInitialVotingInterval &gt; 24*60*60) {
+    REJECT("V3AuthInitialVotingInterval is insanely high.");
+  } else if (((30*60) % options-&gt;V3AuthInitialVotingInterval) != 0) {
+    REJECT("V3AuthInitialVotingInterval does not divide evenly into "
+           "30 minutes.");
+  }
+
+  if (options-&gt;V3AuthInitialVoteDelay != 5*60 &amp;&amp;
+      !options-&gt;TestingTorNetwork) {
+    REJECT("V3AuthInitialVoteDelay may only be changed in testing "
+           "Tor networks!");
+  } else if (options-&gt;V3AuthInitialVoteDelay &lt; MIN_VOTE_SECONDS) {
+    REJECT("V3AuthInitialVoteDelay is way too low.");
+  }
+
+  if (options-&gt;V3AuthInitialDistDelay != 5*60 &amp;&amp;
+      !options-&gt;TestingTorNetwork) {
+    REJECT("V3AuthInitialDistDelay may only be changed in testing "
+           "Tor networks!");
+  } else if (options-&gt;V3AuthInitialDistDelay &lt; MIN_DIST_SECONDS) {
+    REJECT("V3AuthInitialDistDelay is way too low.");
+  }
+
+  if (options-&gt;V3AuthInitialVoteDelay + options-&gt;V3AuthInitialDistDelay &gt;=
+      options-&gt;V3AuthInitialVotingInterval/2) {
+    REJECT("V3AuthInitialVoteDelay plus V3AuthInitialDistDelay must be "
+           "less than half V3AuthInitialVotingInterval");
+  }
+
+  if (options-&gt;DirTimeToLearnReachability != 30*60 &amp;&amp; !options-&gt;TestingTorNetwork) {
+    REJECT("DirTimeToLearnReachability may only be changed in testing "
+           "Tor networks!");
+  } else if (options-&gt;DirTimeToLearnReachability &lt; 0) {
+    REJECT("DirTimeToLearnReachability must be non-negative.");
+  } else if (options-&gt;DirTimeToLearnReachability &gt; 2*60*60) {
+    COMPLAIN("DirTimeToLearnReachability is insanely high.");
+  }
+
+  if (options-&gt;EstimatedDescriptorPropagationTime != 10*60 &amp;&amp;
+      !options-&gt;TestingTorNetwork) {
+    REJECT("EstimatedDescriptorPropagationTime may only be changed in "
+           "testing Tor networks!");
+  } else if (options-&gt;EstimatedDescriptorPropagationTime &lt; 0) {
+    REJECT("EstimatedDescriptorPropagationTime must be non-negative.");
+  } else if (options-&gt;EstimatedDescriptorPropagationTime &gt; 60*60) {
+    COMPLAIN("EstimatedDescriptorPropagationTime is insanely high.");
+  }
+
+  if (options-&gt;TestingTorNetwork) {
+    log_warn(LD_CONFIG, "TestingTorNetwork is set. This will make your node "
+                        "almost unusable in the public Tor network, and is "
+                        "therefore only advised if you are building a "
+                        "testing Tor network!");
+  }
+
   return 0;
 #undef REJECT
 #undef COMPLAIN
@@ -3388,6 +3460,12 @@
     return -1;
   }
 
+  if (old-&gt;TestingTorNetwork != new_val-&gt;TestingTorNetwork) {
+    *msg = tor_strdup("While Tor is running, changing TestingTorNetwork "
+                      "is not allowed.");
+    return -1;
+  }
+
   return 0;
 }
 
@@ -3756,6 +3834,64 @@
     goto err;
   }
 
+  /* If this is a testing network configuration, change defaults
+   * for a list of dependent config options, re-initialize newoptions
+   * with the new defaults, and assign all options to it second time. */
+  if (newoptions-&gt;TestingTorNetwork) {
+
+    /* Change defaults. */
+    #define CHANGE_DEFAULT(key, val)                                \
+    {                                                               \
+      config_var_t *var = config_find_option(&amp;options_format, key); \
+      tor_assert(var);                                              \
+      var-&gt;initvalue = tor_strdup(val);                             \
+    }
+    CHANGE_DEFAULT("ServerDNSAllowBrokenResolvConf", "1");
+    CHANGE_DEFAULT("DirAllowPrivateAddresses", "1");
+    CHANGE_DEFAULT("EnforceDistinctSubnets", "0");
+    CHANGE_DEFAULT("AssumeReachable", "1");
+    CHANGE_DEFAULT("AuthDirMaxServersPerAddr", "0");
+    CHANGE_DEFAULT("AuthDirMaxServersPerAuthAddr", "0");
+    CHANGE_DEFAULT("ClientDNSRejectInternalAddresses", "0");
+    CHANGE_DEFAULT("ExitPolicyRejectPrivate", "0");
+    CHANGE_DEFAULT("V3AuthVotingInterval", "300");
+    CHANGE_DEFAULT("V3AuthVoteDelay", "20");
+    CHANGE_DEFAULT("V3AuthDistDelay", "20");
+    CHANGE_DEFAULT("V3AuthInitialVotingInterval", "300");
+    CHANGE_DEFAULT("V3AuthInitialVoteDelay", "20");
+    CHANGE_DEFAULT("V3AuthInitialDistDelay", "20");
+    CHANGE_DEFAULT("DirTimeToLearnReachability", "0");
+    CHANGE_DEFAULT("EstimatedDescriptorPropagationTime", "0");
+    #undef CHANGE_DEFAULT
+
+    /* Clear newoptions and re-initialize them with new defaults. */
+    config_free(&amp;options_format, newoptions);
+    newoptions = tor_malloc_zero(sizeof(or_options_t));
+    newoptions-&gt;_magic = OR_OPTIONS_MAGIC;
+    options_init(newoptions);
+    newoptions-&gt;command = command;
+    newoptions-&gt;command_arg = command_arg;
+
+    /* Assign all options a second time. */
+    retval = config_get_lines(cf, &amp;cl);
+    if (retval &lt; 0) {
+      err = SETOPT_ERR_PARSE;
+      goto err;
+    }
+    retval = config_assign(&amp;options_format, newoptions, cl, 0, 0, msg);
+    config_free_lines(cl);
+    if (retval &lt; 0) {
+      err = SETOPT_ERR_PARSE;
+      goto err;
+    }
+    retval = config_assign(&amp;options_format, newoptions,
+                           global_cmdline_options, 0, 0, msg);
+    if (retval &lt; 0) {
+      err = SETOPT_ERR_PARSE;
+      goto err;
+    }
+  }
+
   /* Validate newoptions */
   if (options_validate(oldoptions, newoptions, 0, msg) &lt; 0) {
     err = SETOPT_ERR_PARSE; /*XXX021 make this separate.*/
Index: /home/karsten/tor/tor-trunk-private-network/src/or/dirserv.c
===================================================================
--- /home/karsten/tor/tor-trunk-private-network/src/or/dirserv.c	(revision 14671)
+++ /home/karsten/tor/tor-trunk-private-network/src/or/dirserv.c	(working copy)
@@ -2122,10 +2122,6 @@
     router-&gt;is_bad_exit = router-&gt;is_bad_directory = 0;
 }
 
-/** If we've been around for less than this amount of time, our reachability
- * information is not accurate. */
-#define DIRSERV_TIME_TO_GET_REACHABILITY_INFO (30*60)
-
 /** Return a new networkstatus_t* containing our current opinion. (For v3
  * authorities) */
 networkstatus_t *
@@ -2155,7 +2151,7 @@
   tor_assert(private_key);
   tor_assert(cert);
 
-  if (now - time_of_process_start &lt; DIRSERV_TIME_TO_GET_REACHABILITY_INFO)
+  if (now - time_of_process_start &lt; options-&gt;DirTimeToLearnReachability)
     vote_on_reachability = 0;
 
   if (resolve_my_address(LOG_WARN, options, &amp;addr, &amp;hostname)&lt;0) {
@@ -2241,7 +2237,7 @@
       last_consensus_interval = current_consensus-&gt;fresh_until -
         current_consensus-&gt;valid_after;
     else
-      last_consensus_interval = DEFAULT_VOTING_INTERVAL_WHEN_NO_CONSENSUS;
+      last_consensus_interval = options-&gt;V3AuthInitialVotingInterval;
     v3_out-&gt;valid_after =
       dirvote_get_start_of_next_interval(now, (int)last_consensus_interval);
     format_iso_time(tbuf, v3_out-&gt;valid_after);
Index: /home/karsten/tor/tor-trunk-private-network/src/or/dirvote.c
===================================================================
--- /home/karsten/tor/tor-trunk-private-network/src/or/dirvote.c	(revision 14671)
+++ /home/karsten/tor/tor-trunk-private-network/src/or/dirvote.c	(working copy)
@@ -1300,8 +1300,9 @@
     vote_delay = consensus-&gt;vote_seconds;
     dist_delay = consensus-&gt;dist_seconds;
   } else {
-    interval = DEFAULT_VOTING_INTERVAL_WHEN_NO_CONSENSUS;
-    vote_delay = dist_delay = 300;
+    interval = options-&gt;V3AuthInitialVotingInterval;
+    vote_delay = options-&gt;V3AuthInitialVoteDelay;
+    dist_delay = options-&gt;V3AuthInitialDistDelay;
   }
 
   tor_assert(interval &gt; 0);
Index: /home/karsten/tor/tor-trunk-private-network/src/or/or.h
===================================================================
--- /home/karsten/tor/tor-trunk-private-network/src/or/or.h	(revision 14671)
+++ /home/karsten/tor/tor-trunk-private-network/src/or/or.h	(working copy)
@@ -2344,6 +2344,31 @@
    * migration purposes? */
   int V3AuthUseLegacyKey;
 
+  /** The length of time that we think an initial consensus should be
+   * fresh. */
+  int V3AuthInitialVotingInterval;
+
+  /** The length of time we think it will take to distribute initial
+   * votes. */
+  int V3AuthInitialVoteDelay;
+
+  /** The length of time we think it will take to distribute initial
+   * signatures. */
+  int V3AuthInitialDistDelay;
+
+  /** If an authority has been around for less than this amount of time,
+   * its reachability information is not accurate. */ 
+  int DirTimeToLearnReachability;
+
+  /** Clients don't download any descriptor this recent, since it will
+   * probably not have propagated to enough caches. */
+  int EstimatedDescriptorPropagationTime;
+
+  /** If true, we take part in a testing network. Change the defaults of a
+   * couple of other configuration options and allow to change the values
+   * of certain configuration options. */
+  int TestingTorNetwork;
+
   /** File to check for a consensus networkstatus, if we don't have one
    * cached. */
   char *FallbackNetworkstatusFile;
@@ -3186,9 +3211,6 @@
 /** Smallest allowable voting interval. */
 #define MIN_VOTE_INTERVAL 300
 
-/** If there is no consensus, what interval do we default to? */
-#define DEFAULT_VOTING_INTERVAL_WHEN_NO_CONSENSUS (30*60)
-
 void dirvote_free_all(void);
 
 /* vote manipulation */
Index: /home/karsten/tor/tor-trunk-private-network/src/or/routerlist.c
===================================================================
--- /home/karsten/tor/tor-trunk-private-network/src/or/routerlist.c	(revision 14671)
+++ /home/karsten/tor/tor-trunk-private-network/src/or/routerlist.c	(working copy)
@@ -3673,10 +3673,6 @@
   tor_free(resource);
 }
 
-/** Clients don't download any descriptor this recent, since it will probably
- * not have propagated to enough caches. */
-#define ESTIMATED_PROPAGATION_TIME (10*60)
-
 /** Return 0 if this routerstatus is obsolete, too new, isn't
  * running, or otherwise not a descriptor that we would make any
  * use of even if we had it. Else return 1. */
@@ -3688,7 +3684,7 @@
      * But, if we want to have a complete list, fetch it anyway. */
     return 0;
   }
-  if (rs-&gt;published_on + ESTIMATED_PROPAGATION_TIME &gt; now) {
+  if (rs-&gt;published_on + options-&gt;EstimatedDescriptorPropagationTime &gt; now) {
     /* Most caches probably don't have this descriptor yet. */
     return 0;
   }


["patch2.txt.sig" (application/octet-stream)]

</body></email><email><emailId>20080519220803</emailId><senderName>"Kyle Williams"</senderName><senderEmail>kyle.kwilliams@gmail.com</senderEmail><timestampReceived>2008-05-19 22:08:03-0400</timestampReceived><subject>Re: [proposal 136] Re: Proposal: Simplify Configuration of Private Tor Networks</subject><body>

I love it!  Nice work Karsten!


On Mon, May 19, 2008 at 2:53 PM, Karsten Loesing &lt;karsten.loesing@gmx.net&gt;
wrote:

&gt; -----BEGIN PGP SIGNED MESSAGE-----
&gt; Hash: SHA1
&gt;
&gt; Hi Nick,
&gt;
&gt; | What about having a preprocessing step on the options list that
&gt; | expands PrivateTorNetwork 1 into the entire list of options it
&gt; | implies? It's not an error to specify an option twice; when you do,
&gt; | the second takes precedence.
&gt;
&gt; Hmm, I couldn't find the right place in the code to implement your idea.
&gt; I now solved it differently: When reading configurations from torrc and
&gt; the console, Tor checks if TestingTorNetwork was configured. If so,
&gt; default values for dependent options are changed and the configuration
&gt; is read in again. See lines 3835--3892 in config.c.
&gt;
&gt; I also added a hook that prevents TestingTorNetwork from being changed
&gt; after Tor is started. I could not imagine why this would be useful, and
&gt; therefore excluded this possibility to prevent unforeseen errors. See
&gt; lines 3463--3468 in config.c.
&gt;
&gt; | This would mean that RESETCONF wouldn't do the right thing, though.
&gt; | Perhaps a hack like the one in weasel's debian-tor user patch would
&gt; | handle that better.  It's still a hack, but not a totally insane hack.
&gt;
&gt; Right, that's what I've done now.
&gt;
&gt;
&gt; In the proposal I added a section with test cases. These include all
&gt; those scenarios about changing configurations that came to my mind.
&gt; These tests succeeded in a patched Tor and worked fine with a patched
&gt; PuppeTor using v3 directories.
&gt;
&gt; - --Karsten
&gt; -----BEGIN PGP SIGNATURE-----
&gt; Version: GnuPG v1.4.6 (GNU/Linux)
&gt; Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org
&gt;
&gt; iD8DBQFIMfbI0M+WPffBEmURAkHJAJ4pr9yyJ0I9p/iyGbMtHn0cCz3pnACfYy6h
&gt; UNzjTYAbHyq4l25rd654+dM=
&gt; =PYOt
&gt; -----END PGP SIGNATURE-----
&gt;
&gt; Index: /home/karsten/tor/tor-trunk-private-network/src/or/config.c
&gt; ===================================================================
&gt; --- /home/karsten/tor/tor-trunk-private-network/src/or/config.c (revision
&gt; 14671)
&gt; +++ /home/karsten/tor/tor-trunk-private-network/src/or/config.c (working
&gt; copy)
&gt; @@ -174,6 +174,7 @@
&gt;   V(DataDirectory,               STRING,   NULL),
&gt;   OBSOLETE("DebugLogFile"),
&gt;   V(DirAllowPrivateAddresses,    BOOL,     NULL),
&gt; +  V(DirTimeToLearnReachability,  INTERVAL, "30 minutes"),
&gt;   V(DirListenAddress,            LINELIST, NULL),
&gt;   OBSOLETE("DirFetchPeriod"),
&gt;   V(DirPolicy,                   LINELIST, NULL),
&gt; @@ -185,6 +186,7 @@
&gt;   V(DownloadExtraInfo,           BOOL,     "0"),
&gt;   V(EnforceDistinctSubnets,      BOOL,     "1"),
&gt;   V(EntryNodes,                  STRING,   NULL),
&gt; +  V(EstimatedDescriptorPropagationTime, INTERVAL, "10 minutes"),
&gt;   V(ExcludeNodes,                STRING,   NULL),
&gt;   V(ExitNodes,                   STRING,   NULL),
&gt;   V(ExitPolicy,                  LINELIST, NULL),
&gt; @@ -243,6 +245,7 @@
&gt;   V(OutboundBindAddress,         STRING,   NULL),
&gt;   OBSOLETE("PathlenCoinWeight"),
&gt;   V(PidFile,                     STRING,   NULL),
&gt; +  V(TestingTorNetwork,           BOOL,     "0"),
&gt;   V(PreferTunneledDirConns,      BOOL,     "1"),
&gt;   V(ProtocolWarnings,            BOOL,     "0"),
&gt;   V(PublishServerDescriptor,     CSV,      "1"),
&gt; @@ -297,6 +300,9 @@
&gt;   VAR("V1AuthoritativeDirectory",BOOL, V1AuthoritativeDir,   "0"),
&gt;   VAR("V2AuthoritativeDirectory",BOOL, V2AuthoritativeDir,   "0"),
&gt;   VAR("V3AuthoritativeDirectory",BOOL, V3AuthoritativeDir,   "0"),
&gt; +  V(V3AuthInitialVotingInterval, INTERVAL, "30 minutes"),
&gt; +  V(V3AuthInitialVoteDelay,      INTERVAL, "5 minutes"),
&gt; +  V(V3AuthInitialDistDelay,      INTERVAL, "5 minutes"),
&gt;   V(V3AuthVotingInterval,        INTERVAL, "1 hour"),
&gt;   V(V3AuthVoteDelay,             INTERVAL, "5 minutes"),
&gt;   V(V3AuthDistDelay,             INTERVAL, "5 minutes"),
&gt; @@ -3325,6 +3331,72 @@
&gt;     });
&gt;   }
&gt;
&gt; +  if (options-&gt;TestingTorNetwork &amp;&amp; !options-&gt;DirServers) {
&gt; +    REJECT("TestingTorNetwork may only be configured in combination with "
&gt; +           "a non-default set of DirServers.");
&gt; +  }
&gt; +
&gt; +  if (options-&gt;V3AuthInitialVotingInterval != 30*60 &amp;&amp;
&gt; +      !options-&gt;TestingTorNetwork) {
&gt; +    REJECT("V3AuthInitialVotingInterval may only be changed in testing "
&gt; +           "Tor networks!");
&gt; +  } else if (options-&gt;V3AuthInitialVotingInterval &lt; MIN_VOTE_INTERVAL) {
&gt; +    REJECT("V3AuthInitialVotingInterval is insanely low.");
&gt; +  } else if (options-&gt;V3AuthInitialVotingInterval &gt; 24*60*60) {
&gt; +    REJECT("V3AuthInitialVotingInterval is insanely high.");
&gt; +  } else if (((30*60) % options-&gt;V3AuthInitialVotingInterval) != 0) {
&gt; +    REJECT("V3AuthInitialVotingInterval does not divide evenly into "
&gt; +           "30 minutes.");
&gt; +  }
&gt; +
&gt; +  if (options-&gt;V3AuthInitialVoteDelay != 5*60 &amp;&amp;
&gt; +      !options-&gt;TestingTorNetwork) {
&gt; +    REJECT("V3AuthInitialVoteDelay may only be changed in testing "
&gt; +           "Tor networks!");
&gt; +  } else if (options-&gt;V3AuthInitialVoteDelay &lt; MIN_VOTE_SECONDS) {
&gt; +    REJECT("V3AuthInitialVoteDelay is way too low.");
&gt; +  }
&gt; +
&gt; +  if (options-&gt;V3AuthInitialDistDelay != 5*60 &amp;&amp;
&gt; +      !options-&gt;TestingTorNetwork) {
&gt; +    REJECT("V3AuthInitialDistDelay may only be changed in testing "
&gt; +           "Tor networks!");
&gt; +  } else if (options-&gt;V3AuthInitialDistDelay &lt; MIN_DIST_SECONDS) {
&gt; +    REJECT("V3AuthInitialDistDelay is way too low.");
&gt; +  }
&gt; +
&gt; +  if (options-&gt;V3AuthInitialVoteDelay + options-&gt;V3AuthInitialDistDelay &gt;=
&gt; +      options-&gt;V3AuthInitialVotingInterval/2) {
&gt; +    REJECT("V3AuthInitialVoteDelay plus V3AuthInitialDistDelay must be "
&gt; +           "less than half V3AuthInitialVotingInterval");
&gt; +  }
&gt; +
&gt; +  if (options-&gt;DirTimeToLearnReachability != 30*60 &amp;&amp;
&gt; !options-&gt;TestingTorNetwork) {
&gt; +    REJECT("DirTimeToLearnReachability may only be changed in testing "
&gt; +           "Tor networks!");
&gt; +  } else if (options-&gt;DirTimeToLearnReachability &lt; 0) {
&gt; +    REJECT("DirTimeToLearnReachability must be non-negative.");
&gt; +  } else if (options-&gt;DirTimeToLearnReachability &gt; 2*60*60) {
&gt; +    COMPLAIN("DirTimeToLearnReachability is insanely high.");
&gt; +  }
&gt; +
&gt; +  if (options-&gt;EstimatedDescriptorPropagationTime != 10*60 &amp;&amp;
&gt; +      !options-&gt;TestingTorNetwork) {
&gt; +    REJECT("EstimatedDescriptorPropagationTime may only be changed in "
&gt; +           "testing Tor networks!");
&gt; +  } else if (options-&gt;EstimatedDescriptorPropagationTime &lt; 0) {
&gt; +    REJECT("EstimatedDescriptorPropagationTime must be non-negative.");
&gt; +  } else if (options-&gt;EstimatedDescriptorPropagationTime &gt; 60*60) {
&gt; +    COMPLAIN("EstimatedDescriptorPropagationTime is insanely high.");
&gt; +  }
&gt; +
&gt; +  if (options-&gt;TestingTorNetwork) {
&gt; +    log_warn(LD_CONFIG, "TestingTorNetwork is set. This will make your
&gt; node "
&gt; +                        "almost unusable in the public Tor network, and is
&gt; "
&gt; +                        "therefore only advised if you are building a "
&gt; +                        "testing Tor network!");
&gt; +  }
&gt; +
&gt;   return 0;
&gt;  #undef REJECT
&gt;  #undef COMPLAIN
&gt; @@ -3388,6 +3460,12 @@
&gt;     return -1;
&gt;   }
&gt;
&gt; +  if (old-&gt;TestingTorNetwork != new_val-&gt;TestingTorNetwork) {
&gt; +    *msg = tor_strdup("While Tor is running, changing TestingTorNetwork "
&gt; +                      "is not allowed.");
&gt; +    return -1;
&gt; +  }
&gt; +
&gt;   return 0;
&gt;  }
&gt;
&gt; @@ -3756,6 +3834,64 @@
&gt;     goto err;
&gt;   }
&gt;
&gt; +  /* If this is a testing network configuration, change defaults
&gt; +   * for a list of dependent config options, re-initialize newoptions
&gt; +   * with the new defaults, and assign all options to it second time. */
&gt; +  if (newoptions-&gt;TestingTorNetwork) {
&gt; +
&gt; +    /* Change defaults. */
&gt; +    #define CHANGE_DEFAULT(key, val)                                \
&gt; +    {                                                               \
&gt; +      config_var_t *var = config_find_option(&amp;options_format, key); \
&gt; +      tor_assert(var);                                              \
&gt; +      var-&gt;initvalue = tor_strdup(val);                             \
&gt; +    }
&gt; +    CHANGE_DEFAULT("ServerDNSAllowBrokenResolvConf", "1");
&gt; +    CHANGE_DEFAULT("DirAllowPrivateAddresses", "1");
&gt; +    CHANGE_DEFAULT("EnforceDistinctSubnets", "0");
&gt; +    CHANGE_DEFAULT("AssumeReachable", "1");
&gt; +    CHANGE_DEFAULT("AuthDirMaxServersPerAddr", "0");
&gt; +    CHANGE_DEFAULT("AuthDirMaxServersPerAuthAddr", "0");
&gt; +    CHANGE_DEFAULT("ClientDNSRejectInternalAddresses", "0");
&gt; +    CHANGE_DEFAULT("ExitPolicyRejectPrivate", "0");
&gt; +    CHANGE_DEFAULT("V3AuthVotingInterval", "300");
&gt; +    CHANGE_DEFAULT("V3AuthVoteDelay", "20");
&gt; +    CHANGE_DEFAULT("V3AuthDistDelay", "20");
&gt; +    CHANGE_DEFAULT("V3AuthInitialVotingInterval", "300");
&gt; +    CHANGE_DEFAULT("V3AuthInitialVoteDelay", "20");
&gt; +    CHANGE_DEFAULT("V3AuthInitialDistDelay", "20");
&gt; +    CHANGE_DEFAULT("DirTimeToLearnReachability", "0");
&gt; +    CHANGE_DEFAULT("EstimatedDescriptorPropagationTime", "0");
&gt; +    #undef CHANGE_DEFAULT
&gt; +
&gt; +    /* Clear newoptions and re-initialize them with new defaults. */
&gt; +    config_free(&amp;options_format, newoptions);
&gt; +    newoptions = tor_malloc_zero(sizeof(or_options_t));
&gt; +    newoptions-&gt;_magic = OR_OPTIONS_MAGIC;
&gt; +    options_init(newoptions);
&gt; +    newoptions-&gt;command = command;
&gt; +    newoptions-&gt;command_arg = command_arg;
&gt; +
&gt; +    /* Assign all options a second time. */
&gt; +    retval = config_get_lines(cf, &amp;cl);
&gt; +    if (retval &lt; 0) {
&gt; +      err = SETOPT_ERR_PARSE;
&gt; +      goto err;
&gt; +    }
&gt; +    retval = config_assign(&amp;options_format, newoptions, cl, 0, 0, msg);
&gt; +    config_free_lines(cl);
&gt; +    if (retval &lt; 0) {
&gt; +      err = SETOPT_ERR_PARSE;
&gt; +      goto err;
&gt; +    }
&gt; +    retval = config_assign(&amp;options_format, newoptions,
&gt; +                           global_cmdline_options, 0, 0, msg);
&gt; +    if (retval &lt; 0) {
&gt; +      err = SETOPT_ERR_PARSE;
&gt; +      goto err;
&gt; +    }
&gt; +  }
&gt; +
&gt;   /* Validate newoptions */
&gt;   if (options_validate(oldoptions, newoptions, 0, msg) &lt; 0) {
&gt;     err = SETOPT_ERR_PARSE; /*XXX021 make this separate.*/
&gt; Index: /home/karsten/tor/tor-trunk-private-network/src/or/dirserv.c
&gt; ===================================================================
&gt; --- /home/karsten/tor/tor-trunk-private-network/src/or/dirserv.c
&gt;  (revision 14671)
&gt; +++ /home/karsten/tor/tor-trunk-private-network/src/or/dirserv.c
&gt;  (working copy)
&gt; @@ -2122,10 +2122,6 @@
&gt;     router-&gt;is_bad_exit = router-&gt;is_bad_directory = 0;
&gt;  }
&gt;
&gt; -/** If we've been around for less than this amount of time, our
&gt; reachability
&gt; - * information is not accurate. */
&gt; -#define DIRSERV_TIME_TO_GET_REACHABILITY_INFO (30*60)
&gt; -
&gt;  /** Return a new networkstatus_t* containing our current opinion. (For v3
&gt;  * authorities) */
&gt;  networkstatus_t *
&gt; @@ -2155,7 +2151,7 @@
&gt;   tor_assert(private_key);
&gt;   tor_assert(cert);
&gt;
&gt; -  if (now - time_of_process_start &lt; DIRSERV_TIME_TO_GET_REACHABILITY_INFO)
&gt; +  if (now - time_of_process_start &lt; options-&gt;DirTimeToLearnReachability)
&gt;     vote_on_reachability = 0;
&gt;
&gt;   if (resolve_my_address(LOG_WARN, options, &amp;addr, &amp;hostname)&lt;0) {
&gt; @@ -2241,7 +2237,7 @@
&gt;       last_consensus_interval = current_consensus-&gt;fresh_until -
&gt;         current_consensus-&gt;valid_after;
&gt;     else
&gt; -      last_consensus_interval = DEFAULT_VOTING_INTERVAL_WHEN_NO_CONSENSUS;
&gt; +      last_consensus_interval = options-&gt;V3AuthInitialVotingInterval;
&gt;     v3_out-&gt;valid_after =
&gt;       dirvote_get_start_of_next_interval(now,
&gt; (int)last_consensus_interval);
&gt;     format_iso_time(tbuf, v3_out-&gt;valid_after);
&gt; Index: /home/karsten/tor/tor-trunk-private-network/src/or/dirvote.c
&gt; ===================================================================
&gt; --- /home/karsten/tor/tor-trunk-private-network/src/or/dirvote.c
&gt;  (revision 14671)
&gt; +++ /home/karsten/tor/tor-trunk-private-network/src/or/dirvote.c
&gt;  (working copy)
&gt; @@ -1300,8 +1300,9 @@
&gt;     vote_delay = consensus-&gt;vote_seconds;
&gt;     dist_delay = consensus-&gt;dist_seconds;
&gt;   } else {
&gt; -    interval = DEFAULT_VOTING_INTERVAL_WHEN_NO_CONSENSUS;
&gt; -    vote_delay = dist_delay = 300;
&gt; +    interval = options-&gt;V3AuthInitialVotingInterval;
&gt; +    vote_delay = options-&gt;V3AuthInitialVoteDelay;
&gt; +    dist_delay = options-&gt;V3AuthInitialDistDelay;
&gt;   }
&gt;
&gt;   tor_assert(interval &gt; 0);
&gt; Index: /home/karsten/tor/tor-trunk-private-network/src/or/or.h
&gt; ===================================================================
&gt; --- /home/karsten/tor/tor-trunk-private-network/src/or/or.h     (revision
&gt; 14671)
&gt; +++ /home/karsten/tor/tor-trunk-private-network/src/or/or.h     (working
&gt; copy)
&gt; @@ -2344,6 +2344,31 @@
&gt;    * migration purposes? */
&gt;   int V3AuthUseLegacyKey;
&gt;
&gt; +  /** The length of time that we think an initial consensus should be
&gt; +   * fresh. */
&gt; +  int V3AuthInitialVotingInterval;
&gt; +
&gt; +  /** The length of time we think it will take to distribute initial
&gt; +   * votes. */
&gt; +  int V3AuthInitialVoteDelay;
&gt; +
&gt; +  /** The length of time we think it will take to distribute initial
&gt; +   * signatures. */
&gt; +  int V3AuthInitialDistDelay;
&gt; +
&gt; +  /** If an authority has been around for less than this amount of time,
&gt; +   * its reachability information is not accurate. */
&gt; +  int DirTimeToLearnReachability;
&gt; +
&gt; +  /** Clients don't download any descriptor this recent, since it will
&gt; +   * probably not have propagated to enough caches. */
&gt; +  int EstimatedDescriptorPropagationTime;
&gt; +
&gt; +  /** If true, we take part in a testing network. Change the defaults of a
&gt; +   * couple of other configuration options and allow to change the values
&gt; +   * of certain configuration options. */
&gt; +  int TestingTorNetwork;
&gt; +
&gt;   /** File to check for a consensus networkstatus, if we don't have one
&gt;    * cached. */
&gt;   char *FallbackNetworkstatusFile;
&gt; @@ -3186,9 +3211,6 @@
&gt;  /** Smallest allowable voting interval. */
&gt;  #define MIN_VOTE_INTERVAL 300
&gt;
&gt; -/** If there is no consensus, what interval do we default to? */
&gt; -#define DEFAULT_VOTING_INTERVAL_WHEN_NO_CONSENSUS (30*60)
&gt; -
&gt;  void dirvote_free_all(void);
&gt;
&gt;  /* vote manipulation */
&gt; Index: /home/karsten/tor/tor-trunk-private-network/src/or/routerlist.c
&gt; ===================================================================
&gt; --- /home/karsten/tor/tor-trunk-private-network/src/or/routerlist.c
&gt; (revision 14671)
&gt; +++ /home/karsten/tor/tor-trunk-private-network/src/or/routerlist.c
&gt; (working copy)
&gt; @@ -3673,10 +3673,6 @@
&gt;   tor_free(resource);
&gt;  }
&gt;
&gt; -/** Clients don't download any descriptor this recent, since it will
&gt; probably
&gt; - * not have propagated to enough caches. */
&gt; -#define ESTIMATED_PROPAGATION_TIME (10*60)
&gt; -
&gt;  /** Return 0 if this routerstatus is obsolete, too new, isn't
&gt;  * running, or otherwise not a descriptor that we would make any
&gt;  * use of even if we had it. Else return 1. */
&gt; @@ -3688,7 +3684,7 @@
&gt;      * But, if we want to have a complete list, fetch it anyway. */
&gt;     return 0;
&gt;   }
&gt; -  if (rs-&gt;published_on + ESTIMATED_PROPAGATION_TIME &gt; now) {
&gt; +  if (rs-&gt;published_on + options-&gt;EstimatedDescriptorPropagationTime &gt;
&gt; now) {
&gt;     /* Most caches probably don't have this descriptor yet. */
&gt;     return 0;
&gt;   }
&gt;
&gt;
&gt;

[Attachment #3 (text/html)]

I love it!  Nice work Karsten!&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;div class="gmail_quote"&gt;On Mon, May \
19, 2008 at 2:53 PM, Karsten Loesing &lt;&lt;a \
href="mailto:karsten.loesing@gmx.net"&gt;karsten.loesing@gmx.net&lt;/a&gt;&gt; \
wrote:&lt;br&gt;&lt;blockquote class="gmail_quote" style="border-left: 1px solid rgb(204, 204, \
204); margin: 0pt 0pt 0pt 0.8ex; padding-left: 1ex;"&gt; &lt;div class="Ih2E3d"&gt;-----BEGIN \
                PGP SIGNED MESSAGE-----&lt;br&gt;
Hash: SHA1&lt;br&gt;
&lt;br&gt;&lt;/div&gt;
Hi Nick,&lt;div class="Ih2E3d"&gt;&lt;br&gt;
&lt;br&gt;
&gt; What about having a preprocessing step on the options list that&lt;br&gt;
&gt; expands PrivateTorNetwork 1 into the entire list of options it&lt;br&gt;
&gt; implies? It's not an error to specify an option twice; when you do,&lt;br&gt;
&gt; the second takes precedence.&lt;br&gt;
&lt;br&gt;&lt;/div&gt;
Hmm, I couldn't find the right place in the code to implement your idea.&lt;br&gt;
I now solved it differently: When reading configurations from torrc and&lt;br&gt;
the console, Tor checks if TestingTorNetwork was configured. If so,&lt;br&gt;
default values for dependent options are changed and the configuration&lt;br&gt;
is read in again. See lines 3835--3892 in config.c.&lt;br&gt;
&lt;br&gt;
I also added a hook that prevents TestingTorNetwork from being changed&lt;br&gt;
after Tor is started. I could not imagine why this would be useful, and&lt;br&gt;
therefore excluded this possibility to prevent unforeseen errors. See&lt;br&gt;
lines 3463--3468 in config.c.&lt;div class="Ih2E3d"&gt;&lt;br&gt;
&lt;br&gt;
&gt; This would mean that RESETCONF wouldn't do the right thing, though.&lt;br&gt;
&gt; Perhaps a hack like the one in weasel's debian-tor user patch would&lt;br&gt;
&gt; handle that better.  It's still a hack, but not a totally insane hack.&lt;br&gt;
&lt;br&gt;&lt;/div&gt;
Right, that's what I've done now.&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
In the proposal I added a section with test cases. These include all&lt;br&gt;
those scenarios about changing configurations that came to my mind.&lt;br&gt;
These tests succeeded in a patched Tor and worked fine with a patched&lt;br&gt;
PuppeTor using v3 directories.&lt;div class="Ih2E3d"&gt;&lt;br&gt;
&lt;br&gt;
- --Karsten&lt;br&gt;
-----BEGIN PGP SIGNATURE-----&lt;br&gt;
Version: GnuPG v1.4.6 (GNU/Linux)&lt;br&gt;
Comment: Using GnuPG with Mozilla - &lt;a href="http://enigmail.mozdev.org" \
target="_blank"&gt;http://enigmail.mozdev.org&lt;/a&gt;&lt;br&gt; &lt;br&gt;&lt;/div&gt;
iD8DBQFIMfbI0M+WPffBEmURAkHJAJ4pr9yyJ0I9p/iyGbMtHn0cCz3pnACfYy6h&lt;br&gt;
UNzjTYAbHyq4l25rd654+dM=&lt;br&gt;
=PYOt&lt;br&gt;
-----END PGP SIGNATURE-----&lt;br&gt;
&lt;br&gt;Index: /home/karsten/tor/tor-trunk-private-network/src/or/config.c&lt;br&gt;
===================================================================&lt;br&gt;
--- /home/karsten/tor/tor-trunk-private-network/src/or/config.c (revision 14671)&lt;br&gt;
+++ /home/karsten/tor/tor-trunk-private-network/src/or/config.c (working copy)&lt;br&gt;
@@ -174,6 +174,7 @@&lt;br&gt;
   V(DataDirectory,               STRING, \
  NULL),&lt;br&gt;    OBSOLETE("DebugLogFile"),&lt;br&gt;
   V(DirAllowPrivateAddresses,    BOOL,     NULL),&lt;br&gt;
+  V(DirTimeToLearnReachability,  INTERVAL, "30 minutes"),&lt;br&gt;
   V(DirListenAddress,            LINELIST, \
NULL),&lt;br&gt;    OBSOLETE("DirFetchPeriod"),&lt;br&gt;
   V(DirPolicy,                   \
LINELIST, NULL),&lt;br&gt; @@ -185,6 +186,7 @@&lt;br&gt;
   V(DownloadExtraInfo,           BOOL,     \
"0"),&lt;br&gt;    V(EnforceDistinctSubnets,      BOOL, \
    "1"),&lt;br&gt;    V(EntryNodes,         \
         STRING,   NULL),&lt;br&gt; + \
 V(EstimatedDescriptorPropagationTime, INTERVAL, "10 minutes"),&lt;br&gt;  \
  V(ExcludeNodes,                STRING, \
  NULL),&lt;br&gt;    V(ExitNodes,             \
      STRING,   NULL),&lt;br&gt;    V(ExitPolicy,     \
             LINELIST, NULL),&lt;br&gt; @@ -243,6 +245,7 \
@@&lt;br&gt;    V(OutboundBindAddress,         STRING,   \
NULL),&lt;br&gt;    OBSOLETE("PathlenCoinWeight"),&lt;br&gt;
   V(PidFile,                   \
  STRING,   NULL),&lt;br&gt; +  V(TestingTorNetwork,       \
    BOOL,     "0"),&lt;br&gt;    \
V(PreferTunneledDirConns,      BOOL,     "1"),&lt;br&gt; \
  V(ProtocolWarnings,            BOOL,   \
  "0"),&lt;br&gt;    V(PublishServerDescriptor,     CSV, \
     "1"),&lt;br&gt; @@ -297,6 +300,9 @@&lt;br&gt;
   VAR("V1AuthoritativeDirectory",BOOL, V1AuthoritativeDir,   \
"0"),&lt;br&gt;    VAR("V2AuthoritativeDirectory",BOOL, \
V2AuthoritativeDir,   "0"),&lt;br&gt;    \
VAR("V3AuthoritativeDirectory",BOOL, V3AuthoritativeDir,   \
"0"),&lt;br&gt; +  V(V3AuthInitialVotingInterval, INTERVAL, "30 \
minutes"),&lt;br&gt; +  V(V3AuthInitialVoteDelay,      INTERVAL, \
"5 minutes"),&lt;br&gt; +  V(V3AuthInitialDistDelay,     \
 INTERVAL, "5 minutes"),&lt;br&gt;    V(V3AuthVotingInterval,   \
     INTERVAL, "1 hour"),&lt;br&gt;    V(V3AuthVoteDelay, \
            INTERVAL, "5 minutes"),&lt;br&gt;  \
  V(V3AuthDistDelay,             INTERVAL, "5 \
minutes"),&lt;br&gt; @@ -3325,6 +3331,72 @@&lt;br&gt;
     });&lt;br&gt;
   }&lt;br&gt;
&lt;br&gt;
+  if (options-&gt;TestingTorNetwork &amp;&amp; !options-&gt;DirServers) {&lt;br&gt;
+    REJECT("TestingTorNetwork may only be configured in combination \
with "&lt;br&gt; +           "a non-default set of \
DirServers.");&lt;br&gt; +  }&lt;br&gt;
+&lt;br&gt;
+  if (options-&gt;V3AuthInitialVotingInterval != 30*60 &amp;&amp;&lt;br&gt;
+      !options-&gt;TestingTorNetwork) {&lt;br&gt;
+    REJECT("V3AuthInitialVotingInterval may only be changed in \
testing "&lt;br&gt; +           "Tor \
networks!");&lt;br&gt; +  } else if (options-&gt;V3AuthInitialVotingInterval &lt; \
MIN_VOTE_INTERVAL) {&lt;br&gt; +    REJECT("V3AuthInitialVotingInterval is \
insanely low.");&lt;br&gt; +  } else if (options-&gt;V3AuthInitialVotingInterval \
&gt; 24*60*60) {&lt;br&gt; +    REJECT("V3AuthInitialVotingInterval is \
insanely high.");&lt;br&gt; +  } else if (((30*60) % \
options-&gt;V3AuthInitialVotingInterval) != 0) {&lt;br&gt; +   \
 REJECT("V3AuthInitialVotingInterval does not divide evenly into "&lt;br&gt; \
+           "30 minutes.");&lt;br&gt; +  }&lt;br&gt;
+&lt;br&gt;
+  if (options-&gt;V3AuthInitialVoteDelay != 5*60 &amp;&amp;&lt;br&gt;
+      !options-&gt;TestingTorNetwork) {&lt;br&gt;
+    REJECT("V3AuthInitialVoteDelay may only be changed in testing \
"&lt;br&gt; +           "Tor networks!");&lt;br&gt;
+  } else if (options-&gt;V3AuthInitialVoteDelay &lt; MIN_VOTE_SECONDS) {&lt;br&gt;
+    REJECT("V3AuthInitialVoteDelay is way too low.");&lt;br&gt;
+  }&lt;br&gt;
+&lt;br&gt;
+  if (options-&gt;V3AuthInitialDistDelay != 5*60 &amp;&amp;&lt;br&gt;
+      !options-&gt;TestingTorNetwork) {&lt;br&gt;
+    REJECT("V3AuthInitialDistDelay may only be changed in testing \
"&lt;br&gt; +           "Tor networks!");&lt;br&gt;
+  } else if (options-&gt;V3AuthInitialDistDelay &lt; MIN_DIST_SECONDS) {&lt;br&gt;
+    REJECT("V3AuthInitialDistDelay is way too low.");&lt;br&gt;
+  }&lt;br&gt;
+&lt;br&gt;
+  if (options-&gt;V3AuthInitialVoteDelay + options-&gt;V3AuthInitialDistDelay \
&gt;=&lt;br&gt; +      options-&gt;V3AuthInitialVotingInterval/2) {&lt;br&gt;
+    REJECT("V3AuthInitialVoteDelay plus V3AuthInitialDistDelay must \
be "&lt;br&gt; +           "less than half \
V3AuthInitialVotingInterval");&lt;br&gt; +  }&lt;br&gt;
+&lt;br&gt;
+  if (options-&gt;DirTimeToLearnReachability != 30*60 &amp;&amp; \
!options-&gt;TestingTorNetwork) {&lt;br&gt; +   \
 REJECT("DirTimeToLearnReachability may only be changed in testing \
"&lt;br&gt; +           "Tor networks!");&lt;br&gt;
+  } else if (options-&gt;DirTimeToLearnReachability &lt; 0) {&lt;br&gt;
+    REJECT("DirTimeToLearnReachability must be \
non-negative.");&lt;br&gt; +  } else if (options-&gt;DirTimeToLearnReachability \
&gt; 2*60*60) {&lt;br&gt; +    COMPLAIN("DirTimeToLearnReachability is \
insanely high.");&lt;br&gt; +  }&lt;br&gt;
+&lt;br&gt;
+  if (options-&gt;EstimatedDescriptorPropagationTime != 10*60 &amp;&amp;&lt;br&gt;
+      !options-&gt;TestingTorNetwork) {&lt;br&gt;
+    REJECT("EstimatedDescriptorPropagationTime may only be changed in \
"&lt;br&gt; +           "testing Tor \
networks!");&lt;br&gt; +  } else if \
(options-&gt;EstimatedDescriptorPropagationTime &lt; 0) {&lt;br&gt; +   \
 REJECT("EstimatedDescriptorPropagationTime must be \
non-negative.");&lt;br&gt; +  } else if \
(options-&gt;EstimatedDescriptorPropagationTime &gt; 60*60) {&lt;br&gt; +   \
 COMPLAIN("EstimatedDescriptorPropagationTime is insanely high.");&lt;br&gt; \
+  }&lt;br&gt; +&lt;br&gt;
+  if (options-&gt;TestingTorNetwork) {&lt;br&gt;
+    log_warn(LD_CONFIG, "TestingTorNetwork is set. This will make \
your node "&lt;br&gt; +                   \
     "almost unusable in the public Tor network, and is \
"&lt;br&gt; +                     \
   "therefore only advised if you are building a "&lt;br&gt; +   \
                    \
 "testing Tor network!");&lt;br&gt; +  }&lt;br&gt;
+&lt;br&gt;
   return 0;&lt;br&gt;
 #undef REJECT&lt;br&gt;
 #undef COMPLAIN&lt;br&gt;
@@ -3388,6 +3460,12 @@&lt;br&gt;
     return -1;&lt;br&gt;
   }&lt;br&gt;
&lt;br&gt;
+  if (old-&gt;TestingTorNetwork != new_val-&gt;TestingTorNetwork) {&lt;br&gt;
+    *msg = tor_strdup("While Tor is running, changing \
TestingTorNetwork "&lt;br&gt; +               \
       "is not allowed.");&lt;br&gt; +    return \
-1;&lt;br&gt; +  }&lt;br&gt;
+&lt;br&gt;
   return 0;&lt;br&gt;
 }&lt;br&gt;
&lt;br&gt;
@@ -3756,6 +3834,64 @@&lt;br&gt;
     goto err;&lt;br&gt;
   }&lt;br&gt;
&lt;br&gt;
+  /* If this is a testing network configuration, change defaults&lt;br&gt;
+   * for a list of dependent config options, re-initialize newoptions&lt;br&gt;
+   * with the new defaults, and assign all options to it second time. */&lt;br&gt;
+  if (newoptions-&gt;TestingTorNetwork) {&lt;br&gt;
+&lt;br&gt;
+    /* Change defaults. */&lt;br&gt;
+    #define CHANGE_DEFAULT(key, val)           \
                     \&lt;br&gt; + \
   {                     \
                        \
                  \&lt;br&gt; +     \
 config_var_t *var = config_find_option(&amp;options_format, key); \&lt;br&gt; + \
     tor_assert(var);               \
                        \
       \&lt;br&gt; +      var-&gt;initvalue = \
tor_strdup(val);                   \
          \&lt;br&gt; +    }&lt;br&gt;
+    CHANGE_DEFAULT("ServerDNSAllowBrokenResolvConf", \
"1");&lt;br&gt; +   \
 CHANGE_DEFAULT("DirAllowPrivateAddresses", "1");&lt;br&gt; + \
   CHANGE_DEFAULT("EnforceDistinctSubnets", "0");&lt;br&gt; + \
   CHANGE_DEFAULT("AssumeReachable", "1");&lt;br&gt; +   \
 CHANGE_DEFAULT("AuthDirMaxServersPerAddr", "0");&lt;br&gt; + \
   CHANGE_DEFAULT("AuthDirMaxServersPerAuthAddr", \
"0");&lt;br&gt; +   \
 CHANGE_DEFAULT("ClientDNSRejectInternalAddresses", \
"0");&lt;br&gt; +   \
 CHANGE_DEFAULT("ExitPolicyRejectPrivate", "0");&lt;br&gt; + \
   CHANGE_DEFAULT("V3AuthVotingInterval", "300");&lt;br&gt; + \
   CHANGE_DEFAULT("V3AuthVoteDelay", "20");&lt;br&gt; + \
   CHANGE_DEFAULT("V3AuthDistDelay", "20");&lt;br&gt; + \
   CHANGE_DEFAULT("V3AuthInitialVotingInterval", \
"300");&lt;br&gt; +   \
 CHANGE_DEFAULT("V3AuthInitialVoteDelay", "20");&lt;br&gt; + \
   CHANGE_DEFAULT("V3AuthInitialDistDelay", "20");&lt;br&gt; \
+    CHANGE_DEFAULT("DirTimeToLearnReachability", \
"0");&lt;br&gt; +   \
 CHANGE_DEFAULT("EstimatedDescriptorPropagationTime", \
"0");&lt;br&gt; +    #undef CHANGE_DEFAULT&lt;br&gt;
+&lt;br&gt;
+    /* Clear newoptions and re-initialize them with new defaults. */&lt;br&gt;
+    config_free(&amp;options_format, newoptions);&lt;br&gt;
+    newoptions = tor_malloc_zero(sizeof(or_options_t));&lt;br&gt;
+    newoptions-&gt;_magic = OR_OPTIONS_MAGIC;&lt;br&gt;
+    options_init(newoptions);&lt;br&gt;
+    newoptions-&gt;command = command;&lt;br&gt;
+    newoptions-&gt;command_arg = command_arg;&lt;br&gt;
+&lt;br&gt;
+    /* Assign all options a second time. */&lt;br&gt;
+    retval = config_get_lines(cf, &amp;cl);&lt;br&gt;
+    if (retval &lt; 0) {&lt;br&gt;
+      err = SETOPT_ERR_PARSE;&lt;br&gt;
+      goto err;&lt;br&gt;
+    }&lt;br&gt;
+    retval = config_assign(&amp;options_format, newoptions, cl, 0, 0, \
msg);&lt;br&gt; +    config_free_lines(cl);&lt;br&gt;
+    if (retval &lt; 0) {&lt;br&gt;
+      err = SETOPT_ERR_PARSE;&lt;br&gt;
+      goto err;&lt;br&gt;
+    }&lt;br&gt;
+    retval = config_assign(&amp;options_format, newoptions,&lt;br&gt;
+                         \
  global_cmdline_options, 0, 0, msg);&lt;br&gt; +    if (retval &lt; 0) \
{&lt;br&gt; +      err = SETOPT_ERR_PARSE;&lt;br&gt;
+      goto err;&lt;br&gt;
+    }&lt;br&gt;
+  }&lt;br&gt;
+&lt;br&gt;
   /* Validate newoptions */&lt;br&gt;
   if (options_validate(oldoptions, newoptions, 0, msg) &lt; 0) {&lt;br&gt;
     err = SETOPT_ERR_PARSE; /*XXX021 make this separate.*/&lt;br&gt;
Index: /home/karsten/tor/tor-trunk-private-network/src/or/dirserv.c&lt;br&gt;
===================================================================&lt;br&gt;
--- /home/karsten/tor/tor-trunk-private-network/src/or/dirserv.c       \
                 (revision 14671)&lt;br&gt;
+++ /home/karsten/tor/tor-trunk-private-network/src/or/dirserv.c       \
 (working copy)&lt;br&gt; @@ -2122,10 +2122,6 @@&lt;br&gt;
     router-&gt;is_bad_exit = router-&gt;is_bad_directory = 0;&lt;br&gt;
 }&lt;br&gt;
&lt;br&gt;
-/** If we've been around for less than this amount of time, our reachability&lt;br&gt;
- * information is not accurate. */&lt;br&gt;
-#define DIRSERV_TIME_TO_GET_REACHABILITY_INFO (30*60)&lt;br&gt;
-&lt;br&gt;
 /** Return a new networkstatus_t* containing our current opinion. (For v3&lt;br&gt;
  * authorities) */&lt;br&gt;
 networkstatus_t *&lt;br&gt;
@@ -2155,7 +2151,7 @@&lt;br&gt;
   tor_assert(private_key);&lt;br&gt;
   tor_assert(cert);&lt;br&gt;
&lt;br&gt;
-  if (now - time_of_process_start &lt; \
DIRSERV_TIME_TO_GET_REACHABILITY_INFO)&lt;br&gt; +  if (now - time_of_process_start \
&lt; options-&gt;DirTimeToLearnReachability)&lt;br&gt;      vote_on_reachability \
= 0;&lt;br&gt; &lt;br&gt;
   if (resolve_my_address(LOG_WARN, options, &amp;addr, &amp;hostname)&lt;0) \
{&lt;br&gt; @@ -2241,7 +2237,7 @@&lt;br&gt;
       last_consensus_interval = current_consensus-&gt;fresh_until \
-&lt;br&gt;          current_consensus-&gt;valid_after;&lt;br&gt;
     else&lt;br&gt;
-      last_consensus_interval = \
DEFAULT_VOTING_INTERVAL_WHEN_NO_CONSENSUS;&lt;br&gt; +     \
 last_consensus_interval = options-&gt;V3AuthInitialVotingInterval;&lt;br&gt;    \
  v3_out-&gt;valid_after =&lt;br&gt;        \
dirvote_get_start_of_next_interval(now, (int)last_consensus_interval);&lt;br&gt;    \
                  format_iso_time(tbuf, v3_out-&gt;valid_after);&lt;br&gt;
Index: /home/karsten/tor/tor-trunk-private-network/src/or/dirvote.c&lt;br&gt;
===================================================================&lt;br&gt;
--- /home/karsten/tor/tor-trunk-private-network/src/or/dirvote.c       \
                 (revision 14671)&lt;br&gt;
+++ /home/karsten/tor/tor-trunk-private-network/src/or/dirvote.c       \
 (working copy)&lt;br&gt; @@ -1300,8 +1300,9 @@&lt;br&gt;
     vote_delay = consensus-&gt;vote_seconds;&lt;br&gt;
     dist_delay = consensus-&gt;dist_seconds;&lt;br&gt;
   } else {&lt;br&gt;
-    interval = DEFAULT_VOTING_INTERVAL_WHEN_NO_CONSENSUS;&lt;br&gt;
-    vote_delay = dist_delay = 300;&lt;br&gt;
+    interval = options-&gt;V3AuthInitialVotingInterval;&lt;br&gt;
+    vote_delay = options-&gt;V3AuthInitialVoteDelay;&lt;br&gt;
+    dist_delay = options-&gt;V3AuthInitialDistDelay;&lt;br&gt;
   }&lt;br&gt;
&lt;br&gt;
   tor_assert(interval &gt; 0);&lt;br&gt;
Index: /home/karsten/tor/tor-trunk-private-network/src/or/or.h&lt;br&gt;
===================================================================&lt;br&gt;
--- /home/karsten/tor/tor-trunk-private-network/src/or/or.h     (revision \
                14671)&lt;br&gt;
+++ /home/karsten/tor/tor-trunk-private-network/src/or/or.h     (working \
copy)&lt;br&gt; @@ -2344,6 +2344,31 @@&lt;br&gt;
    * migration purposes? */&lt;br&gt;
   int V3AuthUseLegacyKey;&lt;br&gt;
&lt;br&gt;
+  /** The length of time that we think an initial consensus should be&lt;br&gt;
+   * fresh. */&lt;br&gt;
+  int V3AuthInitialVotingInterval;&lt;br&gt;
+&lt;br&gt;
+  /** The length of time we think it will take to distribute initial&lt;br&gt;
+   * votes. */&lt;br&gt;
+  int V3AuthInitialVoteDelay;&lt;br&gt;
+&lt;br&gt;
+  /** The length of time we think it will take to distribute initial&lt;br&gt;
+   * signatures. */&lt;br&gt;
+  int V3AuthInitialDistDelay;&lt;br&gt;
+&lt;br&gt;
+  /** If an authority has been around for less than this amount of time,&lt;br&gt;
+   * its reachability information is not accurate. */&lt;br&gt;
+  int DirTimeToLearnReachability;&lt;br&gt;
+&lt;br&gt;
+  /** Clients don't download any descriptor this recent, since it will&lt;br&gt;
+   * probably not have propagated to enough caches. */&lt;br&gt;
+  int EstimatedDescriptorPropagationTime;&lt;br&gt;
+&lt;br&gt;
+  /** If true, we take part in a testing network. Change the defaults of a&lt;br&gt;
+   * couple of other configuration options and allow to change the values&lt;br&gt;
+   * of certain configuration options. */&lt;br&gt;
+  int TestingTorNetwork;&lt;br&gt;
+&lt;br&gt;
   /** File to check for a consensus networkstatus, if we don't have one&lt;br&gt;
    * cached. */&lt;br&gt;
   char *FallbackNetworkstatusFile;&lt;br&gt;
@@ -3186,9 +3211,6 @@&lt;br&gt;
 /** Smallest allowable voting interval. */&lt;br&gt;
 #define MIN_VOTE_INTERVAL 300&lt;br&gt;
&lt;br&gt;
-/** If there is no consensus, what interval do we default to? */&lt;br&gt;
-#define DEFAULT_VOTING_INTERVAL_WHEN_NO_CONSENSUS (30*60)&lt;br&gt;
-&lt;br&gt;
 void dirvote_free_all(void);&lt;br&gt;
&lt;br&gt;
 /* vote manipulation */&lt;br&gt;
Index: /home/karsten/tor/tor-trunk-private-network/src/or/routerlist.c&lt;br&gt;
===================================================================&lt;br&gt;
--- /home/karsten/tor/tor-trunk-private-network/src/or/routerlist.c     \
                (revision 14671)&lt;br&gt;
+++ /home/karsten/tor/tor-trunk-private-network/src/or/routerlist.c     \
(working copy)&lt;br&gt; @@ -3673,10 +3673,6 @@&lt;br&gt;
   tor_free(resource);&lt;br&gt;
 }&lt;br&gt;
&lt;br&gt;
-/** Clients don't download any descriptor this recent, since it will \
                probably&lt;br&gt;
- * not have propagated to enough caches. */&lt;br&gt;
-#define ESTIMATED_PROPAGATION_TIME (10*60)&lt;br&gt;
-&lt;br&gt;
 /** Return 0 if this routerstatus is obsolete, too new, isn't&lt;br&gt;
  * running, or otherwise not a descriptor that we would make any&lt;br&gt;
  * use of even if we had it. Else return 1. */&lt;br&gt;
@@ -3688,7 +3684,7 @@&lt;br&gt;
      * But, if we want to have a complete list, fetch it anyway. \
*/&lt;br&gt;      return 0;&lt;br&gt;
   }&lt;br&gt;
-  if (rs-&gt;published_on + ESTIMATED_PROPAGATION_TIME &gt; now) {&lt;br&gt;
+  if (rs-&gt;published_on + options-&gt;EstimatedDescriptorPropagationTime &gt; \
now) {&lt;br&gt;      /* Most caches probably don't have this descriptor yet. \
*/&lt;br&gt;      return 0;&lt;br&gt;
   }&lt;br&gt;
&lt;br&gt;
&lt;br&gt;&lt;/blockquote&gt;&lt;/div&gt;&lt;br&gt;



</body></email><email><emailId>20080523222503</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2008-05-23 22:25:03-0400</timestampReceived><subject>Re: [proposal 136] Re: Proposal: Simplify Configuration of Private Tor Networks</subject><body>

On Mon, May 19, 2008 at 11:53:12PM +0200, Karsten Loesing wrote:
&gt; I now solved it differently: When reading configurations from torrc and
&gt; the console, Tor checks if TestingTorNetwork was configured. If so,
&gt; default values for dependent options are changed and the configuration
&gt; is read in again. See lines 3835--3892 in config.c.
[snip]
&gt; +  /* If this is a testing network configuration, change defaults
&gt; +   * for a list of dependent config options, re-initialize newoptions
&gt; +   * with the new defaults, and assign all options to it second time. */
&gt; +  if (newoptions-&gt;TestingTorNetwork) {
&gt; +
&gt; +    /* Change defaults. */
&gt; +    #define CHANGE_DEFAULT(key, val)                                \
&gt; +    {                                                               \
&gt; +      config_var_t *var = config_find_option(&amp;options_format, key); \
&gt; +      tor_assert(var);                                              \
&gt; +      var-&gt;initvalue = tor_strdup(val);                             \
&gt; +    }
&gt; +    CHANGE_DEFAULT("ServerDNSAllowBrokenResolvConf", "1");

The var-&gt;initvalue = tor_strdup(val) above clobbers the current value of
var-&gt;initvalue. For the first time we assign config options, that's fine,
since its initial value is from a static table. But for future times we
assign config options, we'll leak the previous value.

One better approach might be to have a static table of keys (strings)
and values (strings) for the alternate defaults, and walk through the
table doing a config_find_option() on the key and then assigning value
directly from the table (rather than making a copy).

I'll let Nick chime in with other better approaches, or to correct me,
as necessary. :)

--Roger

</body></email><email><emailId>20080528121549</emailId><senderName>Karsten Loesing</senderName><senderEmail>karsten.loesing@gmx.net</senderEmail><timestampReceived>2008-05-28 12:15:49-0400</timestampReceived><subject>Re: [proposal 136] Re: Proposal: Simplify Configuration of Private</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Roger Dingledine wrote:
| The var-&gt;initvalue = tor_strdup(val) above clobbers the current value of
| var-&gt;initvalue. For the first time we assign config options, that's fine,
| since its initial value is from a static table. But for future times we
| assign config options, we'll leak the previous value.
|
| One better approach might be to have a static table of keys (strings)
| and values (strings) for the alternate defaults, and walk through the
| table doing a config_find_option() on the key and then assigning value
| directly from the table (rather than making a copy).

You are right. I fixed that as you proposed (or similarly) and attached
a new patch.

- --Karsten
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFIPUz10M+WPffBEmURArC5AKDEOjP3YKdB93brqPbhuuZ29UwxXQCfRpzp
97KmXg6WLOh9B4LzHWNy/tg=
=EiSl
-----END PGP SIGNATURE-----

["patch3.txt" (text/plain)]

Index: /home/karsten/tor/tor-trunk-private-network/src/or/config.c
===================================================================
--- /home/karsten/tor/tor-trunk-private-network/src/or/config.c	(revision 14770)
+++ /home/karsten/tor/tor-trunk-private-network/src/or/config.c	(working copy)
@@ -174,6 +174,7 @@
   V(DataDirectory,               STRING,   NULL),
   OBSOLETE("DebugLogFile"),
   V(DirAllowPrivateAddresses,    BOOL,     NULL),
+  V(DirTimeToLearnReachability,  INTERVAL, "30 minutes"),
   V(DirListenAddress,            LINELIST, NULL),
   OBSOLETE("DirFetchPeriod"),
   V(DirPolicy,                   LINELIST, NULL),
@@ -185,6 +186,7 @@
   V(DownloadExtraInfo,           BOOL,     "0"),
   V(EnforceDistinctSubnets,      BOOL,     "1"),
   V(EntryNodes,                  STRING,   NULL),
+  V(EstimatedDescriptorPropagationTime, INTERVAL, "10 minutes"),
   V(ExcludeNodes,                STRING,   NULL),
   V(ExitNodes,                   STRING,   NULL),
   V(ExitPolicy,                  LINELIST, NULL),
@@ -244,6 +246,7 @@
   V(OutboundBindAddress,         STRING,   NULL),
   OBSOLETE("PathlenCoinWeight"),
   V(PidFile,                     STRING,   NULL),
+  V(TestingTorNetwork,           BOOL,     "0"),
   V(PreferTunneledDirConns,      BOOL,     "1"),
   V(ProtocolWarnings,            BOOL,     "0"),
   V(PublishServerDescriptor,     CSV,      "1"),
@@ -298,6 +301,9 @@
   VAR("V1AuthoritativeDirectory",BOOL, V1AuthoritativeDir,   "0"),
   VAR("V2AuthoritativeDirectory",BOOL, V2AuthoritativeDir,   "0"),
   VAR("V3AuthoritativeDirectory",BOOL, V3AuthoritativeDir,   "0"),
+  V(V3AuthInitialVotingInterval, INTERVAL, "30 minutes"),
+  V(V3AuthInitialVoteDelay,      INTERVAL, "5 minutes"),
+  V(V3AuthInitialDistDelay,      INTERVAL, "5 minutes"),
   V(V3AuthVotingInterval,        INTERVAL, "1 hour"),
   V(V3AuthVoteDelay,             INTERVAL, "5 minutes"),
   V(V3AuthDistDelay,             INTERVAL, "5 minutes"),
@@ -314,6 +320,26 @@
   V(MinUptimeHidServDirectoryV2, INTERVAL, "24 hours"),
   { NULL, CONFIG_TYPE_OBSOLETE, 0, NULL }
 };
+
+static config_var_t testing_tor_network_defaults[] = {
+  V(ServerDNSAllowBrokenResolvConf, BOOL,  "1"),
+  V(DirAllowPrivateAddresses,    BOOL,     "1"),
+  V(EnforceDistinctSubnets,      BOOL,     "0"),
+  V(AssumeReachable,             BOOL,     "1"),
+  V(AuthDirMaxServersPerAddr,    UINT,     "0"),
+  V(AuthDirMaxServersPerAuthAddr,UINT,     "0"),
+  V(ClientDNSRejectInternalAddresses, BOOL,"0"),
+  V(ExitPolicyRejectPrivate,     BOOL,     "0"),
+  V(V3AuthVotingInterval,        INTERVAL, "5 minutes"),
+  V(V3AuthVoteDelay,             INTERVAL, "20 seconds"),
+  V(V3AuthDistDelay,             INTERVAL, "20 seconds"),
+  V(V3AuthInitialVotingInterval, INTERVAL, "5 minutes"),
+  V(V3AuthInitialVoteDelay,      INTERVAL, "20 seconds"),
+  V(V3AuthInitialDistDelay,      INTERVAL, "20 seconds"),
+  V(DirTimeToLearnReachability,  INTERVAL, "0 minutes"),
+  V(EstimatedDescriptorPropagationTime, INTERVAL, "0 minutes"),
+  { NULL, CONFIG_TYPE_OBSOLETE, 0, NULL }
+};
 #undef VAR
 
 #define VAR(name,conftype,member,initvalue)                             \
@@ -3326,6 +3352,73 @@
     });
   }
 
+  if (options-&gt;TestingTorNetwork &amp;&amp; !options-&gt;DirServers) {
+    REJECT("TestingTorNetwork may only be configured in combination with "
+           "a non-default set of DirServers.");
+  }
+
+  if (options-&gt;V3AuthInitialVotingInterval != 30*60 &amp;&amp;
+      !options-&gt;TestingTorNetwork) {
+    REJECT("V3AuthInitialVotingInterval may only be changed in testing "
+           "Tor networks!");
+  } else if (options-&gt;V3AuthInitialVotingInterval &lt; MIN_VOTE_INTERVAL) {
+    REJECT("V3AuthInitialVotingInterval is insanely low.");
+  } else if (options-&gt;V3AuthInitialVotingInterval &gt; 24*60*60) {
+    REJECT("V3AuthInitialVotingInterval is insanely high.");
+  } else if (((30*60) % options-&gt;V3AuthInitialVotingInterval) != 0) {
+    REJECT("V3AuthInitialVotingInterval does not divide evenly into "
+           "30 minutes.");
+  }
+
+  if (options-&gt;V3AuthInitialVoteDelay != 5*60 &amp;&amp;
+      !options-&gt;TestingTorNetwork) {
+    REJECT("V3AuthInitialVoteDelay may only be changed in testing "
+           "Tor networks!");
+  } else if (options-&gt;V3AuthInitialVoteDelay &lt; MIN_VOTE_SECONDS) {
+    REJECT("V3AuthInitialVoteDelay is way too low.");
+  }
+
+  if (options-&gt;V3AuthInitialDistDelay != 5*60 &amp;&amp;
+      !options-&gt;TestingTorNetwork) {
+    REJECT("V3AuthInitialDistDelay may only be changed in testing "
+           "Tor networks!");
+  } else if (options-&gt;V3AuthInitialDistDelay &lt; MIN_DIST_SECONDS) {
+    REJECT("V3AuthInitialDistDelay is way too low.");
+  }
+
+  if (options-&gt;V3AuthInitialVoteDelay + options-&gt;V3AuthInitialDistDelay &gt;=
+      options-&gt;V3AuthInitialVotingInterval/2) {
+    REJECT("V3AuthInitialVoteDelay plus V3AuthInitialDistDelay must be "
+           "less than half V3AuthInitialVotingInterval");
+  }
+
+  if (options-&gt;DirTimeToLearnReachability != 30*60 &amp;&amp;
+      !options-&gt;TestingTorNetwork) {
+    REJECT("DirTimeToLearnReachability may only be changed in testing "
+           "Tor networks!");
+  } else if (options-&gt;DirTimeToLearnReachability &lt; 0) {
+    REJECT("DirTimeToLearnReachability must be non-negative.");
+  } else if (options-&gt;DirTimeToLearnReachability &gt; 2*60*60) {
+    COMPLAIN("DirTimeToLearnReachability is insanely high.");
+  }
+
+  if (options-&gt;EstimatedDescriptorPropagationTime != 10*60 &amp;&amp;
+      !options-&gt;TestingTorNetwork) {
+    REJECT("EstimatedDescriptorPropagationTime may only be changed in "
+           "testing Tor networks!");
+  } else if (options-&gt;EstimatedDescriptorPropagationTime &lt; 0) {
+    REJECT("EstimatedDescriptorPropagationTime must be non-negative.");
+  } else if (options-&gt;EstimatedDescriptorPropagationTime &gt; 60*60) {
+    COMPLAIN("EstimatedDescriptorPropagationTime is insanely high.");
+  }
+
+  if (options-&gt;TestingTorNetwork) {
+    log_warn(LD_CONFIG, "TestingTorNetwork is set. This will make your node "
+                        "almost unusable in the public Tor network, and is "
+                        "therefore only advised if you are building a "
+                        "testing Tor network!");
+  }
+
   return 0;
 #undef REJECT
 #undef COMPLAIN
@@ -3389,6 +3482,12 @@
     return -1;
   }
 
+  if (old-&gt;TestingTorNetwork != new_val-&gt;TestingTorNetwork) {
+    *msg = tor_strdup("While Tor is running, changing TestingTorNetwork "
+                      "is not allowed.");
+    return -1;
+  }
+
   return 0;
 }
 
@@ -3757,6 +3856,50 @@
     goto err;
   }
 
+  /* If this is a testing network configuration, change defaults
+   * for a list of dependent config options, re-initialize newoptions
+   * with the new defaults, and assign all options to it second time. */
+  if (newoptions-&gt;TestingTorNetwork) {
+
+    /* Change defaults. */
+    int i;
+    for (i = 0; testing_tor_network_defaults[i].name; ++i) {
+      config_var_t *new_var = &amp;testing_tor_network_defaults[i];
+      config_var_t *old_var =
+          config_find_option(&amp;options_format, new_var-&gt;name);
+      tor_assert(new_var);
+      tor_assert(old_var);
+      old_var-&gt;initvalue = new_var-&gt;initvalue;
+    }
+
+    /* Clear newoptions and re-initialize them with new defaults. */
+    config_free(&amp;options_format, newoptions);
+    newoptions = tor_malloc_zero(sizeof(or_options_t));
+    newoptions-&gt;_magic = OR_OPTIONS_MAGIC;
+    options_init(newoptions);
+    newoptions-&gt;command = command;
+    newoptions-&gt;command_arg = command_arg;
+
+    /* Assign all options a second time. */
+    retval = config_get_lines(cf, &amp;cl);
+    if (retval &lt; 0) {
+      err = SETOPT_ERR_PARSE;
+      goto err;
+    }
+    retval = config_assign(&amp;options_format, newoptions, cl, 0, 0, msg);
+    config_free_lines(cl);
+    if (retval &lt; 0) {
+      err = SETOPT_ERR_PARSE;
+      goto err;
+    }
+    retval = config_assign(&amp;options_format, newoptions,
+                           global_cmdline_options, 0, 0, msg);
+    if (retval &lt; 0) {
+      err = SETOPT_ERR_PARSE;
+      goto err;
+    }
+  }
+
   /* Validate newoptions */
   if (options_validate(oldoptions, newoptions, 0, msg) &lt; 0) {
     err = SETOPT_ERR_PARSE; /*XXX021 make this separate.*/
Index: /home/karsten/tor/tor-trunk-private-network/src/or/dirserv.c
===================================================================
--- /home/karsten/tor/tor-trunk-private-network/src/or/dirserv.c	(revision 14770)
+++ /home/karsten/tor/tor-trunk-private-network/src/or/dirserv.c	(working copy)
@@ -2122,10 +2122,6 @@
     router-&gt;is_bad_exit = router-&gt;is_bad_directory = 0;
 }
 
-/** If we've been around for less than this amount of time, our reachability
- * information is not accurate. */
-#define DIRSERV_TIME_TO_GET_REACHABILITY_INFO (30*60)
-
 /** Return a new networkstatus_t* containing our current opinion. (For v3
  * authorities) */
 networkstatus_t *
@@ -2155,7 +2151,7 @@
   tor_assert(private_key);
   tor_assert(cert);
 
-  if (now - time_of_process_start &lt; DIRSERV_TIME_TO_GET_REACHABILITY_INFO)
+  if (now - time_of_process_start &lt; options-&gt;DirTimeToLearnReachability)
     vote_on_reachability = 0;
 
   if (resolve_my_address(LOG_WARN, options, &amp;addr, &amp;hostname)&lt;0) {
@@ -2241,7 +2237,7 @@
       last_consensus_interval = current_consensus-&gt;fresh_until -
         current_consensus-&gt;valid_after;
     else
-      last_consensus_interval = DEFAULT_VOTING_INTERVAL_WHEN_NO_CONSENSUS;
+      last_consensus_interval = options-&gt;V3AuthInitialVotingInterval;
     v3_out-&gt;valid_after =
       dirvote_get_start_of_next_interval(now, (int)last_consensus_interval);
     format_iso_time(tbuf, v3_out-&gt;valid_after);
Index: /home/karsten/tor/tor-trunk-private-network/src/or/dirvote.c
===================================================================
--- /home/karsten/tor/tor-trunk-private-network/src/or/dirvote.c	(revision 14770)
+++ /home/karsten/tor/tor-trunk-private-network/src/or/dirvote.c	(working copy)
@@ -1300,8 +1300,9 @@
     vote_delay = consensus-&gt;vote_seconds;
     dist_delay = consensus-&gt;dist_seconds;
   } else {
-    interval = DEFAULT_VOTING_INTERVAL_WHEN_NO_CONSENSUS;
-    vote_delay = dist_delay = 300;
+    interval = options-&gt;V3AuthInitialVotingInterval;
+    vote_delay = options-&gt;V3AuthInitialVoteDelay;
+    dist_delay = options-&gt;V3AuthInitialDistDelay;
   }
 
   tor_assert(interval &gt; 0);
Index: /home/karsten/tor/tor-trunk-private-network/src/or/or.h
===================================================================
--- /home/karsten/tor/tor-trunk-private-network/src/or/or.h	(revision 14770)
+++ /home/karsten/tor/tor-trunk-private-network/src/or/or.h	(working copy)
@@ -2350,6 +2350,31 @@
    * migration purposes? */
   int V3AuthUseLegacyKey;
 
+  /** The length of time that we think an initial consensus should be
+   * fresh. */
+  int V3AuthInitialVotingInterval;
+
+  /** The length of time we think it will take to distribute initial
+   * votes. */
+  int V3AuthInitialVoteDelay;
+
+  /** The length of time we think it will take to distribute initial
+   * signatures. */
+  int V3AuthInitialDistDelay;
+
+  /** If an authority has been around for less than this amount of time,
+   * its reachability information is not accurate. */
+  int DirTimeToLearnReachability;
+
+  /** Clients don't download any descriptor this recent, since it will
+   * probably not have propagated to enough caches. */
+  int EstimatedDescriptorPropagationTime;
+
+  /** If true, we take part in a testing network. Change the defaults of a
+   * couple of other configuration options and allow to change the values
+   * of certain configuration options. */
+  int TestingTorNetwork;
+
   /** File to check for a consensus networkstatus, if we don't have one
    * cached. */
   char *FallbackNetworkstatusFile;
@@ -3192,9 +3217,6 @@
 /** Smallest allowable voting interval. */
 #define MIN_VOTE_INTERVAL 300
 
-/** If there is no consensus, what interval do we default to? */
-#define DEFAULT_VOTING_INTERVAL_WHEN_NO_CONSENSUS (30*60)
-
 void dirvote_free_all(void);
 
 /* vote manipulation */
Index: /home/karsten/tor/tor-trunk-private-network/src/or/routerlist.c
===================================================================
--- /home/karsten/tor/tor-trunk-private-network/src/or/routerlist.c	(revision 14770)
+++ /home/karsten/tor/tor-trunk-private-network/src/or/routerlist.c	(working copy)
@@ -3673,10 +3673,6 @@
   tor_free(resource);
 }
 
-/** Clients don't download any descriptor this recent, since it will probably
- * not have propagated to enough caches. */
-#define ESTIMATED_PROPAGATION_TIME (10*60)
-
 /** Return 0 if this routerstatus is obsolete, too new, isn't
  * running, or otherwise not a descriptor that we would make any
  * use of even if we had it. Else return 1. */
@@ -3688,7 +3684,7 @@
      * But, if we want to have a complete list, fetch it anyway. */
     return 0;
   }
-  if (rs-&gt;published_on + ESTIMATED_PROPAGATION_TIME &gt; now) {
+  if (rs-&gt;published_on + options-&gt;EstimatedDescriptorPropagationTime &gt; now) {
     /* Most caches probably don't have this descriptor yet. */
     return 0;
   }


["patch3.txt.sig" (application/octet-stream)]

</body></email><email><emailId>20080529202153</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-05-29 20:21:53-0400</timestampReceived><subject>Re: [proposal 136] Re: Proposal: Simplify Configuration of Private Tor Networks</subject><body>

On Wed, May 28, 2008 at 02:15:49PM +0200, Karsten Loesing wrote:
&gt; -----BEGIN PGP SIGNED MESSAGE-----
&gt; Hash: SHA1
&gt; 
&gt; Roger Dingledine wrote:
&gt; | The var-&gt;initvalue = tor_strdup(val) above clobbers the current value of
&gt; | var-&gt;initvalue. For the first time we assign config options, that's fine,
&gt; | since its initial value is from a static table. But for future times we
&gt; | assign config options, we'll leak the previous value.
&gt; |
&gt; | One better approach might be to have a static table of keys (strings)
&gt; | and values (strings) for the alternate defaults, and walk through the
&gt; | table doing a config_find_option() on the key and then assigning value
&gt; | directly from the table (rather than making a copy).
&gt; 
&gt; You are right. I fixed that as you proposed (or similarly) and attached
&gt; a new patch.

Hi, Karsten!  This looks pretty good to me.  There are a few
issues remaining; let me know if you'd like me to fix them
myself, or if you'd like to do it.

The biggest issue is that there's no documentation for these new
options in the manpage.  They probably want a new section of their
own, since they're only useful for testing.

&gt; +  if (options-&gt;V3AuthInitialVotingInterval != 30*60 &amp;&amp;
&gt; +      !options-&gt;TestingTorNetwork) {

Hmmm.  I don't like encoding the default explicitly in two places.
It's not obvious above that if somebody changes the default from "30
minutes" they also need to change the test here.  The long-term fix is
probably a more general config_is_default() function, but for now I
don't see a trivial fix.

&gt; +    REJECT("V3AuthInitialVotingInterval may only be changed in testing "
&gt; +           "Tor networks!");
&gt; +  } else if (options-&gt;V3AuthInitialVotingInterval &lt; MIN_VOTE_INTERVAL) {
&gt; +    REJECT("V3AuthInitialVotingInterval is insanely low.");
&gt; +  } else if (options-&gt;V3AuthInitialVotingInterval &gt; 24*60*60) {
&gt; +    REJECT("V3AuthInitialVotingInterval is insanely high.");

This test is redundant with the test below; there isn't much reason to
say "too high" for everything over a day, and "doesn't divide 30
minutes evenly" for everything between 31 minutes and a day.

&gt; +  } else if (((30*60) % options-&gt;V3AuthInitialVotingInterval) != 0) {
&gt; +    REJECT("V3AuthInitialVotingInterval does not divide evenly into "
&gt; +           "30 minutes.");
&gt; +  }
 [...]
&gt; +  /* If this is a testing network configuration, change defaults
&gt; +   * for a list of dependent config options, re-initialize newoptions
&gt; +   * with the new defaults, and assign all options to it second time. */
&gt; +  if (newoptions-&gt;TestingTorNetwork) {
&gt; +
&gt; +    /* Change defaults. */
&gt; +    int i;
&gt; +    for (i = 0; testing_tor_network_defaults[i].name; ++i) {
&gt; +      config_var_t *new_var = &amp;testing_tor_network_defaults[i];
&gt; +      config_var_t *old_var =
&gt; +          config_find_option(&amp;options_format, new_var-&gt;name);
&gt; +      tor_assert(new_var);
&gt; +      tor_assert(old_var);
&gt; +      old_var-&gt;initvalue = new_var-&gt;initvalue;
&gt; +    }
&gt; +
&gt; +    /* Clear newoptions and re-initialize them with new defaults. */
&gt; +    config_free(&amp;options_format, newoptions);
&gt; +    newoptions = tor_malloc_zero(sizeof(or_options_t));
&gt; +    newoptions-&gt;_magic = OR_OPTIONS_MAGIC;
&gt; +    options_init(newoptions);
&gt; +    newoptions-&gt;command = command;
&gt; +    newoptions-&gt;command_arg = command_arg;
&gt; +
&gt; +    /* Assign all options a second time. */
&gt; +    retval = config_get_lines(cf, &amp;cl);
&gt; +    if (retval &lt; 0) {
&gt; +      err = SETOPT_ERR_PARSE;
&gt; +      goto err;
&gt; +    }

Wow.  This whole "parse it twice" business is a little hackish, but I
don't see a better way to do it offhand, so I'll not argue.
</body></email><email><emailId>20080517081116</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2008-05-17 08:11:16-0400</timestampReceived><subject>Re: moria1 and moria2 still on 0.2.0.25?</subject><body>

On Fri, May 16, 2008 at 05:21:47PM -0700, Wesley Kenzie wrote:
&gt; Why is it that 2 of the v3 directory authorities (moria1 and moria2 at
&gt; mit.edu running on the same IP address 128.31.0.34) are still running
&gt; version 0.2.0.25?  I see that all the other 6 v3 directory authorities have
&gt; upgraded, but not these 2 ...

Answer one: they're running 0.2.0.25-rc-dev (r14599), which is a
snapshot from the 0.2.0.x branch from right before we committed the
version bump.

Answer two: moria2 isn't a v3 directory authority (though it is a v1,
v2, and hidserv directory authority).

Answer three: questions like this should probably be on or-talk in the
future.

Hope that helps :),
--Roger

</body></email><email><emailId>20080529110314</emailId><senderName>M</senderName><senderEmail>maillist@piirakka.com</senderEmail><timestampReceived>2008-05-29 11:03:14-0400</timestampReceived><subject>Fingerprint is marked rejected</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Hi

My tor-node was affected by the Debian ssl-bug. I followed the
instructions at
http://archives.seul.org/or/announce/May-2008/msg00000.html and deleted
(moved them to other directory) /var/lib/tor/keys/secret_* and restared
tor-server.

After that following lines were appearing in the logs:

May 29 13:08:11.103 [warn] http status 400 ("Fingerprint is marked
rejected") response from dirserver '86.59.21.38:80'. Please correct.

May 29 13:08:11.277 [warn] http status 400 ("Fingerprint is marked
rejected") response from dirserver '88.198.7.215:80'. Please correct.

I tried to google the error but all I got was some dirservers sourcecode
and pathches that contained the following error.

Any ideas to fix this?

M


-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFIPo1yeaKwdrf2V0oRAvZbAJ0Qud5y+fpCUoozk6TnLKkyUrxdYwCggdLx
2XvMzrgWX73KQWlHLgfIbDY=
=76Ts
-----END PGP SIGNATURE-----
</body></email><email><emailId>20080519195631</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-05-19 19:56:31-0400</timestampReceived><subject>Draft schedule for Tor 0.2.1.x.</subject><body>

Hi, folks!

It's time to start talking more about what goes into the next release
of Tor, the 0.2.1.x series.  I think this release's development will
go much more smoothly if we have rough time windows in mind for when
parts of its development need to be done.

These are all rough targets.  We can bend them if we have a big reason
to do so, such as fixing a big security problem or interoperating
right with an important external project.  On the other hand, we
shouldn't bend them unless we're willing to risk delaying the release
by doing so.  I've tried to include rationales inline.

Here are the rough dates for the next release:

==============================
June 30: PROPOSAL CUTOFF.

All feature proposals for consideration should be in and discussed
before this date.  In the meantime, we should already be implementing
accepted proposals.  Note also the "and discussed": complex proposals
received on June 29 are unlikely to be adequately discussed by June
30.

Trivial proposals might be accepted after this date, if they are
indeed trivial.

July 15: ARCHITECTURE FREEZE.

No major architectural changes should get made to Tor after this date.
[I'm leaving "major architectural change" deliberately underdefined.
It would definitely include switching how we use libevent buffers, or
making big changes to our threading model.]

August 15: FEATURE FREEZE.

No new features should be added after this date.  This is when we
should move to pure testing and bugfixing.

September 15: FIRST RELEASE CANDIDATE

If we've not pushed the other deadlines too hard, we should be ready
for release by now.
==============================

Note that the important thing to do now is to improve and discuss
feature proposals, and write new ones.

yrs,
-- 
Nick Mathewson
</body></email><email><emailId>20080519221944</emailId><senderName>"Kyle Williams"</senderName><senderEmail>kyle.kwilliams@gmail.com</senderEmail><timestampReceived>2008-05-19 22:19:44-0400</timestampReceived><subject>Re: Draft schedule for Tor 0.2.1.x.</subject><body>

Nick,

I have a suggestion.  Automatic updates.
Here is my reason as to why I feel this is probably the most important
feature you need to implement.
"
Mar 31 2008 08:27:52.240 [notice] Tor 0.1.2.9-rc opening new log file.
....
"
That wasn't my tor log, but someone else.  There are still clients out there
that are still affected from the POC last year, EVEN after they updated to
the new version. Check your torrc files folks.

Looking back on Defcon last year, wouldn't it have been nice to be able to
issue an update and know that most of the users would have been updated
within 24-48 hours?  Look at the OpenSSL screwup from last week, wouldn't
that have been nice to be able to issue an update then too (even though it
wasn't your fault)?

I know that you and Roger don't like the in your face approach, but I still
feel that security vulnerabilities/updates need to be brought to the users
attention by displaying big, obvious, in your face alerts about problems.
E-mail sometimes isn't fast enough.  And simply making a notice or warning
of it in the log file doesn't cut it.   You wouldn't want to scare the user
by telling them there is a problem with no solution, so having a big
"Upgrade Now" button in the security alert window would be nice.

You never know what tomorrow brings, and how the face of security could
change in the blink of an eye.  ;-)

Best regards,
Kyle

On Mon, May 19, 2008 at 12:56 PM, Nick Mathewson &lt;nickm@freehaven.net&gt;
wrote:

&gt; Hi, folks!
&gt;
&gt; It's time to start talking more about what goes into the next release
&gt; of Tor, the 0.2.1.x series.  I think this release's development will
&gt; go much more smoothly if we have rough time windows in mind for when
&gt; parts of its development need to be done.
&gt;
&gt; These are all rough targets.  We can bend them if we have a big reason
&gt; to do so, such as fixing a big security problem or interoperating
&gt; right with an important external project.  On the other hand, we
&gt; shouldn't bend them unless we're willing to risk delaying the release
&gt; by doing so.  I've tried to include rationales inline.
&gt;
&gt; Here are the rough dates for the next release:
&gt;
&gt; ==============================
&gt; June 30: PROPOSAL CUTOFF.
&gt;
&gt; All feature proposals for consideration should be in and discussed
&gt; before this date.  In the meantime, we should already be implementing
&gt; accepted proposals.  Note also the "and discussed": complex proposals
&gt; received on June 29 are unlikely to be adequately discussed by June
&gt; 30.
&gt;
&gt; Trivial proposals might be accepted after this date, if they are
&gt; indeed trivial.
&gt;
&gt; July 15: ARCHITECTURE FREEZE.
&gt;
&gt; No major architectural changes should get made to Tor after this date.
&gt; [I'm leaving "major architectural change" deliberately underdefined.
&gt; It would definitely include switching how we use libevent buffers, or
&gt; making big changes to our threading model.]
&gt;
&gt; August 15: FEATURE FREEZE.
&gt;
&gt; No new features should be added after this date.  This is when we
&gt; should move to pure testing and bugfixing.
&gt;
&gt; September 15: FIRST RELEASE CANDIDATE
&gt;
&gt; If we've not pushed the other deadlines too hard, we should be ready
&gt; for release by now.
&gt; ==============================
&gt;
&gt; Note that the important thing to do now is to improve and discuss
&gt; feature proposals, and write new ones.
&gt;
&gt; yrs,
&gt; --
&gt; Nick Mathewson
&gt;

[Attachment #3 (text/html)]

Nick,&lt;br&gt;&lt;br&gt;I have a suggestion.  Automatic updates.  &lt;br&gt;Here is my \
reason as to why I feel this is probably the most important feature you need to \
implement.&lt;br&gt;"&lt;br&gt;Mar 31 2008 08:27:52.240 [notice] Tor 0.1.2.9-rc opening new \
log file.&lt;br&gt;

....&lt;br&gt;"&lt;br&gt;That wasn't my tor log, but someone else.  There are still \
clients out there that are still affected from the POC last year, EVEN after they \
updated to the new version. Check your torrc files folks.&lt;br&gt;

&lt;br&gt;Looking back on Defcon last year, wouldn't it have been nice to be able to \
issue an update and know that most of the users would have been updated within 24-48 \
hours?  Look at the OpenSSL screwup from last week, wouldn't that have been \
nice to be able to issue an update then too (even though it wasn't your \
fault)?&lt;br&gt;

&lt;br&gt;I know that you and Roger don't like the in your face approach, but I still \
feel that security vulnerabilities/updates need to be brought to the users attention \
by displaying big, obvious, in your face alerts about problems.  E-mail \
sometimes isn't fast enough.  And simply making a notice or warning of it in \
the log file doesn't cut it.   You wouldn't want to scare the user \
by telling them there is a problem with no solution, so having a big "Upgrade \
Now" button in the security alert window would be nice.&lt;br&gt;

&lt;br&gt;You never know what tomorrow brings, and how the face of security could change in \
the blink of an eye.  ;-)&lt;br&gt;&lt;br&gt;Best regards,&lt;br&gt;Kyle&lt;br&gt;&lt;br&gt;&lt;div \
class="gmail_quote"&gt;On Mon, May 19, 2008 at 12:56 PM, Nick Mathewson &lt;&lt;a \
href="mailto:nickm@freehaven.net" target="_blank"&gt;nickm@freehaven.net&lt;/a&gt;&gt; \
wrote:&lt;br&gt; &lt;blockquote class="gmail_quote" style="border-left: 1px solid rgb(204, \
204, 204); margin: 0pt 0pt 0pt 0.8ex; padding-left: 1ex;"&gt; Hi, folks!&lt;br&gt;
&lt;br&gt;
It's time to start talking more about what goes into the next release&lt;br&gt;
of Tor, the 0.2.1.x series.  I think this release's development will&lt;br&gt;
go much more smoothly if we have rough time windows in mind for when&lt;br&gt;
parts of its development need to be done.&lt;br&gt;
&lt;br&gt;
These are all rough targets.  We can bend them if we have a big reason&lt;br&gt;
to do so, such as fixing a big security problem or interoperating&lt;br&gt;
right with an important external project.  On the other hand, we&lt;br&gt;
shouldn't bend them unless we're willing to risk delaying the release&lt;br&gt;
by doing so.  I've tried to include rationales inline.&lt;br&gt;
&lt;br&gt;
Here are the rough dates for the next release:&lt;br&gt;
&lt;br&gt;
==============================&lt;br&gt;
June 30: PROPOSAL CUTOFF.&lt;br&gt;
&lt;br&gt;
All feature proposals for consideration should be in and discussed&lt;br&gt;
before this date.  In the meantime, we should already be implementing&lt;br&gt;
accepted proposals.  Note also the "and discussed": complex \
proposals&lt;br&gt; received on June 29 are unlikely to be adequately discussed by June&lt;br&gt;
30.&lt;br&gt;
&lt;br&gt;
Trivial proposals might be accepted after this date, if they are&lt;br&gt;
indeed trivial.&lt;br&gt;
&lt;br&gt;
July 15: ARCHITECTURE FREEZE.&lt;br&gt;
&lt;br&gt;
No major architectural changes should get made to Tor after this date.&lt;br&gt;
[I'm leaving "major architectural change" deliberately \
underdefined.&lt;br&gt; It would definitely include switching how we use libevent buffers, \
or&lt;br&gt; making big changes to our threading model.]&lt;br&gt;
&lt;br&gt;
August 15: FEATURE FREEZE.&lt;br&gt;
&lt;br&gt;
No new features should be added after this date.  This is when we&lt;br&gt;
should move to pure testing and bugfixing.&lt;br&gt;
&lt;br&gt;
September 15: FIRST RELEASE CANDIDATE&lt;br&gt;
&lt;br&gt;
If we've not pushed the other deadlines too hard, we should be ready&lt;br&gt;
for release by now.&lt;br&gt;
==============================&lt;br&gt;
&lt;br&gt;
Note that the important thing to do now is to improve and discuss&lt;br&gt;
feature proposals, and write new ones.&lt;br&gt;
&lt;br&gt;
yrs,&lt;br&gt;
--&lt;br&gt;
&lt;font color="#888888"&gt;Nick Mathewson&lt;br&gt;
&lt;/font&gt;&lt;/blockquote&gt;&lt;/div&gt;&lt;br&gt;



</body></email><email><emailId>20080529191653</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2008-05-29 19:16:53-0400</timestampReceived><subject>Re: Fingerprint is marked rejected</subject><body>

On Thu, May 29, 2008 at 02:03:14PM +0300, M wrote:
&gt; My tor-node was affected by the Debian ssl-bug. I followed the
&gt; instructions at
&gt; http://archives.seul.org/or/announce/May-2008/msg00000.html and deleted
&gt; (moved them to other directory) /var/lib/tor/keys/secret_* and restared
&gt; tor-server.
&gt; 
&gt; After that following lines were appearing in the logs:
&gt; 
&gt; May 29 13:08:11.103 [warn] http status 400 ("Fingerprint is marked
&gt; rejected") response from dirserver '86.59.21.38:80'. Please correct.
&gt; 
&gt; May 29 13:08:11.277 [warn] http status 400 ("Fingerprint is marked
&gt; rejected") response from dirserver '88.198.7.215:80'. Please correct.
&gt; 
&gt; I tried to google the error but all I got was some dirservers sourcecode
&gt; and pathches that contained the following error.
&gt; 
&gt; Any ideas to fix this?

It means that you are still using a weak key.

Perhaps you didn't actually upgrade your openssl?

Or perhaps you have more than one datadirectory, and you removed keys
from one but your Tor is using the other?

--Roger

</body></email><email><emailId>20080517165741</emailId><senderName>Wesley Kenzie</senderName><senderEmail>wkenzie@shaw.ca</senderEmail><timestampReceived>2008-05-17 16:57:41-0400</timestampReceived><subject>RE: moria1 and moria2 still on 0.2.0.25?</subject><body>


&gt; -----Original Message-----
&gt; From: owner-or-dev@freehaven.net 
&gt; [mailto:owner-or-dev@freehaven.net] On Behalf Of Roger Dingledine
&gt; Sent: May 17, 2008 1:11 AM
&gt; To: or-dev@freehaven.net
&gt; Subject: Re: moria1 and moria2 still on 0.2.0.25?
&gt; 
&gt; 
&gt; On Fri, May 16, 2008 at 05:21:47PM -0700, Wesley Kenzie wrote:
&gt; &gt; Why is it that 2 of the v3 directory authorities (moria1 
&gt; and moria2 at 
&gt; &gt; mit.edu running on the same IP address 128.31.0.34) are 
&gt; still running 
&gt; &gt; version 0.2.0.25?  I see that all the other 6 v3 directory 
&gt; authorities 
&gt; &gt; have upgraded, but not these 2 ...
&gt; 
&gt; Answer one: they're running 0.2.0.25-rc-dev (r14599), which 
&gt; is a snapshot from the 0.2.0.x branch from right before we 
&gt; committed the version bump.

Thanks for this clarification.

&gt; 
&gt; Answer two: moria2 isn't a v3 directory authority (though it 
&gt; is a v1, v2, and hidserv directory authority).
&gt; 

GETINFO ns/name/moria2 shows the following:
r moria2 cZvkXeIktgfFNwfQ4hQ+LUI+dM8 HyFqGCieCCKJvznJ2/Y03Clqu9E 2008-05-17
07:53:20 128.31.0.34 9002 9032
s Authority Fast HSDir Named Running Stable V2Dir Valid

So where and how can I determine that moria2 is not a v3 directory
authority?

&gt; Answer three: questions like this should probably be on 
&gt; or-talk in the future.
&gt; 

Sorry for my misunderstanding, but this seems clearly like a
developer-related question/issue.

Wesley


&gt; Hope that helps :),
&gt; --Roger
&gt; 
&gt; 


</body></email><email><emailId>20080524031450</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2008-05-24 03:14:50-0400</timestampReceived><subject>Re: moria1 and moria2 still on 0.2.0.25?</subject><body>

On Sat, May 17, 2008 at 09:57:41AM -0700, Wesley Kenzie wrote:
&gt; &gt; Answer two: moria2 isn't a v3 directory authority (though it 
&gt; &gt; is a v1, v2, and hidserv directory authority).
&gt; 
&gt; GETINFO ns/name/moria2 shows the following:
&gt; r moria2 cZvkXeIktgfFNwfQ4hQ+LUI+dM8 HyFqGCieCCKJvznJ2/Y03Clqu9E 2008-05-17
&gt; 07:53:20 128.31.0.34 9002 9032
&gt; s Authority Fast HSDir Named Running Stable V2Dir Valid
&gt; 
&gt; So where and how can I determine that moria2 is not a v3 directory
&gt; authority?

Take a look at add_default_trusted_dir_authorities() in src/or/config.c

I wonder if we should make a way to do it that doesn't require looking
at the code. Would a "tor --list-authorities" help perhaps? Nick/others,
any better suggestions (preferably ones that don't involve trying to
maintain another file in sync with the code)?

&gt; &gt; Answer three: questions like this should probably be on 
&gt; &gt; or-talk in the future.
&gt; 
&gt; Sorry for my misunderstanding, but this seems clearly like a
&gt; developer-related question/issue.

Ah, true, but it wasn't develop*ment*-related. Everybody on or-talk
wants the developers to answer their question, but that doesn't mean
they should all move to or-dev. :)

--Roger

</body></email><email><emailId>20080520171624</emailId><senderName>"Kyle Williams"</senderName><senderEmail>kyle.kwilliams@gmail.com</senderEmail><timestampReceived>2008-05-20 17:16:24-0400</timestampReceived><subject>Re: Auto-Update -Feature - Was: Draft schedule for Tor 0.2.1.x.</subject><body>

Hello Marcus,

Sorry for not making this more clear.  Thank you for bringing up that point,
which I will address in a moment.

I was referring to the 200,000+ users that are using Tor as a client.  Most
of the users are using Tor on a desktop or laptop.
I would put this 'in your face' alert on the shoulders of Vidalia, since
it's what most people use to control Tor.

So, back to the head-less server sitting in a data center.  Tor already has
a recommended versions that is sent out by the Directory Authorities.
Perhaps a LATEST_STABLE parameter could be sent out, and upon receiving an
update for LATEST_STABLE, one's own Tor instance could automatically update
itself.  Which brings us to the next question, how do we make this
controllable by the operator.  I purpose a AutoUpdate flag in the torrc.

AutoUpdate 1  means update to the LATEST_STABLE
AutoUpdate 0  means don't automatically update to LATEST_STABLE

Which one should be the default?  I bet there would be a lot of debate about
this.  I say AutoUpdate 1 should be the default.

Both options would of course create the appropriate logs messages in Tor's
log.
I'm sure there are a couple of technical aspect's of this I haven't
considered yet, but the general idea isn't a new one and has been done
before with lots of software products available today.

- Kyle


On Mon, May 19, 2008 at 10:50 PM, Marcus Wolschon &lt;marcus@wolschon.biz&gt;
wrote:

&gt; -----BEGIN PGP SIGNED MESSAGE-----
&gt; Hash: SHA1
&gt;
&gt;
&gt;
&gt; Hello Kyle,
&gt;
&gt; so what is your proposal exactly?
&gt; How do you suppose a background-service
&gt; on a very possibly headless and unattended
&gt; machine in a data-center should issue such
&gt; a message to the administrator?
&gt;
&gt; Marcus
&gt;
&gt; Kyle Williams schrieb:
&gt; | Nick,
&gt; |
&gt; | I have a suggestion.  Automatic updates.
&gt; | Here is my reason as to why I feel this is probably the most important
&gt; | feature you need to implement.
&gt; -----BEGIN PGP SIGNATURE-----
&gt; Version: GnuPG v1.4.6 (GNU/Linux)
&gt; Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org
&gt;
&gt; iD8DBQFIMmazf1hPnk3Z0cQRAvCVAKCIB6B3m/UmQfg0liObSLElA0uBDgCg1fJe
&gt; M6e6o7CzN1oxPBEEUM2cXak=
&gt; =lkkw
&gt; -----END PGP SIGNATURE-----
&gt;

[Attachment #3 (text/html)]

Hello Marcus,&lt;br&gt;&lt;br&gt;Sorry for not making this more clear.  Thank you for \
bringing up that point, which I will address in a moment.&lt;br&gt;&lt;br&gt;I was referring to \
the 200,000+ users that are using Tor as a client.  Most of the users are using \
Tor on a desktop or laptop.&lt;br&gt; I would put this 'in your face' alert on the \
shoulders of Vidalia, since it's what most people use to control Tor.&lt;br&gt;&lt;br&gt;So, \
back to the head-less server sitting in a data center.  Tor already has a \
recommended versions that is sent out by the Directory Authorities.  &lt;br&gt; \
Perhaps a LATEST_STABLE parameter could be sent out, and upon receiving an update for \
LATEST_STABLE, one's own Tor instance could automatically update itself.  \
Which brings us to the next question, how do we make this controllable by the \
operator.  I purpose a AutoUpdate flag in the torrc.  &lt;br&gt; &lt;br&gt;AutoUpdate \
1  means update to the LATEST_STABLE&lt;br&gt;AutoUpdate 0  means don't \
automatically update to LATEST_STABLE&lt;br&gt;&lt;br&gt;Which one should be the default?  I \
bet there would be a lot of debate about this.  I say AutoUpdate 1 should be the \
default.&lt;br&gt; &lt;br&gt;Both options would of course create the appropriate logs messages in \
Tor's log.&lt;br&gt;I'm sure there are a couple of technical aspect's of this I \
haven't considered yet, but the general idea isn't a new one and has been \
done before with lots of software products available today.&lt;br&gt; &lt;br&gt;- \
Kyle&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;div class="gmail_quote"&gt;On Mon, May 19, 2008 at 10:50 PM, Marcus \
Wolschon &lt;&lt;a href="mailto:marcus@wolschon.biz"&gt;marcus@wolschon.biz&lt;/a&gt;&gt; \
wrote:&lt;br&gt;&lt;blockquote class="gmail_quote" style="border-left: 1px solid rgb(204, 204, \
                204); margin: 0pt 0pt 0pt 0.8ex; padding-left: 1ex;"&gt;
-----BEGIN PGP SIGNED MESSAGE-----&lt;br&gt;
Hash: SHA1&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
Hello Kyle,&lt;br&gt;
&lt;br&gt;
so what is your proposal exactly?&lt;br&gt;
How do you suppose a background-service&lt;br&gt;
on a very possibly headless and unattended&lt;br&gt;
machine in a data-center should issue such&lt;br&gt;
a message to the administrator?&lt;br&gt;
&lt;br&gt;
Marcus&lt;br&gt;
&lt;br&gt;
Kyle Williams schrieb:&lt;br&gt;
&gt; Nick,&lt;br&gt;
&gt; &lt;br&gt;
&gt; I have a suggestion.  Automatic updates.&lt;br&gt;
&gt; Here is my reason as to why I feel this is probably the most important&lt;br&gt;
&gt; feature you need to implement.&lt;br&gt;
-----BEGIN PGP SIGNATURE-----&lt;br&gt;
Version: GnuPG v1.4.6 (GNU/Linux)&lt;br&gt;
Comment: Using GnuPG with Mozilla - &lt;a href="http://enigmail.mozdev.org" \
target="_blank"&gt;http://enigmail.mozdev.org&lt;/a&gt;&lt;br&gt; &lt;br&gt;
iD8DBQFIMmazf1hPnk3Z0cQRAvCVAKCIB6B3m/UmQfg0liObSLElA0uBDgCg1fJe&lt;br&gt;
M6e6o7CzN1oxPBEEUM2cXak=&lt;br&gt;
=lkkw&lt;br&gt;
-----END PGP SIGNATURE-----&lt;br&gt;
&lt;/blockquote&gt;&lt;/div&gt;&lt;br&gt;



</body></email><email><emailId>20080508002123</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-05-08 00:21:23-0400</timestampReceived><subject>Re: ExitNodes config use fingerprint rather than nickname</subject><body>

On Wed, May 07, 2008 at 02:54:19PM -0700, Wesley Kenzie wrote:
&gt; I am considering trying my hand at a patch to allow fingerprints to be used
&gt; in place of nicknames for ExitNodes and EntryNodes config variables.  (There
&gt; are quite a few duplicate nicknames floating around which are not
&gt; immediately obvious. I added a list of them yesterday to
&gt; http://www.pickaproxy.com/?speak=tor so they can be easily identified.)  The
&gt; problem currently is that duplicate nicknames cannot be used as specified
&gt; exit or entry nodes.

This feature already exists.  Just stick a $ before the fingerprint,
as in:

EntryNodes $70A08C76BCB9ADE55907029B83DB6891957AC92C

If you want to force a given name binding, you can use the format
  $70A08C76BCB9ADE55907029B83DB6891957AC92C=peacetime
to only match a "Named" server with the given nickname and key, or
  $70A08C76BCB9ADE55907029B83DB6891957AC92C~peacetime
to match any server with the given nickname and key.

This feature could be better documented, though, and I'd love to get a
documentation patch to explain all of this better. :)

yrs,
-- 
Nick



</body></email><email><emailId>20080508201328</emailId><senderName>Wesley Kenzie</senderName><senderEmail>wkenzie@shaw.ca</senderEmail><timestampReceived>2008-05-08 20:13:28-0400</timestampReceived><subject>RE: ExitNodes config use fingerprint rather than nickname</subject><body>

&gt; -----Original Message-----
&gt; From: owner-or-dev@freehaven.net 
&gt; [mailto:owner-or-dev@freehaven.net] On Behalf Of Nick Mathewson
&gt; Sent: May 7, 2008 5:21 PM
&gt; To: or-dev@freehaven.net
&gt; Subject: Re: ExitNodes config use fingerprint rather than nickname
&gt; 
&gt; 
&gt; On Wed, May 07, 2008 at 02:54:19PM -0700, Wesley Kenzie wrote:
&gt; &gt; I am considering trying my hand at a patch to allow 
&gt; fingerprints to be 
&gt; &gt; used in place of nicknames for ExitNodes and EntryNodes config 
&gt; &gt; variables.  (There are quite a few duplicate nicknames 
&gt; floating around 
&gt; &gt; which are not immediately obvious. I added a list of them 
&gt; yesterday to 
&gt; &gt; http://www.pickaproxy.com/?speak=tor so they can be easily 
&gt; &gt; identified.)  The problem currently is that duplicate 
&gt; nicknames cannot 
&gt; &gt; be used as specified exit or entry nodes.
&gt; 
&gt; This feature already exists.  Just stick a $ before the 
&gt; fingerprint, as in:
&gt; 
&gt; EntryNodes $70A08C76BCB9ADE55907029B83DB6891957AC92C
&gt; 
&gt; If you want to force a given name binding, you can use the format
&gt;   $70A08C76BCB9ADE55907029B83DB6891957AC92C=peacetime
&gt; to only match a "Named" server with the given nickname and key, or
&gt;   $70A08C76BCB9ADE55907029B83DB6891957AC92C~peacetime
&gt; to match any server with the given nickname and key.
&gt; 
&gt; This feature could be better documented, though, and I'd love 
&gt; to get a documentation patch to explain all of this better. :)
&gt; 

Sounds good, Nick.  Unfortunately I have not been able to get any of the 3
formats to work.  I'm using 0.2.0.25-rc (r14442) and specifying --ExitNodes
on the command line.  The [warn] message "Failed to parse/validate config:
Invalid nickname '529436598DEE2E3AAA07490A563451934591373~Unnamed' in
ExitNodes line" also incorrectly identifies the fingerprint.  The first
character is being chopped off.  In this case there should be a '8' at the
beginning of that fingerprint.

Another example: "[warn] Failed to parse/validate config: Invalid nickname
'6CF4871F49A7A5494543FFF39B167481EBFE7FB~Torzurweitenwelt' in ExitNodes
line".  There should be a '9' in the first position of that nickname.

I'm afraid a patch for this is beyond my current capabilities, but I would
be glad to assist in any way.

Wesley


</body></email><email><emailId>20080508204647</emailId><senderName>Sebastian Hahn</senderName><senderEmail>hahn.seb@web.de</senderEmail><timestampReceived>2008-05-08 20:46:47-0400</timestampReceived><subject>Re: ExitNodes config use fingerprint rather than nickname</subject><body>


On May 8, 2008, at 10:13 PM, Wesley Kenzie wrote:
&gt; Sounds good, Nick.  Unfortunately I have not been able to get any of  
&gt; the 3
&gt; formats to work.  I'm using 0.2.0.25-rc (r14442) and specifying -- 
&gt; ExitNodes
&gt; on the command line.  The [warn] message "Failed to parse/validate  
&gt; config:
&gt; Invalid nickname '529436598DEE2E3AAA07490A563451934591373~Unnamed' in
&gt; ExitNodes line" also incorrectly identifies the fingerprint.  The  
&gt; first
&gt; character is being chopped off.  In this case there should be a '8'  
&gt; at the
&gt; beginning of that fingerprint.

That is expected behaviour on the command line. the $ is interpreted  
to start a variable, thus the next character is also eaten. Try (on  
the command line) to put
\$8 529436598DEE2E3AAA07490A563451934591373~Unnamed and it should  
work, I think.

&gt; I'm afraid a patch for this is beyond my current capabilities, but I  
&gt; would
&gt; be glad to assist in any way.
&gt;
&gt; Wesley

I hope that helps

Sebastian

["PGP.sig" (application/pgp-signature)]

</body></email><email><emailId>20080509045259</emailId><senderName>Wesley Kenzie</senderName><senderEmail>wkenzie@shaw.ca</senderEmail><timestampReceived>2008-05-09 04:52:59-0400</timestampReceived><subject>RE: ExitNodes config use fingerprint rather than nickname</subject><body>

&gt; On May 8, 2008, at 10:13 PM, Wesley Kenzie wrote:
&gt; &gt; Sounds good, Nick.  Unfortunately I have not been able to get any of
&gt; &gt; the 3
&gt; &gt; formats to work.  I'm using 0.2.0.25-rc (r14442) and specifying -- 
&gt; &gt; ExitNodes
&gt; &gt; on the command line.  The [warn] message "Failed to parse/validate  
&gt; &gt; config:
&gt; &gt; Invalid nickname 
&gt; '529436598DEE2E3AAA07490A563451934591373~Unnamed' in
&gt; &gt; ExitNodes line" also incorrectly identifies the fingerprint.  The  
&gt; &gt; first
&gt; &gt; character is being chopped off.  In this case there should 
&gt; be a '8'  
&gt; &gt; at the
&gt; &gt; beginning of that fingerprint.
&gt; 
&gt; That is expected behaviour on the command line. the $ is interpreted  
&gt; to start a variable, thus the next character is also eaten. Try (on  
&gt; the command line) to put
&gt; \$8 529436598DEE2E3AAA07490A563451934591373~Unnamed and it should  
&gt; work, I think.
&gt; 
&gt; &gt; I'm afraid a patch for this is beyond my current capabilities, but I
&gt; &gt; would
&gt; &gt; be glad to assist in any way.
&gt; &gt;
&gt; &gt; Wesley
&gt; 
&gt; I hope that helps
&gt; 
&gt; Sebastian

It sure did!  Thanks muchly, Sebastian.

Wesley


</body></email><email><emailId>20080401160235</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-04-01 16:02:35-0400</timestampReceived><subject>Re: Proposal: More robust consensus voting with diverse authority sets</subject><body>

On Tue, Apr 01, 2008 at 05:02:13PM +0200, Peter Palfrader wrote:
&gt; Filename: xxx-robust-voting.txt

Added as proposal 134.

&gt; Objective:
&gt; 
&gt;   The modified voting procedure outlined in this proposal obsoletes the
&gt;   requirement for most authorities to exactly agree on the list of
&gt;   authorities.

I like this objective.  I've tried to achieve it with earlier designs,
but ran into a couple of brick walls.

[...] 
&gt;   It is necessary to continue with the process in (5) even if we
&gt;   are not in the largest subgraph.  Otherwise one rogue authority
&gt;   could create a number of extra votes (by new authorities) so that
&gt;   everybody stops at 5 and no consensus is built, even tho it would
&gt;   be trusted by all clients.

This is the first attack I thought of; glad you thought of it too. :)

&gt; Possible Attacks/Open Issues/Some thinking required:
&gt; 
&gt;  Q: Can a number (less or exactly half) of the authorities cause an honest
&gt;     authority to vote for "their" consensus rather than the one that would
&gt;     result were all authorities taken into account?

This algorithm is graph-theory-ish enough that we should be able to
say something mathematically strong here.

I have a few more open issues:

  Q: What does this do for cacheing?  Currently, there is at most once
     live consensus at a time, and caches cache that.  What do caches
     do if there are multiple consensuses?  Do they act as clients do
     now, and only accept a consensus if it is signed by a majority of
     the authorities they recognize?  If so, will this ever lead to
     caches holding documents clients don't want, or repeatedly
     bugging the authorities for a consensus they don't have?  If so,
     what can be done?

  Q: How do we do this in a backward compatible way?  There should be
     a spec for that too.

  A less technical Q: What opportunities does this create for social
     attacks?  One of the reasons for choosing the current voting
     approach was to limit the incentives for a social attacker to
     attempt to peel off authorities by convincing only some of them
     to accept a slightly looking bogus authority.  There have been
     similar attacks in the remailer world, I believe.  How can we
     make this less likely?

yrs,
-- 
Nick

</body></email><email><emailId>20080402085834</emailId><senderName>Peter Palfrader</senderName><senderEmail>peter@palfrader.org</senderEmail><timestampReceived>2008-04-02 08:58:34-0400</timestampReceived><subject>Re: Proposal: More robust consensus voting with diverse authority sets</subject><body>

For those reading along at home, such fully connected subgraphs as
written about in the procedure are called cliques.
See http://en.wikipedia.org/wiki/Clique_problem for a short overview.
Finding the maximum clique is an NP hard problem, but it might just
scale to up to our 20 nodes.  There is literature on how to solve it,
for instance Steven Murdoch found "An Exact Parallel Algorithm For The
Maximum Clique Problem" by  Panos M. Pardalos, Jonas Rappe, Mauricio
G.C. Resende - &lt;URL:http://citeseer.ist.psu.edu/pardalos98exact.html&gt;.


Also, it's easy to reduce our directed graph to an undirected graph.  An
edge in the new, undirected graph exists between nodes A and B iff there
is an edge from A to B and an edge from B to A in the undirected graph.
Doing the clique finding dance on that simplified graph should yield the
same result as doing it on the original one.

On Tue, 01 Apr 2008, Nick Mathewson wrote:

&gt;   Q: What does this do for cacheing?  Currently, there is at most once
&gt;      live consensus at a time, and caches cache that.  What do caches
&gt;      do if there are multiple consensuses?  Do they act as clients do
&gt;      now, and only accept a consensus if it is signed by a majority of
&gt;      the authorities they recognize?  If so, will this ever lead to
&gt;      caches holding documents clients don't want, or repeatedly
&gt;      bugging the authorities for a consensus they don't have?  If so,
&gt;      what can be done?

I think that caches should only cache one consensus, and it should be
one they trust.  As long as each authority only ever signs one consensus
document at a time where will at most be one such consensus.

Also, maybe the procedure in the proposal should be changed slightly to
add one more point:  No authority signs a consensus that it itself
wouldn't trust - i.e. if the clique it is in is not larger than the
number of authorities it recognizes (including itself) then it bails
out and doesn't create any consensus this round.

This results in having fewer useless consensus documents that caches
need to fetch only to learn that - with all likelyhood - they will not
trust it either.


&gt;   Q: How do we do this in a backward compatible way?  There should be
&gt;      a spec for that too.

I didn't look into this yet, since we first should figure out what we
want it to do.  Then I guess we do the same thing we did when we
introduced Unnamed, i.e. add a new consensus method (#3) that we
advertise as supporting.

I would assume - I haven't checked the spec or code - that once half of
the authorities advertise consensus method 3 this is the one they'll
use?  In which case they better be able to build a consensus but we're
no worse off than we were before when adding a new authority.  We just
need this last coordinated round of upgrades.


&gt;   A less technical Q: What opportunities does this create for social
&gt;      attacks?  One of the reasons for choosing the current voting
&gt;      approach was to limit the incentives for a social attacker to
&gt;      attempt to peel off authorities by convincing only some of them
&gt;      to accept a slightly looking bogus authority.  There have been
&gt;      similar attacks in the remailer world, I believe.  How can we
&gt;      make this less likely?

I do not have an answer here, other than only make clueful people
directory authorities.

Peter

</body></email><email><emailId>20080402123328</emailId><senderName>"Nikita Borisov"</senderName><senderEmail>nikita@uiuc.edu</senderEmail><timestampReceived>2008-04-02 12:33:28-0400</timestampReceived><subject>Re: Proposal: More robust consensus voting with diverse authority sets</subject><body>

On Wed, Apr 2, 2008 at 3:58 AM, Peter Palfrader &lt;peter@palfrader.org&gt; wrote:
&gt; For those reading along at home, such fully connected subgraphs as
&gt;  written about in the procedure are called cliques.
&gt;  See http://en.wikipedia.org/wiki/Clique_problem for a short overview.
&gt;  Finding the maximum clique is an NP hard problem, but it might just
&gt;  scale to up to our 20 nodes.  There is literature on how to solve it,
&gt;  for instance Steven Murdoch found "An Exact Parallel Algorithm For The
&gt;  Maximum Clique Problem" by  Panos M. Pardalos, Jonas Rappe, Mauricio
&gt;  G.C. Resende - &lt;URL:http://citeseer.ist.psu.edu/pardalos98exact.html&gt;.

I've built a max-clique implementation before, and it worked well for
social network graphs on the order of 100, so 20 should be no problem
at all.

- Nikita
-- 
Nikita Borisov - http://www.crhc.uiuc.edu/~nikita/
Assistant Professor, Electrical and Computer Engineering
Tel: (217) 244-5385, Office: 460 CSL

</body></email><email><emailId>20080402161940</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-04-02 16:19:40-0400</timestampReceived><subject>Re: Proposal: More robust consensus voting with diverse authority sets</subject><body>

On Wed, Apr 02, 2008 at 10:58:34AM +0200, Peter Palfrader wrote:
 [...]
&gt; On Tue, 01 Apr 2008, Nick Mathewson wrote:
&gt; 
&gt; &gt;   Q: What does this do for cacheing?  Currently, there is at most once
&gt; &gt;      live consensus at a time, and caches cache that.  What do caches
&gt; &gt;      do if there are multiple consensuses?  Do they act as clients do
&gt; &gt;      now, and only accept a consensus if it is signed by a majority of
&gt; &gt;      the authorities they recognize?  If so, will this ever lead to
&gt; &gt;      caches holding documents clients don't want, or repeatedly
&gt; &gt;      bugging the authorities for a consensus they don't have?  If so,
&gt; &gt;      what can be done?
&gt; 
&gt; I think that caches should only cache one consensus, and it should be
&gt; one they trust.  As long as each authority only ever signs one consensus
&gt; document at a time where will at most be one such consensus.
&gt; 
&gt; Also, maybe the procedure in the proposal should be changed slightly to
&gt; add one more point:  No authority signs a consensus that it itself
&gt; wouldn't trust - i.e. if the clique it is in is not larger than the
&gt; number of authorities it recognizes (including itself) then it bails
&gt; out and doesn't create any consensus this round.

This is a good idea, I think.

&gt; This results in having fewer useless consensus documents that caches
&gt; need to fetch only to learn that - with all likelyhood - they will not
&gt; trust it either.

Hm.  I'm still not at all fond of the failure mode where a client
downloads a consensus, decides it doesn't like it, and downloads
another and another ad infinitum.  This seems like a potential
problem: the network would run find for a while until one day the set
of authorities signing the dominant consensus was not one that older
clients liked... and then, those clients would start eating bandwidth.
I agree that this would happen only rarely, but it has potential to be
quite nasty when it _does_ happen.  Perhaps we could add a URL format
in order to request a consensus only if it's endorsed by certain
authorities?
 
&gt; &gt;   Q: How do we do this in a backward compatible way?  There should be
&gt; &gt;      a spec for that too.
&gt; 
&gt; I didn't look into this yet, since we first should figure out what we
&gt; want it to do.  Then I guess we do the same thing we did when we
&gt; introduced Unnamed, i.e. add a new consensus method (#3) that we
&gt; advertise as supporting.
&gt; 
&gt; I would assume - I haven't checked the spec or code - that once half of
&gt; the authorities advertise consensus method 3 this is the one they'll
&gt; use?  In which case they better be able to build a consensus but we're
&gt; no worse off than we were before when adding a new authority.  We just
&gt; need this last coordinated round of upgrades.

The 'consensus method' thing is only meant to determine which
algorithm the voting authorities use to produce the consensus from the
votes, not which authorities' votes count.  We should take a close
look at the spec and implementation for it to make sure it can be
extended this way.

&gt; &gt;   A less technical Q: What opportunities does this create for social
&gt; &gt;      attacks?  One of the reasons for choosing the current voting
&gt; &gt;      approach was to limit the incentives for a social attacker to
&gt; &gt;      attempt to peel off authorities by convincing only some of them
&gt; &gt;      to accept a slightly looking bogus authority.  There have been
&gt; &gt;      similar attacks in the remailer world, I believe.  How can we
&gt; &gt;      make this less likely?
&gt; 
&gt; I do not have an answer here, other than only make clueful people
&gt; directory authorities.

Yeah, I tend to believe this one.

Another question, based on our brief IRC conversation the other day:
There seems to be a goals/methods disconnect in this proposal.  Given
that the only application for this proposal is to be able to add or
remove authorities from the list without, it seems like overkill to
solve the more general problem of what do we do with an arbitrarily
screwed-up authority trust graph.  Is there a simpler approach that
does what we want, or do we really need to do the NP-hard thing?

yrs,
-- 
Nick Mathewson

</body></email><email><emailId>20080404214831</emailId><senderName>Peter Palfrader</senderName><senderEmail>peter@palfrader.org</senderEmail><timestampReceived>2008-04-04 21:48:31-0400</timestampReceived><subject>Re: Proposal: More robust consensus voting with diverse authority sets</subject><body>

On Wed, 02 Apr 2008, Nick Mathewson wrote:

&gt; &gt; This results in having fewer useless consensus documents that caches
&gt; &gt; need to fetch only to learn that - with all likelyhood - they will not
&gt; &gt; trust it either.
&gt; 
&gt; Hm.  I'm still not at all fond of the failure mode where a client
&gt; downloads a consensus, decides it doesn't like it, and downloads
&gt; another and another ad infinitum.
&gt;                                     Perhaps we could add a URL format
&gt; in order to request a consensus only if it's endorsed by certain
&gt; authorities?

That's a good idea, but it probably is quite independent of this
proposal.  i.e. we should switch to the fpr URL format whether we go
forward with this proposal or not.


&gt; Another question, based on our brief IRC conversation the other day:
&gt; There seems to be a goals/methods disconnect in this proposal.  Given
&gt; that the only application for this proposal is to be able to add or
&gt; remove authorities from the list without, it seems like overkill to
                               ... without forcing all authorities
                                      to make the change at once, it seems ...
&gt; solve the more general problem of what do we do with an arbitrarily
&gt; screwed-up authority trust graph.  Is there a simpler approach that
&gt; does what we want, or do we really need to do the NP-hard thing?

I admit that I did not pay any attention to computational complexity
when I came up with the procedure.

We might get away with something in Tor like "this authority is new, do
not included its votes in your consensus building before &lt;date&gt;", i.e.
basically making flag days for which authorities we trust in.

Peter
</body></email><email><emailId>20080429141408</emailId><senderName>Peter Palfrader</senderName><senderEmail>peter@palfrader.org</senderEmail><timestampReceived>2008-04-29 14:14:08-0400</timestampReceived><subject>Re: Proposal: More robust consensus voting with diverse authority sets</subject><body>

On Wed, 02 Apr 2008, Nick Mathewson wrote:

&gt;                                    Is there a simpler approach that
&gt; does what we want, or do we really need to do the NP-hard thing?

Did one occur to you yet?  If not, should we go forward with this
proposal?

Peter
</body></email><email><emailId>20080501185051</emailId><senderName>Peter Palfrader</senderName><senderEmail>peter@palfrader.org</senderEmail><timestampReceived>2008-05-01 18:50:51-0400</timestampReceived><subject>Re: Proposal: More robust consensus voting with diverse authority sets</subject><body>

On Tue, 29 Apr 2008, Nick Mathewson wrote:

&gt; So, afaik, the sole remaining big problem in this proposal is
&gt; migration.  IIUC, the current consensus-method thing won't work, for
&gt; reasons explained in an earlier message of mine on this thread:

The thing Nick came up with on IRC was to simply consider all votes
uploaded by authorities running the old software to have an implicit
| Recognizes-Authorites: &lt;current (as of now, May 2008) list of authorities&gt;
line.  They will behave like this is their clique, and upgraded
authorities will continue to think this is their clique until new
servers not trusted by the old folks outnumber those that haven't
upgraded.

This probably looks fine.


&gt; I decided that I'd eel better about the NP-hard thing if we codde up
&gt; the sample C implementation and found out that it scaled well to a
&gt; large number of authorities.

I have implemented this, with a tweak or two in C, and it all works fine
for up to 50 or 60 nodes but once we go towards 100 it all goes pear
shaped.  It _is_ a simple minded approach after all.
[ git clone http://asteria.noreply.org/~weasel/tor-trunk-maxclique.git
  see src/common/graph* and src/util/graph-bench.c ]


One more problem surfaced: This proposal opens up authorities for DoS
attacks by other authorities:

Remember that per the proposal all uploaded votes are accepted, but only
those reachable (directly or indirectly) from recognized authorities are
considered during the maxclique() run.  This gets rid of any muppetry
done by outsiders.

But if a fellow authority operator introduces a large set of other
authorities and recognizes them all or some of them then that can blow
up our graph to sizes we cannot manage.


While discussing this with Nick and Sebastian on IRC we came up with a
number of ideas, most of which don't work:

Bad idea 1: limit the number of authorities any authority is allowed to
   say it trusts.

   A malicous authority can still introduce any number of extra nodes.
   It only needs to list one of them, and they in turn only need to list
   a few and so on for all of them to end up in our graph.  Now our
   simple algorithm does not do particularly bad on sparse graphs but it
   is likly that a specially crafted graph could still make us spend
   ages on figuring out cliques.

Bad idea 3: only accept authorities in our graph when they are
   recognized by at least two other authorities.

   a) Going from "one authority can screw us over" to "two authorities
      can screw us" is not a huge gain.
   b) Why two?  why not three?  four?  five?

Bad idea 2: only try to find the largest clique that this authority (the
   one doing the computation) is in.

   This is not as obviously bad in my opinion as Nick originally
   suggested:

   Finding the maximum clique that I'm in is bounded by the amount of
   authorities I recognize and nobody can screw me with that.

   True, we no longer can guarantee that *all* authorities arrive at the
   same cliques, but does it matter?  I suppose that we will always
   have a sufficient number of authorities that agree they are in the
   same clique to form a working consensus.

   Some authorities will be left out in the cold if all the people who
   they think are in their clique went with a larger clique instead but
   then this authority doesn't succeed in building a consensus (too few
   sigs from other authories).

   (insert handwaving here, you don't need to see a proof).

   Nick, is there another reason why this idea is really bad, or is my
   handwaving above wrong?)


Peter
</body></email><email><emailId>20080502084241</emailId><senderName>Peter Palfrader</senderName><senderEmail>peter@palfrader.org</senderEmail><timestampReceived>2008-05-02 08:42:41-0400</timestampReceived><subject>Re: Proposal: More robust consensus voting with diverse authority sets</subject><body>

On Thu, 01 May 2008, Peter Palfrader wrote:

&gt; But if a fellow authority operator introduces a large set of other
&gt; authorities and recognizes them all or some of them then that can blow
&gt; up our graph to sizes we cannot manage.
&gt; 
&gt; 
&gt; While discussing this with Nick and Sebastian on IRC we came up with a
&gt; number of ideas, most of which don't work:
&gt; 
&gt; Bad idea 1: limit the number of authorities any authority is allowed to
&gt;    say it trusts.
&gt; 
&gt;    A malicous authority can still introduce any number of extra nodes.
&gt;    It only needs to list one of them, and they in turn only need to list
&gt;    a few and so on for all of them to end up in our graph.  Now our
&gt;    simple algorithm does not do particularly bad on sparse graphs but it
&gt;    is likly that a specially crafted graph could still make us spend
&gt;    ages on figuring out cliques.


Hah.  But we can use this.

First, realize that all we care about is how the authorities that are in
our cliques.  I.e. we only care how the authorities vote that we
recognize.  We only want to know if they are part of our voting clique
or not.

Then we no longer need to solve maxclique() over the entire graph, but
we only need to solve maxclique_that_has_point_A_in_it() with A being
each of the authorities we trust.

Now maxclique_that_has_point_P_in_it() in itself hard also*, however we
can make our live easier by limiting the number of authorities that one
may list.  If we discard votes with too many neighbors early we
effectively have created a reasonable upper bound for the amount of work
we have to do while clique finding.

weasel


(I still like the bad idea #2 from the previous post, but that's not as
easy to show as correct.)

* (if maxclique_that_has_point_P_in_it() was in P then I could just run
   it for each point A in the graph and use the largest clique I found
   as my answer for maxclique().)

</body></email><email><emailId>20080502122852</emailId><senderName>Paul Syverson</senderName><senderEmail>syverson@itd.nrl.navy.mil</senderEmail><timestampReceived>2008-05-02 12:28:52-0400</timestampReceived><subject>Re: Proposal: More robust consensus voting with diverse authority sets</subject><body>

On Fri, May 02, 2008 at 10:42:41AM +0200, Peter Palfrader wrote:
&gt; On Thu, 01 May 2008, Peter Palfrader wrote:
&gt; 
&gt; &gt; But if a fellow authority operator introduces a large set of other
&gt; &gt; authorities and recognizes them all or some of them then that can blow
&gt; &gt; up our graph to sizes we cannot manage.
&gt; &gt; 
&gt; &gt; 
&gt; &gt; While discussing this with Nick and Sebastian on IRC we came up with a
&gt; &gt; number of ideas, most of which don't work:
&gt; &gt; 
&gt; &gt; Bad idea 1: limit the number of authorities any authority is allowed to
&gt; &gt;    say it trusts.
&gt; &gt; 
&gt; &gt;    A malicous authority can still introduce any number of extra nodes.
&gt; &gt;    It only needs to list one of them, and they in turn only need to list
&gt; &gt;    a few and so on for all of them to end up in our graph.  Now our
&gt; &gt;    simple algorithm does not do particularly bad on sparse graphs but it
&gt; &gt;    is likly that a specially crafted graph could still make us spend
&gt; &gt;    ages on figuring out cliques.
&gt; 
&gt; 
&gt; Hah.  But we can use this.
&gt; 
&gt; First, realize that all we care about is how the authorities that are in
&gt; our cliques.  I.e. we only care how the authorities vote that we
&gt; recognize.  We only want to know if they are part of our voting clique
&gt; or not.
&gt; 
&gt; Then we no longer need to solve maxclique() over the entire graph, but
&gt; we only need to solve maxclique_that_has_point_A_in_it() with A being
&gt; each of the authorities we trust.
&gt; 

Sounds like you could use some max_flow/min_cut mechanism as in
advogato so that you are only counting votes proportional to the root
of trust. Unlike advogato you don't want to have just one root, since
that would defeat the purpose, but you could still have a mechanism
like this that is only going add nodes to the graph proportional to
trust of root authorities and you can't recursively add more as
described above out of proportion to the trust level. To add more root
authorities would need a separate external mechanism, which should be
easy to do as long as that is not intended to scale much at all.
Apologies if I am making an irrelevant or already considered and
rejected suggested by jumping into a conversation almost all of which
I have not observed.

aloha,
Paul
</body></email><email><emailId>20080530082324</emailId><senderName>M</senderName><senderEmail>maillist@piirakka.com</senderEmail><timestampReceived>2008-05-30 08:23:24-0400</timestampReceived><subject>Re: Fingerprint is marked rejected</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

&gt; It means that you are still using a weak key.
&gt; 
&gt; Perhaps you didn't actually upgrade your openssl?
&gt; 

Thanks, that was it. I forgot i run tor in chrooted enviroment that
contained old openssl-libraries. Fixed. Thanks a lot!

I've build a new chroot (in encrypted disk-image) which is easier to
maintain and upgrade but takes a lot more of diskspace. I installed
base-packages with Debians debootstrap. Now I don't need to compile
newest version from sources and I can upgrade libs etc. by running
apt-get in chrooted enviroment.

M

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFIP7l8eaKwdrf2V0oRAl2sAJ9fOHQ7PiKDyPpf+2IOPoXpGHvOsQCePKDT
U6Ez7W5CFEAuifTNfOh9xEo=
=BMUv
-----END PGP SIGNATURE-----
</body></email><email><emailId>20080531122601</emailId><senderName>Karsten Loesing</senderName><senderEmail>karsten.loesing@gmx.net</senderEmail><timestampReceived>2008-05-31 12:26:01-0400</timestampReceived><subject>Re: Draft schedule for Tor 0.2.1.x.</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Hi Nick,

| ==============================
| June 30: PROPOSAL CUTOFF.
|
| All feature proposals for consideration should be in and discussed
| before this date.  In the meantime, we should already be implementing
| accepted proposals.  Note also the "and discussed": complex proposals
| received on June 29 are unlikely to be adequately discussed by June
| 30.

Here is my personal wish list for 0.2.1.x:

- - Proposal 135 (Simplify Configuration of Private Tor Networks): I'd say
that this one is not a big issue any more. There might still be minor
changes to the implementation, but I can correct them in time.

- - Follow-up proposal to 114 (Distributed Storage for Tor Hidden Service
Descriptors): While writing down the ideas behind proposal 114 for a
paper, I found a few improvements that probably should be incorporated.
Most of these are minor changes, but one of them is a new feature to
exclude bad v2 hidden service directories. If you agree I would write
them down as a new proposal within the next week or so. (We could also
re-open proposal 114, if you'd prefer.)

- - Proposal 121 (Hidden Service Authentication): Even though the current
proposal is already implemented in a branch, the specification might
need some discussion. The last big specification change occurred on
April 28. Domenik's GSoC project is about extending Vidalia to make use
of this new feature, so I thought it might be useful to have this in Tor
0.2.1.x.

- --Karsten
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFIQUPZ0M+WPffBEmURAkCNAJ41tDXxKNwCM68rZnlcMNEZxeWD2gCbBd7K
5AThShoHy5rmOE7qSkqwCac=
=OqG+
-----END PGP SIGNATURE-----
</body></email><email><emailId>20080409023723</emailId><senderName>Camilo Viecco</senderName><senderEmail>cviecco@anml.iu.edu</senderEmail><timestampReceived>2008-04-09 02:37:23-0400</timestampReceived><subject>Re: udp transport PoC</subject><body>

Hi Nick

Thanks for your reply. I will try to answer your comments inline

Nick Mathewson wrote:
&gt;
&gt; Hi, Camilo!  This is interesting stuff.  We definitely need to move to
&gt; a UDP transport at some point, and it's good to try out various
&gt; approaches before we can get them onto the main network.  
&gt;
&gt; One question I got looking at your codebase for a few minutes: Do you
&gt; have a protocol specification for this anywhere (that is, something
&gt; like tor-spec.txt)?
There is no documentation for the protocol. I was more worried about 
making sure
the parts worked well together. That is this is a 'running specification'.
However, the 'philosophy' of the protocol is of a state machine.
Each packet that arrives can change the state of the machine (or create 
new state)
and depending on the state generate a new packet. Also, every second 
triggers
attempts to purge old link connections, circuits and streams.
There are no network buffers and packets currently are handled in a 'hot 
potato'
fashion, that is new packets are transmitted as soon as possible.
The redesign part is the moving of the socks server to the exit node.
I made my own socks4/4a server as other socks servers on the web seemed 
to have
performance problems (latency) when many connections where multiplexed over
high bandwidth delay product networks (antinat and socksd).
(maybe I did not looked hard enough).
&gt;&gt; I really like tor but had became disillusioned by its network
&gt;&gt; performance (or lack of). Thus,
&gt;&gt; as part of my graduate work I have designed a modification of the
&gt;&gt; transport mechanism in tor
&gt;&gt; to use tunnel tcp connections over ucp. That is, socks aware
&gt;&gt; applications open tcp streams
&gt;&gt; to a socks server running at the tor exit node.&gt; Tor does not transport
&gt;&gt; tcp streams
&gt;&gt; but transports the tcp packets (build by the os) in the form of
&gt;&gt; encapsulated autonomous circuit cells over udp.
&gt;
&gt; I really worry about TCP stack fingerprinting and linking with this
&gt; approach, especially if the exit nodes have freedom what they send
&gt; back to the clients.  I guess that it doesn't matter much for a proof
&gt; of concept of the routing algorithm, but it's a problem that will need
&gt; to be solved before a solution can get deployed in Tor.
Actually even in the current codebase, exit nodes cannot send arbitrary 
data to the clients. This is because clients drops packets from 
unrecognized streams; and for streams created at the client node, the 
protocol and port numbers are fixed when each stream is created 
(actually there should be an exeption for ICMP dst unreachable 
messages). However, in practice, my protocol would still be vulnerable 
to clients binding to ports/protocols combination recently used by an 
output stream where the or code has not yet timeouted(?) the stream 
(stream timeouts are set to 300s now). However I think this risk is 
minimal. Use of more intelligent timeouts can reduce this risk, but I 
think it is not possible to avoid completely. Finally, OS firewalls 
could help us here too, but I would like to think of them as an 'extra' 
layer of security.
&gt;
&gt; That's pretty keen!  I had a talk with Roger today about development
&gt; directions for Tor, and I think we're pretty sure that we need to
&gt; support UDP transport within a year or two.  Work like this definitely
&gt; helps to make the case for it.
I am preparing a much more detailed paper, that I can give you after it 
is done.

Camilo
</body></email><email><emailId>20080410052250</emailId><senderName>Marcus Wolschon</senderName><senderEmail>marcus@wolschon.biz</senderEmail><timestampReceived>2008-04-10 05:22:50-0400</timestampReceived><subject>Re: IPv6 Exit [was: Status of Tor proposals ...]</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

coderman schrieb:
| On Wed, Apr 9, 2008 at 9:36 PM, Nick Mathewson &lt;nickm@freehaven.net&gt;
wrote:
|&gt; ...
|&gt;    117  IPv6 exits
|&gt;
|&gt;         This is a good start but could use some revision.  See earlier
|&gt;         thread.  I want to merge in IPv6 support in 0.2.1.x, including
|&gt;         support for both entries and exits, so a revision of this
|&gt;         proposal is important.  Marking as NEEDS-REVISION.
|
|
| i'm probably just overlooking an obvious discussion, but i don't see a
| thread related to IPv6 entry support and/or the previous thread
| referenced here.
|
| does the "entry" support imply full IPv6 support?  (or is "entry"
| simply the requisite client support for utilizing IPv6 exit
| capability?)

Hello Nick,

I sent in a patch to allow TOR to (also)locally bind on an IPv6-address
and to allow hidden services to be on IPv6-addreses. It also made all
the internal data-structures IPv6-aware. The missing piece was
to have exit-nodes connect to IPv6-non-TOR-sites and IPv6 for
server-server communication because I did not want to chance any of
the protocoll to support advertising that you have an IPv6-address
that others can connect to or that you have an IPv6-exit-policy.

Marcus
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFH/aQpf1hPnk3Z0cQRAh75AJ9cBl7IOei8Limd0w6sjYI6n7iP9QCfcELh
4taT+xV1Z7GruJZR0ISfxQo=
=mNH9
-----END PGP SIGNATURE-----
</body></email><email><emailId>20080410201611</emailId><senderName>Geoffrey Goodell</senderName><senderEmail>goodell@eecs.harvard.edu</senderEmail><timestampReceived>2008-04-10 20:16:11-0400</timestampReceived><subject>120-suicide-descriptors: add revocation and send on restart</subject><body>

Proposal 120 addresses the need for Tor servers that are no longer
providing relaying services to quickly be removed from lists of Tor
relays (and the blacklists upon which they depend).

The proposal as written makes two critical assumptions:

(1) that a Tor server that wants to be removed from blacklists is still
in possession of the key that it had when it was relaying, and

(2) that a Tor server that wants to be removed from blacklists will shut
down relaying services before its process dies.

We can address (1) via revocation certificates.  In particular, we need
the ability for a new server running on the same (address, port) to
revoke a previous server running on (address, port).  One challenge is
that this would require some interaction to verify that the new server
is in fact running on the indicated (address, port).

We can address (2) via a new controller command to state that we want to
publish a new descriptor with "reject *:*" and "opt shutdown 1".  When a
controller (e.g. Vidalia) wants to shut down relaying, it can send the
new command, which is interpreted to mean both "set ORPort to 0" and
"publish the new descriptor".

Geoff
</body></email><email><emailId>20080414031616</emailId><senderName>Paul Syverson</senderName><senderEmail>syverson@itd.nrl.navy.mil</senderEmail><timestampReceived>2008-04-14 03:16:16-0400</timestampReceived><subject>Re: Status of Tor proposals and proposal process (March 2008)</subject><body>

On Sun, Apr 13, 2008 at 04:08:40PM -0700, Mike Perry wrote:
&gt; Thus spake Nick Mathewson (nickm@freehaven.net):
&gt; 
&gt; &gt;    115  Two Hop Paths
&gt; &gt;    116  Two hop paths from entry guards
&gt; &gt; 
&gt; &gt;         These both are probably dead at this point: there's been no
&gt; &gt;         activity for some while.  Both have uncertain anonymity
&gt; &gt;         implications, especially in light of new path features (like
&gt; &gt;         bridges) and possible scalability features arma has in mind.
&gt; &gt;         If anybody wants to resurrect them, a first step will be a
&gt; &gt;         really thorough analysis of what different attackers can do
&gt; &gt;         against them.  Marking as DEAD.
&gt; 
&gt; Please do not delete these (go ahead and put them in a DEAD directory
&gt; if you would like, though). I intend on revisiting them as soon as I
&gt; finish up with more immediate Tor tasks and lower hanging fruit. I
&gt; still believe the barriers are fundamentally engineering problems
&gt; rather than theoretical problems, but I do agree the proposals need a
&gt; rewrite to do a more clear job of enumerating and organizing the
&gt; anonymity considerations so that they are easier to grok. The prose in
&gt; 115 can get a bit thick..
&gt; 
&gt; (And to put into perspective any fears that the anonymity issues of
&gt; two hop paths are too hairy to ever try to solve, I contend that
&gt; anonymity under Firefox is a far more fearsome beast ;)
&gt;  

FWIW (probably not much yet), this is one of the things on which I am
hoping to get some research done at some point this summer.

aloha,
Paul
</body></email><email><emailId>20080421163404</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-04-21 16:34:04-0400</timestampReceived><subject>Re: Parallelizing (some of) Tor's AES Operations</subject><body>

[replying on or-dev with permission]

On Mon, Apr 21, 2008 at 02:29:05AM -0400, Matt Edman wrote:
 [...]
&gt; 
&gt; I've been sticking to trying to parallelize encryption of cells on circuits.
&gt; Trying to get all OpenSSL crypto parallelized would be great, but it also
&gt; seems quite a bit trickier and perhaps too ambitious for this small project. 

Agreed.  Sadly, though, OpenSSL AES is 2/3 of all symmetric crypto
done on a typical relay: each cell gets openssl-decrypted on the way
in, processed with relay_crypt, then openssl-encrypted on the way out.
For circuits at an exit node, OpenSSL's AES is only 1/2 of symmetric
crypto done at a relay, and for circuits at the client it's even
higher.

&gt; Here are some of the parallelization approaches I've been pondering:
&gt;
&gt;  1) The most straightforward approach I can think of is to launch
&gt; $NumCpus threads when Tor starts up. When aes_crypt() or
&gt; aes_crypt_inplace() get called from the main thread, the input gets
&gt; split into $length/$NumCpus chunks (or maybe fewer depending on
&gt; input length), which get farmed out to the worker threads.  The main
&gt; thread then collects the results and returns.
&gt;
&gt; A potential downside to this straightforward approach is that the input is
&gt; likely often so small that perhaps the overhead from mutex locking and thread
&gt; signaling dominates any potential gain from the parallelization. It may also
&gt; be a little unbalanced since the input length isn't often a multiple of the
&gt; number of threads (e.g., 509 byte cell sizes). The latter concern probably
&gt; isn't so critical though.

Right.  Personally, I don't expect that this will wind up working very
well in practice, what with the locking but if you want to benchmark
it, it might work out well after all.  Having the main thread wait
while all the subthreads are doing AES seems like a losing proposition.


&gt; 2) I also took a look at a parallel AES-CTR implementation done by some folks
&gt; at the Pittsburgh Supercomputing Center:
&gt; 
&gt;   http://www.psc.edu/networking/projects/hpn-ssh/openssh5.0-CTR-threading.diff
&gt; 
&gt;
&gt; The gist of their approach is to launch two threads for every
&gt; EVP_CIPHER_CTX when it is created. The threads handle pregenerating
&gt; keystream blocks in the background. The main thread reads from one
&gt; of the pregenerated buffers they call keystream queues (there is one
&gt; queue for every thread, plus two), marks the queue as draining, and
&gt; signals the worker threads to buffer up some more blocks if
&gt; necessary. The advantage of having multiple keystream queues is that
&gt; while the main thread is reading from one queue, the others can be
&gt; getting refilled by the worker threads.
&gt;
&gt; I'm not sure how many aes_cnt_cipher_t's a busy Tor relay has, but I'm
&gt; guessing that launching two threads for every one of them results in...a lot
&gt; of threads.  Their performance results for OpenSSH are impressive, but this
&gt; approach may not be exactly appropriate for Tor.

A relay server has around 2 aes_cnt_cipher_t instances per active
circuit, so let's just skip to the next one below.

&gt; 3) A modification of their idea is to only launch $NumCpus threads when Tor
&gt; starts up, rather than a couple for every aes_cnt_cipher_t. Each
&gt; aes_cnt_cipher_t still maintains a couple keystream queues that get filled by
&gt; the worker threads in the background. The PSC implementation allocates 4096
&gt; bytes for each keystream queue. Clearly the downside here is memory
&gt; consumption. I know you've been working to reduce Tor's memory consumption,
&gt; and this change would seem to go in the opposite direction. I'm guessing the
&gt; 4096 bytes could be tuned down quite a bit, but I think we'd still like to
&gt; buffer up at least 512 bytes so we can encrypt an entire cell without having
&gt; to wait for the threads to refill a keystream queue.

Right.  The success of this approach would depend totally on
predicting in advance which circuits are going to want to encrypt lots
of cells and which aren't.  Also, you'd need some way for the main
thread to tell the threads, "I have a bunch of cells waiting for
circuit X, but there's no pregenerated stream left or that circuit, so
please prioritize X's AES stream generation over other circuits'."

I like the latency win on this approach in the ideal case, but the RAM
hit seems nasty, and I worry about increased latency in the case where
the main thread has to wait for more stream.

&gt;  4) A fourth approach would be to farm entire cells out to
&gt; threads. Admittedly, I don't have a complete grasp on the flow of
&gt; cells through the code yet. From looking at relay.c, it looks like
&gt; this would entail (very vaguely) farming out
&gt; relay_crypto_one_payload() and then continuing normal processing of
&gt; the cell when the crypto is done. If I'm understanding correctly, I
&gt; guess we would also need to take care to avoid situations in which
&gt; two cells from the same circuit get farmed out to separate threads,
&gt; but get append_cell_to_circuit_queue()ed out of order. IMO, this
&gt; would be the way to go, but it's not clear to me at the moment how
&gt; to allow processing of cells on other circuits to continue while
&gt; waiting for the crypto to complete on a cell on one circuit.

I agree this is the best way to go.  Before you start, you should
check out the way that Tor handles cells in circuits right now:
that'll make your job even easier.

First off, ignore cells generated and received by clients.  Client
performance matters, but servers are likelier to benefit from
parallelization, to have multiple CPUs, and to be CPU-bound. 

Basics: every connection has two buffers: one for ingoing data and one
for outgoing data.  For servers, cells are received on OR connections
over TLS.  Once OpenSSL has decrypted the connection data, the cells
are in now in their incoming OR connection's input buffer, or "inbuf".

Having read data into the inbuf makes Tor call
connection_or_process_cells_from_inbuf() in connection_or.c.  This
pulls a cell off the buffer and calls command_process_cell() in
command.c.  If the cell is a relay cell, we go to
command_process_relay_cell() and the magic starts.

command_process_relay_cell() doees the following:
  - Given the connection that the cell came in on, and the cell's ciruit
    ID, it looks up the appropriate or_circuit_t for the circuit.
  - It passes the cell to circuit_receive_relay_cell(), which does the
    following:
    - It calls relay_crypt() to actually do the crypto on the cell.[**]
    - If the cell is intended for this hop on the circuit (that is,
      we're the exit or we're the client), pass it off to the
      appropriate edge stream.
    - Otherwise, find the next or_conn in sequence that should get
      this newly decrypted or encrypted cell.
    - Call append_cell_to_ciruit_queue(), which will queue the
      cell on the circuit's cell queue and do some housekeeping.

Note that there's exactly one place in the entire code where
relay_crypt() is called, marked [**] above.  To get things to
parallelize effectively, I think you'd want to replace the call to
relay_crypt, and have it instead place the cell in a work queue for
the worker threads to process.  When the worker threads were done with
one or more cell, you'd need a way for them to tell the main thread
about them, and which circuit's cell queue to put them in.

Alternatively, you could give each circuit _two_ cell queues for each
direction: one for cells that need to be crypted, and one for cells
that are already crypted and are ready to transmit.  All you'd need to
tell the workers about is which circuits have to be processed; all
you'd need to tell the main thread about is which circuits now have
more data.  I like this approach a little better because it doesn't
require quite so much bookkeeping to tell the workers about what keys
to use to crypt what, or to tell the main thread where to put cells.

It will definitely take some thinking to figure out exactly what kind
of locking and notification mechanisms you'd want to use here.  If you
have any questions about waking the main thread, or what kind of
integrity Tor's data structures need, just ask.

This sounds like a really fun project in any case, and one I'd very
much like to include in the next Tor release.  What timeframe will you
be doing this on?

Many thanks,
-- 
Nick






    
      
	  	
</body></email><email><emailId>20080422151019</emailId><senderName>Fabian Keil</senderName><senderEmail>freebsd-listen@fabiankeil.de</senderEmail><timestampReceived>2008-04-22 15:10:19-0400</timestampReceived><subject>Re: Bug: buffers.c:1688: assert_buf_ok: Assertion ch-&gt;data &gt;=</subject><body>


Nick Mathewson &lt;nickm@freehaven.net&gt; wrote:

&gt; On Fri, Apr 18, 2008 at 07:33:32AM +0200, Fabian Keil wrote:
&gt; &gt; A few days ago one of my servers triggered:
&gt; &gt; 
&gt; &gt; Apr 10 17:07:45.728 [notice] Tor 0.2.0.23-rc (r14173) opening log file.

&gt; &gt; Apr 10 17:08:18.375 [notice] Performing bandwidth self-test...done.
&gt; &gt; Apr 11 12:25:25.848 [err] Bug: buffers.c:1688: assert_buf_ok: Assertion ch-&gt;data \
&gt; &gt; &gt;= &amp;ch-&gt;mem[0] failed; aborting. 
&gt; &gt; Unfortunately it doesn't look like a core dump has been created.
&gt; 
&gt; Hm. Unfortunately, this looks like one we're not going to be able to
&gt; trace down without at least a stack trace.  If you like, you can
&gt; submit it to the bugtracker so we don't forget about it.

I'll wait for it to happen again first. Thanks.

Fabian


["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20080424011836</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-04-24 01:18:36-0400</timestampReceived><subject>Re: Proposal: Download consensus documents only when it will be trusted</subject><body>

On Wed, Apr 23, 2008 at 03:40:17PM +0200, Peter Palfrader wrote:
&gt; On Tue, 22 Apr 2008, Peter Palfrader wrote:
&gt; 
&gt; &gt; &gt; Here's a first go at the server side.
&gt; &gt; Split into its own function.
&gt; 
&gt; .) Not all authorities on consensus-&gt;voters actually signed the consensus.
&gt; .) decode the requested fingerprint rather than encoding each
&gt;    authority's id digest.  This gets rid of one of the two smartlists
&gt;    and a bunch of small mallocs.
&gt;

Looks good now.  I say check it in.  Two thing, though.

First thing: could you also patch dir-spec.txt to document the new
URL, and document which versions of Tor started accepting it?

Second thing:

&gt; + * Clients can say they only want a consensus if it's signed by more
&gt; + * than half the authorities in &lt;list&gt;.  They pass this list in

Tags in doxygen comments need to be valid HTML.  House style is to
write &lt;b&gt;list&lt;/b&gt;.

peace,
-- 
Nick
</body></email><email><emailId>20080429201957</emailId><senderName>Karsten Loesing</senderName><senderEmail>karsten.loesing@gmx.net</senderEmail><timestampReceived>2008-04-29 20:19:57-0400</timestampReceived><subject>Proposal: Simplify Configuration of Private Tor Networks</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Hi all,

as you know... [and here starts the outline of the attached proposal:]

"Configuring a private Tor network has become a time-consuming and
error-prone task with the introduction of the v3 directory protocol. In
addition to that, operators of private Tor networks need to set an
increasing number of non-trivial configuration options, and it is hard
to keep FAQ entries describing this task up-to-date. In this proposal we
(1) suggest to (optionally) accelerate timing of the v3 directory voting
process and (2) introduce an umbrella config option specifically aimed
at creating private Tor networks."

There is also a patch attached including the changes required for this
proposal.

Comments are highly appreciated! :)

- --Karsten
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFIF4Ls0M+WPffBEmURAtpZAKCir1HSxkopseSsqNAZ+3lmJs1bKACgp3lu
YQypabFCxZiUyHrr+A8pzx0=
=IBVZ
-----END PGP SIGNATURE-----

["xxx-private-tor-networks.txt" (text/plain)]

Filename: xxx-private-tor-networks.txt
Title: Simplify Configuration of Private Tor Networks
Version: $LastChangedRevision$
Last-Modified: $LastChangedDate$
Author: Karsten Loesing
Created: 29-Apr-2008
Status: Open

Change history:

  29-Apr-2008  Initial proposal for or-dev

Overview:

  Configuring a private Tor network has become a time-consuming and
  error-prone task with the introduction of the v3 directory protocol. In
  addition to that, operators of private Tor networks need to set an
  increasing number of non-trivial configuration options, and it is hard
  to keep FAQ entries describing this task up-to-date. In this proposal we
  (1) suggest to (optionally) accelerate timing of the v3 directory voting
  process and (2) introduce an umbrella config option specifically aimed at
  creating private Tor networks.

Design:

  1. Accelerate Timing of v3 Directory Voting Process

  Tor has reasonable defaults for setting up a large, Internet-scale
  network with comparably high latencies and possibly wrong server clocks.
  However, those defaults are bad when it comes to quickly setting up a
  private Tor network for testing, either on a single node or LAN (things
  might be different when creating a test network on PlanetLab or
  something). Some time constraints should be made configurable for private
  networks. The general idea is to accelerate everything that has to do
  with propagation of directory information, but nothing else, so that a
  private network is available as soon as possible. (As a possible
  safeguard, changing these configuration values could be made dependent on
  the umbrella configuration option introduced in 2.)

  1.1. Initial Voting Schedule

  When a v3 directory does not know any consensus, it assumes an initial,
  hard-coded VotingInterval of 30 minutes, VoteDelay of 5 minutes, and
  DistDelay of 5 minutes. This is important for multiple, simultaneously
  restarted directory authorities to meet at a common time and create an
  initial consensus. Unfortunately, this means that it may take up to half
  an hour (or even more) for a private Tor network to bootstrap.

  We propose to make these three time constants configurable (note that
  V3AuthVotingInterval, V3AuthVoteDelay, and V3AuthDistDelay do not have an
  effect on the _initial_ voting schedule, but only on the schedule that a
  directory authority votes for). This can be achieved by introducing three
  new configuration options: V3AuthInitialVotingInterval,
  V3AuthInitialVoteDelay, and V3AuthInitialDistDelay.

  As first safeguards, Tor should only accept configuration values for
  V3AuthInitialVotingInterval that divide evenly into the default value of
  30 minutes. The effect is that even if people misconfigured their
  directory authorities, they would meet at the default values at the
  latest. The second safeguard is to allow configuration only when the
  umbrella configuration option PrivateTorNetwork is set.

  1.2. Immediately Provide Reachability Information (Running flag)

  The default behavior of a directory authority is to provide the Running
  flag only after the authority is available for at least 30 minutes. The
  rationale is that before that time, an authority simply cannot deliver
  useful information about other running nodes. But for private Tor
  networks this may be different. This is currently implemented in the code
  as:

  /** If we've been around for less than this amount of time, our
   * reachability information is not accurate. */
  #define DIRSERV_TIME_TO_GET_REACHABILITY_INFO (30*60)

  There should be another configuration option DirAssumeRunningDelay with
  a default value of 30 minutes that can be changed when running private
  Tor networks, e.g. to 0 minutes. The configuration value would simply
  replace the quoted constant. Again, changing this option could be
  safeguarded by requiring the umbrella configuration option
  PrivateTorNetwork to be set.

  1.3. Reduce Estimated Descriptor Propagation Time

  Tor currently assumes that it takes up to 10 minutes until router
  descriptors are propagated from the authorities to directory caches.
  This is not very useful for private Tor networks, and we want to be able
  to reduce this time, so that clients can download router descriptors in a
  timely manner.

  /** Clients don't download any descriptor this recent, since it will
   * probably not have propagated to enough caches. */
  #define ESTIMATED_PROPAGATION_TIME (10*60)

  We suggest to introduce a new config option
  EstimatedDescriptorPropagationTime which defaults to 10 minutes, but that
  can be set to any lower non-negative value, e.g. 0 minutes. The same
  safeguards as in 1.2 could be used here, too.

  2. Umbrella Option for Setting Up Private Tor Networks

  Setting up a private Tor network requires a number of specific settings
  that are not required or useful when running Tor in the public Tor
  network. Instead of writing down these options in a FAQ entry, there
  should be a single configuration option, e.g. PrivateTorNetwork, that
  changes all required settings at once. Newer Tor versions would keep the
  set of configuration options up-to-date. It should still remain possible
  to manually overwrite the settings that the umbrella configuration option
  affects.

  The following configuration options are set by PrivateTorNetwork:

  - ServerDNSAllowBrokenResolvConf 1
      Ignore the situation that private relays are not aware of any name
      servers.

  - DirAllowPrivateAddresses 1
      Allow router descriptors containing private IP addresses.

  - EnforceDistinctSubnets 0
      Permit building circuits with relays in the same subnet.

  - AssumeReachable 1
      Omit self-testing for reachability.

  - AuthDirMaxServersPerAddr 0
  - AuthDirMaxServersPerAuthAddr 0
      Permit an unlimited number of nodes on the same IP address.

  - ClientDNSRejectInternalAddresses 0
      Believe in DNS responses resolving to private IP addresses.

  - ExitPolicyRejectPrivate 0
      Allow exiting to private IP addresses. (This one is a matter of
      taste---it might be dangerous to make this a default in a private
      network, although people setting up private Tor networks should know
      what they are doing.)

  - V3AuthVotingInterval 5 minutes
  - V3AuthVoteDelay 20 seconds
  - V3AuthDistDelay 20 seconds
      Accelerate voting schedule after first consensus has been reached.

    V3AuthInitialVotingInterval 5 minutes
    V3AuthInitialVoteDelay 20 seconds
    V3AuthInitialDistDelay 20 seconds
      Accelerate initial voting schedule until first consensus is reached.

    DirAssumeRunningDelay 0 minutes
      Consider routers as Running from the start of running an authority.

    EstimatedDescriptorPropagationTime 0 minutes
      Clients try downloading router descriptors from directory caches,
      even when they are not 10 minutes old.


["private-tor-networks-patch.diff" (text/x-patch)]

Index: /home/karsten/tor/tor-trunk-private-network/src/or/config.c
===================================================================
--- /home/karsten/tor/tor-trunk-private-network/src/or/config.c	(revision 14508)
+++ /home/karsten/tor/tor-trunk-private-network/src/or/config.c	(working copy)
@@ -174,6 +174,7 @@
   V(DataDirectory,               STRING,   NULL),
   OBSOLETE("DebugLogFile"),
   V(DirAllowPrivateAddresses,    BOOL,     NULL),
+  V(DirAssumeRunningDelay,       INTERVAL, "30 minutes"),
   V(DirListenAddress,            LINELIST, NULL),
   OBSOLETE("DirFetchPeriod"),
   V(DirPolicy,                   LINELIST, NULL),
@@ -185,6 +186,7 @@
   V(DownloadExtraInfo,           BOOL,     "0"),
   V(EnforceDistinctSubnets,      BOOL,     "1"),
   V(EntryNodes,                  STRING,   NULL),
+  V(EstimatedDescriptorPropagationTime, INTERVAL, "10 minutes"),
   V(ExcludeNodes,                STRING,   NULL),
   V(ExitNodes,                   STRING,   NULL),
   V(ExitPolicy,                  LINELIST, NULL),
@@ -243,6 +245,7 @@
   V(OutboundBindAddress,         STRING,   NULL),
   OBSOLETE("PathlenCoinWeight"),
   V(PidFile,                     STRING,   NULL),
+  V(PrivateTorNetwork,           BOOL,     "0"),
   V(PreferTunneledDirConns,      BOOL,     "1"),
   V(ProtocolWarnings,            BOOL,     "0"),
   V(PublishServerDescriptor,     CSV,      "1"),
@@ -297,6 +300,9 @@
   VAR("V1AuthoritativeDirectory",BOOL, V1AuthoritativeDir,   "0"),
   VAR("V2AuthoritativeDirectory",BOOL, V2AuthoritativeDir,   "0"),
   VAR("V3AuthoritativeDirectory",BOOL, V3AuthoritativeDir,   "0"),
+  V(V3AuthInitialVotingInterval, INTERVAL, "30 minutes"),
+  V(V3AuthInitialVoteDelay,      INTERVAL, "5 minutes"),
+  V(V3AuthInitialDistDelay,      INTERVAL, "5 minutes"),
   V(V3AuthVotingInterval,        INTERVAL, "1 hour"),
   V(V3AuthVoteDelay,             INTERVAL, "5 minutes"),
   V(V3AuthDistDelay,             INTERVAL, "5 minutes"),
@@ -3306,6 +3312,91 @@
     COMPLAIN("V3AuthVotingInterval does not divide evenly into 24 hours.");
   }
 
+  if (options-&gt;V3AuthInitialVotingInterval != 30*60 &amp;&amp;
+      !options-&gt;PrivateTorNetwork) {
+    REJECT("V3AuthInitialVotingInterval may only be changed in private "
+           "Tor networks!");
+  } else if (options-&gt;V3AuthInitialVotingInterval &lt; MIN_VOTE_INTERVAL) {
+    REJECT("V3AuthInitialVotingInterval is insanely low.");
+  } else if (options-&gt;V3AuthInitialVotingInterval &gt; 24*60*60) {
+      REJECT("V3AuthInitialVotingInterval is insanely high.");
+  } else if (((30*60) % options-&gt;V3AuthInitialVotingInterval) != 0) {
+    REJECT("V3AuthInitialVotingInterval does not divide evenly into "
+           "30 minutes.");
+  }
+
+  if (options-&gt;V3AuthInitialVoteDelay != 5*60 &amp;&amp;
+      !options-&gt;PrivateTorNetwork) {
+    REJECT("V3AuthInitialVoteDelay may only be changed in private "
+           "Tor networks!");
+  } else if (options-&gt;V3AuthInitialVoteDelay &lt; MIN_VOTE_SECONDS) {
+    REJECT("V3AuthInitialVoteDelay is way too low.");
+  }
+
+  if (options-&gt;V3AuthInitialDistDelay != 5*60 &amp;&amp;
+      !options-&gt;PrivateTorNetwork) {
+    REJECT("V3AuthInitialDistDelay may only be changed in private "
+           "Tor networks!");
+  } else if (options-&gt;V3AuthInitialDistDelay &lt; MIN_DIST_SECONDS) {
+    REJECT("V3AuthInitialDistDelay is way too low.");
+  }
+
+  if (options-&gt;V3AuthInitialVoteDelay + options-&gt;V3AuthInitialDistDelay &gt;=
+      options-&gt;V3AuthInitialVotingInterval/2) {
+    REJECT("V3AuthInitialVoteDelay plus V3AuthInitialDistDelay must be "
+           "less than half V3AuthInitialVotingInterval");
+  }
+
+  if (options-&gt;DirAssumeRunningDelay != 30*60 &amp;&amp; !options-&gt;PrivateTorNetwork) {
+    REJECT("DirAssumeRunningDelay may only be changed in private "
+           "Tor networks!");
+  } else if (options-&gt;DirAssumeRunningDelay &lt; 0) {
+    REJECT("DirAssumeRunningDelay must be non-negative.");
+  } else if (options-&gt;DirAssumeRunningDelay &gt; 2*60*60) {
+    COMPLAIN("DirAssumeRunningDelay is insanely high.");
+  }
+
+  if (options-&gt;EstimatedDescriptorPropagationTime != 10*60 &amp;&amp;
+      !options-&gt;PrivateTorNetwork) {
+    REJECT("EstimatedDescriptorPropagationTime may only be changed in "
+           "private Tor networks!");
+  } else if (options-&gt;EstimatedDescriptorPropagationTime &lt; 0) {
+    REJECT("EstimatedDescriptorPropagationTime must be non-negative.");
+  } else if (options-&gt;EstimatedDescriptorPropagationTime &gt; 60*60) {
+    COMPLAIN("EstimatedDescriptorPropagationTime is insanely high.");
+  }
+
+  if (options-&gt;PrivateTorNetwork) {
+    log_warn(LD_CONFIG, "PrivateTorNetwork is set. This will make your node"
+                        "almost unusable in the public Tor network, and is "
+                        "therefore only advised if you are building a "
+                        "private Tor network!");
+    options-&gt;ServerDNSAllowBrokenResolvConf = 1;
+    options-&gt;DirAllowPrivateAddresses = 1;
+    options-&gt;EnforceDistinctSubnets = 0;
+    options-&gt;AssumeReachable = 1;
+    options-&gt;AuthDirMaxServersPerAddr = 0;
+    options-&gt;AuthDirMaxServersPerAuthAddr = 0;
+    options-&gt;ClientDNSRejectInternalAddresses = 0;
+    options-&gt;ExitPolicyRejectPrivate = 0;
+    options-&gt;V3AuthVotingInterval = 5*60;
+    options-&gt;V3AuthVoteDelay = 20;
+    options-&gt;V3AuthDistDelay = 20;
+    options-&gt;V3AuthInitialVotingInterval = 5*60;
+    options-&gt;V3AuthInitialVoteDelay = 20;
+    options-&gt;V3AuthInitialDistDelay = 20;
+    options-&gt;DirAssumeRunningDelay = 0;
+    options-&gt;EstimatedDescriptorPropagationTime = 0;
+  }
+  /* TODO It should be possible to override those values that are set by
+   * "PrivateTorNetwork 1" with the original default values (or even some
+   * other value). Idea: Change default values of these configuration
+   * options to invalid value, e.g. -1, in order to distinguish default
+   * values (then -1) from overridden values, e.g. 0. Requires to safely
+   * change all -1 values back to the actual default values afterwards! Is
+   * this a hack? Well, of course it is, but is there a better way to
+   * achieve the same goal? -KL */
+
   if (rend_config_services(options, 1) &lt; 0)
     REJECT("Failed to configure rendezvous options. See logs for details.");
 
Index: /home/karsten/tor/tor-trunk-private-network/src/or/dirserv.c
===================================================================
--- /home/karsten/tor/tor-trunk-private-network/src/or/dirserv.c	(revision 14508)
+++ /home/karsten/tor/tor-trunk-private-network/src/or/dirserv.c	(working copy)
@@ -2122,10 +2122,6 @@
     router-&gt;is_bad_exit = router-&gt;is_bad_directory = 0;
 }
 
-/** If we've been around for less than this amount of time, our reachability
- * information is not accurate. */
-#define DIRSERV_TIME_TO_GET_REACHABILITY_INFO (30*60)
-
 /** Return a new networkstatus_t* containing our current opinion. (For v3
  * authorities) */
 networkstatus_t *
@@ -2155,7 +2151,7 @@
   tor_assert(private_key);
   tor_assert(cert);
 
-  if (now - time_of_process_start &lt; DIRSERV_TIME_TO_GET_REACHABILITY_INFO)
+  if (now - time_of_process_start &lt; options-&gt;DirAssumeRunningDelay)
     vote_on_reachability = 0;
 
   if (resolve_my_address(LOG_WARN, options, &amp;addr, &amp;hostname)&lt;0) {
@@ -2241,7 +2237,7 @@
       last_consensus_interval = current_consensus-&gt;fresh_until -
         current_consensus-&gt;valid_after;
     else
-      last_consensus_interval = DEFAULT_VOTING_INTERVAL_WHEN_NO_CONSENSUS;
+      last_consensus_interval = options-&gt;V3AuthInitialVotingInterval;
     v3_out-&gt;valid_after =
       dirvote_get_start_of_next_interval(now, (int)last_consensus_interval);
     format_iso_time(tbuf, v3_out-&gt;valid_after);
Index: /home/karsten/tor/tor-trunk-private-network/src/or/dirvote.c
===================================================================
--- /home/karsten/tor/tor-trunk-private-network/src/or/dirvote.c	(revision 14508)
+++ /home/karsten/tor/tor-trunk-private-network/src/or/dirvote.c	(working copy)
@@ -1224,8 +1224,9 @@
     vote_delay = consensus-&gt;vote_seconds;
     dist_delay = consensus-&gt;dist_seconds;
   } else {
-    interval = DEFAULT_VOTING_INTERVAL_WHEN_NO_CONSENSUS;
-    vote_delay = dist_delay = 300;
+    interval = options-&gt;V3AuthInitialVotingInterval;
+    vote_delay = options-&gt;V3AuthInitialVoteDelay;
+    dist_delay = options-&gt;V3AuthInitialDistDelay;
   }
 
   tor_assert(interval &gt; 0);
Index: /home/karsten/tor/tor-trunk-private-network/src/or/or.h
===================================================================
--- /home/karsten/tor/tor-trunk-private-network/src/or/or.h	(revision 14508)
+++ /home/karsten/tor/tor-trunk-private-network/src/or/or.h	(working copy)
@@ -2339,6 +2339,14 @@
   /** The number of intervals we think a consensus should be valid. */
   int V3AuthNIntervalsValid;
 
+  /** DOCDOC */
+  int V3AuthInitialVotingInterval;
+  int V3AuthInitialVoteDelay;
+  int V3AuthInitialDistDelay;
+  int DirAssumeRunningDelay;
+  int EstimatedDescriptorPropagationTime;
+  int PrivateTorNetwork;
+
   /** File to check for a consensus networkstatus, if we don't have one
    * cached. */
   char *FallbackNetworkstatusFile;
@@ -3181,9 +3189,6 @@
 /** Smallest allowable voting interval. */
 #define MIN_VOTE_INTERVAL 300
 
-/** If there is no consensus, what interval do we default to? */
-#define DEFAULT_VOTING_INTERVAL_WHEN_NO_CONSENSUS (30*60)
-
 void dirvote_free_all(void);
 
 /* vote manipulation */
Index: /home/karsten/tor/tor-trunk-private-network/src/or/routerlist.c
===================================================================
--- /home/karsten/tor/tor-trunk-private-network/src/or/routerlist.c	(revision 14508)
+++ /home/karsten/tor/tor-trunk-private-network/src/or/routerlist.c	(working copy)
@@ -3664,10 +3664,6 @@
   tor_free(resource);
 }
 
-/** Clients don't download any descriptor this recent, since it will probably
- * not have propagated to enough caches. */
-#define ESTIMATED_PROPAGATION_TIME (10*60)
-
 /** Return 0 if this routerstatus is obsolete, too new, isn't
  * running, or otherwise not a descriptor that we would make any
  * use of even if we had it. Else return 1. */
@@ -3679,7 +3675,7 @@
      * But, if we want to have a complete list, fetch it anyway. */
     return 0;
   }
-  if (rs-&gt;published_on + ESTIMATED_PROPAGATION_TIME &gt; now) {
+  if (rs-&gt;published_on + options-&gt;EstimatedDescriptorPropagationTime &gt; now) {
     /* Most caches probably don't have this descriptor yet. */
     return 0;
   }


["xxx-private-tor-networks.txt.sig" (application/octet-stream)]
["private-tor-networks-patch.diff.sig" (application/octet-stream)]

</body></email><email><emailId>20080429204102</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-04-29 20:41:02-0400</timestampReceived><subject>Re: Proposal: More robust consensus voting with diverse authority sets</subject><body>

On Tue, Apr 29, 2008 at 04:14:08PM +0200, Peter Palfrader wrote:
&gt; On Wed, 02 Apr 2008, Nick Mathewson wrote:
&gt; 
&gt; &gt;                                    Is there a simpler approach that
&gt; &gt; does what we want, or do we really need to do the NP-hard thing?
&gt; 
&gt; Did one occur to you yet?  If not, should we go forward with this
&gt; proposal?

All I can think of is providing explicit "flag day" options in the
authority configuration: something to the effect of "before May 1, the
authority list is X; after May 1, the authority list is Y."  This
isn't as powerful as proposal 134 though, and I think it might be less
good than we need.

I decided that I'd eel better about the NP-hard thing if we codde up
the sample C implementation and found out that it scaled well to a
large number of authorities.  ("Scaling well" here means something
like "not replacing RSA as our biggest time-sink in voting", and
"large number of authorities" meaning something far larger than
anything we're hoping to do now.)

To test this, I hacked up a quick and dirty recursive max-clique
implemention in python, to get a handle on scaling issues and
efficiency concerns.  With a little tweaking and a few standard AI
search hacks, I got something that performed fine up to even 50
authorities (which is more than we ever plan to do).  I've attached
the code, in case anybody wants to adopt the approach: basically, it's
a greedy depth-first search with pruning.

So, afaik, the sole remaining big problem in this proposal is
migration.  IIUC, the current consensus-method thing won't work, for
reasons explained in an earlier message of mine on this thread:

   &gt;The 'consensus method' thing is only meant to determine which
   &gt;algorithm the voting authorities use to produce the consensus from the
   &gt;votes, not which authorities' votes count.

Once we solve this, I think building proposal 134 would be a fine
thing to do.

peace,
-- 
Nick

["maxclique.py" (text/x-python)]

import time
import random
random.seed()

# So, here's the algorithm, *APPROXIMATELY*:
#
#  To find the biggest clique of some graph:
#     Find the biggest clique of that graph that has size greater than 0.
#
#  To find the biggest clique in some graph with size greater than N:
#     If there are N or fewer points in the graph, return no clique.
#     Else, if there are 3 or fewer points in the graph, manually
#        find the biggest clique.
#     Else:
#        Let P0 = the most connected point in the graph.
#        Let G' = the subgraph of all points connected to P0.
#        Recursively find C, the biggest clique in G' of size greater than N-1.
#        If Size(C) == Size(G'), return C.
#        Let Best = the larger of N and Size(C)+1.
#        Let G'' = the subgraph of all points in the graph other than P0.
#        Recursively find C', the biggest clique in G'' of size greater
#           than Best.
#        Return the larger of C and C'.
#


def maxp(points, edges, onlyIfBetterThan):
    """given a list of points and a symmetric set of (point,point) pairs,
       return the list of points in the largest clique of points in
       'points' such that for all distint p1,p2 in the result, (p1,p2)
       is in edges.  If no clique has more than onlyIfBetterThan elements,
       possibly return an empty list."""
    nPoints = len(points)
    if onlyIfBetterThan &gt;= nPoints:
        # There's no way we can get an answer with more than onlyIfBetterThan
        # points without having more than that number of points to work with.
        return []

    if nPoints == 3:
        # Only 3 points? Stop recursing
        p0,p1,p2 = points
        if (p0,p1) in edges:
            if (p0,p2) in edges and (p1,p2) in edges:
                return points
            else:
                return points[0:2]
        elif (p1,p2) in edges:
            return points[1:]
        elif (p0,p2) in edges:
            return [ p0, p2 ]
        else:
            return [ p0 ]
    elif nPoints &gt; 3:
        # First, find o2, the biggest clique that contains point 0.
        # Only consider points that are directly connected to point 0,
        # obviously.
        p0 = points[0]
        pRest = [p for p in points[1:] if (p0,p) in edges]
        o2 = maxp(pRest, edges, onlyIfBetterThan-1)
        o2.append(p0)
        if len(o2) == nPoints:
            # o2 is the same size as the entire subgraph under consideration;
            # we can't do better than that.
            return o2

        # Now find the biggest clique that _doesn't_ contain point 0.
        # We just found o2, so we don't need to consider any result
        # with size &lt;= len(o2).
        onlyIfBetterThan = max(len(o2), onlyIfBetterThan)
        o1 = maxp(points[1:], edges, onlyIfBetterThan)

        # Return whichever of o1 or o2 was the largest.
        if len(o1) &gt; len(o2):
            if len(o2) &lt; onlyIfBetterThan:
                return []
            return o1
        else:
            if len(o2) &lt; onlyIfBetterThan:
                return []
            return o2

    # The rest of this function is just corner cases for small
    # numbers of points.
    elif nPoints == 0:
        return points
    elif nPoints == 1:
        return points
    elif nPoints == 2:
        if (points[0], points[1]) in edges:
            return points
        else:
            return [ points[0] ]


def maxclique(aset):
    # make that aset is symmetric: delete asymmetric bits.
    for a,b in list(aset):
        if (b,a) not in aset:
            del aset[a,b]

    count = {}
    for k,k2 in aset:
        try:
            count[k] += 1
        except KeyError:
            count[k] = 1
    points = [p for c, p in sorted((c,p) for p,c in count.iteritems())]

    return maxp(points, aset, 0)

def randGraph(nP, nE):
    points = range(1,nP+1)
    edges = set()
    if nE &gt; (nP*(nP-1))/2:
        nE = nP*(nP-1)/2
    for _ in xrange(nE):
        while 1:
            a = random.choice(points)
            b = random.choice(points)
            if a != b and (a,b) not in edges:
                edges.add((a,b))
                edges.add((b,a))
                break
    return edges

def bench(nodes,edges,iters):
    e = randGraph(nodes, edges)
    t = time.time()
    for _ in xrange(iters):
        maxclique(e)
    t2 = time.time()
    print "%s nodes, %s edges: %s msec" % (nodes,edges,((t2-t)/iters)*1000)

if __name__ == '__main__':
    print bench(50,800,30)


</body></email><email><emailId>20080301181559</emailId><senderName>unknown</senderName><senderEmail>unknown@pgpru.com</senderEmail><timestampReceived>2008-03-01 18:15:59-0400</timestampReceived><subject>Re: Multiple Directory Authorities' keys compromise: a partial</subject><body>

On Wed, 13 Feb 2008 04:08:04 -0500
Roger Dingledine &lt;arma@xxx.xxx&gt; wrote:


&gt; Ygrek just reminded me that nobody had answered this. Sorry for the delay;
&gt; I'll try to provide a brief response here.

Thanks Roger. We continue to discuss the problem on our website with our heads
overheated. :-)

&gt; Actually, of the current v3 authorities:
&gt; 3 are in the US (moria1, lefkada, ides)
&gt; 3 are in Europe (tor26, gabelmoo, dannenberg)
&gt; but yes, it's definitely an issue we need to stay aware of.
[...]
&gt; Worse, since these attacks rarely (never?) show up in practice, we're
&gt; never going to get feedback that the code is still working.


This issue can lead to the crisis of trust. In case of the attack 3+1 corrupted
authorities + 1 controlled ISP is no more better than a single anonymizer with
access to users logs. It wouldn't be "rare" when the adversary is law enforcement
agency or another "political" adversary,
which is able to get DA keys and install Tor virtual network simulator on an
ISP. And all this is way easier than pretend to be a "global adversary". Worse,
this "hypothetical" attack will be deterministic, not probabilistic.

It's to say that ways to deter this attack is similar to thunderbolt protection. You
can place a lightning rod on a house's roof, and will avoid direct lightning
strike. Lightning striking an unprotected area is uncommon. In the absence of a
lightning rod it's very rare for your house to be stroke too. You may think that
the lightning rod is unnecessary. But if the direct lightning stroke will happen
it will be devastating.

&gt; The most
&gt; likely scenario for any balance that we pick between too brittle and
&gt; not brittle enough is that in about a year people will start seeing the
&gt; warnings when no actual attack is occurring, and we'll wonder why the
&gt; code is there.

Agreed. The core problem is: We don't have a clear criteria of attack, and we
don't have a simple scenario for defense.

We assume that the adversary conducts this attack against a single or a very
small fraction of isolated Tor users in order to avoid disclosure of such
abilities. Attack is based on creating a distorted view of the Tor network for
the targeted user(s) (virtual network simulation and rerouting intercepted and
decrypted/re-encrypted traffic to the real Tor network afterwards).

User can detect this attack in two ways: autonomous (collecting anomalies in the
network statistics), and relative (comparing the network statistics with other
trusted users by exchanging suspicious network statuses on secure off-the-band
channels: encrypted email, personal face-to-face contacts). If concerned users can
identify suspicious node keys (signed by rogue DAs) with the help of more users,
they can publish that keys or their hashes for "peer review" as a demonstration
of evidence. Concerned users will play a role of "Tor watchers".

Here we propose a very simple (and maybe a naive) approach for the first step
— autonomous detection (just as an example, wasn't tested in the wild).

If the user has N_k nodes' keys from the current network status and N_k-1 from
the previous network status, then

C=N_k/N_k-1 is the change in the numbers of keys (and nodes themselves).

Let I be the index of keys found in both lists of N_k and N_k-1

I_max = max I = min (N_k, N_k-1)

Let D=I/I_max -– changes of keys themselves (differences).

We can replace this with D=(I+1)/(I_max+1) to avoid zero values (not always needed,
in a reality we have a big values for I).

If C&gt;=1, then we calculate S=C/D; and if C&lt;1, then we calculate S=C*D

The closer S to 1, the more stable Tor network is. If S changes significantly,
then we have the network instability (S&lt;1 is better than S&gt;1) . S can be easily
calculated from the Tor network status file. But we can't easily count broken or
blocked connection to nodes from the status list (which could be a sign of attack
by itself).

More correct solution is calculate independed sum of S=(C-1)^2+(D-1)^2 and keep
this value as close to zero as possible.

Another possible approach is measuring descriptors as intersections in the set M =
M1 AND M2, and consider Z(M1, M2) = min( |M|/|M1| , |M|/|M2| ) as normalized and
time direction invarianted value in the range of [0..1], 0 – most unstable;
1 – fully stable. Finally, calculate R = (1-Z)

With differences D we can calculate any values from status (consensus) file for
nodes (IP, type) to avoid great changing with numbers of entry and exit nodes
and other distortions.

We discuss about "delayed partial cache poisoning" or "multistep attack" from
attacker: ability of avoiding any visible statistical disturbances and guess,
this is impractical for attacker and can be easy detected with our criteria.

For example: if only 10% nodes keys changes per step by attacker then user have
a very litle value of chance to download false status 9 times in succession:
Pr=0.1x0.2x0.3*...0.9= .00036
But user have a big chance 1-Pr in one of any 9 steps to download back real Tor
network status (nodes consensus) from node, not controlled by adversary (mirror)
and detect attack by measuring S.

Our conjecture is "adaptive (or selective) blocking" connections is possible but
don't gives a significant advantages to adversary.

Another problem for adversary is too many broken connections from mixing real and
false nodes. In our another example user has a half of false nodes and another
half of real ones. He can select randomly 8 types of circuits:

(1-1-1) - full controlled, connection going to virtual Tor simulator, deanonimized
by adversary and rerouted to real Tor without user suspicion.
(0-0-0) - full unknown and free from adversary, can be passive retransmitted
adversary to real Tor cloud without deanonimizing
(0-0-1), (0-1-0), (0-1-1), (1-0-1) -partially known to adversary, but cause a
broken connection (not working circuits)
(1-0-0), (1-1-0) - partialy known, but not deanonimizing by adversary, working
if adversary reroute this from virtual Tor simulator to real Tor cloud.

With 50% falsed keys and virtualized nodes an adversary haves only 1/8 deanonimizing
circuits and user haves 50% broken circuits.

Too many broken circuits or blocked connections with stable high disturbance of
S in close steps of consensus refreshes is a sign of attack too.

Real scenario for attack is one step blocking all nodes (except false
DA's), waiting of downloads false concensus from rogue DA and replace
100% of nodes keys for simulate virtual Tor network without giving any
chance to user escapes from virtual Tor to real Tor.

It's possible from these examples to develop working and more corrected
numerical recipe to determine the hazardous difference between two network-status
documents. Such offline statistics gathering and analyzing can be performed with
separate tools used by enthusiastic paranoids :)
Maybe this statistics and info about network status can be distributed for peer
review by means of web of trust – based on the existing infrastructure, not
relying on Tor, thus providing one more way of external verification not requiring
any changes in tor source.

Concerned users ("Tor watchers") could print diagrams of suspicious changes and
publish them, or exchange and analyze data using web of trust or other ways to
communicate such DA audits to the public.


We assume the problem need to have a lot of research and experiments to get an
acceptable solution.

"OpenPGP-in-Russia Team"

</body></email><email><emailId>20080316233302</emailId><senderName>Peter Palfrader</senderName><senderEmail>peter@palfrader.org</senderEmail><timestampReceived>2008-03-16 23:33:02-0400</timestampReceived><subject>Re: openbsd malloc on alpha</subject><body>

On Sun, 16 Mar 2008, Nick Mathewson wrote:

&gt; &gt; it turns out the problem is that the pagesize on alpha is 8k.

&gt; &gt; -#if defined(__sparc__)
&gt; &gt; +#if defined(__sparc__) || defined (__alpha__)
&gt; 
&gt; That's quite clever.  How did you find it?  For now, I'll add an early
&gt; runtime check to make sure that runtime pagesize matches compile-time
&gt; page size when using openbsd-malloc.

I just got lucky.  While looking over the source of openbsd malloc I saw
the special case for sparc and decided to give it try on alpha too.  It
happened to work.

Checking if pagesize matches between compile and runtime seems like a
smart move.

Cheers,
Peter
-- 
                           |  .''`.  ** Debian GNU/Linux **
      Peter Palfrader      | : :' :      The  universal
 http://www.palfrader.org/ | `. `'      Operating System
                           |   `-    http://www.debian.org/
</body></email><email><emailId>20080317034214</emailId><senderName>Jacob Appelbaum</senderName><senderEmail>jacob@appelbaum.net</senderEmail><timestampReceived>2008-03-17 03:42:14-0400</timestampReceived><subject>Re: Passing language code to check.torproject.org</subject><body>

Steven J. Murdoch wrote:
&gt; On Fri, Mar 14, 2008 at 06:55:11PM -0700, Jacob Appelbaum wrote:
&gt;&gt; Yes. I agree. It's quite useful to mask that. In the event of the user
&gt;&gt; not having Torbutton enabled - Am I right to assume that they would
&gt;&gt; probably leak their language choice? I think it will but I'm an English
&gt;&gt; speaker and I haven't tested it.
&gt; 
&gt; Yes, Firefox will by default state its preferences for language and
&gt; character set. Torbutton hides these when enabled.

Ok, that's what I thought.

&gt; 
&gt;&gt; How do you feel about using https for this? Phobos bought us a cert that
&gt;&gt; should be good for the rest of the year. Ideally, if we use SSL, we're
&gt;&gt; going to have even less of an issue leaking possible linkable language
&gt;&gt; information to exit nodes.
&gt; 
&gt; That sounds like a good idea. I've applied the change.

Great.

&gt; 
&gt;&gt; We probably also want to ensure that any link on check.tpo doesn't leak
&gt;&gt; a referring url that includes their language choice.
&gt; 
&gt; Right. This needs more investigation, but one option is to set a
&gt; cookie with the language setting, and then redirect to a different
&gt; page. Then the referring URL will not include the language choice. We
&gt; would set a cookie, but that would only contain the language, not a
&gt; user ID, and could be set with a very short expiry time.
&gt; 

That seems reasonable. What about people who have disabled cookies?

I had considered just opening a link in a new window. We don't have very
many links and I believe that covers the risk of the referrer?

&gt;&gt; I think this is good providing a switch to https://check.torproject.org
&gt; 
&gt; OK, it's applied and I'll test it before the next release.
&gt; 

Sounds good.

Regards,
Jacob Appelbaum

</body></email><email><emailId>20080410045439</emailId><senderName>coderman</senderName><senderEmail>coderman@gmail.com</senderEmail><timestampReceived>2008-04-10 04:54:39-0400</timestampReceived><subject>Re: IPv6 Exit [was: Status of Tor proposals ...]</subject><body>

On Wed, Apr 9, 2008 at 9:36 PM, Nick Mathewson &lt;nickm@freehaven.net&gt; wrote:
&gt; ...
&gt;    117  IPv6 exits
&gt;
&gt;         This is a good start but could use some revision.  See earlier
&gt;         thread.  I want to merge in IPv6 support in 0.2.1.x, including
&gt;         support for both entries and exits, so a revision of this
&gt;         proposal is important.  Marking as NEEDS-REVISION.


i'm probably just overlooking an obvious discussion, but i don't see a
thread related to IPv6 entry support and/or the previous thread
referenced here.

does the "entry" support imply full IPv6 support?  (or is "entry"
simply the requisite client support for utilizing IPv6 exit
capability?)


&gt; Other problems are:
&gt;    - The process doesn't seem to look far enough future.  We seem
&gt;     to be planning for the next release, but not for the next two or
&gt;     three years.

the UDP/DTLS re-architecture could fit the 3 year time frame ... :P

(a half joke; this is incredibly complicated, and the easy approaches
like TCP over UDP will suck in addition to compromising anonymity...
of course, the challenge is half the fun, right?)
</body></email><email><emailId>20080410051825</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-04-10 05:18:25-0400</timestampReceived><subject>Re: IPv6 Exit [was: Status of Tor proposals ...]</subject><body>

On Wed, Apr 09, 2008 at 09:54:39PM -0700, coderman wrote:
&gt; On Wed, Apr 9, 2008 at 9:36 PM, Nick Mathewson &lt;nickm@freehaven.net&gt; wrote:
&gt; &gt; ...
&gt; &gt;    117  IPv6 exits
&gt; &gt;
&gt; &gt;         This is a good start but could use some revision.  See earlier
&gt; &gt;         thread.  I want to merge in IPv6 support in 0.2.1.x, including
&gt; &gt;         support for both entries and exits, so a revision of this
&gt; &gt;         proposal is important.  Marking as NEEDS-REVISION.
&gt; 
&gt; 
&gt; i'm probably just overlooking an obvious discussion, but i don't see a
&gt; thread related to IPv6 entry support and/or the previous thread
&gt; referenced here.

Ah, I should have been more explicit here.  I don't recall much
previous discussion on IPv6 entries.  Previous good ipv6 exit proposal
discussion was in July and December:
   http://archives.seul.org/or/dev/Jul-2007/threads.html
     (See "IPv6 exit proposal" thread)
   http://archives.seul.org/or/dev/Dec-2007/threads.html
     (See "Tor Ipv6-Patch" thread)

What I mean by entries is that, if servers with IPv6 addresses
advertise those addresses in addition to their IPv4 addresses, we can
suppport IPv6-only clients.  I hear such things starting to exist in
some obscure-but-important places.

&gt; does the "entry" support imply full IPv6 support?  (or is "entry"
&gt; simply the requisite client support for utilizing IPv6 exit
&gt; capability?)

Full IPv6 support isn't on my personal radar for 0.2.1.x.  Making
server-to-server connections use IPv6 is problematic, because if there
are some Tor nodes without IPv4 addresses, then only nodes with IPv6
addresses can contact them.  But this changes our network topology in
ways that could compromise anonymity and that need to be analyzed.

&gt; &gt; Other problems are:
&gt; &gt;    - The process doesn't seem to look far enough future.  We seem
&gt; &gt;     to be planning for the next release, but not for the next two or
&gt; &gt;     three years.
&gt; 
&gt; the UDP/DTLS re-architecture could fit the 3 year time frame ... :P
&gt; 
&gt; (a half joke; this is incredibly complicated, and the easy approaches
&gt; like TCP over UDP will suck in addition to compromising anonymity...
&gt; of course, the challenge is half the fun, right?)

Right.  Personally, I'd like to target this for some time in 2009 or
2010.  It's big enough that if we don't get a good start desiging it,
it won't go anywhere, though.  I'm glad to see that people are
starting to try things out here in the research field; it's an
ambitious project, but the good ones usually are.

(The above paragraph contains idle musings, and is not to be taken as
committing to a roadmap for 2008-2010.)

not-fully-able-to-belive-it'll-be-2010-so-soon-ly yours, 
-- 
Nick
</body></email><email><emailId>20080410043646</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-04-10 04:36:46-0400</timestampReceived><subject>Status of Tor proposals and proposal process (March 2008)</subject><body>

Hi!  It's been about a year since we announced the new process for
amending the Tor protocol, and it's gone pretty well so far, I think.
It's gotten us better design proposals with more rigor for this stuff
than we've had before, and it's kept us from littering the specs with
stuff that never got implemented.

The message announcing the current process was here:
    http://archives.seul.org/or/dev/Mar-2007/msg00003.html
See that message, and proposal 001, for an overview of how the
proposal process is supposed to work.

Here are the proposals that were accepted and implemented in 0.2.0.x:
   101  Voting on the Tor Directory System
   102  Dropping "opt" from the directory format
   103  Splitting identity key from regularly used signing key
   104  Long and Short Router Descriptors
   122  Network status entries need a new Unnamed flag
   123  Naming authorities automatically create bindings

    These proposals, collectively, describe the improved (more secure
    and less bandwidth-heavy) directory protocol in Tor 0.2.0.x.

   107  Uptime Sanity Checking
   108  Base "Stable" Flag on Mean Time Between Failure
   109  No more than one server per IP address

    These help avoid a set of traffic-hogging attack in the route
    selection algorithm.

   111  Prioritizing local traffic over relayed traffic

    Enables Tor clients to also operate relays while dedicating a certain
    amount of bandwidth to their own traffic (if any).  [Still needs to
    be merged into tor-spec.txt.]

   114  Distributed Storage for Tor Hidden Service Descriptors

    An improved hidden service discovery system by Karsten Loesing to
    remove most of the problems with the older hidden service
    discovery design: descriptor format was a weird binary blob;
    authorities were single points of failure, etc.
     
   119  New PROTOCOLINFO command for controllers

    A way to help controllers tell how Tor expects them to authenticate,
    and what version of the control protocol they're supposed to speak.

   125  Behavior for bridge users, bridge relays, and bridge authorities

    Specifies the basic's of Tor's newer anti-censorship features.
    Needs to be moved into tor-spec.txt, or become a new spec document.

   126  Getting GeoIP data and publishing usage summaries

    Describes a way for the bridge authority/authorities to learn
    which censors are blocking which bridges, without learning info
    that can endanger specific users.

   129  Block Insecure Protocols by Default

    Lets clients warn about (or block) connections to ports that
    almost always risk password exposure.

   105  Version negotiation for the Tor protocol
   106  Checking fewer things during TLS handshakes
   130  Version 2 Tor connection protocol

     These proposals describe our new harder-to-fingerprint TLS
     handshake, and the remaining handshake that we do afterwards.
     Proposal 130 supersedes and draws heavily on proposal 124:
     "Blocking resistant TLS certificate usage".

Here are the currently open/pending proposals.  I'm going to comment a
bit on each; if you want to talk more about one or more of these,
please start a new thread so that this doesn't get horribly confused.
Also remember that all of these have been discussed on or-dev before,
so you'll want to check the archives before replying.

OPEN:
   110  Avoiding infinite length circuits

        Implementation for this is multi-phased, and in-process.  This
        should get revised to reflect current status and moved to
        status ACCEPTED.  Marking as NEEDS-REVISION.

   113  Simplifying directory authority administration

        I think this is mostly done or superseded by 123.  There are
        issues in its problem section that aren't yet solved, but the
        proposal doesn't really claim to say how to solve them AFAICT.
        New proposals to address the remaining issues would be good,
        though.  Marking as SUPERSEDED.

   115  Two Hop Paths
   116  Two hop paths from entry guards

        These both are probably dead at this point: there's been no
        activity for some while.  Both have uncertain anonymity
        implications, especially in light of new path features (like
        bridges) and possible scalability features arma has in mind.
        If anybody wants to resurrect them, a first step will be a
        really thorough analysis of what different attackers can do
        against them.  Marking as DEAD.

   117  IPv6 exits

        This is a good start but could use some revision.  See earlier
        thread.  I want to merge in IPv6 support in 0.2.1.x, including
        support for both entries and exits, so a revision of this
        proposal is important.  Marking as NEEDS-REVISION.

   120  Suicide descriptors when Tor servers stop

        Needs some revision along with a renaming.  Not a bad idea
        IMO, but we should do some simple analysis to figure out
        how much good it will do us in advance.

   121  Hidden Service Authentication

        Karsten's the go-to person for this one.  I haven't looked at
        it in a while, but the basic idea seems sound and valuable.

NEEDS-RESEARCH:

   118  Advertising multiple ORPorts at once

        Good idea.  We should do something like this, but the proposal
        as-written is terribly fragmentary and gnomic.  What twit
        wrote this?  Oh.  Me.  Changing status to DRAFT.

DRAFT:
   127  Relaying dirport requests to Tor download site / website

        I need to think more about how I feel about this one.

   128  Families of private bridges

        Roger is working on this.  It seems like a valuable feature
        for certain anti-censorship models.  Once it's out of DRAFT,
        I'll check it out more closely.

   132  A Tor Web Service For Verifying Correct Browser Configuration
   133  Incorporate Unreachable ORs into the Tor Network
   134  More robust consensus voting with diverse authority sets

        See recent discussion on all of these.

Problems and issues with the current proposal process:

  There are some non-optimal issues with the current proposal process.
  These existed in our old non-process too, but they were less obvious
  there.  The worst one, from my POV, is that discussion often dies
  out before consensus is reached or before a proposal is finished.
  The best I can think to do here is to do status mails like this more
  often, and to be more explicit about saying stuff like "this issue
  needs to be fixed IMO for the proposal to be accepted" or "I can't
  revise this to work any time soon. Does anybody else want to try?"

  Other problems are:
    - The process doesn't seem to look far enough future.  We seem
      to be planning for the next release, but not for the next two or
      three years.  This is also a planning issue that should get fixed.
    - It's not always trivial to map proposals to their or-dev
      discussions.
    - Versioning and history could be better kept.
    - I don't think we've made it clear what needs/merits a proposal
      and what doesn't.
    - As far as I can no, nobody is using proposal 098 (A list of
      proposals to write) or 099 (miscellaneous micro-proposals).
      Perhaps they should get fixed or retired.
 
   There are probably other issues too.

In the interest of ending on a positive note:

  Summarizing all the stuff we've talked about here has made me really
  proud of everything that we as a software project have built in Tor
  0.2.0.x.  Many thanks to everyone who helped or participated!

peace,
-- 
Nick
</body></email><email><emailId>20080418053332</emailId><senderName>Fabian Keil</senderName><senderEmail>freebsd-listen@fabiankeil.de</senderEmail><timestampReceived>2008-04-18 05:33:32-0400</timestampReceived><subject>Bug: buffers.c:1688: assert_buf_ok: Assertion ch-&gt;data &gt;=</subject><body>


A few days ago one of my servers triggered:

Apr 10 17:07:45.728 [notice] Tor 0.2.0.23-rc (r14173) opening log file.
Apr 10 17:07:46.005 [warn] I have no descriptor for the router named "zwiebelkuchen" \
in my declared family; I'll use the nickname as is, but this may confuse clients. Apr \
10 17:07:46.005 [warn] I have no descriptor for the router named "zwiebelsuppe" in my \
declared family; I'll use the nickname as is, but this may confuse clients. Apr 10 \
17:07:46.052 [notice] Your Tor server's identity key fingerprint is 'SlickLittleGirl \
AD35 6EF8 E87A 89E6 C898 B745 00D5 8607 AC69 1178' Apr 10 17:07:53.825 [notice] I \
learned some more directory information, but not enough to build a circuit: We have \
no recent network-status consensus. Apr 10 17:07:54.190 [notice] Self-testing \
indicates your ORPort is reachable from the outside. Excellent. Publishing server \
descriptor. Apr 10 17:08:09.066 [notice] We now have enough directory information to \
build circuits. Apr 10 17:08:11.621 [notice] Tor has successfully opened a circuit. \
Looks like client functionality is working. Apr 10 17:08:18.088 [notice] Self-testing \
indicates your DirPort is reachable from the outside. Excellent. Apr 10 17:08:18.375 \
[notice] Performing bandwidth self-test...done. Apr 11 12:25:25.848 [err] Bug: \
buffers.c:1688: assert_buf_ok: Assertion ch-&gt;data &gt;= &amp;ch-&gt;mem[0] failed; aborting.

Unfortunately it doesn't look like a core dump has been created.

The system is running Debian (didn't have the time to
depinguinate it yet) with the noreply.org binaries.

Fabian


["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20080413151915</emailId><senderName>Peter Palfrader</senderName><senderEmail>peter@palfrader.org</senderEmail><timestampReceived>2008-04-13 15:19:15-0400</timestampReceived><subject>Proposal: Download consensus documents only when it will be trusted</subject><body>

This came up in the More robust consensus voting with diverse authority
sets thread but is a different issue.

There are several open issues throughout the proposal and they are
marked with XXX in the text.


Filename: 134-robust-voting.txt
Title: Download consensus documents only when it will be trusted
Author: Peter Palfrader
Created: 2008-04-13
Status: Draft

Overview:

  Servers only provide consensus documents to clients when it is known that
  the client will trust it.


Motivation:

  When clients[1] want a new network status consensus they request it
  from a Tor server using the URL path /tor/status-vote/current/consensus.
  Then after downloading the client checks if this consensus can be
  trusted.  Whether the client trusts the consensus depends on the
  authorities that the client trusts and how many of those
  authorities signed the consensus document.

  If the client cannot trust the consensus document it is disregarded
  and a new download is tried at a later time.  Several hundred
  kilobytes of server bandwidth were wasted by this single client's
  request.

  With hundreds of thousands of clients this will have undesirable
  consequences when the list of authorities has changed so much that a
  large number of established clients no longer can trust any consensus
  document formed.

Objective:

  The objective of this proposal is to make clients not download
  consensuses they will not trust.

Proposal:

  The list of authorities that are trusted by a client are encoded in
  the URL they send to the directory server when requesting a consensus
  document.

  The directory server then only sends back the consensus when more than
  half of the authorities listed in the request have signed the
  consensus.  If it is known that the consensus will not be trusted
  a reasonable error code is sent back to the client.
  [XXX: What is a reasonable error code?
        "404 no pon^Wconsensus for you"?]

  This proposal does not require directory caches to keep more than one
  consensus document.  This proposal also does not require authorities
  to verify the signature on the consensus document of authorities they
  do not recognize.

  [XXX: Do caches keep signatures from authorities they do not recognize
        on the consensus document they download currently?  If not, they
        should.]
  [XXX: Is using the existence of a directory-signature block at the end
        of the consensus sufficient to tell if an authority has signed
        the consensus?  Can anybody just post signatures and we will
        distribute them, or will an authority that appends them to the
        consensus verify the signature, and that this signature's
        creator is listed in the consensus's dir-source?]

  The new URL scheme to download a consensus is
  /tor/status-vote/current/consensus/&lt;F&gt; where F is a list of
  fingerprints, sorted in ascending order, and concatenated using a +
  sign.

  Fingerprints are uppercase hexadecimal encodings of the authority
  identity key's digest.  Servers should also accept requests that
  use lower case or mixed case hexadecimal encodings.

  [XXX: Can we get away with a shortened hex digest?  40 characters per
        authority brings us up to 600 bytes just for fingerprint part of
        the GET URL, and some proxies might have issues with URLs that
        get much longer than that.  What's the worst that can happen
        when we only use the significant 2 or so bytes (4 hex chars)
        for this purpose?]

  A .z URL for compressed versions of the consensus will be provided
  similarly to existing resources and is the URL that usually should
  be used by clients.

Migration:

  The old location of the consensus should continue to work
  indefinitely.  Not only is it used by old clients, but it is a useful
  resource for automated tools that do not particularly care which
  authorities have signed the consensus.

  Authorities that are known to the client a priori by being shipped
  with the Tor code are assumed to handle this format.
  [XXX: or we add a new flag, "v3c" or whatever to the dirserver
        line.  It depends on how fast we can upgrade the
        authorities before we add this to client code.]

  When downloading a consensus document from caches clients only pick
  caches that are known to support this new format.
  [XXX OR: When downloading a consensus document from caches that
           do not support this new format they fall back to the old
           download location].

  Caches support the new format starting with Tor version [XXX].

Anonymity Implications:

  By supplying the list of authorities a client trusts to the directory
  server we leak information (like likely version of Tor client) to the
  directory server.  In the current system we also leak that we are
  very old - by re-downloading the consensus over and over again, but
  only when we are so old that we no longer can trust the consensus.



Footnotes:
 1. For the purpose of this proposal a client can be any Tor instance
    that downloads a consensus document.  This includes relays,
    directory caches as well as end users.
</body></email><email><emailId>20080413152142</emailId><senderName>Peter Palfrader</senderName><senderEmail>peter@palfrader.org</senderEmail><timestampReceived>2008-04-13 15:21:42-0400</timestampReceived><subject>Re: Proposal: Download consensus documents only when it will be trusted</subject><body>

On Sun, 13 Apr 2008, Peter Palfrader wrote:

&gt;   The list of authorities that are trusted by a client are encoded in
&gt;   the URL they send to the directory server when requesting a consensus
&gt;   document.

A completely different approach is that clients do a HEAD /.../consensus
request.  The head would contain X-signed-by: headers.  If the client is
satisfied that a sufficient number of authorities have signed the
consensus it will then proceed to download it using a GET ../consensus
request as it does now.

Peter
</body></email><email><emailId>20080414001913</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-04-14 00:19:13-0400</timestampReceived><subject>Re: Proposal: Download consensus documents only when it will be trusted</subject><body>

On Sun, Apr 13, 2008 at 05:19:15PM +0200, Peter Palfrader wrote:
&gt; This came up in the More robust consensus voting with diverse authority
&gt; sets thread but is a different issue.
&gt; 
&gt; There are several open issues throughout the proposal and they are
&gt; marked with XXX in the text.
&gt; 
&gt; 
&gt; Filename: 134-robust-voting.txt
&gt; Title: Download consensus documents only when it will be trusted
&gt; Author: Peter Palfrader
&gt; Created: 2008-04-13
&gt; Status: Draft
&gt; 
&gt; Overview:
&gt; 
&gt;   Servers only provide consensus documents to clients when it is known that
&gt;   the client will trust it.

Good idea.
 
  [...]
&gt;   The directory server then only sends back the consensus when more than
&gt;   half of the authorities listed in the request have signed the
&gt;   consensus.  If it is known that the consensus will not be trusted
&gt;   a reasonable error code is sent back to the client.
&gt;   [XXX: What is a reasonable error code?
&gt;         "404 no pon^Wconsensus for you"?]

The client asked for an object we don't have; sounds like a 404 to me.

&gt; 
&gt;   This proposal does not require directory caches to keep more than one
&gt;   consensus document.  This proposal also does not require authorities
&gt;   to verify the signature on the consensus document of authorities they
&gt;   do not recognize.
&gt; 
&gt;   [XXX: Do caches keep signatures from authorities they do not recognize
&gt;         on the consensus document they download currently?  If not, they
&gt;         should.]

They do.

&gt;   [XXX: Is using the existence of a directory-signature block at the end
&gt;         of the consensus sufficient to tell if an authority has signed
&gt;         the consensus?  Can anybody just post signatures and we will
&gt;         distribute them, or will an authority that appends them to the
&gt;         consensus verify the signature, and that this signature's
&gt;         creator is listed in the consensus's dir-source?]

We should look at this.  Right now, we should not accept any signature
from an authority not listed in the consensus as having contributed to
the consensus.  (That is, if there isn't a dir-source line for a given
identity key, we shouldn't accept a signature corresponding to it.)

&gt;   The new URL scheme to download a consensus is
&gt;   /tor/status-vote/current/consensus/&lt;F&gt; where F is a list of
&gt;   fingerprints, sorted in ascending order, and concatenated using a +
&gt;   sign.
&gt; 
&gt;   Fingerprints are uppercase hexadecimal encodings of the authority
&gt;   identity key's digest.  Servers should also accept requests that
&gt;   use lower case or mixed case hexadecimal encodings.
&gt;
&gt; 
&gt;   [XXX: Can we get away with a shortened hex digest?  40 characters per
&gt;         authority brings us up to 600 bytes just for fingerprint part of
&gt;         the GET URL, and some proxies might have issues with URLs that
&gt;         get much longer than that.  What's the worst that can happen
&gt;         when we only use the significant 2 or so bytes (4 hex chars)
&gt;         for this purpose?]

The worst is that the client gets back a consensus it didn't want if
some new authority winds up having a key that matches the key the
client wants in the first N byets.  That doesn't seem disasterous.

&gt;   A .z URL for compressed versions of the consensus will be provided
&gt;   similarly to existing resources and is the URL that usually should
&gt;   be used by clients.
&gt; 
&gt; Migration:
&gt; 
&gt;   The old location of the consensus should continue to work
&gt;   indefinitely.  Not only is it used by old clients, but it is a useful
&gt;   resource for automated tools that do not particularly care which
&gt;   authorities have signed the consensus.
&gt; 
&gt;   Authorities that are known to the client a priori by being shipped
&gt;   with the Tor code are assumed to handle this format.
&gt;   [XXX: or we add a new flag, "v3c" or whatever to the dirserver
&gt;         line.  It depends on how fast we can upgrade the
&gt;         authorities before we add this to client code.]

I don't want to add more flags for this; assuming all the authorities
have upgraded like this is probably OK.

&gt;   When downloading a consensus document from caches clients only pick
&gt;   caches that are known to support this new format.
&gt;   [XXX OR: When downloading a consensus document from caches that
&gt;            do not support this new format they fall back to the old
&gt;            download location].

Falling back to the old location seems smart, or else new clients will
totally stop using old directory servers for consensuses.
 
&gt;   Caches support the new format starting with Tor version [XXX].
&gt; 
&gt; Anonymity Implications:
&gt; 
&gt;   By supplying the list of authorities a client trusts to the directory
&gt;   server we leak information (like likely version of Tor client) to the
&gt;   directory server.  In the current system we also leak that we are
&gt;   very old - by re-downloading the consensus over and over again, but
&gt;   only when we are so old that we no longer can trust the consensus.

Hm.  I don't think that the old approach leaks the exact version quite
so immediately as the new one does, but I agree that the information
extractable is about the same.

&gt; Footnotes:
&gt;  1. For the purpose of this proposal a client can be any Tor instance
&gt;     that downloads a consensus document.  This includes relays,
&gt;     directory caches as well as end users.

</body></email><email><emailId>20080414054505</emailId><senderName>Sebastian Hahn</senderName><senderEmail>hahn.seb@web.de</senderEmail><timestampReceived>2008-04-14 05:45:05-0400</timestampReceived><subject>Re: Proposal: Download consensus documents only when it will be trusted</subject><body>


On Apr 14, 2008, at 2:19 AM, Nick Mathewson wrote:
&gt; On Sun, Apr 13, 2008 at 05:19:15PM +0200, Peter Palfrader wrote:
&gt;&gt;
&gt;&gt; Anonymity Implications:
&gt;&gt;
&gt;&gt;  By supplying the list of authorities a client trusts to the  
&gt;&gt; directory
&gt;&gt;  server we leak information (like likely version of Tor client) to  
&gt;&gt; the
&gt;&gt;  directory server.  In the current system we also leak that we are
&gt;&gt;  very old - by re-downloading the consensus over and over again, but
&gt;&gt;  only when we are so old that we no longer can trust the consensus.
&gt;
&gt; Hm.  I don't think that the old approach leaks the exact version quite
&gt; so immediately as the new one does, but I agree that the information
&gt; extractable is about the same.

In case it is decided that this leakage is very bad, I thought of  
something:

I do not know whether this will work technically, but couldn't the  
client
decide where to download from? I'm thinking of a "directory descriptor",
and a client asks for one of those at a location. If it is satisfied,  
it requests
the information from that directory, if not, it asks (at a different  
location) for
another descriptor, or a few of them at once. Do you think this could  
work?

OT: Please someone tell me (on IRC or private mail) if my e-mail still  
has a
broken certificate, I'm really trying to fix that problem.

Thanks
Sebastian

["PGP.sig" (application/pgp-signature)]

</body></email><email><emailId>20080421202441</emailId><senderName>Peter Palfrader</senderName><senderEmail>peter@palfrader.org</senderEmail><timestampReceived>2008-04-21 20:24:41-0400</timestampReceived><subject>Re: Proposal: Download consensus documents only when it will be trusted</subject><body>

On Sun, 13 Apr 2008, Nick Mathewson wrote:

&gt; &gt; Servers only provide consensus documents to clients when it is known that
&gt; &gt; the client will trust it.

Here's a first go at the server side.


diff --git a/src/or/directory.c b/src/or/directory.c
index aee76a5..b2fe369 100644
--- a/src/or/directory.c
+++ b/src/or/directory.c
@@ -2290,7 +2290,7 @@ directory_handle_command_get(dir_connection_t *conn, const char \
*headers,  }
 
   if (!strcmpstart(url,"/tor/status/")
-      || !strcmp(url, "/tor/status-vote/current/consensus")) {
+      || !strcmpstart(url, "/tor/status-vote/current/consensus")) {
     /* v2 or v3 network status fetch. */
     smartlist_t *dir_fps = smartlist_create();
     int is_v3 = !strcmpstart(url, "/tor/status-vote");
@@ -2311,6 +2311,52 @@ directory_handle_command_get(dir_connection_t *conn, const \
char *headers,  } else {
       networkstatus_t *v = networkstatus_get_latest_consensus();
       time_t now = time(NULL);
+      /* clients can say they only want a consensus if it's signed by more
+       * than half the authorities in &lt;list&gt;.  They pass this list in
+       * the url as ..consensus/&lt;fpr&gt;+&lt;fpr&gt;+&lt;fpr&gt;
+       * &lt;fpr&gt; may be an abbreviated fingerprint, i.e. only a left substring
+       * of the full authority identity digest.
+       */
+      #define CONSENSUS_URL_PREFIX "/tor/status-vote/current/consensus/"
+      int signer_list = !strcmpstart(url, CONSENSUS_URL_PREFIX);
+      if (signer_list) {
+        const char *want_url = url + strlen(CONSENSUS_URL_PREFIX);
+        smartlist_t *want = smartlist_create();
+        smartlist_t *voterdigests = smartlist_create();
+        int need_at_least = 0;
+        int have = 0;
+
+        SMARTLIST_FOREACH(v-&gt;voters, networkstatus_voter_info_t *, vi, {
+          char *d = tor_malloc(HEX_DIGEST_LEN+1);
+          base16_encode(d, HEX_DIGEST_LEN+1, vi-&gt;identity_digest, DIGEST_LEN);
+          smartlist_add(voterdigests, d);
+        });
+
+        dir_split_resource_into_fingerprints(want_url, want, NULL, 0, 0);
+        need_at_least = smartlist_len(want)/2+1;
+        SMARTLIST_FOREACH(want, const char *, d, {
+          SMARTLIST_FOREACH(voterdigests, char *, voter, {
+            if (!strcasecmpstart(voter, d)) {
+              have++;
+              tor_free(voter);
+              SMARTLIST_DEL_CURRENT(voterdigests, voter);
+            };
+          });
+        });
+
+        SMARTLIST_FOREACH(voterdigests, char *, d, tor_free(d));
+        smartlist_free(voterdigests);
+
+        SMARTLIST_FOREACH(want, char *, d, tor_free(d));
+        smartlist_free(want);
+
+        if (have &lt; need_at_least) {
+          write_http_status_line(conn, 404, "No consensus signed by sufficient \
number of requested authorities"); +          smartlist_free(dir_fps);
+          goto done;
+        }
+      }
+
       smartlist_add(dir_fps, tor_memdup("\0\0\0\0\0\0\0\0\0\0"
                                         "\0\0\0\0\0\0\0\0\0\0", 20));
       request_type = compressed?"v3.z":"v3";


Should we keep the list of encoded hexdigests around all the time?  Or
should we not compare the hex encoded strings but instead the binary
representation?

And why is there no function/macro that combines individual items being
freed and then freeing the smartlist?  That seems to be needed quite
often.

Peter


</body></email><email><emailId>20080314115420</emailId><senderName>"Steven J. Murdoch"</senderName><senderEmail>tor+steven.murdoch@cl.cam.ac.uk</senderEmail><timestampReceived>2008-03-14 11:54:20-0400</timestampReceived><subject>Passing language code to check.torproject.org</subject><body>

[ Cc'ing or-dev in case anyone else wants to contribute ]

Jacob,

Since the Tor Browser Bundle uses Torbutton, Firefox reports that it
is using US English to websites. This is good because it hides what
country a particular user is coming from, and so increases the size of
the anonymity set.

Tor Browser Bundle has check.torproject.org as the homepage, which is
currently only in English. However, even if it were translated, it
cannot automatically show the right language, because of TorButton's
language cloaking.

I think the simplest solution is for the default homepage for Tor
Browser Bundle to be set to include the language code, e.g.
 http://check.torproject.org/?lang=zh-CN

This will allow the check page to display the right language, while
not leaking that to other sites.

The down-side is that check.torproject.org will get the country code,
but I think that is less of a problem. The site would only learn that
a particular anonymous user has configured a certain language with the
Tor Browser Bundle. 

This is less sensitive than knowing that a particular user has set
this language and is interested in this particular website.

Any thoughts? If there are no objections, I'll add this to the next
version of the bundle. Currently check.torproject.org appears to
ignore the language code, so it won't make a difference now, but will
be ready when the site is translated.

Steven.

-- 
w: http://www.cl.cam.ac.uk/users/sjm217/
</body></email><email><emailId>20080315015511</emailId><senderName>Jacob Appelbaum</senderName><senderEmail>jacob@appelbaum.net</senderEmail><timestampReceived>2008-03-15 01:55:11-0400</timestampReceived><subject>Re: Passing language code to check.torproject.org</subject><body>

Steven J. Murdoch wrote:
&gt; [ Cc'ing or-dev in case anyone else wants to contribute ]
&gt; 
&gt; Jacob,
&gt; 
&gt; Since the Tor Browser Bundle uses Torbutton, Firefox reports that it
&gt; is using US English to websites. This is good because it hides what
&gt; country a particular user is coming from, and so increases the size of
&gt; the anonymity set.

Yes. I agree. It's quite useful to mask that. In the event of the user
not having Torbutton enabled - Am I right to assume that they would
probably leak their language choice? I think it will but I'm an English
speaker and I haven't tested it.

&gt; 
&gt; Tor Browser Bundle has check.torproject.org as the homepage, which is
&gt; currently only in English. However, even if it were translated, it
&gt; cannot automatically show the right language, because of TorButton's
&gt; language cloaking.
&gt; 

Right.

&gt; I think the simplest solution is for the default homepage for Tor
&gt; Browser Bundle to be set to include the language code, e.g.
&gt;  http://check.torproject.org/?lang=zh-CN

How do you feel about using https for this? Phobos bought us a cert that
should be good for the rest of the year. Ideally, if we use SSL, we're
going to have even less of an issue leaking possible linkable language
information to exit nodes.

We probably also want to ensure that any link on check.tpo doesn't leak
a referring url that includes their language choice.

&gt; 
&gt; This will allow the check page to display the right language, while
&gt; not leaking that to other sites.

It does seem like a reasonable thing to do at some point. I certainly
have wanted to integrate the language with the "it doesn't appear that
you are using Tor" message. It's not very helpful to have that in a
language someone doesn't understand.

&gt; 
&gt; The down-side is that check.torproject.org will get the country code,
&gt; but I think that is less of a problem. The site would only learn that
&gt; a particular anonymous user has configured a certain language with the
&gt; Tor Browser Bundle. 
&gt; 

Right. I think this underscores the need for trust in running
check.torproject.org.

&gt; This is less sensitive than knowing that a particular user has set
&gt; this language and is interested in this particular website.
&gt; 
&gt; Any thoughts? If there are no objections, I'll add this to the next
&gt; version of the bundle. Currently check.torproject.org appears to
&gt; ignore the language code, so it won't make a difference now, but will
&gt; be ready when the site is translated.
&gt; 

I think this is good providing a switch to https://check.torproject.org

Best,
Jake

</body></email><email><emailId>20080317133357</emailId><senderName>"Toby Douglass"</senderName><senderEmail>toby.douglass@45mercystreet.com</senderEmail><timestampReceived>2008-03-17 13:33:57-0400</timestampReceived><subject>select()</subject><body>

Hi.

I installed Tor on the weekend.  I've noticed that when I have a large
number of concurrent sockets open - say, browsing with half a dozen tabs
or more - everything actually *stops*.  I have to stop loading all the
tabs, and then go back to doing them, say, one by one.

Would I be right in saying this is because select() is getting overwhelmed?



</body></email><email><emailId>20080317134159</emailId><senderName>"Jonathan Yu"</senderName><senderEmail>jonathan.i.yu@gmail.com</senderEmail><timestampReceived>2008-03-17 13:41:59-0400</timestampReceived><subject>Re: select()</subject><body>

Hi there:

I am by no means an expert, but I don't think that this is the case.
Tor uses libevent, which will automatically select the best I/O
multiplexing system; this is probably anything but select() on your
system. Hopefully it's an event-based system like kqueue (BSD) or
realtime signals (Linux).

There will probably be logs in the Tor console if this is indeed the
case.... My first advice would be to take a look there. It may be
because your system has run out of memory and begun swapping to disk?
Not knowing the characteristics of your installation, it is difficult
to tell.

I hope this helps, but if you want more complete advice I suggest you
submit information such as your system specifications, operating
system, configuration, and so forth.

Regards,

Jon

On Mon, Mar 17, 2008 at 8:33 AM, Toby Douglass
&lt;toby.douglass@45mercystreet.com&gt; wrote:
&gt; Hi.
&gt;
&gt;  I installed Tor on the weekend.  I've noticed that when I have a large
&gt;  number of concurrent sockets open - say, browsing with half a dozen tabs
&gt;  or more - everything actually *stops*.  I have to stop loading all the
&gt;  tabs, and then go back to doing them, say, one by one.
&gt;
&gt;  Would I be right in saying this is because select() is getting overwhelmed?
&gt;
&gt;
&gt;
&gt;
</body></email><email><emailId>200803171341590</emailId><senderName>"Jonathan Yu"</senderName><senderEmail>jonathan.i.yu@gmail.com</senderEmail><timestampReceived>2008-03-17 13:41:59-0400</timestampReceived><subject>Re: select()</subject><body>

Hi there:

I am by no means an expert, but I don't think that this is the case.
Tor uses libevent, which will automatically select the best I/O
multiplexing system; this is probably anything but select() on your
system. Hopefully it's an event-based system like kqueue (BSD) or
realtime signals (Linux).

There will probably be logs in the Tor console if this is indeed the
case.... My first advice would be to take a look there. It may be
because your system has run out of memory and begun swapping to disk?
Not knowing the characteristics of your installation, it is difficult
to tell.

I hope this helps, but if you want more complete advice I suggest you
submit information such as your system specifications, operating
system, configuration, and so forth.

Regards,

Jon

On Mon, Mar 17, 2008 at 8:33 AM, Toby Douglass
&lt;toby.douglass@45mercystreet.com&gt; wrote:
&gt; Hi.
&gt;
&gt;  I installed Tor on the weekend.  I've noticed that when I have a large
&gt;  number of concurrent sockets open - say, browsing with half a dozen tabs
&gt;  or more - everything actually *stops*.  I have to stop loading all the
&gt;  tabs, and then go back to doing them, say, one by one.
&gt;
&gt;  Would I be right in saying this is because select() is getting overwhelmed?
&gt;
&gt;
&gt;
&gt;
</body></email><email><emailId>20080317134532</emailId><senderName>"Toby Douglass"</senderName><senderEmail>toby.douglass@45mercystreet.com</senderEmail><timestampReceived>2008-03-17 13:45:32-0400</timestampReceived><subject>Re: select()</subject><body>

Jonathan Yu wrote:
&gt; Hi there:
&gt;
&gt; I am by no means an expert, but I don't think that this is the case.
&gt; Tor uses libevent, which will automatically select the best I/O
&gt; multiplexing system; this is probably anything but select() on your
&gt; system. Hopefully it's an event-based system like kqueue (BSD) or
&gt; realtime signals (Linux).

I omitted specifing that I am in fact running on Windows 2000.  Libevent
uses select() *only* under Windows.

BTW, I note this reply was to "or-dev@freehaven.net" and cc:'d
"or-dev@seul.org".  Why the two addresses?  I've left freehaven as a cc:
just in case.


</body></email><email><emailId>200803171345320</emailId><senderName>"Toby Douglass"</senderName><senderEmail>toby.douglass@45mercystreet.com</senderEmail><timestampReceived>2008-03-17 13:45:32-0400</timestampReceived><subject>Re: select()</subject><body>

Jonathan Yu wrote:
&gt; Hi there:
&gt;
&gt; I am by no means an expert, but I don't think that this is the case.
&gt; Tor uses libevent, which will automatically select the best I/O
&gt; multiplexing system; this is probably anything but select() on your
&gt; system. Hopefully it's an event-based system like kqueue (BSD) or
&gt; realtime signals (Linux).

I omitted specifing that I am in fact running on Windows 2000.  Libevent
uses select() *only* under Windows.

BTW, I note this reply was to "or-dev@freehaven.net" and cc:'d
"or-dev@seul.org".  Why the two addresses?  I've left freehaven as a cc:
just in case.


</body></email><email><emailId>20080317135021</emailId><senderName>"Jonathan Yu"</senderName><senderEmail>jonathan.i.yu@gmail.com</senderEmail><timestampReceived>2008-03-17 13:50:21-0400</timestampReceived><subject>Re: select()</subject><body>

On Mon, Mar 17, 2008 at 8:45 AM, Toby Douglass
&lt;toby.douglass@45mercystreet.com&gt; wrote:
&gt; Jonathan Yu wrote:
&gt;  &gt; Hi there:
&gt;  &gt;
&gt;  &gt; I am by no means an expert, but I don't think that this is the case.
&gt;  &gt; Tor uses libevent, which will automatically select the best I/O
&gt;  &gt; multiplexing system; this is probably anything but select() on your
&gt;  &gt; system. Hopefully it's an event-based system like kqueue (BSD) or
&gt;  &gt; realtime signals (Linux).
&gt;
&gt;  I omitted specifing that I am in fact running on Windows 2000.  Libevent
&gt;  uses select() *only* under Windows.
I would suggest running Tor in a normal console window (not a service)
and seeing what log messages pop up when the slowdown occurs.

Optionally, you can dig through torrc (which is not included in the
Windows install by default) to find the appropriate option, or use a
controller like Vidalia to adjust the configuration so as to view the
log data.
&gt;
&gt;  BTW, I note this reply was to "or-dev@freehaven.net" and cc:'d
&gt;  "or-dev@seul.org".  Why the two addresses?  I've left freehaven as a cc:
&gt;  just in case.
I suppose I'm just registered to a different list, but they are
probably cross-posted appropriately.
&gt;
&gt;
&gt;
</body></email><email><emailId>20080310184652</emailId><senderName>"Steven J. Murdoch"</senderName><senderEmail>tor+steven.murdoch@cl.cam.ac.uk</senderEmail><timestampReceived>2008-03-10 18:46:52-0400</timestampReceived><subject>Improving the robustness of Tor Check</subject><body>

The default home page for the Tor Browser Bundle is
http://check.torproject.org/ which tells the user whether they are
using Tor. This catches quite a few misconfiguration errors so is very
valuable for usability and security.

However, there are a few cases of where it will get it wrong. This in
itself is undesirable and it also means that the message shown is
qualified as "probably", which is disconcerting.

These errors (false positives and false negatives) are inherent to the
approach taken by Tor Check (and the other services). To resolve them
a new design is needed. The proposal below suggests how this could be
implemented.

Any comments would be appreciated. I'd be especially interested in
spotting any security issues, and how to more easily implement it.

Steven.

----
Filename: xxx-verify-tor-usage.txt
Title: Help users to verify they are using Tor
Version: $Revision: 13937 $
Last-Modified: $Date: 2008-03-10 11:08:31 +0000 (Mon, 10 Mar 2008) $
Author: Steven J. Murdoch
Created: 2008-01-25
Status: Needs-Revision

Overview:

  Websites for checking whether a user is accessing them via Tor are a
  very helpful aid to configuring web browsers correctly. Existing
  solutions have both false positives and false negatives when
  checking if Tor is being used. This proposal will discuss how to
  modify Tor so as to make testing more reliable.

Motivation:

  Currently deployed websites for detecting Tor use work by comparing
  the client IP address for a request with a list of known Tor nodes.
  This approach is generally effective, but suffers from both false
  positives and false negatives. 

  If a user has a Tor exit node installed, or just happens to have
  been allocated an IP address previously used by a Tor exit node, any
  web requests will be incorrectly flagged as coming from Tor. If any
  customer of an ISP which implements a transparent proxy runs an exit
  node, all other users of the ISP will be flagged as Tor users.

  Conversely, if the exit node chosen by a Tor user has not yet been
  recorded by the Tor checking website, requests will be incorrectly
  flagged as not coming via Tor.
  
  The only reliable way to tell whether Tor is being used or not is for
  the Tor client to flag this to the browser.

Proposal:

  A DNS name should be registered and point to an IP address 
  controlled by the Tor project and likely to remain so for the
  useful lifetime of a Tor client. A web server should be placed
  at this IP address.
  
  Tor should be modified to treat requests to port 80, at the
  specified DNS name or IP address specially. Instead of opening a
  circuit, it should respond to a HTTP request with a helpful web
  page:

  - If the request to open a connection was to the domain name, the web
    page should state that Tor is working properly.
  - If the request was to the IP address, the web page should state
    that there is a DNS-leakage vulnerability.

  If the request goes through to the real web server, the page
  should state that Tor has not been set up properly.

Extensions:

  Identifying proxy server:

  If needed, other applications between the web browser and Tor (e.g.
  Polipo and Privoxy) could piggyback on the same mechanism to flag
  whether they are in use. All three possible web pages should include
  a machine-readable placeholder, into which another program could
  insert their own message.

  For example, the webpage returned by Tor to indicate a successful
  configuration could include the following HTML:
   &lt;h2&gt;Connection chain&lt;/h2&gt;
   &lt;ul&gt;
   &lt;li&gt;Tor 0.1.2.14-alpha
   &lt;!-- Tor Connectivity Check: success --&gt;
   &lt;/ul&gt;

  When the proxy server observes this string, in response to a request
  for the Tor connectivity check web page, it would prepend it's own
  message, resulting in the following being returned to the web
  browser:
   &lt;h2&gt;Connection chain
   &lt;ul&gt;
   &lt;li&gt;Tor 0.1.2.14-alpha
   &lt;li&gt;Polipo version 1.0.4
   &lt;!-- Tor Connectivity Check: success --&gt;
   &lt;/ul&gt;

  Checking external connectivity:

  If Tor intercepts a request, and returns a response itself, the user
  will not actually confirm whether Tor is able to build a successful
  circuit. It may then be advantageous to include an image in the web
  page which is loaded from a different domain. If this is able to be
  loaded then the user will know that external connectivity through
  Tor works.

Security and resiliency implications:

  What attacks are possible?

  If the IP addressed used for this feature moves there will be two
  consequences:
   - A new website at this IP address will remain inaccessible over
     Tor
   - Tor users who are leaking DNS will be informed that Tor is not
     working, rather than that it is active but leaking DNS
  We should thus attempt to find an IP address which we reasonably
  belive can remain static.

Open issues:

  If a Tor version which does not support this extra feature is used,
  the webpage returned will indicate that Tor is not being used. Can
  this be safely fixed?

Related work:

  The proposed mechanism is very similar to config.privoxy.org. The
  most significant difference is that if the web browser is
  misconfigured, Tor will only get an IP address. Even in this case,
  Tor should be able to respond with a webpage to notify the user of how
  to fix the problem. This also implies that Tor must be told of the
  special IP address, and so must be effectively permanent.
---

-- 
w: http://www.cl.cam.ac.uk/users/sjm217/
</body></email><email><emailId>20080316202547</emailId><senderName>Robert Hogan</senderName><senderEmail>robert@roberthogan.net</senderEmail><timestampReceived>2008-03-16 20:25:47-0400</timestampReceived><subject>A Tor Web Service For Verifying Correct Browser Configuration</subject><body>


Filename: xxx-browser-check-tor-service.txt
Title: A Tor Web Service For Verifying Correct Browser Configuration
Version: $Revision: 13955 $
Last-Modified: $Date: 2008-03-16 18:51:55 +0000 (Sun, 16 Mar 2008) $
Author: Robert Hogan
Created: 2008-03-08
Status: Draft

Overview:

  Tor should operate a primitive web service on the loopback network device
  that tests the operation of user's browser, privacy proxy and Tor client.
  The tests are performed by serving unique, randomly generated elements in
  image URLs embedded in static HTML. The images are only displayed if the DNS
  and HTTP requests for them are routed through Tor, otherwise the 'alt' text
  may be displayed. The proposal assumes that 'alt' text is not displayed on
  all browsers so suggests that text and links should accompany each image
  advising the user on next steps in case the test fails.

  The service is primarily for the use of controllers, since presumably users
  aren't going to want to edit text files and then type something exotic like
  127.0.0.1:9999 into their address bar. In the main use case the controller
  will have configured the actual port for the webservice so will know where
  to direct the request. It would also be the responsibility of the controller
  to ensure the webservice is available, and tor is running, before allowing
  the user to access the page through their browser.

Motivation:

  This is a complementary approach to proposal 131. It overcomes some of the
  limitations of the approach described in proposal 131: reliance
  on a permanent, real IP address and compatibility with older versions of
  Tor. Unlike 131, it is not as useful to Tor users who are not running a
  controller.

Objective:

  Provide a reliable means of helping users to determine if their Tor
  installation, privacy proxy and browser are properly configured for
  anonymous browsing.

Proposal:

  When configured to do so, Tor should run a basic web service available
  on a configured port on 127.0.0.1. The purpose of this web service is to
  serve a number of basic test images that will allow the user to determine
  if their browser is properly configured and that Tor is working normally.

  The service can consist of a single web page with two columns. The left
  column contains images, the right column contains advice on what the
  display/non-display of the column means.

  The rest of this proposal assumes that the service is running on port
  9999. The port should be configurable, and configuring the port enables the
  service. The service must run on 127.0.0.1.

  In all the examples below [uniquesessionid] refers to a random, base64
  encoded string that is unique to the URL it is contained in. Tor only ever
  stores the most recently generated [uniquesessionid] for each URL, storing 3
  in total. Tor should generate a [uniquesessionid] for each of the test URLs
  below every time a HTTP GET is received at 127.0.0.1:9999 for index.htm.

  The most suitable image for each test case is an implementation decision.
  Tor will need to store and serve images for the first and second test
  images, and possibly the third (see 'Open Issues').

  1. DNS Request Test Image
  
  This is a HTML element embedded in the page served by Tor at
  http://127.0.0.1:9999:

  &lt;IMG src="http://[uniquesessionid]:9999/torlogo.jpg" alt="If you can see
  this text, your browser's DNS requests are not being routed through Tor."
  width="200" height="200" align="middle" border="2"&gt;

  If the browser's DNS request for [uniquesessionid] is routed through Tor,
  Tor will intercept the request and return 127.0.0.1 as the resolved IP
  address. This will shortly be followed by a HTTP request from the browser
  for http://127.0.0.1:9999/torlogo.jpg. This request should be served with
  the appropriate image.

  If the browser's DNS request for [uniquesessionid] is not routed through Tor
  the browser may display the 'alt' text specified in the html element. The
  HTML served by Tor should also contain text accompanying the image to advise
  users what it means if they do not see an image. It should also provide a
  link to click that provides information on how to remedy the problem. This
  behaviour also applies to the images described in 2. and 3. below, so should
  be assumed there as well.


  2. Proxy Configuration Test Image

  This is a HTML element embedded in the page served by Tor at
  http://127.0.0.1:9999:

  &lt;IMG src="http://torproject.org/[uniquesessionid].jpg" alt="If you can see
  this text, your browser is not configured to work with Tor." width="200"
  height="200" align="middle" border="2"&gt;

  If the HTTP request for the resource [uniquesessionid].jpg is received by
  Tor it will serve the appropriate image in response. It should serve this
  image itself, without attempting to retrieve anything from the Internet.

  If Tor can identify the name of the proxy application requesting the
  resource then it could store and serve an image identifying the proxy to the
  user.

  3. Tor Connectivity Test Image

  This is a HTML element embedded in the page served by Tor at
  http://127.0.0.1:9999:

  &lt;IMG src="http://torproject.org/[uniquesessionid]-torlogo.jpg" alt="If you
  can see this text, your Tor installation cannot connect to the Internet."
  width="200" height="200" align="middle" border="2"&gt;

  The referenced image should actually exist on the Tor project website. If
  Tor receives the request for the above resource it should remove the random
  base64 encoded digest from the request (i.e. [uniquesessionid]-) and attempt
  to retrieve the real image.

  Even on a fully operational Tor client this test may not always succeed. The
  user should be advised that one or more attempts to retrieve this image may
  be necessary to confirm a genuine problem.

Open Issues:

  The final connectivity test relies on an externally maintained resource, if
  this resource becomes unavailable the connectivity test will always fail.
  Either the text accompanying the test should advise of this possibility or
  Tor clients should be advised of the location of the test resource in the
  main network directory listings.

  Any number of misconfigurations may make the web service unreachable, it is
  the responsibility of the user's controller to recognize these and assist
  the user in eliminating them. Tor can mitigate against the specific
  misconfiguration of routing HTTP traffic to 127.0.0.1 to Tor itself by
  serving such requests through the SOCKS port as well as the configured web
  service report.

  Now Tor is inspecting the URLs requested on its SOCKS port and 'dropping'
  them. It already inspects for raw IP addresses (to warn of DNS leaks) but
  maybe the behaviour proposed here is qualitatively different. Maybe this is
  an unwelcome precedent that can be used to beat the project over the head in
  future. Or maybe it's not such a bad thing, Tor is merely attempting to make
  normally invalid resource requests valid for a given purpose.


["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20080324221044</emailId><senderName>Robert Hogan</senderName><senderEmail>robert@roberthogan.net</senderEmail><timestampReceived>2008-03-24 22:10:44-0400</timestampReceived><subject>Fwd: Proposal: Incorporate Unreachable ORs into the Tor Network</subject><body>


On Saturday 22 March 2008 15:13:10 Nick Mathewson wrote:
&gt; On Sat, Mar 22, 2008 at 11:11:12AM +0000, Robert Hogan wrote:
&gt; &gt; I'm not sure how much merit this proposal has, or how serious it's
&gt; &gt; problems are.  Does anyone have any thoughts on it? Are the problems
&gt; &gt; I've outlined fatal, or is there a problem with it I've missed? I
&gt; &gt; suspect one or the other.
&gt;
&gt; Hi, Robert!  I think this is definitely a step in the right direction,
&gt; with some tricky issues associated with it.  In particular, it
&gt; represents a big deviation from Tor's current clique topology.  We
&gt; should definitely drop the clique assumption (for scaling reasons if
&gt; nothing else) at some point, though, and there's no reason it can't be
&gt; soon.
&gt;
&gt; Send it to or-dev and let's talk about it there?
&gt;

Hi Nick,

Had to scratch my head on what clique topology means but I think I get it: where 
every node has to be able to connect to every other in the network. I guess that 
does mean a few anonymity properties previously taken for granted on Tor may get 
flushed out by this - pretty sure I haven't captured them all.

Are there any better ways of finding out how many servers out there fail to 
publish because they can't pass the orport reachability test? The proposal 
assumes there are a lot, but maybe there are surprisingly few.



----------  Forwarded Message  ----------

Subject: Proposal: Incorporate Unreachable ORs into the Tor Network
Date: Saturday 22 March 2008
From: Robert Hogan &lt;robert@roberthogan.net&gt;
To: or-talk@freehaven.net

I'm not sure how much merit this proposal has, or how serious it's problems are. 
Does anyone have any thoughts on it? Are the problems I've outlined fatal, or is 
there a problem with it I've missed? I suspect one or the other.


--

Filename: xxx-unreachable-ORs.txt
Title: Incorporate Unreachable ORs into the Tor Network
Author: Robert Hogan
Created: 2008-03-08
Status: Draft

Overview:

  Propose a scheme for harnessing the bandwidth of ORs who cannot currently
  participate in the Tor network because they can only make outbound
  TCP connections.

Motivation: 

  Restrictive local and remote firewalls are preventing many willing
  candidates from becoming ORs on the Tor network.These
  ORs have a casual interest in joining the network but their operator is not
  sufficiently motivated or adept to complete the necessary router or firewall
  configuration. The Tor network is losing out on their bandwidth. At the
  moment we don't even know how many such 'candidate' ORs there are.


Objective:

  1. Establish how many ORs are unable to qualify for publication because
     they cannot establish that their ORPort is reachable.

  2. Devise a method for making such ORs available to clients for circuit
     building without prejudicing their anonymity.

Proposal:

  ORs whose ORPort reachability testing fails a specified number of
  consecutive times should:
   1. Enlist themselves with the authorities setting a 'Fallback' flag. This
      flag indicates that the OR is up and running but cannot connect to
      itself.
   2. Open an orconn with all ORs whose fingerprint begins with the same
      byte as their own. The management of this orconn will be transferred
      entirely to the OR at the other end.
   2. The fallback OR should update it's router status to contain the
      'Running' flag if it has managed to open an orconn with 3/4 of the ORs
      with an FP beginning with the same byte as its own.

  Tor ORs who are contacted by fallback ORs requesting an orconn should:
   1. Accept the orconn until they have reached a defined limit of orconn
      connections with fallback ORs.
   2. Should only accept such orconn requests from listed fallback ORs who
      have an FP beginning with the same byte as its own.

  Tor clients can include fallback ORs in the network by doing the
  following:
   1. When building a circuit, observe the fingerprint of each node they
      wish to connect to.
   2. When randomly selecting a node from the set of all eligible nodes,
      add all published, running fallback nodes to the set where the first
      byte of the fingerprint matches the previous node in the circuit.

Anonymity Implications:

  At least some, and possibly all, nodes on the network will have a set
  of nodes that only they and a few others can build circuits on.

    1. This means that fallback ORs might be unsuitable for use as middlemen
       nodes, because if the exit node is the attacker it knows that the
       number of nodes that could be the entry guard in the circuit is
       reduced to roughly 1/256th of the network, or worse 1/256th of all
       nodes listed as Guards. For the same reason, fallback nodes would
       appear to be unsuitable for two-hop circuits.

    2. This is not a problem if fallback ORs are always exit nodes. If
       the fallback OR is an attacker it will not be able to reduce the
       set of possible nodes for the entry guard any further than a normal,
       published OR.

Possible Attacks/Open Issues:

  1. Gaming Node Selection
    Does running a fallback OR customized for a specific set of published ORs
    improve an attacker's chances of seeing traffic from that set of published
    ORs? Would such a strategy be any more effective than running published
    ORs with other 'attractive' properties?

  2. DOS Attack
    An attacker could prevent all other legitimate fallback ORs with a
    given byte-1 in their FP from functioning by running 20 or 30 fallback ORs
    and monopolizing all available fallback slots on the published ORs. 
    This same attacker would then be in a position to monopolize all the
    traffic of the fallback ORs on that byte-1 network segment. I'm not sure
    what this would allow such an attacker to do.

  4. Circuit-Sniffing
    An observer watching exit traffic from a fallback server will know that the
    previous node in the circuit is one of a  very small, identifiable
    subset of the total ORs in the network. To establish the full path of the
    circuit they would only have to watch the exit traffic from the fallback
    OR and all the traffic from the 20 or 30 ORs it is likely to be connected
    to. This means it is substantially easier to establish all members of a
    circuit which has a fallback OR as an exit (sniff and analyse 10-50 (i.e.
    1/256 varying) + 1 ORs) rather than a normal published OR (sniff all 2560
    or so ORs on the network). The same mechanism that allows the client to
    expect a specific fallback OR to be available from a specific published OR
    allows an attacker to prepare his ground.

    Mitigant:
    In terms of the resources and access required to monitor 2000 to 3000
    nodes, the effort of the adversary is not significantly diminished when he
    is only interested in 20 or 30. It is hard to see how an adversary who can
    obtain access to a randomly selected portion of the Tor network would face
    any new or qualitatively different obstacles in attempting to access much
    of the rest of it.


Implementation Issues:

  The number of ORs this proposal would add to the Tor network is not known.
  This is because there is no mechanism at present for recording unsuccessful
  attempts to become an OR. If the proposal is considered promising it may be
  worthwhile to issue an alpha series release where candidate ORs post a
  primitive fallback descriptor to the authority directories. This fallback
  descriptor would not contain any other flag that would make it eligible for
  selection by clients. It would act solely as a means of sizing the number of
  Tor instances that try and fail to become ORs.

  The upper limit on the number of orconns from fallback ORs a normal,
  published OR should be willing to accept is an open question. Is one
  hundred, mostly idle, such orconns too onerous?





-------------------------------------------------------

["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20080328174123</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-03-28 17:41:23-0400</timestampReceived><subject>[jarusl@cs.northwestern.edu: Tor proxy for Virtual Machines]</subject><body>

Forwarding this with permission.  It looks like interesting work,
especially for people pursuing VM-based anonymization strategies.

----- Forwarded message from "John R. Lange" &lt;jarusl@cs.northwestern.edu&gt; -----

From: "John R. Lange" &lt;jarusl@cs.northwestern.edu&gt;
To: tor-volunteer@torproject.org
Subject: Tor proxy for Virtual Machines
X-Spam-Level: 

Hi,

As part of one of our research projects, I put together a small proxy tool 
that anonymizes all TCP and DNS traffic originating in a virtual machine 
(at least with VMWare or Xen). It currently runs under linux, but contains 
very early support for Windows.

It plugs in beneath the Virtual Machine Monitor, so it is capable of 
providing TOR support for any application+OS combination without any 
configuration or special proxy tool needing to be installed in the guest 
environment.

It works by configuring a VM's network adapter to connect to a host-only 
network, where none of the packets are ever transmitted out of the host 
machine. Every ethernet packet coming from the VM is then captured and 
translated into SOCKs traffic that is forwarded to a TOR proxy. If the 
packet is not supported then it is simply dropped and is never transmitted 
on the network.

More info on the tool can be found here:
http://www.artifex.org/~jarusl/TorVTL/

While the paper can be found here:
http://www.artifex.org/~jarusl/research/pubs/hpdc07-vtl.pdf

I'm unsure whether this will be of any interest to people, but I figured 
I'd let you know.

regards
--Jack
Jack Lange ; NU CS ; jarusl@cs.northwestern.edu
http://www.cs.northwestern.edu

----- End forwarded message -----
</body></email><email><emailId>20080317025316</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-03-17 02:53:16-0400</timestampReceived><subject>Re: A Tor Web Service For Verifying Correct Browser Configuration</subject><body>

On Sun, Mar 16, 2008 at 08:25:47PM +0000, Robert Hogan wrote:
&gt; 
&gt; Filename: xxx-browser-check-tor-service.txt
&gt; Title: A Tor Web Service For Verifying Correct Browser Configuration
&gt; Version: $Revision: 13955 $
&gt; Last-Modified: $Date: 2008-03-16 18:51:55 +0000 (Sun, 16 Mar 2008) $
&gt; Author: Robert Hogan
&gt; Created: 2008-03-08
&gt; Status: Draft

Added as proposal 132.
</body></email><email><emailId>20080322155757</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-03-22 15:57:57-0400</timestampReceived><subject>Re: A Tor Web Service For Verifying Correct Browser Configuration</subject><body>

On Sun, Mar 16, 2008 at 08:25:47PM +0000, Robert Hogan wrote:

{For reference, this is now proposal 132.  See 
   http://www.torproject.org/svn/trunk/doc/spec/proposals/132-browser-check-tor-service.txt
}

&gt; 
&gt; Filename: xxx-browser-check-tor-service.txt
&gt; Title: A Tor Web Service For Verifying Correct Browser Configuration
&gt; Version: $Revision: 13955 $
&gt; Last-Modified: $Date: 2008-03-16 18:51:55 +0000 (Sun, 16 Mar 2008) $
&gt; Author: Robert Hogan
&gt; Created: 2008-03-08
&gt; Status: Draft


Hi, Robert!  I'd like to ask about a couple of alternative designs
that periodically come up for this problem, and ask about security
implications.

The two main alternative designs are:  
   - Use a remote "am I using Tor" page.

     This handles tests 2 and 3 pretty easily, and with a little
     effort can be made to do test 1.

   - Have a controller do it without modifying, or with minimal
     modifications to, the Tor client.

     Test 3 (net connectivity by Tor) is as easy as looking for
     whether Tor can build a circuit, I think.  For test 2 (is browser
     using Tor), just use a MAPADDRESS command to replace a randomly
     chosen unique ID hostname with (say) torproect.org.  For test 1
     (is browser using Tor for DNS), send the browser to request a
     random hostname, and then look in Tor's DNS cache to see whether
     Tor has a cached entry there.

     [There may be better ways to do these.]

The security implications as near as I can tell are:

    * It adds a way to tell if people are using Tor: when they test an
      instance of Tor that isn't configured properly, they'll leak
      pretty identifiable requests to one or two well-known addresses.

    * There are lots of attacks this doesn't solve, particularly
      browser-based ones.  We could solve this by having a link to a
      remote "am I using Tor right" page, I guess.

    * It adds another local resource that speaks HTTP; experience
      suggests that we should think about whether remote pages can use
      links or javascript to redirect users here in a way that will be
      useful to an adversary.

None of these seem really terrible to me at the moment, but we should
analyze them.


What do you think?
-- 
Nick
</body></email><email><emailId>20080323154557</emailId><senderName>Jens Kubieziel</senderName><senderEmail>maillist@kubieziel.de</senderEmail><timestampReceived>2008-03-23 15:45:57-0400</timestampReceived><subject>Re: A Tor Web Service For Verifying Correct Browser Configuration</subject><body>


* Robert Hogan schrieb am 2008-03-16 um 21:25 Uhr:
&gt;   3. Tor Connectivity Test Image
&gt; 
&gt;   &lt;IMG src="http://torproject.org/[uniquesessionid]-torlogo.jpg" alt="If you

I woould suggest using HTTPS here. Assuming Alice has a misconfigured
Tor-Software and mallory wants to trick her. He can set up a DNS
wildcard and redirect the traffic from point 1 to his servers. They send
the appropriate image. He redirects
http://www.torproject.org/[uniquesessionid].jpg to the appropriate image
and does this also with the above image. So Alice sees a website which
basically tells her that everything is fine.

When the last point uses HTTPS, Mallory can use some MITM, but normally
Alices browser should tell her that something isn't going well here.

Besten Gruß

-- 
Jens Kubieziel                                   http://www.kubieziel.de
FdI#212: Qualifizierter Support
Ein Schuldiger kann benannt werden. (Martin Schmitt)

["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20080311203517</emailId><senderName>Robert Hogan</senderName><senderEmail>robert@roberthogan.net</senderEmail><timestampReceived>2008-03-11 20:35:17-0400</timestampReceived><subject>Re: Improving the robustness of Tor Check</subject><body>


On Monday 10 March 2008 18:46:52 you wrote:
&gt;
&gt; Proposal:
&gt;
&gt;   A DNS name should be registered and point to an IP address
&gt;   controlled by the Tor project and likely to remain so for the
&gt;   useful lifetime of a Tor client. A web server should be placed
&gt;   at this IP address.
&gt;
&gt;   Tor should be modified to treat requests to port 80, at the
&gt;   specified DNS name or IP address specially. Instead of opening a
&gt;   circuit, it should respond to a HTTP request with a helpful web
&gt;   page:
&gt;
&gt;   - If the request to open a connection was to the domain name, the web
&gt;     page should state that Tor is working properly.
&gt;   - If the request was to the IP address, the web page should state
&gt;     that there is a DNS-leakage vulnerability.
&gt;
&gt;   If the request goes through to the real web server, the page
&gt;   should state that Tor has not been set up properly.

Here's an alternative, maybe it was considered and discounted for a good 
reason, but:

1. Tor runs a primitive 'web service' on localhost:9999 or whatever.
2. The user/controller connects to this service directly through a browser.
3. The service consists of a web page saying 'This is your Tor client'. 'Click 
Next To Test Your Tor'.
4. Then, from an embedded set of frames (or a series of 'next' buttons) your 
browser launches a set of requests served in the html from Tor. This could 
include stuff like :

- A frame (or image link ) that launches a request to 
http://[unqiuesessionid].tor/test.jpg. This frame has a caption stating 
that 'could not resolve domain name' or a blank image means you are leaking 
DNS. If you are not, Tor recognises the sessionid and special url and serves 
a 'DNS OK' page or image in that frame.
- A frame that launches a request to an external domain. Caption something 
like 'if you see a nice picture here your Tor is working, if the image has 
not loaded there's a problem'

Anyway, I hope you get my drift. Given that Tor already *has* a http service I 
imagine this would be pretty straightforward to implement. Given that the 
check page is likely to be used by bundles and controllers almost exclusively 
it should be pretty seamless from a user's point of view.



["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20080312185352</emailId><senderName>Robert Hogan</senderName><senderEmail>robert@roberthogan.net</senderEmail><timestampReceived>2008-03-12 18:53:52-0400</timestampReceived><subject>Re: Improving the robustness of Tor Check</subject><body>


On Tuesday 11 March 2008 20:35:17 Robert Hogan wrote:
&gt; On Monday 10 March 2008 18:46:52 you wrote:
&gt; &gt; Proposal:
&gt; &gt;
&gt; &gt;   A DNS name should be registered and point to an IP address
&gt; &gt;   controlled by the Tor project and likely to remain so for the
&gt; &gt;   useful lifetime of a Tor client. A web server should be placed
&gt; &gt;   at this IP address.
&gt; &gt;
&gt; &gt;   Tor should be modified to treat requests to port 80, at the
&gt; &gt;   specified DNS name or IP address specially. Instead of opening a
&gt; &gt;   circuit, it should respond to a HTTP request with a helpful web
&gt; &gt;   page:
&gt; &gt;
&gt; &gt;   - If the request to open a connection was to the domain name, the web
&gt; &gt;     page should state that Tor is working properly.
&gt; &gt;   - If the request was to the IP address, the web page should state
&gt; &gt;     that there is a DNS-leakage vulnerability.
&gt; &gt;
&gt; &gt;   If the request goes through to the real web server, the page
&gt; &gt;   should state that Tor has not been set up properly.
&gt;
&gt; Here's an alternative, maybe it was considered and discounted for a good
&gt; reason, but:
&gt;
&gt; 1. Tor runs a primitive 'web service' on localhost:9999 or whatever.
&gt; 2. The user/controller connects to this service directly through a browser.
&gt; 3. The service consists of a web page saying 'This is your Tor client'.
&gt; 'Click Next To Test Your Tor'.
&gt; 4. Then, from an embedded set of frames (or a series of 'next' buttons)
&gt; your browser launches a set of requests served in the html from Tor. This
&gt; could include stuff like :
&gt;
&gt; - A frame (or image link ) that launches a request to
&gt; http://[unqiuesessionid].tor/test.jpg. This frame has a caption stating
&gt; that 'could not resolve domain name' or a blank image means you are leaking
&gt; DNS. If you are not, Tor recognises the sessionid and special url and
&gt; serves a 'DNS OK' page or image in that frame.
&gt; - A frame that launches a request to an external domain. Caption something
&gt; like 'if you see a nice picture here your Tor is working, if the image has
&gt; not loaded there's a problem'
&gt;
&gt; Anyway, I hope you get my drift. Given that Tor already *has* a http
&gt; service I imagine this would be pretty straightforward to implement. Given
&gt; that the check page is likely to be used by bundles and controllers almost
&gt; exclusively it should be pretty seamless from a user's point of view.

I should have added that my reason for suggesting this alternative is that I 
believe it solves the issues you outline in 'Open Issues' and 'Security and 
resiliency implications'. It could also help avoid possible complications 
from DNS poisoning or other crafty stuff when the page displays an image from 
an external source (specified by and known to Tor).

For example, page 2 of the assistant displays an image, a url in an html page 
served by Tor. Either the image is displayed or is not loaded. But it may 
have been displayed by some kind of crafty browser attack that bypassed Tor. 
So after a few minutes a refresh-header in the served page will then reload 
the page, this time with Tor's response on whether it saw and served the 
request for the image or not. This could also be a 'Check With Tor' button 
rather than a refresh-header.





["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20080314112155</emailId><senderName>"Steven J. Murdoch"</senderName><senderEmail>tor+steven.murdoch@cl.cam.ac.uk</senderEmail><timestampReceived>2008-03-14 11:21:55-0400</timestampReceived><subject>Re: Improving the robustness of Tor Check</subject><body>

On Tue, Mar 11, 2008 at 08:35:17PM +0000, Robert Hogan wrote:
&gt; - A frame (or image link ) that launches a request to 
&gt; http://[unqiuesessionid].tor/test.jpg. This frame has a caption stating 
&gt; that 'could not resolve domain name' or a blank image means you are leaking 
&gt; DNS. If you are not, Tor recognises the sessionid and special url and serves 
&gt; a 'DNS OK' page or image in that frame.

Thanks for the suggestion.

The reason I didn't use this approach is because what happens if the
browser is not configured to use Tor. A blank image or generic "could
not resolve domain name" error message is not very helpful. With my
proposal, a user would be sent to a webpage which explains what went
wrong and how to fix it.

There is still one problematic case, which is if the proxy
configuration is set to the wrong port. Here the user would see a
generic error message. Maybe there could be some way to combine the
two approaches, since connections to 127.0.0.1 will bypass proxy
settings in most cases.

This does mean, however, that if Tor is not running at all, the user
would get a generic error page. I can't think of a solution which
fixes both cases in a neat way.

That said, the main scenario I want to prevent is a user thinking
they're using Tor when they're not. Having their browser unable to
access any web page is undesirable, but at least they're not going to
do anything unsafe.

Steven.

-- 
w: http://www.cl.cam.ac.uk/users/sjm217/
</body></email><email><emailId>20080315092337</emailId><senderName>Robert Hogan</senderName><senderEmail>robert@roberthogan.net</senderEmail><timestampReceived>2008-03-15 09:23:37-0400</timestampReceived><subject>Re: Improving the robustness of Tor Check</subject><body>


On Friday 14 March 2008 11:21:55 you wrote:
&gt; On Tue, Mar 11, 2008 at 08:35:17PM +0000, Robert Hogan wrote:
&gt; &gt; - A frame (or image link ) that launches a request to
&gt; &gt; http://[unqiuesessionid].tor/test.jpg. This frame has a caption stating
&gt; &gt; that 'could not resolve domain name' or a blank image means you are
&gt; &gt; leaking DNS. If you are not, Tor recognises the sessionid and special url
&gt; &gt; and serves a 'DNS OK' page or image in that frame.
&gt;
&gt; Thanks for the suggestion.
&gt;
&gt; The reason I didn't use this approach is because what happens if the
&gt; browser is not configured to use Tor. A blank image or generic "could
&gt; not resolve domain name" error message is not very helpful. With my
&gt; proposal, a user would be sent to a webpage which explains what went
&gt; wrong and how to fix it.
&gt;

What I had in mind was html along the following lines:

&lt;p&gt;This wizard will test if your browser is correctly configured for using 
Tor.&lt;/p&gt;
&lt;p&gt;Take a look at the box below. Does it contain an image of the Tor logo?&lt;/p&gt;
&lt;IMG src="http://jfklsfjslkfdsl.tor/torlogo.jpg" alt="If you can see this 
text, please click 'No'" width="200" height="200" align="middle" border="2"&gt;
&lt;br&gt;
&lt;INPUT type="button" name="Yes" value="Yes"&gt;
&lt;INPUT type="button" name="No" value="No"&gt;

Clicking 'No' (as prompted by the alt text if the image is not displayed 
and/or the text above the image) would serve the webpage describing what the 
user needs to do to prevent dns leaking. If the image is properly displayed, 
the user would click Yes and go to a page serving another image that tests 
external connectivity. There's no reason why both these pages couldn't be 
served directly by Tor also.

&gt; There is still one problematic case, which is if the proxy
&gt; configuration is set to the wrong port. Here the user would see a
&gt; generic error message. Maybe there could be some way to combine the
&gt; two approaches, since connections to 127.0.0.1 will bypass proxy
&gt; settings in most cases.
&gt;
&gt; This does mean, however, that if Tor is not running at all, the user
&gt; would get a generic error page. I can't think of a solution which
&gt; fixes both cases in a neat way.

The tor web service I'm suggesting would only be useful for controllers, since 
presumably users aren't going to want to type something exotic like 
127.0.0.1:9999 into their address bar. In this situation the Torbrowser 
bundle or TorK will have configured the actual port for the webservice so 
will know where to direct the request. It would also be the responsibility of 
the controller to ensure the webservice is available, and tor is running, 
before allowing the user to access the page through their browser.

This would mitigate against both the problems above, but it's probably 
impossible to prevent them ever happening.

I think our use cases may be different enough for both to be worth pursuing 
separately. An internet-based web service that Tor knows about and can use to 
advise users if they're properly configured is good for torbutton users and 
the like who just want something to click when they're asking for help on IRC 
or reading the docs. A tor-based web service would be good for controllers 
since they can make sure it's available and configured before use and can 
avoid the problems associated with relying on an external service outside 
their control. 

I'll do up a proper proposal so the pros and cons of what I'm suggesting are 
clear.

&gt;
&gt; That said, the main scenario I want to prevent is a user thinking
&gt; they're using Tor when they're not. Having their browser unable to
&gt; access any web page is undesirable, but at least they're not going to
&gt; do anything unsafe.
&gt;
&gt; Steven.



["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20080316191207</emailId><senderName>Mike Perry</senderName><senderEmail>mikeperry@fscked.org</senderEmail><timestampReceived>2008-03-16 19:12:07-0400</timestampReceived><subject>Re: Improving the robustness of Tor Check</subject><body>


Thus spake Steven J. Murdoch (tor+Steven.Murdoch@cl.cam.ac.uk):

I'd like to propose an extension that would make it much easier for
Torbutton to provide feedback via a simple icon indication.


&gt; Extensions:

    Automatic Firefox Notification:

    All forms of the website should return valid XHTML and have a 
    hidden link with an id attribute "TorCheckResult" and a target 
    property that can be queried to determine the result. For example, 
    a hidden link would convey success like this:

    &lt;a id="TorCheckResult" target="success" href="/"&gt;&lt;/a&gt;

    failure like this: 
    
    &lt;a id="TorCheckResult" target="failure" href="/"&gt;&lt;/a&gt;
    
    and DNS leaks like this:    

    &lt;a id="TorCheckResult" target="dnsleak" href="/"&gt;&lt;/a&gt;

    Firefox extensions such as Torbutton would then be able to 
    issue an XMLHttpRequest for the page and query the result
    with resultXML.getElementById("TorCheckResult").target
    to automatically report the Tor status to the user when
    they first attempt to enable Tor activity, or whenever 
    they request a check from the extension preferences window.

    If the check website is to be themed with heavy graphics and/or
    extensive documentation, the check result itself should be 
    contained in a seperate lightweight iframe that extensions can 
    request via an alternate url.

 
&gt;   Identifying proxy server:
&gt; 
&gt;   If needed, other applications between the web browser and Tor (e.g.
&gt;   Polipo and Privoxy) could piggyback on the same mechanism to flag
&gt;   whether they are in use. All three possible web pages should include
&gt;   a machine-readable placeholder, into which another program could
&gt;   insert their own message.
&gt; 
&gt;   For example, the webpage returned by Tor to indicate a successful
&gt;   configuration could include the following HTML:
&gt;    &lt;h2&gt;Connection chain&lt;/h2&gt;
&gt;    &lt;ul&gt;
&gt;    &lt;li&gt;Tor 0.1.2.14-alpha

Change this to:

     &lt;li&gt;Tor 0.1.2.14-alpha&lt;/li&gt;

&gt;    &lt;!-- Tor Connectivity Check: success --&gt;
&gt;    &lt;/ul&gt;
&gt; 
&gt;   When the proxy server observes this string, in response to a request
&gt;   for the Tor connectivity check web page, it would prepend it's own
&gt;   message, resulting in the following being returned to the web
&gt;   browser:
&gt;    &lt;h2&gt;Connection chain
&gt;    &lt;ul&gt;
&gt;    &lt;li&gt;Tor 0.1.2.14-alpha

Change this to:

     &lt;li&gt;Tor 0.1.2.14-alpha&lt;/li&gt;

&gt;    &lt;li&gt;Polipo version 1.0.4

Change this to:

     &lt;li&gt;Polipo version 1.0.4&lt;/li&gt;

&gt;    &lt;!-- Tor Connectivity Check: success --&gt;
&gt;    &lt;/ul&gt;



-- 
Mike Perry
Mad Computer Scientist
fscked.org evil labs

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>200803171350210</emailId><senderName>"Jonathan Yu"</senderName><senderEmail>jonathan.i.yu@gmail.com</senderEmail><timestampReceived>2008-03-17 13:50:21-0400</timestampReceived><subject>Re: select()</subject><body>

On Mon, Mar 17, 2008 at 8:45 AM, Toby Douglass
&lt;toby.douglass@45mercystreet.com&gt; wrote:
&gt; Jonathan Yu wrote:
&gt;  &gt; Hi there:
&gt;  &gt;
&gt;  &gt; I am by no means an expert, but I don't think that this is the case.
&gt;  &gt; Tor uses libevent, which will automatically select the best I/O
&gt;  &gt; multiplexing system; this is probably anything but select() on your
&gt;  &gt; system. Hopefully it's an event-based system like kqueue (BSD) or
&gt;  &gt; realtime signals (Linux).
&gt;
&gt;  I omitted specifing that I am in fact running on Windows 2000.  Libevent
&gt;  uses select() *only* under Windows.
I would suggest running Tor in a normal console window (not a service)
and seeing what log messages pop up when the slowdown occurs.

Optionally, you can dig through torrc (which is not included in the
Windows install by default) to find the appropriate option, or use a
controller like Vidalia to adjust the configuration so as to view the
log data.
&gt;
&gt;  BTW, I note this reply was to "or-dev@freehaven.net" and cc:'d
&gt;  "or-dev@seul.org".  Why the two addresses?  I've left freehaven as a cc:
&gt;  just in case.
I suppose I'm just registered to a different list, but they are
probably cross-posted appropriately.
&gt;
&gt;
&gt;
</body></email><email><emailId>20080316004510</emailId><senderName>"Steven J. Murdoch"</senderName><senderEmail>tor+steven.murdoch@cl.cam.ac.uk</senderEmail><timestampReceived>2008-03-16 00:45:10-0400</timestampReceived><subject>Re: Passing language code to check.torproject.org</subject><body>

On Fri, Mar 14, 2008 at 06:55:11PM -0700, Jacob Appelbaum wrote:
&gt; Yes. I agree. It's quite useful to mask that. In the event of the user
&gt; not having Torbutton enabled - Am I right to assume that they would
&gt; probably leak their language choice? I think it will but I'm an English
&gt; speaker and I haven't tested it.

Yes, Firefox will by default state its preferences for language and
character set. Torbutton hides these when enabled.

&gt; How do you feel about using https for this? Phobos bought us a cert that
&gt; should be good for the rest of the year. Ideally, if we use SSL, we're
&gt; going to have even less of an issue leaking possible linkable language
&gt; information to exit nodes.

That sounds like a good idea. I've applied the change.

&gt; We probably also want to ensure that any link on check.tpo doesn't leak
&gt; a referring url that includes their language choice.

Right. This needs more investigation, but one option is to set a
cookie with the language setting, and then redirect to a different
page. Then the referring URL will not include the language choice. We
would set a cookie, but that would only contain the language, not a
user ID, and could be set with a very short expiry time.

&gt; I think this is good providing a switch to https://check.torproject.org

OK, it's applied and I'll test it before the next release.

Steven.

-- 
w: http://www.cl.cam.ac.uk/users/sjm217/
</body></email><email><emailId>20080422153733</emailId><senderName>Peter Palfrader</senderName><senderEmail>peter@palfrader.org</senderEmail><timestampReceived>2008-04-22 15:37:33-0400</timestampReceived><subject>Re: Proposal: Download consensus documents only when it will be trusted</subject><body>

On Mon, 21 Apr 2008, Peter Palfrader wrote:

&gt; On Sun, 13 Apr 2008, Nick Mathewson wrote:
&gt; 
&gt; &gt; &gt; Servers only provide consensus documents to clients when it is known that
&gt; &gt; &gt; the client will trust it.
&gt; 
&gt; Here's a first go at the server side.

Split into its own function.


diff --git a/src/or/directory.c b/src/or/directory.c
index aee76a5..ac5eb04 100644
--- a/src/or/directory.c
+++ b/src/or/directory.c
@@ -57,6 +57,7 @@ static void dir_routerdesc_download_failed(smartlist_t *failed,
                                            int was_extrainfo,
                                            int was_descriptor_digests);
 static void note_request(const char *key, size_t bytes);
+static int client_likes_our_consensus(networkstatus_t *v, const char *want_url);
 
 /********* START VARIABLES **********/
 
@@ -2163,6 +2164,52 @@ directory_dump_request_log(void)
 }
 #endif
 
+/* Decide whether a client would accept the consensus we have
+ *
+ * Clients can say they only want a consensus if it's signed by more
+ * than half the authorities in &lt;list&gt;.  They pass this list in
+ * the url as ..consensus/&lt;fpr&gt;+&lt;fpr&gt;+&lt;fpr&gt;
+ * &lt;fpr&gt; may be an abbreviated fingerprint, i.e. only a left substring
+ * of the full authority identity digest.
+ *
+ * Returns 1 more than half of the requested authorities signed
+ * the consensus, 0 otherwise.
+ */
+int
+client_likes_our_consensus(networkstatus_t *v, const char *want_url)
+{
+  smartlist_t *want = smartlist_create();
+  smartlist_t *voterdigests = smartlist_create();
+  int need_at_least = 0;
+  int have = 0;
+
+  SMARTLIST_FOREACH(v-&gt;voters, networkstatus_voter_info_t *, vi, {
+    char *d = tor_malloc(HEX_DIGEST_LEN+1);
+    base16_encode(d, HEX_DIGEST_LEN+1, vi-&gt;identity_digest, DIGEST_LEN);
+    smartlist_add(voterdigests, d);
+  });
+
+  dir_split_resource_into_fingerprints(want_url, want, NULL, 0, 0);
+  need_at_least = smartlist_len(want)/2+1;
+  SMARTLIST_FOREACH(want, const char *, d, {
+    SMARTLIST_FOREACH(voterdigests, char *, voter, {
+      if (!strcasecmpstart(voter, d)) {
+        have++;
+        tor_free(voter);
+        SMARTLIST_DEL_CURRENT(voterdigests, voter);
+      };
+    });
+  });
+
+  SMARTLIST_FOREACH(voterdigests, char *, d, tor_free(d));
+  smartlist_free(voterdigests);
+
+  SMARTLIST_FOREACH(want, char *, d, tor_free(d));
+  smartlist_free(want);
+
+  return (have &gt;= need_at_least);
+}
+
 /** Helper function: called when a dirserver gets a complete HTTP GET
  * request.  Look for a request for a directory or for a rendezvous
  * service descriptor.  On finding one, write a response into
@@ -2290,7 +2337,7 @@ directory_handle_command_get(dir_connection_t *conn, const char \
*headers,  }
 
   if (!strcmpstart(url,"/tor/status/")
-      || !strcmp(url, "/tor/status-vote/current/consensus")) {
+      || !strcmpstart(url, "/tor/status-vote/current/consensus")) {
     /* v2 or v3 network status fetch. */
     smartlist_t *dir_fps = smartlist_create();
     int is_v3 = !strcmpstart(url, "/tor/status-vote");
@@ -2311,6 +2358,14 @@ directory_handle_command_get(dir_connection_t *conn, const \
char *headers,  } else {
       networkstatus_t *v = networkstatus_get_latest_consensus();
       time_t now = time(NULL);
+      #define CONSENSUS_URL_PREFIX "/tor/status-vote/current/consensus/"
+      if (!strcmpstart(url, CONSENSUS_URL_PREFIX) &amp;&amp;
+          !client_likes_our_consensus(v, url + strlen(CONSENSUS_URL_PREFIX))) {
+        write_http_status_line(conn, 404, "Consensus not signed by sufficient number \
of requested authorities"); +        smartlist_free(dir_fps);
+        goto done;
+      }
+
       smartlist_add(dir_fps, tor_memdup("\0\0\0\0\0\0\0\0\0\0"
                                         "\0\0\0\0\0\0\0\0\0\0", 20));
       request_type = compressed?"v3.z":"v3";


</body></email><email><emailId>20080423134017</emailId><senderName>Peter Palfrader</senderName><senderEmail>peter@palfrader.org</senderEmail><timestampReceived>2008-04-23 13:40:17-0400</timestampReceived><subject>Re: Proposal: Download consensus documents only when it will be trusted</subject><body>

On Tue, 22 Apr 2008, Peter Palfrader wrote:

&gt; &gt; Here's a first go at the server side.
&gt; Split into its own function.

.) Not all authorities on consensus-&gt;voters actually signed the consensus.
.) decode the requested fingerprint rather than encoding each
   authority's id digest.  This gets rid of one of the two smartlists
   and a bunch of small mallocs.

diff --git a/src/or/directory.c b/src/or/directory.c
index aee76a5..de9c50c 100644
--- a/src/or/directory.c
+++ b/src/or/directory.c
@@ -57,6 +57,7 @@ static void dir_routerdesc_download_failed(smartlist_t *failed,
                                            int was_extrainfo,
                                            int was_descriptor_digests);
 static void note_request(const char *key, size_t bytes);
+static int client_likes_consensus(networkstatus_t *v, const char *want_url);
 
 /********* START VARIABLES **********/
 
@@ -2163,6 +2164,57 @@ directory_dump_request_log(void)
 }
 #endif
 
+/** Decide whether a client would accept the consensus we have
+ *
+ * Clients can say they only want a consensus if it's signed by more
+ * than half the authorities in &lt;list&gt;.  They pass this list in
+ * the url as ..consensus/&lt;fpr&gt;+&lt;fpr&gt;+&lt;fpr&gt;
+ * &lt;fpr&gt; may be an abbreviated fingerprint, i.e. only a left substring
+ * of the full authority identity digest. (Only strings of even length,
+ * i.e. encodings of full bytes, are handled correctly.  In the case
+ * of an odd number of hex digits the last one is silently ignored.)
+ *
+ * Returns 1 if more than half of the requested authorities signed the
+ * consensus, 0 otherwise.
+ */
+int
+client_likes_consensus(networkstatus_t *v, const char *want_url)
+{
+  smartlist_t *want_authorities = smartlist_create();
+  int need_at_least;
+  int have = 0;
+
+  dir_split_resource_into_fingerprints(want_url, want_authorities, NULL, 0, 0);
+  need_at_least = smartlist_len(want_authorities)/2+1;
+  SMARTLIST_FOREACH(want_authorities, const char *, d, {
+    char want_digest[DIGEST_LEN];
+    int want_len = strlen(d)/2;
+    if (want_len &gt; DIGEST_LEN)
+      want_len = DIGEST_LEN;
+
+    if (base16_decode(want_digest, DIGEST_LEN, d, want_len*2) &lt; 0) {
+      log_warn(LD_DIR,"Failed to decode requested authority digest %s.", d);
+      continue;
+    };
+
+    SMARTLIST_FOREACH(v-&gt;voters, networkstatus_voter_info_t *, vi, {
+      if (vi-&gt;signature &amp;&amp;
+          !memcmp(vi-&gt;identity_digest, want_digest, want_len)) {
+        have++;
+        break;
+      };
+    });
+
+    /* early exit, if we already have enough */
+    if (have &gt;= need_at_least)
+      break;
+  });
+
+  SMARTLIST_FOREACH(want_authorities, char *, d, tor_free(d));
+  smartlist_free(want_authorities);
+  return (have &gt;= need_at_least);
+}
+
 /** Helper function: called when a dirserver gets a complete HTTP GET
  * request.  Look for a request for a directory or for a rendezvous
  * service descriptor.  On finding one, write a response into
@@ -2290,7 +2342,7 @@ directory_handle_command_get(dir_connection_t *conn, const char *headers,
   }
 
   if (!strcmpstart(url,"/tor/status/")
-      || !strcmp(url, "/tor/status-vote/current/consensus")) {
+      || !strcmpstart(url, "/tor/status-vote/current/consensus")) {
     /* v2 or v3 network status fetch. */
     smartlist_t *dir_fps = smartlist_create();
     int is_v3 = !strcmpstart(url, "/tor/status-vote");
@@ -2311,6 +2363,15 @@ directory_handle_command_get(dir_connection_t *conn, const char *headers,
     } else {
       networkstatus_t *v = networkstatus_get_latest_consensus();
       time_t now = time(NULL);
+      #define CONSENSUS_URL_PREFIX "/tor/status-vote/current/consensus/"
+      if (!strcmpstart(url, CONSENSUS_URL_PREFIX) &amp;&amp;
+          !client_likes_consensus(v, url + strlen(CONSENSUS_URL_PREFIX))) {
+        write_http_status_line(conn, 404, "Consensus not signed by sufficient "
+                                          "number of requested authorities");
+        smartlist_free(dir_fps);
+        goto done;
+      }
+
       smartlist_add(dir_fps, tor_memdup("\0\0\0\0\0\0\0\0\0\0"
                                         "\0\0\0\0\0\0\0\0\0\0", 20));
       request_type = compressed?"v3.z":"v3";
</body></email><email><emailId>20080418132357</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-04-18 13:23:57-0400</timestampReceived><subject>Re: Bug: buffers.c:1688: assert_buf_ok: Assertion ch-&gt;data &gt;= &amp;ch-&gt;mem[0] failed</subject><body>

On Fri, Apr 18, 2008 at 07:33:32AM +0200, Fabian Keil wrote:
&gt; A few days ago one of my servers triggered:
&gt; 
&gt; Apr 10 17:07:45.728 [notice] Tor 0.2.0.23-rc (r14173) opening log file.
&gt; Apr 10 17:07:46.005 [warn] I have no descriptor for the router named \
&gt; "zwiebelkuchen" in my declared family; I'll use the nickname as is, but this may \
&gt; confuse clients. Apr 10 17:07:46.005 [warn] I have no descriptor for the router \
&gt; named "zwiebelsuppe" in my declared family; I'll use the nickname as is, but this \
&gt; may confuse clients. Apr 10 17:07:46.052 [notice] Your Tor server's identity key \
&gt; fingerprint is 'SlickLittleGirl AD35 6EF8 E87A 89E6 C898 B745 00D5 8607 AC69 1178' \
&gt; Apr 10 17:07:53.825 [notice] I learned some more directory information, but not \
&gt; enough to build a circuit: We have no recent network-status consensus. Apr 10 \
&gt; 17:07:54.190 [notice] Self-testing indicates your ORPort is reachable from the \
&gt; outside. Excellent. Publishing server descriptor. Apr 10 17:08:09.066 [notice] We \
&gt; now have enough directory information to build circuits. Apr 10 17:08:11.621 \
&gt; [notice] Tor has successfully opened a circuit. Looks like client functionality is \
&gt; working. Apr 10 17:08:18.088 [notice] Self-testing indicates your DirPort is \
&gt; reachable from the outside. Excellent. Apr 10 17:08:18.375 [notice] Performing \
&gt; bandwidth self-test...done. Apr 11 12:25:25.848 [err] Bug: buffers.c:1688: \
&gt; assert_buf_ok: Assertion ch-&gt;data &gt;= &amp;ch-&gt;mem[0] failed; aborting. 
&gt; Unfortunately it doesn't look like a core dump has been created.

Hm. Unfortunately, this looks like one we're not going to be able to
trace down without at least a stack trace.  If you like, you can
submit it to the bugtracker so we don't forget about it.

From what I can tell, it looks like a representation error in a buffer
chunk, but I don't see any code path that can lead to that particular
problem being created, so all I can think of right now is some kind of
memory stomping bug.

yrs,
-- 
Nick


</body></email><email><emailId>20080413230840</emailId><senderName>Mike Perry</senderName><senderEmail>mikeperry@fscked.org</senderEmail><timestampReceived>2008-04-13 23:08:40-0400</timestampReceived><subject>Re: Status of Tor proposals and proposal process (March 2008)</subject><body>


Thus spake Nick Mathewson (nickm@freehaven.net):

&gt;    115  Two Hop Paths
&gt;    116  Two hop paths from entry guards
&gt; 
&gt;         These both are probably dead at this point: there's been no
&gt;         activity for some while.  Both have uncertain anonymity
&gt;         implications, especially in light of new path features (like
&gt;         bridges) and possible scalability features arma has in mind.
&gt;         If anybody wants to resurrect them, a first step will be a
&gt;         really thorough analysis of what different attackers can do
&gt;         against them.  Marking as DEAD.

Please do not delete these (go ahead and put them in a DEAD directory
if you would like, though). I intend on revisiting them as soon as I
finish up with more immediate Tor tasks and lower hanging fruit. I
still believe the barriers are fundamentally engineering problems
rather than theoretical problems, but I do agree the proposals need a
rewrite to do a more clear job of enumerating and organizing the
anonymity considerations so that they are easier to grok. The prose in
115 can get a bit thick..

(And to put into perspective any fears that the anonymity issues of
two hop paths are too hairy to ever try to solve, I contend that
anonymity under Firefox is a far more fearsome beast ;)
 
-- 
Mike Perry
Mad Computer Scientist
fscked.org evil labs

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20080414000002</emailId><senderName></senderName><senderEmail>nickm</senderEmail><timestampReceived>2008-04-14 00:00:02-0400</timestampReceived><subject>Re: Status of Tor proposals and proposal process (March 2008)</subject><body>

On Sun, Apr 13, 2008 at 04:08:40PM -0700, Mike Perry wrote:
&gt; Thus spake Nick Mathewson (nickm@freehaven.net):
&gt; 
&gt; &gt;    115  Two Hop Paths
&gt; &gt;    116  Two hop paths from entry guards
&gt; &gt; 
&gt; &gt;         These both are probably dead at this point: there's been no
&gt; &gt;         activity for some while.  Both have uncertain anonymity
&gt; &gt;         implications, especially in light of new path features (like
&gt; &gt;         bridges) and possible scalability features arma has in mind.
&gt; &gt;         If anybody wants to resurrect them, a first step will be a
&gt; &gt;         really thorough analysis of what different attackers can do
&gt; &gt;         against them.  Marking as DEAD.
&gt; 
&gt; Please do not delete these (go ahead and put them in a DEAD directory
&gt; if you would like, though).

Don't worry.  Proposals don't get deleted.  Look at the "Status" lines
near the heads of the files, and look at 000-index.txt : the only
thing involved in marking proposals as "Dead" is changing their status
to "Dead".  For more info, see 001-process.txt .

yrs,
-- 
Nick
</body></email><email><emailId>20080317145332</emailId><senderName></senderName><senderEmail>phobos</senderEmail><timestampReceived>2008-03-17 14:53:32-0400</timestampReceived><subject>Re: select()</subject><body>

On Mon, Mar 17, 2008 at 01:45:32PM -0000, toby.douglass@45mercystreet.com wrote 0.6K bytes in 16 lines about:
: BTW, I note this reply was to "or-dev@freehaven.net" and cc:'d
: "or-dev@seul.org".  Why the two addresses?  I've left freehaven as a cc:
: just in case.

They are the same list, just aliases to one another.

-- 
Andrew
</body></email><email><emailId>20080319105004</emailId><senderName>"Steven J. Murdoch"</senderName><senderEmail>tor+steven.murdoch@cl.cam.ac.uk</senderEmail><timestampReceived>2008-03-19 10:50:04-0400</timestampReceived><subject>Re: Improving the robustness of Tor Check</subject><body>

On Sun, Mar 16, 2008 at 12:12:07PM -0700, Mike Perry wrote:
&gt; I'd like to propose an extension that would make it much easier for
&gt; Torbutton to provide feedback via a simple icon indication.
...

Good idea. I've added this to the proposal.

Steven.

-- 
w: http://www.cl.cam.ac.uk/users/sjm217/
</body></email><email><emailId>20080323233027</emailId><senderName>Robert Hogan</senderName><senderEmail>robert@roberthogan.net</senderEmail><timestampReceived>2008-03-23 23:30:27-0400</timestampReceived><subject>Re: A Tor Web Service For Verifying Correct Browser Configuration</subject><body>


On Saturday 22 March 2008 15:57:57 Nick Mathewson wrote:
&gt; On Sun, Mar 16, 2008 at 08:25:47PM +0000, Robert Hogan wrote:
&gt;
&gt; {For reference, this is now proposal 132.  See
&gt;   
&gt; http://www.torproject.org/svn/trunk/doc/spec/proposals/132-browser-check-to
&gt;r-service.txt }
&gt;
&gt; &gt; Filename: xxx-browser-check-tor-service.txt
&gt; &gt; Title: A Tor Web Service For Verifying Correct Browser Configuration
&gt; &gt; Version: $Revision: 13955 $
&gt; &gt; Last-Modified: $Date: 2008-03-16 18:51:55 +0000 (Sun, 16 Mar 2008) $
&gt; &gt; Author: Robert Hogan
&gt; &gt; Created: 2008-03-08
&gt; &gt; Status: Draft
&gt;
&gt; Hi, Robert!  I'd like to ask about a couple of alternative designs
&gt; that periodically come up for this problem, and ask about security
&gt; implications.
&gt;
&gt; The two main alternative designs are:
&gt;    - Use a remote "am I using Tor" page.
&gt;
&gt;      This handles tests 2 and 3 pretty easily, and with a little
&gt;      effort can be made to do test 1.
&gt;

Here are the pros/cons for remote vs local service:

Remote - Pro:
- Fixes/Upgrades not release dependent.
- Available to all users immediately.

Remote - Con:
- A remote service not accessed through Tor could be manipulated to deceive the 
user into thinking they *are* using Tor. 
- Dependence on external resources.
- Failing the test allows Tor users to expose themselves by accessing 
well-defined resources.

Local - Pro:
- No dependence on external resources. (If test 3 is modified to serve an image 
when a circuit is successfully built, rather than serving an actual external 
resource.)

Local - Con:
- Failing the test allows Tor users to expose themselves by accessing 
well-defined resources.
- Release dependent. Users will be stuck with any implementation flaws until they 
upgrade.
- An additional HTTP service on Tor is an additional attack channel. Assuming 
that the service does not accept HTTP POST, what can an attacker garner from a 
GET? Could an attacker use it to determine if a user is running Tor? Could they 
send malformed URL requests to crash the service and exploit Tor? Perhaps the 
service could be single use - it is enabled by the controller and once it has 
served responses for all defined tests or after a period of time, closes down 
until re-enabled.


&gt;    - Have a controller do it without modifying, or with minimal
&gt;      modifications to, the Tor client.
&gt;
&gt;      Test 3 (net connectivity by Tor) is as easy as looking for
&gt;      whether Tor can build a circuit, I think.  For test 2 (is browser
&gt;      using Tor), just use a MAPADDRESS command to replace a randomly
&gt;      chosen unique ID hostname with (say) torproect.org.  For test 1
&gt;      (is browser using Tor for DNS), send the browser to request a
&gt;      random hostname, and then look in Tor's DNS cache to see whether
&gt;      Tor has a cached entry there.
&gt;

Yes, the controller could create/maintain one or two static, locally stored html 
pages for the user to open. The first one would contain the tests. The second 
would contain the results gathered by the controller. Or maybe an auto-refresh 
http header would serve just as well to serve the test and then the results.

Since a tor http test service is really only going to be useful for controllers, 
maybe this approach is the best overall.  The contents of the page could be 
specified by the tor project. The html page could even be distributed with Tor 
and installed to some specified location for controllers to access. The downside 
with this is that controllers would have to modify some of the page's contents 
for the tests to work properly and copy the page to an alternative location for 
opening.

Alternatively Tor could generate the page on request (with the randomized 
hostnames etc.) at a controller selected location. But this is just passing work 
to Tor unnecessarily I think.

I think it would be important for the page to be distributed or specified by 
Tor - otherwise controller maintainers are just muddling through themselves.


&gt;      [There may be better ways to do these.]
&gt;
&gt; The security implications as near as I can tell are:
&gt;
&gt;     * It adds a way to tell if people are using Tor: when they test an
&gt;       instance of Tor that isn't configured properly, they'll leak
&gt;       pretty identifiable requests to one or two well-known addresses.
&gt;
&gt;     * There are lots of attacks this doesn't solve, particularly
&gt;       browser-based ones.  We could solve this by having a link to a
&gt;       remote "am I using Tor right" page, I guess.
&gt;
&gt;     * It adds another local resource that speaks HTTP; experience
&gt;       suggests that we should think about whether remote pages can use
&gt;       links or javascript to redirect users here in a way that will be
&gt;       useful to an adversary.
&gt;
&gt; None of these seem really terrible to me at the moment, but we should
&gt; analyze them.
&gt;
&gt;
&gt; What do you think?



["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20080324163533</emailId><senderName>Jens Kubieziel</senderName><senderEmail>maillist@kubieziel.de</senderEmail><timestampReceived>2008-03-24 16:35:33-0400</timestampReceived><subject>typos in proposal 131</subject><body>


If the IP addressed used for this feature moves there will be two
                 ^^ --&gt; address

belive can remain static.
   ^^ --&gt; ie

Besten Gruß

-- 
Jens Kubieziel                                   http://www.kubieziel.de
Like almost everyone who uses e-mail, I receive a ton of spam every day.
Much of it offers to help me get out of debt or get rich quick. It would
be funny if it weren't so irritating. Bill Gates

["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20080327161123</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-03-27 16:11:23-0400</timestampReceived><subject>Re: Fwd: Proposal: Incorporate Unreachable ORs into the Tor Network</subject><body>

On Mon, Mar 24, 2008 at 10:10:44PM +0000, Robert Hogan wrote:
&gt; On Saturday 22 March 2008 15:13:10 Nick Mathewson wrote:
&gt; &gt; On Sat, Mar 22, 2008 at 11:11:12AM +0000, Robert Hogan wrote:
&gt; &gt; &gt; I'm not sure how much merit this proposal has, or how serious it's
&gt; &gt; &gt; problems are.  Does anyone have any thoughts on it? Are the problems
&gt; &gt; &gt; I've outlined fatal, or is there a problem with it I've missed? I
&gt; &gt; &gt; suspect one or the other.
&gt; &gt;
&gt; &gt; Hi, Robert!  I think this is definitely a step in the right direction,
&gt; &gt; with some tricky issues associated with it.  In particular, it
&gt; &gt; represents a big deviation from Tor's current clique topology.  We
&gt; &gt; should definitely drop the clique assumption (for scaling reasons if
&gt; &gt; nothing else) at some point, though, and there's no reason it can't be
&gt; &gt; soon.
&gt; &gt;
&gt; &gt; Send it to or-dev and let's talk about it there?

Added as proposal 133.

&gt; &gt;
&gt; 
&gt; Hi Nick,
&gt;
&gt;  Had to scratch my head on what clique topology means but I think I
&gt; get it: where every node has to be able to connect to every other in
&gt; the network. I guess that does mean a few anonymity properties
&gt; previously taken for granted on Tor may get flushed out by this -
&gt; pretty sure I haven't captured them all.

Right.  There are some papers that have tried to figure out the
implications of limited topologies like this, but I don't know what
they have to say about this case in particular.

What's bigger in scope is that our current requirement that (mostly)
every router be able to talk (mostly) to every other router can't
possibly scale.  Assuming that the number of users stays large enough
to saturate most routers, as the number of routers grows, so does the
number of sockets and buffers that every router needs to maintain.
Thus, for the network to continue to grow, we'll need a design where
the number of links does not grow as the square of the number of
routers.

George Danezis's "Mix-networks with Restricted Routes" paper in PET
2003 tried to analyze the anonymity implications of one design like
this in a mix-network situation.  Roger, Vitaly, and Paul talked about
some restricted-route designs in their "Synchronous Batching" apper.
The MorphMix design is also worth looking at, though new attacks
against it appear pretty frequently.

The main challenges in designs of this kind are:

  - Attacks where an attacker who sees only one part of the path can
    deduce too much information about the rest of the path from the
    network topology.

  - Attacks where a set of attacker-controlled nodes manipulate the
    topology assignment process to arrange to move into a strategic
    position relative to one another on the network.

There are probably other attacks, too.

&gt;  Are there any better ways of finding out how many servers out there
&gt; fail to publish because they can't pass the orport reachability
&gt; test? The proposal assumes there are a lot, but maybe there are
&gt; surprisingly few.

I don't know a better way than what you suggest (having such servers
upload "I'd like to be a server, but I'm unreachable" statements to
the authorities).  I'm not sure how much we can learn from this,
though: it will only tell us how many people have set up computers to
be servers, found that their firewalls have blocked them, and then
given up but left the Tors configured as servers.  This isn't the same
as learning how many people would *like* to set up Tor servers, but
know that they can't do so with their firewalls, and have decided not
to try.

yrs,
-- 
Nick
</body></email><email><emailId>20080327185422</emailId><senderName>Fabian Keil</senderName><senderEmail>freebsd-listen@fabiankeil.de</senderEmail><timestampReceived>2008-03-27 18:54:22-0400</timestampReceived><subject>Re: [or-cvs] r14216: Only log a notice that dmalloc has been set up</subject><body>


nickm@seul.org wrote:

&gt; Author: nickm
&gt; Date: 2008-03-27 12:46:39 -0400 (Thu, 27 Mar 2008)
&gt; New Revision: 14216

&gt; Log:
&gt;  r19093@catbus:  nickm | 2008-03-27 12:43:58 -0400
&gt;  Only log a notice that dmalloc has been set up if it fails.  Actually,
&gt; since we have not added a temp log yet, I am not sure this ever does
&gt; anything.
 
&gt; Modified: tor/trunk/src/or/main.c
&gt; ===================================================================
&gt; --- tor/trunk/src/or/main.c	2008-03-27 16:46:36 UTC (rev 14215)
&gt; +++ tor/trunk/src/or/main.c	2008-03-27 16:46:39 UTC (rev 14216)
&gt; @@ -1969,7 +1969,8 @@
&gt;  #ifdef USE_DMALLOC
&gt;    int r = CRYPTO_set_mem_ex_functions(_tor_malloc, _tor_realloc,
&gt;                                        _tor_dmalloc_free);
&gt; -  log_notice(LD_CONFIG, "Set up dmalloc; returned %d", r);
&gt; +  if (!r) {
&gt; +    log_warn("Couldn't configure openssl to use dmalloc functions.");
&gt;  #endif
&gt;  #ifdef NT_SERVICE
&gt;    {

I might be missing the bigger picture here,
but the opening curly brace looks lonely to me.

Fabian

["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20080328214618</emailId><senderName>Kyle Williams</senderName><senderEmail>kyle.kwilliams@gmail.com</senderEmail><timestampReceived>2008-03-28 21:46:18-0400</timestampReceived><subject>Re: [jarusl@cs.northwestern.edu: Tor proxy for Virtual Machines]</subject><body>

I've seen this and it is very interesting.  I like how reference 16 
points to JanusVM, which basically does the same thing.  JanusVM also 
works with Qemu that has been patched to work with LibPCAP.

However, the crutch with both projects being "... that you have the PCAP 
and LIBNET libraries installed."  Which really isn't much.

With JanusVM the host OS is using the guest OS to transport traffic over 
Tor.
With TorVTL the guest OS is using Tor from the host OS to transport 
traffic.  I would imagine you could run this inside a VM too if one so 
desired.

Very nice. :)

- Kyle


Nick Mathewson wrote:
&gt; Forwarding this with permission.  It looks like interesting work,
&gt; especially for people pursuing VM-based anonymization strategies.
&gt; 
&gt; ----- Forwarded message from "John R. Lange" &lt;jarusl@cs.northwestern.edu&gt; -----
&gt; 
&gt; From: "John R. Lange" &lt;jarusl@cs.northwestern.edu&gt;
&gt; To: tor-volunteer@torproject.org
&gt; Subject: Tor proxy for Virtual Machines
&gt; X-Spam-Level: 
&gt; 
&gt; Hi,
&gt; 
&gt; As part of one of our research projects, I put together a small proxy tool 
&gt; that anonymizes all TCP and DNS traffic originating in a virtual machine 
&gt; (at least with VMWare or Xen). It currently runs under linux, but contains 
&gt; very early support for Windows.
&gt; 
&gt; It plugs in beneath the Virtual Machine Monitor, so it is capable of 
&gt; providing TOR support for any application+OS combination without any 
&gt; configuration or special proxy tool needing to be installed in the guest 
&gt; environment.
&gt; 
&gt; It works by configuring a VM's network adapter to connect to a host-only 
&gt; network, where none of the packets are ever transmitted out of the host 
&gt; machine. Every ethernet packet coming from the VM is then captured and 
&gt; translated into SOCKs traffic that is forwarded to a TOR proxy. If the 
&gt; packet is not supported then it is simply dropped and is never transmitted 
&gt; on the network.
&gt; 
&gt; More info on the tool can be found here:
&gt; http://www.artifex.org/~jarusl/TorVTL/
&gt; 
&gt; While the paper can be found here:
&gt; http://www.artifex.org/~jarusl/research/pubs/hpdc07-vtl.pdf
&gt; 
&gt; I'm unsure whether this will be of any interest to people, but I figured 
&gt; I'd let you know.
&gt; 
&gt; regards
&gt; --Jack
&gt; Jack Lange ; NU CS ; jarusl@cs.northwestern.edu
&gt; http://www.cs.northwestern.edu
&gt; 
&gt; ----- End forwarded message -----
&gt; 

</body></email><email><emailId>20080201224504</emailId><senderName>"Kevin Bauer"</senderName><senderEmail>ksbauer@gmail.com</senderEmail><timestampReceived>2008-02-01 22:45:04-0400</timestampReceived><subject>Re: Proposal to mitigate insecure protocols over Tor</subject><body>

As a follow-up to our numbers on insecure protocol usage over Tor, we
developed a method for detecting certain types of exit node logging.
The basic idea behind our method is to 1) set up an authoritative DNS
server for a block of unused IP addresses and 2) send SYN pings to our
unused IPs through exit nodes. If any of the exit nodes perform a
reverse DNS query for the IP, then it shows that they were observing
the traffic. Certain configurations of tcpdump perform reverse DNS
queries in real-time.

After only 1 day of running the detection mechanism described above,
we got DNS hits from one exit router. Upon further inspection, we
found that it only performed reverse DNS queries when it was SYN
pinged through port 110 (the default POP3 port). It seems clear that
this exit router is targeting this "insecure" port, possibly looking
for usernames and passwords.

The router in question is:

Router Name: bytebutlerfour
Fingerprint: 8E17 BA28 629A 8272 8CB3 A642 D282 6DD8 EF56 240E
Contact: Mike &lt;master@desastercenter.com&gt;
IP Address: 84.189.5.52
Hostname: p54BD0534.dip0.t-ipconnect.de
Onion Router Port: 65001
Directory Server Port: None
Country Code: DE
Platform / Version: Tor 0.1.2.19 on Windows Server 2003 Service Pack 1
[domain controller] {enterprise} {terminal services, single user}
{terminal services}
Last Descriptor Published (GMT): 2008-01-31 19:54:04
Current Uptime: 1 Day(s), 1 Hour(s), 29 Minute(s), 46 Second(s)
Bandwidth (Max/Burst/Observed - In Bps): 20480 / 28672 / 23355
Family: $1D3EFD211CB0E230D2223CE72117FDF4665D445E
$1D93DCDFA5987EEC7B279B4583E989D178F91E73
$2FA9A64ADEBBB3A424E7D7891FB63C3AC652E675
$6640ADB2810AA20B616B5599BC422FC1D1394D02

Kevin

On Jan 25, 2008 1:34 AM, Roger Dingledine &lt;arma@mit.edu&gt; wrote:
&gt; On Sun, Jan 20, 2008 at 10:27:57PM -0700, Kevin Bauer wrote:
&gt; &gt; On Jan 19, 2008 11:57 PM, Roger Dingledine &lt;arma@mit.edu&gt; wrote:
&gt; &gt; &gt; So the next question is: reject by default or just warn? I'm inclined to
&gt; &gt; &gt; reject by default, just to counter the number of users who are probably
&gt; &gt; &gt; happily using Tor and have no idea that there's a problem. Even if they
&gt; &gt; &gt; get angry and stop using Tor because it's "broken" now, that's probably
&gt; &gt; &gt; ok for them.
&gt; &gt;
&gt; &gt; For Telnet, IMAP, and POP, I would suggest that the policy be to block
&gt; &gt; by default for the following reason.  During our 8 day observations
&gt; &gt; cited in the initial proposal, the Telnet, IMAP, and POP traffic
&gt; &gt; accounted for around 0.16% of the total connections that were
&gt; &gt; established through our exit node. So we're probably not talking about
&gt; &gt; a large fraction of the protocols that are used over Tor.
&gt;
&gt; Well, you have to remember that we're blocking by port, not blocking
&gt; by protocol.
&gt;
&gt; In chatting with some folks on #tor, they reminded me that an increasing
&gt; number of pop / imap clients are using STARTTLS:
&gt; http://tools.ietf.org/html/rfc2595
&gt; which uses the same ports as the unencrypted varieties.
&gt;
&gt; In an ideal world, we would somehow be able to divine whether the
&gt; protocol going over the port was doing a safe thing or an unsafe thing.
&gt; But I don't much want to write pop and imap proxies, nor to write a pop
&gt; or imap analyzer inside Tor and run it on all the traffic that happens
&gt; to ask for these ports. It still seems like the only real option is
&gt; to just reject them by default, and give Vidalia a good interface to
&gt; reenable ports if you think you're doing it right.
&gt;
&gt; I wonder what proportion of our users are doing this, and if there are
&gt; instructions out there on the 'net somewhere for how to enable encryption
&gt; in standard mail programs?
&gt;
&gt; Of course, if it's optimistic encryption and the mail client doesn't
&gt; know what TLS key to expect from the other side, the encryption may not
&gt; help us much against a hostile exit relay. So the question is not just
&gt; "do they support starttls", but also "do they manage keys intuitively
&gt; and well". And I bet we can all guess the answer to that.
&gt;
&gt; &gt; As far as I know (and perhaps someone can correct me if I'm wrong
&gt; &gt; here), most popular instant messaging services (like AIM, MSN , Yahoo,
&gt; &gt; Jabber, etc.) exchange login credentials securely over SSL/TLS. Thus,
&gt; &gt; in my opinion, they differ from Telnet, IMAP, and POP in this respect.
&gt; &gt; However, they do generally seem to expose a user's screen name in the
&gt; &gt; application header. Thus, they may be unwise to use over Tor for
&gt; &gt; anonymity reasons. Certainly a warning about the risks that are
&gt; &gt; inherent in these instant messaging protocols is prudent, but I think
&gt; &gt; that the information leakage is probably no worse than what is
&gt; &gt; possible over HTTP.
&gt;
&gt; I talked to Ian Goldberg about AIM, and he confirmed that AIM gives at
&gt; least a token effort to not leak your password in the clear. It does
&gt; leak your username, but hopefully this is something that our users can
&gt; comprehend and act appropriately.
&gt;
&gt; --Roger
&gt;
&gt;
</body></email><email><emailId>20080213072935</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2008-02-13 07:29:35-0400</timestampReceived><subject>Re: Small leak patch</subject><body>

On Tue, Feb 12, 2008 at 10:01:32AM +0100, freddyz77@tin.it wrote:
&gt; I discovered a small fd leak in src/common/compat.c:tor_mmap_file
[snip]
&gt; If file is zero fd was not released.

Fixed:
http://archives.seul.org/or/cvs/Feb-2008/msg00141.html
http://archives.seul.org/or/cvs/Feb-2008/msg00142.html

Thanks!
--Roger

</body></email><email><emailId>20080213090804</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2008-02-13 09:08:04-0400</timestampReceived><subject>Re: Multiple Directory Authorities' keys compromise: a partial solution for Tor clients protection</subject><body>

Ygrek just reminded me that nobody had answered this. Sorry for the delay;
I'll try to provide a brief response here.

On Fri, Dec 28, 2007 at 01:29:37PM +0300, unknown wrote:
&gt; The core problem with Tor is the lack of directory authorities which one
&gt; need to unconditionally trust. Despite the mechanisms of DAs consensus
&gt; voting and client comparing signed data downloaded from different DAs,
&gt; an opponent controlling more than half of DAs' keys is able to conduct
&gt; a multitude of attacks.

Yep.

&gt; Unfortunately, we have a really small set of semi-trusted authorities
&gt; and more than a half of them are in the single jurisdiction (US), so we
&gt; are forced to believe that owners of these servers really protect their
&gt; servers' keys from compromise, and operators themselves are free from
&gt; any third-party malicious influence ;-)

Actually, of the current v3 authorities:

3 are in the US (moria1, lefkada, ides)
3 are in Europe (tor26, gabelmoo, dannenberg)

but yes, it's definitely an issue we need to stay aware of.

&gt; We propose a partial (very limited, but adequate) solution: Tor client with active \
&gt; connection and relatively "fresh" stats cache can resort to "heuristic" analysis \
&gt; for suspicious stats changes. 
&gt; At most two criteria can be analyzed:
&gt; 
&gt; 1) An attempt to download stats from all of the mirrors is blocked or gives the \
&gt; stats with invalid signatures. As a result, it could be downloaded only from \
&gt; semi-trusted DAs. (Possibility of a legitimate DA's IP substituted with a malicious \
&gt; one, and data authenticated with compromised keys). 
&gt; 2) Tor-nodes' keys signed by a DA are changed significantly (for example, &gt;90% of \
&gt; all keys) during a very short period of time. (This case rises a suspicion about \
&gt; fake stats injection for user cache.) 
&gt; Some questions remains: How many keys have to be affected by this attack to rise a \
&gt; suspicion? What the minimum time period threshold should be? 
&gt; ...) What's about other criteria of suspicious activity or formal model of other \
&gt; possible attacks detection for Tor clients?

Right. This is really tricky though. If we are too brittle, then we will
throw false warnings to ordinary users, who will get really agitated but
not really know what they're supposed to do. (Every few weeks there's
another big thread on or-talk where a warning message that we thought
would never happen in ordinary circumstances did happen and the users
get all upset about it.) And if we're not brittle enough, then we won't
catch much at all in the way of possible attacks.

Worse, since these attacks rarely (never?) show up in practice, we're
never going to get feedback that the code is still working. The most
likely scenario for any balance that we pick between too brittle and
not brittle enough is that in about a year people will start seeing the
warnings when no actual attack is occurring, and we'll wonder why the
code is there.

Extra worse, there is no single balance that's right for all users. If a
user is on a network with a firewall that he doesn't understand, it will
block some outgoing connections, and then the "you're being attacked!"
warnings are more likely to pop up, confusing the user further. (We also
need to tolerate users who accidentally unplug their ethernet cable,
try to use Tor, and conclude that there's a massive global conspiracy
against Tor.)

Then what if we have a bug where a lot of Tor servers die at once, so
the network looks quite a bit different in a very short period of time.
Should we make that even worse by popping up "Possible attack! Click
ok!" messages?

All of the above scenarios actually do happen periodically. Whereas
we've never seen an attack on a majority of the directory authorities.
So to keep things sane both now and a year from now, I think we would
err on the side of "try to not show the warning" as much as possible --
and then there's less point with the whole feature.

&gt; We propose next log messages for the Tor client as an indication of probable \
&gt; attack-in-progress: 
&gt; -&gt; Warning! Warning: a lot of tor-nodes' keys were changed during a short period of \
&gt;                 time!
&gt; -&gt; If more than a half of Directory Authorities' keys are compromised, stats could \
&gt; be poisoned with a fake data.

An ordinary user would have no idea what this means. Should they stop
using Tor and retry their connection without Tor? Should they ignore it?
Should they get really scared, and then try one of the above choices?

&gt; As a paranoid option listed in config file (client-only section) one may use:
&gt; 
&gt; StopTorIfTooManyKeysChanged 0|1

This would be a fine option for a few people to set, but we couldn't
usefully turn it on by default, for the reasons explained above.

But I agree with you that being able to detect this situation would be
potentially useful. Rather than having Tor itself do it, why not have an
external tool that monitors your cached directory information (or asks
via the control port) and notifies you if it decides something is too
suspicious? You could then tune its level of suspicion however you like,
since you're the one running it and you know what it's looking for and
how to interpret the output. That would also help resolve your other
questions of "what is the right thing for an ordinary user to do when
he sees this", since ordinary users would learn about it when we put
out the emergency security update.

What do you think?

--Roger


</body></email><email><emailId>20080222144450</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2008-02-22 14:44:50-0400</timestampReceived><subject>Re: [or-cvs] r13656: Note a couple of items for backport in TODO.012, including  (in tor/branches/to</subject><body>

On Thu, Feb 21, 2008 at 10:41:14AM -0500, nickm@seul.org wrote:
&gt; +  - r13372: Don't use ourselves as intro point, rend point, or final hop
&gt; +    for internal circuits.
&gt;    - r13532: Drop tor_strpartition().
&gt; +  - r13643: reset timeout when flushing final bytes from a connection.
&gt; +  - r13655: avoid flush on connection closed because of bug.
&gt;  Backport for 0.1.2.x once better tested:
&gt; +  - r13647: Make "trackhostexits ." work

None of these look like critical bugfixes. More generally, it looks like
we're switching towards a backport policy of "if it isn't too complex
and it might help", which is different from our earlier policy of "if
it's a really big deal and it looks like it won't break anything".

I think the stable users will be fine without most of these changes.
It's easy to fall into the trap of actively maintaining two versions at
once; but imo we don't have the developer-power to do that.

--Roger

</body></email><email><emailId>20080224221026</emailId><senderName></senderName><senderEmail>nickm</senderEmail><timestampReceived>2008-02-24 22:10:26-0400</timestampReceived><subject>Re: [or-cvs] r13688: Servers that don't know their own IP address should go to th (in tor/trunk: . s</subject><body>

On Sun, Feb 24, 2008 at 11:49:24AM +0000, Robert Hogan wrote:
 [...]
&gt; I encountered this bug while trying to get 'getinfo extra-info/digest/X' to 
&gt; work for my own server's extra-info digest.
&gt; 
&gt; The attached fixes 2 things:
&gt; 
&gt; 1. Though it shouldn't happen now that desc_routerinfo is properly created, 
&gt; adding a null &amp;(router_get_my_routerinfo()-&gt;cache_info) in 
&gt; dirserv_get_routerdescs causes a segfault later on in getinfo_helper_dir.
&gt; 
&gt; 2. If the requested extra-info is for our own server, supply it every time: it 
&gt; isn't always retrievable by extrainfo_get_by_descriptor_digest.

Thanks!  I've checked this in.
</body></email><email><emailId>20080229183628</emailId><senderName>Robert Hogan</senderName><senderEmail>robert@roberthogan.net</senderEmail><timestampReceived>2008-02-29 18:36:28-0400</timestampReceived><subject>Re: Getting 'Unreachable' Servers Onto The Network</subject><body>


On Thursday 28 February 2008 19:38:04 Robert Hogan wrote:
&gt; Maybe it's a solution in search of a problem, maybe UPnP will sort most of
&gt; this out, but assuming that the following problem is real and substantial:
&gt;
&gt; Problem: Restrictive local/remote firewalls and routers are preventing many
&gt; willing candidates from becoming OR servers. UPnP can mitigate this problem
&gt; if it is confined to a DSL router firewall (with UPnP enabled by the user)
&gt; but it still leaves a substantial chunk of willing servers out there whose
&gt; ORPort is not available to outside connection attempts. The Tor network is
&gt; losing out on their bandwidth. At the moment we don't even know how many
&gt; such 'candidate' servers there are.
&gt;

&gt;
&gt; Major objections:
&gt;
&gt;  i. Thousands, millions of idle orconns! Uugh! It's an ugly thought I
&gt; admit, but they're pretty cheap as far as I know. Would a server have any
&gt; actual problem handling them?
&gt;

The notion of connecting to *loads* of other servers is pretty daft. Perhaps a 
better way of doing it would be:

- Every published server accepts orconns from a maximum of N fallback servers.
- Every fallback server maintains N orconns with published servers.

When clients are building fallback circuits they simply request an unspecified 
fallback server for either the middleman or exit. The choice of server is 
left to the node constructing that leg of the circuit.

The choice of server is communicated to the client and the client verifies 
that a listed fallback server has been chosen. It would only use the same 
fallback server X number of times per fallback circuit, and never more than a 
specific number of times from the same published server for a defined period 
of time.

&gt;  ii. [insert major anonymity problem here]

Which is probably where this comes in. The choice of fallback server is 
delegated to a published server but as long as the client is careful this 
shouldn't matter.


&gt;
&gt; This isn't the result of days of solemn reflection so feel free to kick me
&gt; out of the park on it.



["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20080101154150</emailId><senderName>unknown</senderName><senderEmail>unknown@pgpru.com</senderEmail><timestampReceived>2008-01-01 15:41:50-0400</timestampReceived><subject>Re: Multiple Directory Authorities' keys compromise: a partial</subject><body>

Happy 2008! Here we go again ;-)

Any comments?

On Fri, 28 Dec 2007 13:29:37 +0300
unknown &lt;unknown@xxxxx.xxx&gt; wrote:

 Multiple Directory Authorities' keys compromise: a partial
 solution for Tor clients protection.

 The core problem with Tor is the lack of directory
 authorities which one need to unconditionally trust. Despite
 the mechanisms of DAs consensus voting and client comparing
 signed data downloaded from different DAs, an opponent
 controlling more than half of DAs' keys is able to conduct
 a multitude of attacks.

 Unfortunately, we have a really small set of semi-trusted
 authorities and more than a half of them are in the single
 jurisdiction (US), so we are forced to believe that owners
 of these servers really protect their servers' keys from
 compromise, and operators themselves are free from any
 third-party malicious influence ;-)

 Main security and trust problems were improved in v3 directory
 authority protocol, but not resolved completely.

 If the third-party agent Mallory possesses more than half
 of semi-trusted DA keys and has an ISP-level access to user
 traffic, he still can make an MITM-based virtual network
 simulation for that user, like this:

 Normal client activity:

 Alice -&gt; encrypted traffic -&gt; [real Tor cloud] -&gt; decrypted
 traffic from exitnode -&gt; Bob

 Intercepted client activity:

 Alice -&gt; encrypted traffic -&gt; [Mellory's virtual Tor network
 simulation] -&gt; decrypted traffic for Mellory -&gt;
 -&gt; [Mellory's Tor client using Alice's circuits] -&gt; [real
 Tor cloud] -&gt; decrypted traffic from exitnode -&gt; Bob

 ###

 We propose a partial (very limited, but adequate) solution:
 Tor client with active connection and relatively "fresh"
 stats cache can resort to "heuristic" analysis for suspicious
 stats changes.

 At most two criteria can be analyzed:

 1) An attempt to download stats from all of the mirrors
 is blocked or gives the stats with invalid signatures. As
 a result, it could be downloaded only from semi-trusted
 DAs. (Possibility of a legitimate DA's IP substituted with a
 malicious one, and data authenticated with compromised keys).

 2) Tor-nodes' keys signed by a DA are changed significantly
 (for example, &gt;90% of all keys) during a very short period of
 time. (This case rises a suspicion about fake stats injection
 for user cache.)

 Some questions remains: How many keys have to be affected
 by this attack to raise a suspicion? What the minimum time
 period threshold should be?

 ...) What's about other criteria of suspicious activity
 or formal model of other possible attacks detection for
 Tor clients?

 We propose next log messages for the Tor client as an
 indication of probable attack-in-progress:

 -&gt; Warning! Warning: a lot of tor-nodes' keys were changed
 during a short period of time!
 -&gt; If more than a half of Directory Authorities' keys are
 compromised, stats could be poisoned with a fake data.

 As a paranoid option listed in config file (client-only
 section) one may use:

 StopTorIfTooManyKeysChanged 0|1

 Other open questions: Suppose user has this option
 enabled. Is it then sufficient to stop Tor-client when
 before-mentioned log event comes up or should also be done
 some other things too? What are the right things to do for
 users who got that log event? What's the right procedure to
 run Tor-client for users who have an outdated cache to be
 safe from this attack?

 There is a long discussion on this problem on our site where
 we continue to propose a lot of ideas related to the topic.

 "OpenPGP-in-Russia Team"

</body></email><email><emailId>20080102082825</emailId><senderName>"anon ymous"</senderName><senderEmail>a.y.main.contact@googlemail.com</senderEmail><timestampReceived>2008-01-02 08:28:25-0400</timestampReceived><subject>Re: Tor and privoxy had been ported to iphone and works very well.</subject><body>

On 12/31/07, Nick Mathewson &lt;nickm@freehaven.net&gt; wrote:
&gt; On Mon, Dec 24, 2007 at 05:17:27PM +0800, cjacker huang wrote:
&gt; &gt; Here is the debug.log,
&gt; &gt; Any suggestion?
&gt; &gt;
&gt;
&gt; If there's any way you can get a stack trace the next time this
&gt; happens, that would help a lot in debugging it.  It looks like there's
&gt; a directory connection object with its purpose uninitialized, but it's
&gt; not clear what's creating it.
&gt;
&gt; yrs,
&gt; --
&gt; Nick
&gt;
</body></email><email><emailId>20080102164548</emailId><senderName>Paul Syverson</senderName><senderEmail>syverson@itd.nrl.navy.mil</senderEmail><timestampReceived>2008-01-02 16:45:48-0400</timestampReceived><subject>Re: Topic of a diploma</subject><body>

On Wed, Jan 02, 2008 at 10:59:44AM -0500, Nick Mathewson wrote:
&gt; 
&gt; You might also check out other related papers on anonbib; there's some
&gt; good research been happening in the last few years.  IMO, new defenses
&gt; are generally more interesting than new attacks, since the attacks are
&gt; already so good that new, equally good attacks aren't very impressive.
&gt; 

I agree that attacks are far enough ahead of defenses that this is
where immediate need seems greatest (also where it seems hardest).
And, unlike the rest of computer security, a substantial defensive
result here would probably get more attention in the anonymity
research community than yet another attack.  That said, I disagree
that "attacks are already so good that new, equally good attacks
aren't very impressive".  The threat side is still sufficiently
uncharted that it is very important to keep developing it. Otherwise
we run the risk of investing a lot of effort into getting specific
defenses against known attacks only to be blown out of the water by
something "equally good" because a comprehensive response was
needed. This is always a risk in security, but anonymity (and
low-latency anonymity in particular) is still immature enough that it
remains especially true here. Another attack that is a small variant
of a type that is well understood and researched is not very
interesting, but I think lots more basic attack research remains to be
done.

aloha,
Paul
</body></email><email><emailId>20080107132151</emailId><senderName>Paul Syverson</senderName><senderEmail>syverson@itd.nrl.navy.mil</senderEmail><timestampReceived>2008-01-07 13:21:51-0400</timestampReceived><subject>Re: [or-cvs] r13048: first thoughts on rate limiting stream creations at exits  (tor/trunk/doc/spec/</subject><body>

On Mon, Jan 07, 2008 at 05:41:49AM -0500, arma@seul.org wrote:
&gt; 
&gt; Added:
&gt;    tor/trunk/doc/spec/proposals/ideas/xxx-rate-limit-exits.txt
&gt; Log:
&gt; first thoughts on rate limiting stream creations at exits
&gt; 
&gt; +
&gt; +4. Client-side limitations
&gt; +
&gt; +  Perhaps the clients should have built-in rate limits too, so they avoid
&gt; +  harrassing the servers by default?
&gt; +
&gt; +  Tricky if we want to get Tor clients in use at large enclaves.
&gt; +
&gt; 

I am thinking that a lot of things will need to be addressed if Tor
clients are to be used at large enclaves. (I assume you mean something
like client-at-the-enclave-firewall rather than
client-at-the-workstation.  The latter will still probably require
many things before it can be effected but I imagine client-side rate
limits would be a nonissue or a minor issue vs. for other users.)
</body></email><email><emailId>20080109141150</emailId><senderName>dante</senderName><senderEmail>dante@virtualblueness.net</senderEmail><timestampReceived>2008-01-09 14:11:50-0400</timestampReceived><subject>Tor Ramdisk Image</subject><body>


Hi everyone,

I've constructed a micro linux system which lives on a small bootable  ISO
image (about 4 MB) and which provides a secure environment purely in RAM to
host a TOR server.  Privacy and anonymity is kept to a maximum by
turning off
logging at all levels, and since everything runs in ephemeral memory, no
information survives a reboot.  To further ensure that nothing is leaked
during run-time, a hardened system is employed based on a monolithically
compiled GRSEC/PAX patched kernel with a hardened toolchain.

I figure this is useful for those who

    1) want to run tor servers on old boxes
    2) are concerned about security since tor servers are targeted
    3) are worried about having their hard drives examined

The project is in beta right now and I am testing a middle man tor
router named 'RamOnly'.
I have yet to test an exit node.  Everything appears to be working
fine.  There are
only two disadvantages to this approache that I see right now:

    1) router keys are lost upon reboot
    2) a monolithically compiled kernel means that it is hardware specific
    and so the user will have to rebuild their own ISO image.

I'm not sure of the best way to address 1 right now (keep the keys on a
usb drive?  download
them from some url?).  Issue 2 I will address by writing automated build
scripts once I
am happy with the approach.  In the mean time, a howto can be found at
the following urls:

    http://www.virtualblueness.net/~blueness/tor-ramdisk        (slow)
    
    ftp://cheshire.dyc.edu/pub/tor-ramdisk        (faster)

    ftp://ddl.dyc.edu/pub/tor-ramdisk        (fastest)

I also provide some scripts to make life easier and two pre-built images
(i686 and amd64) that run in
vmware.

Yet to do:

    1) Test an exit node, make sure proper DNS is working

    2) Reduce the toolchain further to minimize attack vectors

    3) Add RSBAC rules for increased security

    4) Check/tighten PAX flags on executables for increased security


I invite comments/criticism.




</body></email><email><emailId>20080109192715</emailId><senderName>Robert Hogan</senderName><senderEmail>robert@roberthogan.net</senderEmail><timestampReceived>2008-01-09 19:27:15-0400</timestampReceived><subject>Re: moniTor -- a console-based monitoring tool for Tor relays</subject><body>


On Wednesday 09 January 2008 14:00:52 Karsten Loesing wrote:
&gt; Hi all,
&lt;snip&gt;

This sounds like a very useful tool.

&gt;
&gt; (3) The event/log area contains a comprehensive view on the last N
&gt; events. N would probably best be determined by the remaining display
&gt; space in a console. Useful events might be log statements on WARN and
&gt; ERR level (this level could be changed with a command-line argument to
&gt; moniTor), DESCCHANGED, and STATUS_SERVER. Every event would be condensed
&gt; to a single line by leaving out less important data like the current
&gt; date (only display time) and truncate descriptions after a certain
&gt; length. In addition, the complete events are written to a local file to
&gt; enable reconstruction of errors later on.
&gt;

This chimes with something I was thinking of the other day: a controller 
feature (GETEVENTS ?) that allows you to retrieve the last N events of a 
given type or severity. At the moment they just get blackholed, unless you're 
logging too - which AFAIK is not something Tor wants to encourage. This 
feature would be useful for controllers generally, since in some cases 
they're connecting to Tor 'soon' after it has started, rather than 
immediately.

&gt; ~  Recent events (see also /home/tor/gabelmoo/monitor.log):
&gt; ~  14:30:01 [warn] Consensus does not include configured authority 'moria
&gt; ~  14:30:01 [warn] Consensus does not include configured authority 'ides'
&gt; ~  14:30:01 [warn] 0 unknown, 0 missing key, 2 good, 0 bad, 1 no signatur
&gt; ~  14:30:01 [warn] Not enough info to publish pending consensus
&gt;

Without logging enabled, the above wouldn't be possible unless the feature 
above is in place. 

I can do my usual flaky first patch to get it up and going if it's agreed to 
be a good idea.

Oh, and there's also no interface for dirconns at the moment either.

["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20080111142024</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2008-01-11 14:20:24-0400</timestampReceived><subject>Re: Guard nodes (was: Re: [or-cvs] r13101)</subject><body>

On Fri, Jan 11, 2008 at 09:00:21AM -0500, Paul Syverson wrote:
&gt; &gt; Though a correlation attack to identify guards and an active attack to
&gt; &gt; knock them down would shorten the interval.
&gt; 
&gt; Lasse and I talked about this in our Oakland 96 paper where we
&gt; introduced the attack and the guard node response. We had experiments
&gt; on the then Tor network rather than analytic results however. This was
&gt; the motivation for the layered guard node design we presented
&gt; (something I don't think is worth pursuing implementing without more
&gt; study of several aspects.)

Yeah. I've actually been thinking about layered guards nodes with respect
to bridge relays. Right now a bridge user uses the bridge relays as his
entry guards, which means he could connect to any next hop from them.
But a) that makes his connections distinguishable from the connections
initiated by the bridge relay; and b) that means that bridge relays are
easier to enumerate, by an attacker who runs a few fast Tor servers and
sees who connects.

See also Section 3.8 of
https://www.torproject.org/svn/trunk/doc/spec/proposals/125-bridges.txt
for an alternate phrasing of this issue.

&gt; &gt; But yes, I still make the basic assumption that there exists a statistical
&gt; &gt; attack that's good enough with just a single request -- even if we
&gt; &gt; haven't discovered it quite yet.

&gt; Sorry. Do you mean an attack that is statistical but where the
&gt; probability is practically speaking high enough for an effective
&gt; attack after a single request? If you mean an attack that
&gt; deterministically works with a single request, I can't understand how
&gt; the latter could be called "statistical".

I meant the former. Or something like it. ;)

--Roger

</body></email><email><emailId>20080113230919</emailId><senderName>Peter Palfrader</senderName><senderEmail>peter@palfrader.org</senderEmail><timestampReceived>2008-01-13 23:09:19-0400</timestampReceived><subject>Re: r13115 profile of a directory authority</subject><body>

On Sun, 13 Jan 2008, Peter Palfrader wrote:

&gt; 12 hours of running r13115 on tor26,

and about that on 13125 with --disable-cell-pool and
--disable-buf-freelists

Tor26 pushed slightly more directory stuff in this perioud than in the
12hours of the previous r13115 profile.  No idea how much can be learned
from comparing them.


CPU: P4 / Xeon with 2 hyper-threads, speed 3000 MHz (estimated)
Counted GLOBAL_POWER_EVENTS events (time during which processor is not stopped) with \
a unit mask of 0x01 (mandatory) count 100000 GLOBAL_POWER_E...|
  samples|      %|
------------------
 75885383 41.7878 libcrypto.so.0.9.7
 61473004 33.8514 libz.so.1.2.2
 21678347 11.9376 tor
 16909872  9.3118 libc-2.3.2.so
  2144302  1.1808 libevent-1.1a.so.1.0.2
  1770767  0.9751 libssl.so.0.9.7
  1735193  0.9555 libpthread-0.60.so
        2 1.1e-06 libdl-2.3.2.so


CPU: P4 / Xeon with 2 hyper-threads, speed 3000 MHz (estimated)
Counted GLOBAL_POWER_EVENTS events (time during which processor is not stopped) with \
a unit mask of 0x01 (mandatory) count 100000 samples  %        app name               \
symbol name 26948925 14.8440  libz.so.1.2.2            longest_match
26199929 14.4315  libcrypto.so.0.9.7       bn_mul_add_words
16528986  9.1045  libz.so.1.2.2            deflate_slow
9643343   5.3118  libcrypto.so.0.9.7       bn_sqr_comba8
6215605   3.4237  libz.so.1.2.2            build_tree
6132746   3.3780  libcrypto.so.0.9.7       AES_decrypt
6107393   3.3641  libcrypto.so.0.9.7       AES_encrypt
5555349   3.0600  tor                      rijndaelEncrypt
4831885   2.6615  libz.so.1.2.2            compress_block
4419120   2.4341  libcrypto.so.0.9.7       sha1_block_asm_data_order
3505822   1.9311  libcrypto.so.0.9.7       BN_from_montgomery
3462427   1.9072  libc-2.3.2.so            _int_malloc
3409432   1.8780  libcrypto.so.0.9.7       bn_add_words
3212627   1.7696  libc-2.3.2.so            memcpy
2883963   1.5885  libz.so.1.2.2            fill_window
2574821   1.4183  libcrypto.so.0.9.7       bn_sub_words
1817340   1.0010  libcrypto.so.0.9.7       AES_cbc_encrypt
1635510   0.9009  tor                      aes_crypt
1621373   0.8931  libc-2.3.2.so            __cfree
1562288   0.8605  tor                      digestmap_get
1281988   0.7061  libcrypto.so.0.9.7       bn_mul_comba8
1235218   0.6804  libcrypto.so.0.9.7       OPENSSL_cleanse
1228183   0.6765  libc-2.3.2.so            __malloc
1167337   0.6430  libcrypto.so.0.9.7       bn_sqr_recursive
1118379   0.6160  libz.so.1.2.2            send_tree
1053733   0.5804  libcrypto.so.0.9.7       BN_usub
880786    0.4852  libz.so.1.2.2            gen_bitlen
820915    0.4522  libpthread-0.60.so       __libc_sigaction
694675    0.3826  libc-2.3.2.so            memset
649229    0.3576  libc-2.3.2.so            __GI___strtol_internal
598460    0.3296  libcrypto.so.0.9.7       BN_copy
594150    0.3273  libc-2.3.2.so            __GI___strcasecmp
588877    0.3244  libz.so.1.2.2            scan_tree
555871    0.3062  libc-2.3.2.so            _IO_vfprintf_internal
544869    0.3001  libz.so.1.2.2            bi_reverse
508162    0.2799  tor                      assert_buf_ok
473252    0.2607  libc-2.3.2.so            strlen
448299    0.2469  tor                      assert_connection_ok
429392    0.2365  libcrypto.so.0.9.7       SHA1_Update
424607    0.2339  tor                      buf_datalen
423434    0.2332  libc-2.3.2.so            __memchr
422262    0.2326  libz.so.1.2.2            adler32
386900    0.2131  libevent-1.1a.so.1.0.2   evsignal_recalc
375275    0.2067  libc-2.3.2.so            _int_free
369789    0.2037  tor                      run_connection_housekeeping
355432    0.1958  libcrypto.so.0.9.7       __i686.get_pc_thunk.bx
347608    0.1915  libevent-1.1a.so.1.0.2   epoll_dispatch
345482    0.1903  tor                      connection_bucket_refill
340864    0.1878  tor                      smartlist_isin
309153    0.1703  libcrypto.so.0.9.7       HMAC_Init_ex
267253    0.1472  tor                      dirserv_orconn_tls_done
261551    0.1441  libssl.so.0.9.7          tls1_enc
260377    0.1434  libc-2.3.2.so            __GI_strftime
253996    0.1399  tor                      routerstatus_parse_entry_from_string
236492    0.1303  libc-2.3.2.so            _IO_default_xsputn_internal
234107    0.1290  libcrypto.so.0.9.7       SHA1_Final
233605    0.1287  libc-2.3.2.so            malloc_consolidate
-- 
                           |  .''`.  ** Debian GNU/Linux **
      Peter Palfrader      | : :' :      The  universal
 http://www.palfrader.org/ | `. `'      Operating System
                           |   `-    http://www.debian.org/


</body></email><email><emailId>20080124045108</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-01-24 04:51:08-0400</timestampReceived><subject>[nickm@freehaven.net: Tor meetup in San Francisco this Thursday, 7pm, Sugarlump Coffee Lounge]</subject><body>


Forwarded from or-talk, since some people who are here but not there
were interested. :)

----- Forwarded message from Nick Mathewson &lt;nickm@freehaven.net&gt; -----

On Tue, Jan 22, 2008 at 01:13:24AM -0500, Nick Mathewson wrote:
&gt; Hi, all!
&gt; 
&gt; I'll be in San Francisco for most of this week, and I thought it would
&gt; be neat to have a Tor Folks meetup on Thursday, probably in the late
&gt; afternoon or early evening.  Let me know (off-list) if there's any
&gt; interest, and I'll figure out where -- probably a coffee shop or
&gt; something.

Hi again!  Thanks to local recommendations, we'll be meeting up at the
Sugarlump Coffee Lounge at 7pm Thursday night.  I'm planning to stick
around for a couple hours.  According to my source, they're
an okay compromise between "tolerable coffee" and "likely to have
enough space in case a bunch of people show up."

   Where: Sugarlump Coffee Lounge, 2862 24th Street at Bryant.
   When: 7pm.
   What: No actual agenda; just hanging out, meeting local Tor
     users, operators, and enthusiasts.

Hope you can make it!

peace,
-- 
Nick





----- End forwarded message -----

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20080125083424</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2008-01-25 08:34:24-0400</timestampReceived><subject>Re: Proposal to mitigate insecure protocols over Tor</subject><body>

On Sun, Jan 20, 2008 at 10:27:57PM -0700, Kevin Bauer wrote:
&gt; On Jan 19, 2008 11:57 PM, Roger Dingledine &lt;arma@mit.edu&gt; wrote:
&gt; &gt; So the next question is: reject by default or just warn? I'm inclined to
&gt; &gt; reject by default, just to counter the number of users who are probably
&gt; &gt; happily using Tor and have no idea that there's a problem. Even if they
&gt; &gt; get angry and stop using Tor because it's "broken" now, that's probably
&gt; &gt; ok for them.
&gt; 
&gt; For Telnet, IMAP, and POP, I would suggest that the policy be to block
&gt; by default for the following reason.  During our 8 day observations
&gt; cited in the initial proposal, the Telnet, IMAP, and POP traffic
&gt; accounted for around 0.16% of the total connections that were
&gt; established through our exit node. So we're probably not talking about
&gt; a large fraction of the protocols that are used over Tor.

Well, you have to remember that we're blocking by port, not blocking
by protocol.

In chatting with some folks on #tor, they reminded me that an increasing
number of pop / imap clients are using STARTTLS:
http://tools.ietf.org/html/rfc2595
which uses the same ports as the unencrypted varieties.

In an ideal world, we would somehow be able to divine whether the
protocol going over the port was doing a safe thing or an unsafe thing.
But I don't much want to write pop and imap proxies, nor to write a pop
or imap analyzer inside Tor and run it on all the traffic that happens
to ask for these ports. It still seems like the only real option is
to just reject them by default, and give Vidalia a good interface to
reenable ports if you think you're doing it right.

I wonder what proportion of our users are doing this, and if there are
instructions out there on the 'net somewhere for how to enable encryption
in standard mail programs?

Of course, if it's optimistic encryption and the mail client doesn't
know what TLS key to expect from the other side, the encryption may not
help us much against a hostile exit relay. So the question is not just
"do they support starttls", but also "do they manage keys intuitively
and well". And I bet we can all guess the answer to that.

&gt; As far as I know (and perhaps someone can correct me if I'm wrong
&gt; here), most popular instant messaging services (like AIM, MSN , Yahoo,
&gt; Jabber, etc.) exchange login credentials securely over SSL/TLS. Thus,
&gt; in my opinion, they differ from Telnet, IMAP, and POP in this respect.
&gt; However, they do generally seem to expose a user's screen name in the
&gt; application header. Thus, they may be unwise to use over Tor for
&gt; anonymity reasons. Certainly a warning about the risks that are
&gt; inherent in these instant messaging protocols is prudent, but I think
&gt; that the information leakage is probably no worse than what is
&gt; possible over HTTP.

I talked to Ian Goldberg about AIM, and he confirmed that AIM gives at
least a token effort to not leak your password in the clear. It does
leak your username, but hopefully this is something that our users can
comprehend and act appropriately.

--Roger

</body></email><email><emailId>20080224114924</emailId><senderName>Robert Hogan</senderName><senderEmail>robert@roberthogan.net</senderEmail><timestampReceived>2008-02-24 11:49:24-0400</timestampReceived><subject>Re: [or-cvs] r13688: Servers that don't know their own IP address should go to th (in tor/trunk: . s</subject><body>

[Attachment #2 (multipart/mixed)]


On Saturday 23 February 2008 23:39:16 arma@seul.org wrote:
&gt; Author: arma
&gt; Date: 2008-02-23 18:39:16 -0500 (Sat, 23 Feb 2008)
&gt; New Revision: 13688
&gt;
&gt; Modified:
&gt;    tor/trunk/ChangeLog
&gt;    tor/trunk/src/or/dirserv.c
&gt;    tor/trunk/src/or/router.c
&gt; Log:
&gt; Servers that don't know their own IP address should go to the
&gt; authorities for their first directory fetch, even if their DirPort
&gt; is off or if they don't know they're reachable yet. This will help
&gt; them bootstrap better. Bugfix on 0.2.0.18-alpha; fixes bug 609.
&gt;
&gt;

I encountered this bug while trying to get 'getinfo extra-info/digest/X' to 
work for my own server's extra-info digest.

The attached fixes 2 things:

1. Though it shouldn't happen now that desc_routerinfo is properly created, 
adding a null &amp;(router_get_my_routerinfo()-&gt;cache_info) in 
dirserv_get_routerdescs causes a segfault later on in getinfo_helper_dir.

2. If the requested extra-info is for our own server, supply it every time: it 
isn't always retrievable by extrainfo_get_by_descriptor_digest.

["extrainfo.patch" (text/x-diff)]

Index: src/or/dirserv.c
===================================================================
--- src/or/dirserv.c	(revision 13692)
+++ src/or/dirserv.c	(working copy)
@@ -2673,7 +2673,8 @@
     SMARTLIST_FOREACH(digests, const char *, d,
        {
          if (router_digest_is_me(d)) {
-           smartlist_add(descs_out, &amp;(router_get_my_routerinfo()-&gt;cache_info));
+           if (router_get_my_routerinfo()) /* make sure desc_routerinfo exists */
+             smartlist_add(descs_out, &amp;(router_get_my_routerinfo()-&gt;cache_info));
          } else {
            routerinfo_t *ri = router_get_by_digest(d);
            /* Don't actually serve a descriptor that everyone will think is
Index: src/or/control.c
===================================================================
--- src/or/control.c	(revision 13692)
+++ src/or/control.c	(working copy)
@@ -1523,8 +1523,12 @@
     if (strlen(question) == HEX_DIGEST_LEN) {
       char d[DIGEST_LEN];
       signed_descriptor_t *sd = NULL;
-      if (base16_decode(d, sizeof(d), question, strlen(question))==0)
-        sd = extrainfo_get_by_descriptor_digest(d);
+      if (base16_decode(d, sizeof(d), question, strlen(question))==0) {
+        if (router_extrainfo_digest_is_me(d))
+          sd = &amp;(router_get_my_extrainfo()-&gt;cache_info);
+        else
+          sd = extrainfo_get_by_descriptor_digest(d);
+      }
       if (sd) {
         const char *body = signed_descriptor_get_body(sd);
         if (body)
Index: src/or/or.h
===================================================================
--- src/or/or.h	(revision 13692)
+++ src/or/or.h	(working copy)
@@ -3794,6 +3794,7 @@
 extrainfo_t *router_get_my_extrainfo(void);
 const char *router_get_my_descriptor(void);
 int router_digest_is_me(const char *digest);
+int router_extrainfo_digest_is_me(const char *digest);
 int router_is_me(routerinfo_t *router);
 int router_fingerprint_is_me(const char *fp);
 int router_pick_published_address(or_options_t *options, uint32_t *addr);
Index: src/or/router.c
===================================================================
--- src/or/router.c	(revision 13692)
+++ src/or/router.c	(working copy)
@@ -1094,6 +1094,19 @@
   return identitykey &amp;&amp; !memcmp(identitykey_digest, digest, DIGEST_LEN);
 }
 
+/** Return true iff I'm a server and &lt;b&gt;digest&lt;/b&gt; is equal to
+ * my identity digest. */
+int
+router_extrainfo_digest_is_me(const char *digest)
+{
+  if (!router_get_my_extrainfo())
+    return 0;
+
+  return !memcmp(digest,
+                 &amp;(router_get_my_extrainfo()-&gt;cache_info).signed_descriptor_digest,
+                 DIGEST_LEN);
+}
+
 /** A wrapper around router_digest_is_me(). */
 int
 router_is_me(routerinfo_t *router)

["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20080228193804</emailId><senderName>Robert Hogan</senderName><senderEmail>robert@roberthogan.net</senderEmail><timestampReceived>2008-02-28 19:38:04-0400</timestampReceived><subject>Getting 'Unreachable' Servers Onto The Network</subject><body>


Maybe it's a solution in search of a problem, maybe UPnP will sort most of 
this out, but assuming that the following problem is real and substantial:

Problem: Restrictive local/remote firewalls and routers are preventing many 
willing candidates from becoming OR servers. UPnP can mitigate this problem 
if it is confined to a DSL router firewall (with UPnP enabled by the user) 
but it still leaves a substantial chunk of willing servers out there whose 
ORPort is not available to outside connection attempts. The Tor network is 
losing out on their bandwidth. At the moment we don't even know how many 
such 'candidate' servers there are.

Possible solution:

Tor servers whose ORPort reachability testing fails should:

 i. enlist themselves with the authorities setting a 'Fallback' flag. This 
flag indicates that the server is up and running but cannot connect to 
itself.

 ii. Open an orconn with an Xth part of the other Tor servers on the network. 
The management of this orconn will be transferred entirely to the servers at 
the other end. 

 iii. When building circuits clients will take into account the number of 
servers it knows about that have a 'Fallback' flag. Whatever proportion this 
is of the total will determine what proportion of circuits it attempts to 
build using one of these servers. So if 1/4 of listed servers are flagged 
fallback it will attempt to build 1 in every 4 circuits with one of these 
servers at either middleman or exit. (These numbers are hypothetical).

 iv. After a presumably mathematically predictable number of maximum tries the 
client will try a combination that works and build a circuit with a fallback 
server on it. 

Expected behaviour of 'Fallback' servers:

 i. Open as many idle orconns with other servers on the network as possible 
and keep them open until the server is shut down.

 ii. Always respect other servers requests to shut down the orconn.

 iii. Always allow themselves to be exit servers if called upon.

Expected behaviour of other server towards 'Fallback' servers:

 i. Only accept orconns from listed 'Fallback' servers.
 ii. Do not always build client-requested circuits to 'Fallback' servers you 
have an orconn with. Reject some as unreachable?

Halfway house:

If we don't know how big the problem actually is, perhaps we should start 
allowing such servers to at least register their attempt with the authorities 
in some way, perhaps just by implementing step i under 'Possible Solution'.

Questions I don't know the answers to:

i. How many other servers a 'Fallback' server should connect to in order to 
allow a client successfully include it in a circuit without trying an 
unreasonable amount of times.

ii. How a client proportions the number of 'fallback' servers listed to the 
number of circuits it attempts to build with them.

iii. What kind of critical mass of fallback servers is required for the thing 
to work.

Major objections:

 i. Thousands, millions of idle orconns! Uugh! It's an ugly thought I admit, 
but they're pretty cheap as far as I know. Would a server have any actual 
problem handling them?

 ii. [insert major anonymity problem here]

This isn't the result of days of solemn reflection so feel free to kick me out 
of the park on it.

["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20080109140052</emailId><senderName>Karsten Loesing</senderName><senderEmail>karsten.loesing@gmx.net</senderEmail><timestampReceived>2008-01-09 14:00:52-0400</timestampReceived><subject>moniTor -- a console-based monitoring tool for Tor relays</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Hi all,

as discussed yesterday with ioerror on #tor, these are my first thoughts
on a console-based monitoring tool for Tor relays. They are the result
of a spontaneous brainstorming session today, so there might be a lot
more possibilities and some ideas will probably turn out to be either
useless or unimplementable.

The purpose of moniTor (working title only) is to monitor a local Tor
relay via its control port and include useful system information of the
underlying machine. When running this tool, it dynamically updates its
content like top does for Linux processes. moniTor is meant to run in a
console without the need for a graphical interface. For the sake of
simplicity, users won't be able to provide any input after starting
moniTor. The primary application will be for admins who have recently
set up their Tor relay and want to check if everything looks fine or to
look in every now and then to look if the relay is still operating.

The tool is not designed to be used with Tor clients, but only with
relays; therefore it does not contain useful client information. It will
also not change any configuration of Tor or send any signals to it, but
only monitor what's going on. The tool is neither meant to record and
present historical data; it is only running when explicitly started by
the user, not as a daemon process. Further, there will be no
notifications created by this tool and sent to the user, e.g. via
e-mail. Although these might be useful features, too, they will not be
covered by this tool.

The user interface will contain three areas: (1) static info area, (2)
dynamic info are, and (3) event/log area:

(1) The static info area will contain information that does not change
while running Tor. Examples are the Tor version, location of Tor's
config file, IP address, a short summary of the exit policy (any exit
connection allowed or none at all), OR and Dir port configuration, the
node's nickname and fingerprint, etc. The implementation would use
GETINFO and GETCONF to find out these values. Although all static info
would also be available elsewhere, it might be a nice confirmation for
(unexperienced) Tor admins that their specified configurations are in use.

(2) The dynamic info area will contain steadily (once per second?)
updated fields for Tor-related and system-wide information:

- - System resource usage of Tor process: What share of CPU time and
memory is Tor using as compared to the rest of the system (other
processes, idle CPU/free space)? In an implementation this would
probably require calls to the underlying system, rather than requests to
Tor's control port.

- - Connections: How many open connections are there at the moment? This
could be split up into the number of connections to the OR port, to the
Dir port, etc.

- - Bandwidth: What does Tor report about the used bandwidth? This could
be presented and updated for the current second, but also as averages
for the last 60 seconds. Again, this does not include any history
exceeding the time of running the tool.

(3) The event/log area contains a comprehensive view on the last N
events. N would probably best be determined by the remaining display
space in a console. Useful events might be log statements on WARN and
ERR level (this level could be changed with a command-line argument to
moniTor), DESCCHANGED, and STATUS_SERVER. Every event would be condensed
to a single line by leaving out less important data like the current
date (only display time) and truncate descriptions after a certain
length. In addition, the complete events are written to a local file to
enable reconstruction of errors later on.

A typical output of moniTor could look like this (with some fake data
for the purpose of this example):

~  Name/ID: gabelmoo 6833 3D07 61BC F397 A587 A0C0 B963 E4A9 E99E C4D3
~  Version: 0.2.0.15-alpha-dev (r13077) on Linux x86_64
~  Config: /home/tor/gabelmoo/torrc,     Exit policy: no exit allowed
~  IP address: 88.198.7.215,    OR port:  443,    Dir port:   80

~  CPU:  9.0% this tor,  3.4% other processes, 87.6% idle
~  Mem: 49.9% this tor,  2.0% other processes, 48.1% free
~  Connections: 1090 OR conns,  320 Dir conns
~  Bandwidth:  1.2 MB/s current,  1.3 MB/s avg

~  Recent events (see also /home/tor/gabelmoo/monitor.log):
~  14:30:01 [warn] Consensus does not include configured authority 'moria
~  14:30:01 [warn] Consensus does not include configured authority 'ides'
~  14:30:01 [warn] 0 unknown, 0 missing key, 2 good, 0 bad, 1 no signatur
~  14:30:01 [warn] Not enough info to publish pending consensus

These are my first ideas. Please feel free to add comments! Plus, if
there is already a tool with similar purpose that could be
used/extended, please let me and ioerror know!

- --Karsten
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFHhNOT0M+WPffBEmURAsWcAJ92bm9gQdi4i3KNzGR3llmH++rBOgCeNC5v
y/Y2+9xvZYz5voyE3T0wAxo=
=2yka
-----END PGP SIGNATURE-----
</body></email><email><emailId>20080111105720</emailId><senderName>Karsten Loesing</senderName><senderEmail>karsten.loesing@gmx.net</senderEmail><timestampReceived>2008-01-11 10:57:20-0400</timestampReceived><subject>Guard nodes (was: Re: [or-cvs] r13101)</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

| Author: arma
| Date: 2008-01-10 21:23:33 -0500 (Thu, 10 Jan 2008)
| New Revision: 13101
|
| Modified:
|    tor/trunk/doc/design-paper/roadmap-future.tex
|
| [...]
|
| +\subsection{Exactly what do guard nodes provide?}
| +
| +Entry guards seem to defend against all sorts of attacks. Can we work
| +through all the benefits they provide? Papers like Nikita's CCS 2007
| +paper make me think their value is not well-understood by the research
| +community.

There is one thing with guards that I am still unsure about. Maybe
somebody can clear that up for me?

When using guards against the locating attack of hidden services, does
it make any difference for this attack _how_many_ requests an attacker
performs to the hidden service? More precise: Would a single request (or
a very low number) suffice when the attacker is picked as guard node,
and would an unlimited number of requests not be enough when the
attacker is not picked as guard node?

Thanks!
- --Karsten
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFHh0uP0M+WPffBEmURArhtAJ4h+dYRmi2ZkRjoD5u6aO4QGC7BUQCdEBjm
fh1cTV3s4UNBF5dspDIK4pI=
=Od8o
-----END PGP SIGNATURE-----
</body></email><email><emailId>20080113085245</emailId><senderName>Peter Palfrader</senderName><senderEmail>peter@palfrader.org</senderEmail><timestampReceived>2008-01-13 08:52:45-0400</timestampReceived><subject>r13115 profile of a directory authority</subject><body>

12 hours of running r13115 on tor26,

It never got up to the usual traffic because oprofile just seems to bog
down the system, so it pushed about 8Mbps instead of 15.  It read about
the same as usually, so it appears to only have affected directory
traffic, not OR traffic.


CPU: P4 / Xeon with 2 hyper-threads, speed 3000 MHz (estimated)
Counted GLOBAL_POWER_EVENTS events (time during which processor is not stopped) with \
a unit mask of 0x01 (mandatory) count 100000 GLOBAL_POWER_E...|
  samples|      %|
------------------
 44623843 49.5072 libcrypto.so.0.9.7
 21086402 23.3940 libz.so.1.2.2
 12692107 14.0810 tor
  8458885  9.3846 libc-2.3.2.so
  1297660  1.4397 libevent-1.1a.so.1.0.2
   998934  1.1083 libpthread-0.60.so
   978259  1.0853 libssl.so.0.9.7


CPU: P4 / Xeon with 2 hyper-threads, speed 3000 MHz (estimated)
Counted GLOBAL_POWER_EVENTS events (time during which processor is not stopped) with \
a unit mask of 0x01 (mandatory) count 100000 samples  %        app name               \
symbol name 15358145 17.0388  libcrypto.so.0.9.7       bn_mul_add_words
9777867  10.8479  libz.so.1.2.2            longest_match
5683715   6.3057  libcrypto.so.0.9.7       bn_sqr_comba8
5599689   6.2125  libz.so.1.2.2            deflate_slow
3745279   4.1551  libcrypto.so.0.9.7       AES_decrypt
3701442   4.1065  libcrypto.so.0.9.7       AES_encrypt
3382893   3.7531  tor                      rijndaelEncrypt
2616231   2.9025  libcrypto.so.0.9.7       sha1_block_asm_data_order
2038809   2.2619  libcrypto.so.0.9.7       BN_from_montgomery
1989104   2.2068  libcrypto.so.0.9.7       bn_add_words
1839274   2.0406  libz.so.1.2.2            build_tree
1673315   1.8564  libz.so.1.2.2            compress_block
1592124   1.7664  libc-2.3.2.so            memcpy
1513712   1.6794  libcrypto.so.0.9.7       bn_sub_words
1099640   1.2200  libcrypto.so.0.9.7       AES_cbc_encrypt
993250    1.1019  tor                      aes_crypt
945198    1.0486  libz.so.1.2.2            fill_window
855293    0.9489  tor                      digestmap_get
844073    0.9364  libc-2.3.2.so            __cfree
759519    0.8426  libc-2.3.2.so            _int_malloc
746750    0.8285  libcrypto.so.0.9.7       bn_mul_comba8
686288    0.7614  libcrypto.so.0.9.7       bn_sqr_recursive
685153    0.7601  libcrypto.so.0.9.7       OPENSSL_cleanse
619141    0.6869  libc-2.3.2.so            __malloc
599695    0.6653  libcrypto.so.0.9.7       BN_usub
496450    0.5508  libpthread-0.60.so       __libc_sigaction
435533    0.4832  libc-2.3.2.so            __GI___strtol_internal
423713    0.4701  libc-2.3.2.so            _IO_vfprintf_internal
387292    0.4297  libc-2.3.2.so            memset
346446    0.3844  libcrypto.so.0.9.7       BN_copy
342047    0.3795  libc-2.3.2.so            __GI___strcasecmp
330546    0.3667  libz.so.1.2.2            send_tree
329731    0.3658  libc-2.3.2.so            strlen
270853    0.3005  tor                      assert_connection_ok
264659    0.2936  tor                      assert_buf_ok
264340    0.2933  libz.so.1.2.2            gen_bitlen
249666    0.2770  libevent-1.1a.so.1.0.2   evsignal_recalc
248111    0.2753  libc-2.3.2.so            __memchr
242651    0.2692  tor                      smartlist_isin
240813    0.2672  tor                      buf_datalen
235848    0.2617  libcrypto.so.0.9.7       SHA1_Update
208477    0.2313  libcrypto.so.0.9.7       __i686.get_pc_thunk.bx
206539    0.2291  tor                      connection_bucket_refill
201951    0.2241  libevent-1.1a.so.1.0.2   epoll_dispatch
200649    0.2226  libc-2.3.2.so            __GI_strftime
191969    0.2130  tor                      run_connection_housekeeping
173502    0.1925  libz.so.1.2.2            scan_tree
173174    0.1921  libcrypto.so.0.9.7       HMAC_Init_ex
171401    0.1902  libc-2.3.2.so            _IO_default_xsputn_internal
163002    0.1808  libz.so.1.2.2            bi_reverse
160362    0.1779  tor                      routerstatus_parse_entry_from_string
153736    0.1706  libc-2.3.2.so            _int_free
151558    0.1681  tor                      dirserv_orconn_tls_done
145389    0.1613  libssl.so.0.9.7          tls1_enc
140966    0.1564  libz.so.1.2.2            adler32
135627    0.1505  tor                      connection_or_get_by_identity_digest
128962    0.1431  libc-2.3.2.so            strstr

-- 
                           |  .''`.  ** Debian GNU/Linux **
      Peter Palfrader      | : :' :      The  universal
 http://www.palfrader.org/ | `. `'      Operating System
                           |   `-    http://www.debian.org/


</body></email><email><emailId>20080123014212</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-01-23 01:42:12-0400</timestampReceived><subject>[nickm@freehaven.net: Tor meetup in San Francisco this Thursday]</subject><body>


Forwarded from or-talk.  Rememeber to reply OFF-LIST. :)

----- Forwarded message from Nick Mathewson &lt;nickm@freehaven.net&gt; -----

From: Nick Mathewson &lt;nickm@freehaven.net&gt;
To: or-talk@freehaven.net
Date: Tue, 22 Jan 2008 01:13:24 -0500
Subject: Tor meetup in San Francisco this Thursday
Reply-To: or-talk@freehaven.net
Mail-Followup-To: Nick Mathewson &lt;nickm@freehaven.net&gt;,
	or-talk@freehaven.net
X-Spam-Level: 

Hi, all!

I'll be in San Francisco for most of this week, and I thought it would
be neat to have a Tor Folks meetup on Thursday, probably in the late
afternoon or early evening.  Let me know (off-list) if there's any
interest, and I'll figure out where -- probably a coffee shop or
something.

yrs,
-- 
Nick Mathewson



----- End forwarded message -----

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20080111132129</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2008-01-11 13:21:29-0400</timestampReceived><subject>Re: Guard nodes (was: Re: [or-cvs] r13101)</subject><body>

On Fri, Jan 11, 2008 at 11:57:20AM +0100, Karsten Loesing wrote:
&gt; | +Entry guards seem to defend against all sorts of attacks. Can we work
&gt; | +through all the benefits they provide? Papers like Nikita's CCS 2007
&gt; | +paper make me think their value is not well-understood by the research
&gt; | +community.
&gt; 
&gt; There is one thing with guards that I am still unsure about. Maybe
&gt; somebody can clear that up for me?
&gt; 
&gt; When using guards against the locating attack of hidden services, does
&gt; it make any difference for this attack _how_many_ requests an attacker
&gt; performs to the hidden service? More precise: Would a single request (or
&gt; a very low number) suffice when the attacker is picked as guard node,
&gt; and would an unlimited number of requests not be enough when the
&gt; attacker is not picked as guard node?

That's my claim, yes.

It would be useful to get a better intuition about reasonable situations
where this claim is false.

It's actually a bit more subtle than the above -- Tor clients do use
alternate guard nodes if their preferred guards go down or become
unguardworthy, and the set of guard-worthy nodes in the network does
change over time. So you have to consider the timeframe of the unlimited
number of requests. Perhaps a better way to say it is that the success
of the attack during a given interval doesn't improve with the number
of requests.

Though a correlation attack to identify guards and an active attack to
knock them down would shorten the interval.

And even then it's not quite right, because I bet somebody could show,
for a given statistical attack, that it gets more accurate results with
two requests than one. So maybe I mean that it doesn't improve with
large numbers of requests. :)

But yes, I still make the basic assumption that there exists a statistical
attack that's good enough with just a single request -- even if we
haven't discovered it quite yet.

--Roger

</body></email><email><emailId>20080111140021</emailId><senderName>Paul Syverson</senderName><senderEmail>syverson@itd.nrl.navy.mil</senderEmail><timestampReceived>2008-01-11 14:00:21-0400</timestampReceived><subject>Re: Guard nodes (was: Re: [or-cvs] r13101)</subject><body>

On Fri, Jan 11, 2008 at 08:21:29AM -0500, Roger Dingledine wrote:
&gt; 
&gt; It's actually a bit more subtle than the above -- Tor clients do use
&gt; alternate guard nodes if their preferred guards go down or become
&gt; unguardworthy, and the set of guard-worthy nodes in the network does
&gt; change over time. So you have to consider the timeframe of the unlimited
&gt; number of requests. Perhaps a better way to say it is that the success
&gt; of the attack during a given interval doesn't improve with the number
&gt; of requests.
&gt; 
&gt; Though a correlation attack to identify guards and an active attack to
&gt; knock them down would shorten the interval.
&gt; 

Lasse and I talked about this in our Oakland 96 paper where we
introduced the attack and the guard node response. We had experiments
on the then Tor network rather than analytic results however. This was
the motivation for the layered guard node design we presented
(something I don't think is worth pursuing implementing without more
study of several aspects.)

&gt; And even then it's not quite right, because I bet somebody could show,
&gt; for a given statistical attack, that it gets more accurate results with
&gt; two requests than one. So maybe I mean that it doesn't improve with
&gt; large numbers of requests. :)
&gt; 
&gt; But yes, I still make the basic assumption that there exists a statistical
&gt; attack that's good enough with just a single request -- even if we
&gt; haven't discovered it quite yet.
&gt; 

Sorry. Do you mean an attack that is statistical but where the
probability is practically speaking high enough for an effective
attack after a single request? If you mean an attack that
deterministically works with a single request, I can't understand how
the latter could be called "statistical".

aloha,
Paul
</body></email><email><emailId>20080117191800</emailId><senderName>"Kevin Bauer"</senderName><senderEmail>ksbauer@gmail.com</senderEmail><timestampReceived>2008-01-17 19:18:00-0400</timestampReceived><subject>Proposal to mitigate insecure protocols over Tor</subject><body>

Below is a proposal to mitigate insecure protocol use over Tor.

Title: Block Insecure Protocols by Default
Author: Kevin Bauer &amp; Damon McCoy
Date: January 15, 2008

Overview:

	This document 1) demonstrates the extent to which insecure protocols are
	currently used within the Tor network, and 2) proposes a simple solution
	to prevent users from unknowingly using these insecure protocols. By
	insecure, we consider protocols that explicitly leak sensitive user names
	and/or passwords, such as POP, IMAP, Telnet, and FTP.

Motivation:

	As part of a general study of Tor use in 2006/2007 [1], we attempted to
	understand what types of protocols are used over Tor. While we observed a
        enormous volume of Web and Peer-to-peer traffic, we were
surprised by the
	number of insecure protocols that were used over Tor. For example, over an
	8 day observation period, we observed the following number of connections
	over insecure protocols:

	POP and IMAP:10,326 connections
	Telnet: 8,401 connections
	FTP: 3,788 connections

	Each of the above listed protocols exchange user name and password
	information in plain-text. As an upper bound, we could have observed
	22,515 user names and passwords. This observation echos the reports of
	a Tor router logging and posting e-mail passwords in August 2007 [2]. The
	response from the Tor community has been to further educate users
	about the dangers of using insecure protocols over Tor. However, we
	recently repeated our Tor usage study from last year and noticed that the
	trend in insecure protocol use has not declined. Therefore, we propose that
	additional steps be taken to protect naive Tor users from inadvertently
	exposing their identities (and even passwords) over Tor.

Security Implications:

	None. This proposal is intended to improve Tor's security by limiting the
	use of insecure protocols.

Specification:

	As an initial step towards mitigating the use of the above-mentioned
	insecure protocols, we propose that the default ports for each respective
	insecure service be blocked at the Tor client's socks proxy. These default
	ports include:

	  23 - Telnet
	109 - POP2
	110 - POP3
	143 - IMAP

	Notice that FTP is not included in the proposed list of ports to block. This
	is because FTP is often used anonymously, i.e., without any identifying
	user name or password.

	This blocking scheme can be implemented as a set of flags in the client's
	torrc configuration file:
		
	  BlockInsecureProtocols 0|1
	  WarnInsecureProtocols 0|1

	When the warning flag is activated, a message should be displayed to
	the user similar to the message given when Tor's socks proxy is given an IP
	address rather than resolving a host name.

	We recommend that the default torrc configuration file block insecure
	protocols and provide a warning to the user to explain the behavior.

	Finally, there are many popular web pages that do not offer secure
	login features, such as MySpace, and it would be prudent to provide
	additional rules to Privoxy to attempt to protect users from unknowingly
	submitting their login credentials in plain-text.

Compatibility:

	None, as the proposed changes are to be implemented in the client.

References:

	[1] Shining Light in Dark Places: A Study of Anonymous Network Usage.
             University of Colorado Technical Report CU-CS-1032-07. August 2007.

	[2] Rogue Nodes Turn Tor Anonymizer Into Eavesdropper's Paradise.
             http://www.wired.com/politics/security/news/2007/09/embassy_hacks.
	     Wired. September 10, 2007.
</body></email><email><emailId>20080117205656</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2008-01-17 20:56:56-0400</timestampReceived><subject>Re: Proposal to mitigate insecure protocols over Tor</subject><body>

On Thu, Jan 17, 2008 at 12:18:00PM -0700, Kevin Bauer wrote:
&gt; Title: Block Insecure Protocols by Default
&gt; Author: Kevin Bauer &amp; Damon McCoy

Hi Kevin,

Thanks for the proposal. I've been pondering something similar
lately. I've got a few questions below.

&gt; 	POP and IMAP:10,326 connections
&gt; 	Telnet: 8,401 connections
&gt; 	FTP: 3,788 connections

Were (many of) these FTP username/password pairs anon-ftp or were they
actual logins?

&gt; 	As an initial step towards mitigating the use of the above-mentioned
&gt; 	insecure protocols, we propose that the default ports for each respective
&gt; 	insecure service be blocked at the Tor client's socks proxy. These default
&gt; 	ports include:
&gt; 
&gt; 	  23 - Telnet
&gt; 	109 - POP2
&gt; 	110 - POP3
&gt; 	143 - IMAP

Right, this seems like it's not a crazy idea. I had been pondering
setting up some Tor controller status events "insecure port used" that
Vidalia could monitor to inform its user that they had just tried doing
something dangerous.

&gt; 	  BlockInsecureProtocols 0|1
&gt; 	  WarnInsecureProtocols 0|1

This seems like a fine interface. The status events I mention above
could still be useful, because if Block is default, there will be a lot
of confused users unless Vidalia pops up a little something explaining
that what they just tried may not be a smart move.

(Vidalia could also have the ability to turn off the warnings, for users
who know they want to do it. But we need to be careful in that regard --
see the Firefox comments below.)

&gt; 	When the warning flag is activated, a message should be displayed to
&gt; 	the user similar to the message given when Tor's socks proxy is given an IP
&gt; 	address rather than resolving a host name.
&gt; 
&gt; 	We recommend that the default torrc configuration file block insecure
&gt; 	protocols and provide a warning to the user to explain the behavior.

Right. I think integration into Vidalia is critical -- few users know
that Tor even *has* log messages.

&gt; 	Finally, there are many popular web pages that do not offer secure
&gt; 	login features, such as MySpace, and it would be prudent to provide
&gt; 	additional rules to Privoxy to attempt to protect users from unknowingly
&gt; 	submitting their login credentials in plain-text.

This is the big issue here. It's all well and good to block pop
connections. But there are still many ways to give up secrets on an
unencrypted (or unauthenticated) http channel.

Now, Firefox already has a pop-up warning about this! But users have
been trained to ignore it.

We're trying to move away from Privoxy towards Polipo, and to put
the application-level security/privacy smarts into Torbutton-dev
https://torbutton.torproject.org/dev/ So relying on Privoxy for stuff
going forward is not a good move. I wonder if there are good ways to
get Torbutton to help users with http-level issues?

Thanks,
--Roger

</body></email><email><emailId>20080117224906</emailId><senderName>Carsten_Krüger</senderName><senderEmail>c.krueger@gmx.org</senderEmail><timestampReceived>2008-01-17 22:49:06-0400</timestampReceived><subject>Re: Proposal to mitigate insecure protocols over Tor</subject><body>

Hello,

&gt;         As an initial step towards mitigating the use of the above-mentioned
&gt;         insecure protocols, we propose that the default ports for each respective
&gt;         insecure service be blocked at the Tor client's socks proxy. These default
&gt;         ports include:

&gt;           23 - Telnet
&gt;         109 - POP2
&gt;         110 - POP3
&gt;         143 - IMAP

Than you should block http, too.
Nearly all blogs, webmail interfaces, bulletin boards, ebay, amazon and so on work with
unencrypted traffic (login at ebay and amazon is encrypted but session
afterwards runs via http).

When you block all these ports by default 90% of the users drop tor
because it didn't work[tm] and they don't care about the warning messages.

My guess is that even you try to do MITM attacks at https, pop3s,
imaps, smtps and ssh 90% of the users ignore the warning about wrong
fingerprints and broken certificate chains.

greetings
Carsten

</body></email><email><emailId>20080117234425</emailId><senderName>"Kevin Bauer"</senderName><senderEmail>ksbauer@gmail.com</senderEmail><timestampReceived>2008-01-17 23:44:25-0400</timestampReceived><subject>Re: Proposal to mitigate insecure protocols over Tor</subject><body>

On Jan 17, 2008 1:56 PM, Roger Dingledine &lt;arma@mit.edu&gt; wrote:
&gt; On Thu, Jan 17, 2008 at 12:18:00PM -0700, Kevin Bauer wrote:
&gt; &gt; Title: Block Insecure Protocols by Default
&gt; &gt; Author: Kevin Bauer &amp; Damon McCoy
&gt;
&gt; Hi Kevin,
&gt;
&gt; Thanks for the proposal. I've been pondering something similar
&gt; lately. I've got a few questions below.
&gt;
&gt; &gt;       POP and IMAP:10,326 connections
&gt; &gt;       Telnet: 8,401 connections
&gt; &gt;       FTP: 3,788 connections
&gt;
&gt; Were (many of) these FTP username/password pairs anon-ftp or were they
&gt; actual logins?
&gt;

We restricted our analysis to application protocol identification
only, so we do not have any data on what portion of the ftp traffic
used a username/password pair. I suspect that the majority of the ftp
traffic was anonymous, but I can't provide data to support that.

&gt; &gt;       As an initial step towards mitigating the use of the above-mentioned
&gt; &gt;       insecure protocols, we propose that the default ports for each respective
&gt; &gt;       insecure service be blocked at the Tor client's socks proxy. These default
&gt; &gt;       ports include:
&gt; &gt;
&gt; &gt;         23 - Telnet
&gt; &gt;       109 - POP2
&gt; &gt;       110 - POP3
&gt; &gt;       143 - IMAP
&gt;
&gt; Right, this seems like it's not a crazy idea. I had been pondering
&gt; setting up some Tor controller status events "insecure port used" that
&gt; Vidalia could monitor to inform its user that they had just tried doing
&gt; something dangerous.
&gt;
&gt; &gt;         BlockInsecureProtocols 0|1
&gt; &gt;         WarnInsecureProtocols 0|1
&gt;
&gt; This seems like a fine interface. The status events I mention above
&gt; could still be useful, because if Block is default, there will be a lot
&gt; of confused users unless Vidalia pops up a little something explaining
&gt; that what they just tried may not be a smart move.
&gt;
&gt; (Vidalia could also have the ability to turn off the warnings, for users
&gt; who know they want to do it. But we need to be careful in that regard --
&gt; see the Firefox comments below.)
&gt;
&gt; &gt;       When the warning flag is activated, a message should be displayed to
&gt; &gt;       the user similar to the message given when Tor's socks proxy is given an IP
&gt; &gt;       address rather than resolving a host name.
&gt; &gt;
&gt; &gt;       We recommend that the default torrc configuration file block insecure
&gt; &gt;       protocols and provide a warning to the user to explain the behavior.
&gt;
&gt; Right. I think integration into Vidalia is critical -- few users know
&gt; that Tor even *has* log messages.
&gt;
&gt; &gt;       Finally, there are many popular web pages that do not offer secure
&gt; &gt;       login features, such as MySpace, and it would be prudent to provide
&gt; &gt;       additional rules to Privoxy to attempt to protect users from unknowingly
&gt; &gt;       submitting their login credentials in plain-text.
&gt;
&gt; This is the big issue here. It's all well and good to block pop
&gt; connections. But there are still many ways to give up secrets on an
&gt; unencrypted (or unauthenticated) http channel.
&gt;
&gt; Now, Firefox already has a pop-up warning about this! But users have
&gt; been trained to ignore it.
&gt;
&gt; We're trying to move away from Privoxy towards Polipo, and to put
&gt; the application-level security/privacy smarts into Torbutton-dev
&gt; https://torbutton.torproject.org/dev/ So relying on Privoxy for stuff
&gt; going forward is not a good move. I wonder if there are good ways to
&gt; get Torbutton to help users with http-level issues?
&gt;
&gt; Thanks,
&gt; --Roger
&gt;
&gt;

I agree that insecure http is a significant avenue for information
leakage over Tor. What we are suggesting in this proposal is that we
try to limit the *really stupid* ways that very sensitive information
(user names/passwords) can be accidentally exposed by a naive Tor
user. The protocols that we mentioned not only can lead to anonymity
loss, but also the potential compromise of the accounts when observed
by a malicious exit node.

Adding the appropriate warning messages to Vidalia is a great idea,
even though it's difficult to make users listen to our warnings. At
the very least, if the warnings are present, then the user can decide
to listen to the warning or ignore it. At that point, I would argue
that it's the user's own fault for ignoring our attempt to protect
them. Ultimately, there is no way to force users to be smart about how
they use Tor.

Kevin
</body></email><email><emailId>20080120065720</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2008-01-20 06:57:20-0400</timestampReceived><subject>Re: Proposal to mitigate insecure protocols over Tor</subject><body>

On Thu, Jan 17, 2008 at 04:44:25PM -0700, Kevin Bauer wrote:
&gt; &gt; &gt;         BlockInsecureProtocols 0|1
&gt; &gt; &gt;         WarnInsecureProtocols 0|1
&gt; &gt;
&gt; &gt; This seems like a fine interface. The status events I mention above
&gt; &gt; could still be useful, because if Block is default, there will be a lot
&gt; &gt; of confused users unless Vidalia pops up a little something explaining
&gt; &gt; that what they just tried may not be a smart move.

Ok, I added the features here:
http://archives.seul.org/or/cvs/Jan-2008/msg00182.html
(I changed my mind a bit about the interface, but hopefully the one I
picked will do fine.)

&gt; I agree that insecure http is a significant avenue for information
&gt; leakage over Tor. What we are suggesting in this proposal is that we
&gt; try to limit the *really stupid* ways that very sensitive information
&gt; (user names/passwords) can be accidentally exposed by a naive Tor
&gt; user. The protocols that we mentioned not only can lead to anonymity
&gt; loss, but also the potential compromise of the accounts when observed
&gt; by a malicious exit node.

True -- but that can happen through port 80 too. I still worry a little
that by adding these warnings for only some of the risky behavior, users
will do other risky behavior, not get a warning, and believe that it is
therefore safe. But I think you're right, it's better to warn for some
of it than to warn for none of it.

So the next question is: reject by default or just warn? I'm inclined to
reject by default, just to counter the number of users who are probably
happily using Tor and have no idea that there's a problem. Even if they
get angry and stop using Tor because it's "broken" now, that's probably
ok for them.

And the last question is: what ports? 23, 110, 143 are easy choices. I
guess 109 is also a popularly used port? What about the AIM port -- even
if people are using OTR are they still leaking their username/password
during login? What others?

Thanks,
--Roger

</body></email><email><emailId>20080121052757</emailId><senderName>"Kevin Bauer"</senderName><senderEmail>ksbauer@gmail.com</senderEmail><timestampReceived>2008-01-21 05:27:57-0400</timestampReceived><subject>Re: Proposal to mitigate insecure protocols over Tor</subject><body>

On Jan 19, 2008 11:57 PM, Roger Dingledine &lt;arma@mit.edu&gt; wrote:
&gt; On Thu, Jan 17, 2008 at 04:44:25PM -0700, Kevin Bauer wrote:
&gt; &gt; &gt; &gt;         BlockInsecureProtocols 0|1
&gt; &gt; &gt; &gt;         WarnInsecureProtocols 0|1
&gt; &gt; &gt;
&gt; &gt; &gt; This seems like a fine interface. The status events I mention above
&gt; &gt; &gt; could still be useful, because if Block is default, there will be a lot
&gt; &gt; &gt; of confused users unless Vidalia pops up a little something explaining
&gt; &gt; &gt; that what they just tried may not be a smart move.
&gt;
&gt; Ok, I added the features here:
&gt; http://archives.seul.org/or/cvs/Jan-2008/msg00182.html
&gt; (I changed my mind a bit about the interface, but hopefully the one I
&gt; picked will do fine.)

Looks great!

&gt;
&gt; &gt; I agree that insecure http is a significant avenue for information
&gt; &gt; leakage over Tor. What we are suggesting in this proposal is that we
&gt; &gt; try to limit the *really stupid* ways that very sensitive information
&gt; &gt; (user names/passwords) can be accidentally exposed by a naive Tor
&gt; &gt; user. The protocols that we mentioned not only can lead to anonymity
&gt; &gt; loss, but also the potential compromise of the accounts when observed
&gt; &gt; by a malicious exit node.
&gt;
&gt; True -- but that can happen through port 80 too. I still worry a little
&gt; that by adding these warnings for only some of the risky behavior, users
&gt; will do other risky behavior, not get a warning, and believe that it is
&gt; therefore safe. But I think you're right, it's better to warn for some
&gt; of it than to warn for none of it.
&gt;

Good point. MySpace is a prime example of a very popular site that
does not offer a secure login process. Perhaps more can be done at the
HTTP proxy level to address the insecurities that are specific to web
traffic?

&gt; So the next question is: reject by default or just warn? I'm inclined to
&gt; reject by default, just to counter the number of users who are probably
&gt; happily using Tor and have no idea that there's a problem. Even if they
&gt; get angry and stop using Tor because it's "broken" now, that's probably
&gt; ok for them.
&gt;

For Telnet, IMAP, and POP, I would suggest that the policy be to block
by default for the following reason.  During our 8 day observations
cited in the initial proposal, the Telnet, IMAP, and POP traffic
accounted for around 0.16% of the total connections that were
established through our exit node. So we're probably not talking about
a large fraction of the protocols that are used over Tor.

&gt; And the last question is: what ports? 23, 110, 143 are easy choices. I
&gt; guess 109 is also a popularly used port? What about the AIM port -- even
&gt; if people are using OTR are they still leaking their username/password
&gt; during login? What others?

Agreed, ports 23 (telnet), 109 (pop2), 110 (pop3), and 143 (imap)
should certainly be ports of interest, and possibly be blocked by
default for the reason described above.

As far as I know (and perhaps someone can correct me if I'm wrong
here), most popular instant messaging services (like AIM, MSN , Yahoo,
Jabber, etc.) exchange login credentials securely over SSL/TLS. Thus,
in my opinion, they differ from Telnet, IMAP, and POP in this respect.
However, they do generally seem to expose a user's screen name in the
application header. Thus, they may be unwise to use over Tor for
anonymity reasons. Certainly a warning about the risks that are
inherent in these instant messaging protocols is prudent, but I think
that the information leakage is probably no worse than what is
possible over HTTP.

&gt;
&gt; Thanks,
&gt; --Roger
&gt;
&gt;

Kevin
</body></email><email><emailId>20081008131201</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2008-10-08 13:12:01-0400</timestampReceived><subject>Brainstorming about Tor, Germany, and data retention</subject><body>

Hi folks,

We need to build a plan for Tor, data retention, and Germany. The data
retention law in Germany comes into effect Jan 1 2009. Coincidentally,
this is just after the 25C3 congress, and many people there will be
asking me about our plan. I hope to do a talk there on Tor's plan wrt
German data retention. Maybe we should also consider a panel with an
actual informed German person, like Frank or Julius or Andreas?

Now, part of the challenge here is that there's so much misinformation
(and lack of information) floating around. Some questions we need
answered:

1) Will ISPs be required to log connection timing information of their
users? What exactly will the information be -- destination IP address,
port, timestamp of beginning of connection, timestamp of end? Or more
than that? Or less?

2) Are there ISPs that plan to not log? If so, how many?

3) Do we expect the authorities will only use the logs in a pinpoint
way, or will they also trawl? That is, will they go to an ISP and say
"tell me what this user did during this five minute period", or can they
ask every ISP at once "tell me all your info about every connection to
amazon.com on Saturday"? As a special case of this, is asking for info
from 500 Tor relays more like a pinpoint request or more like trawling?

4) Is it just each ISP that directly interacts with customers that has
to log, or is it all the ISPs, all the way up the chain? That is, are
there tier-1 ISPs that will end up with massive logs, and will there be
a lot of points you can go if you want to see what a user has been up to?

5) Will Tor relays be required by law to log "stuff" too? If so, is it
the same stuff as in question #1?

6) Are there Tor relays that plan to not log? E.g. CCC or Foebud or GPF?
Is fighting a law by not following it even a normal way of fighting a
law in Germany? :)

First, let's recall that Tor is most vulnerable at the endpoints: the
entry point and the exit point. If an attacker gets data about the middle
of the circuit, but doesn't get both the entry point and the exit point,
then they don't really win much.

There are two categories of users we can consider: people inside
Germany and people outside Germany. And as Karsten keeps reminding me,
the third category is relay operators in Germany, who really want some
advice.

The first defense that comes to mind is to never set the Guard flag on
German Tor relays. That means that people outside Germany will never
reveal their location to a German Tor relay, since their guards will
always be outside. Folks inside Germany will still have a problem, since
*their* ISPs will probably still log connection data.

Note that German users contacting German websites are always going to
have a problem; we can't do anything about it if the ISP of the user
and the ISP of the website both log, and later compare notes.

That said, though, if the logs they keep aren't very precise, then
comparing them won't actually be very useful. In particular, if they just
have TLS connection start and stop timestamps from the entry node side,
then we could adapt Tor so it starts the TLS connection well before
it needs it (this is already done to a large extent, since we build
circuits preemptively), and so it stops the TLS connection well after
it is done with it (we are mostly set up for this already too, since we
delay a while before closing unused connections -- we just need to make
that a variable delay rather than a constant delay).

Of course, if every ISP were to keep logs of the timing of every _packet_
on every connection, we'd be back in bad shape. But I think such a burden
is impractical (to say nothing of illegal, even in the current Germany).

Another catch here is the lesson we learned from the students at U
Colorado with their PETS paper: even if you only logged one side of a
conversation, it's still really risky to have that log, because you have
no idea who *else* happened to log somewhere else on the Tor network
at the same time. Both parties could be thinking to themselves "hey,
I've only got half the conversation, this can't hurt anybody", but if
they both publish then suddenly users are linked.

If we conclude then that logging even one side of a conversation is
bad (because you never know who else might have data that matches up),
then we should be really uncomfortable with exit relays in Germany too.
After all, their ISPs will have half the conversation logged already. And
while there's no trivial way to turn a log from an exit relay into
knowing where the clients are, it's still one of the steps down that path.
Worse, logs at the exit relay side won't be padded by the above "start
the TLS connection early and end it late" strategies, since they'll be
seeing the bare exit connections.

If we truly believed that the databases these ISPs build will be kept
secure against all attackers, and we truly believed that the databases
would never be used for trawling (see question #3 at the top), then it
might not be so bad. But that's a lot to ask.

On the other hand, it would be a real shame to withhold both the Guard
flag and the Exit flag from all Tor relays in Germany. There really isn't
much left, especially if we plan to experiment with 2-hop paths one day.

Now, what about the relay operators, and *their* duty to log? First,
note that from the perspective of an exit relay, the game is already up:
if the ISP logs connections, it has pretty much everything useful the
exit relay could be logging anyway.

(Exception: that isn't the case if the circuit consists entirely of
German Tor relays. No matter what strategy we conclude here, it seems
clear that we should disallow circuits like that.)

I don't mean to say "therefore it is fine for Tor exit relays to log"
-- I think it is a dark day when anonymity infrastructure operators
start tracking their users -- but we should recognize that the damage is
already done here by the ISP, regardless of what the exit relay chooses.

On the other hand, if we do the "make TLS start and stop times less
dependent on stream connection times" trick, then what the entry guard
knows and what the entry guard's ISP knows *are* in fact different. This
argues for never letting German Tor relays be entry guards, so we don't
put them in this position.

Speaking of which, there's another lesson we can learn from the distant
past. Once upon a time, in my first congress talk about Tor back in
21c3, the Wikipedia people stood up and asked how they were supposed to
deal with anonymous users. My answer at the time was basically "there
are effectively anonymous users on the Internet already, sorry, you'll
just have to deal." Their eventual answer was to build a big list of
anything ever associated with Tor, and block edits from it. If we had
worked with them from the start, we could have saved a lot of grief by
giving them precise lists of current exit IP addresses, etc. The lesson
here is that we need a better answer for both German Tor relay operators
and for German law enforcement than "sorry, you'll just have to deal",
since otherwise they *will* come up with answers that we don't like.

That said, my first reaction is still "Tor relays must not log, even in
Germany. If you're planning to log, please shut down your relay instead."
Is there some approach we can take that doesn't result in 1/3 of the Tor
network disappearing in January?

For example, if Tor users always avoid German Tor relays for circuit
positions where they know more than their ISP knows (i.e. entry guard),
can German relay operators then argue that they don't know any more than
their ISP does, so if you want logs just go hassle the ISP? If we explain
the design clearly enough, that puts operators in a better position than
"sorry, sir, I *could* log that for you, but I have chosen not to."

Ok, so let's break this down into cases.

1) User outside of Germany, entry outside of Germany, exit and destination
outside of Germany. User is in pretty good shape, other than relatively
minor "partitioning" attacks coming from people with access to German
logs being able to rule out a fraction of the Tor network.

2) User outside of Germany, entry outside Germany, exit or destination
inside Germany. User is also in pretty good shape, in that just by
having exit or destination logs, you don't know where the user could be.
We're vulnerable to somebody who happened to collect logs of entry
traffic, and have to hope they never combine them with the German logs,
but that's a plausible thing to hope.

3) User inside Germany, entry outside Germany, exit and destination
outside Germany. Country-wide logs could enumerate German Tor users
(if they don't use bridges), but there wouldn't be anything to line up
to on the exit side.

4) User inside Germany, entry outside Germany, exit or destination
inside Germany. If our TLS start/stop trick is good enough, and there
are many Tor users in Germany, and the ISP logs can't be fetched in a
trawling manner ("show me all German users who were connected to the
Tor network during this time period"), then it's also not easy to line
up user to exit.

As an aside, it seems that German Tor users may benefit from using
(non-German) bridge relays as their first hop, as it complicates the
"all German users who were connected to the Tor network" step.

Also, because we can make the "take away the Guard flag" change at the
directory authorities, clients get the new protection without needing
to upgrade. This will make it easier to argue that all Tor users are
choosing paths in the new way.

One thing I missed in the analysis is Internet connections that traverse
Germany, for example the connection from an Austrian Tor user to a Danish
Tor entry guard. I don't know how common these paths are, and I don't know
whether such connections are proposed to be logged under the proposed law.

I have also made generous assumptions on the part of the law enforcement,
as to how rational they will be in evaluating the law. I know we can be
paranoid and assume the worst, but in that case we might as well excise
all German Tor relays from the network and be done with it.

What else did I miss?

--Roger

</body></email><email><emailId>20081008141319</emailId><senderName>Carsten_Krüger</senderName><senderEmail>c.krueger@gmx.org</senderEmail><timestampReceived>2008-10-08 14:13:19-0400</timestampReceived><subject>Re: Brainstorming about Tor, Germany, and data retention</subject><body>


Hello Roger,

&gt; 1) Will ISPs be required to log connection timing information of their
&gt; users? What exactly will the information be -- destination IP address,
&gt; port, timestamp of beginning of connection, timestamp of end? Or more
&gt; than that? Or less?

That's not planed.
The ISPs have to log the dynamic IP of the user, the time (log in/log
out including timezone) and the identifier of the telephone/dsl line.
Only for email, telephone and sms there are more rulez.

Directive 2006/24/EC of the European Parliament and of the Council
http://eur-lex.europa.eu/LexUriServ/LexUriServ.do?uri=CELEX:32006L0024:EN:HTML
(I've attached it, the server is down at the time of writing)

&gt; 2) Are there ISPs that plan to not log? If so, how many?

very unlikly

&gt; 3) Do we expect the authorities will only use the logs in a pinpoint
&gt; way, or will they also trawl? That is, will they go to an ISP and say
&gt; "tell me what this user did during this five minute period", or can they
&gt; ask every ISP at once "tell me all your info about every connection to
&gt; amazon.com on Saturday"? As a special case of this, is asking for info
&gt; from 500 Tor relays more like a pinpoint request or more like trawling?

That's not possible.
Authorities can lawfull intercept the traffic of some users (sniff the
hole traffic). That could be an end user or an tor operator.
Lawfull interception is only applicable if the person is suspicios.
There are more or less well defined criteria when it is allowed to
intercept (it's not allowed for prevention)
Additionaly they can ask amazon.com for there logfiles.

greetings
Carsten
["Directive 2006-24-EC of the European Parliament and of the Council.txt.bz2" (application/octet-stream)]

</body></email><email><emailId>20081111195014</emailId><senderName>Sambuddho Chakravarty</senderName><senderEmail>sc2516@columbia.edu</senderEmail><timestampReceived>2008-11-11 19:50:14-0400</timestampReceived><subject>determining which are the ORs a Tor circuit is using</subject><body>

Hello All
 I have a general question. I am using the default torrc (without
specifying which ORs to select and letting the client determine the
"best" ones for itself). Is there a way to detect which are the ORs the
client picks up for the entry , middleman and exit nodes (rather than
hacking into the source code of the tor client). I am using a rather
dated version of the client - 0.1.2.18.

Thanks
Sambuddho

</body></email><email><emailId>20081111195520</emailId><senderName>mrwigglet</senderName><senderEmail>mrwigglet@gmail.com</senderEmail><timestampReceived>2008-11-11 19:55:20-0400</timestampReceived><subject>Re: determining which are the ORs a Tor circuit is using</subject><body>

I know it is saved in the log files, although there may be an easier way to
do it.  There are lots of paths built that are in a waiting state, so you'd
have to do some connecting the actual circuit being used with when it was
built.  I don't know of a built in way of doing this.


On Tue, Nov 11, 2008 at 12:50 PM, Sambuddho Chakravarty &lt;sc2516@columbia.edu
&gt; wrote:

&gt; Hello All
&gt;  I have a general question. I am using the default torrc (without
&gt; specifying which ORs to select and letting the client determine the
&gt; "best" ones for itself). Is there a way to detect which are the ORs the
&gt; client picks up for the entry , middleman and exit nodes (rather than
&gt; hacking into the source code of the tor client). I am using a rather
&gt; dated version of the client - 0.1.2.18.
&gt;
&gt; Thanks
&gt; Sambuddho
&gt;
&gt;


-- 
Nathan Evans
Research Assistant
Department of Computer Science
University of Denver

[Attachment #3 (text/html)]

I know it is saved in the log files, although there may be an easier way to do \
it.  There are lots of paths built that are in a waiting state, so you'd \
have to do some connecting the actual circuit being used with when it was \
built.  I don't know of a built in way of doing this.&lt;br&gt; &lt;br&gt;&lt;br&gt;&lt;div \
class="gmail_quote"&gt;On Tue, Nov 11, 2008 at 12:50 PM, Sambuddho Chakravarty &lt;span \
dir="ltr"&gt;&lt;&lt;a href="mailto:sc2516@columbia.edu"&gt;sc2516@columbia.edu&lt;/a&gt;&gt;&lt;/span&gt; \
wrote:&lt;br&gt;&lt;blockquote class="gmail_quote" style="border-left: 1px solid rgb(204, 204, \
204); margin: 0pt 0pt 0pt 0.8ex; padding-left: 1ex;"&gt; Hello All&lt;br&gt;
 I have a general question. I am using the default torrc (without&lt;br&gt;
specifying which ORs to select and letting the client determine the&lt;br&gt;
"best" ones for itself). Is there a way to detect which are the ORs the&lt;br&gt;
client picks up for the entry , middleman and exit nodes (rather than&lt;br&gt;
hacking into the source code of the tor client). I am using a rather&lt;br&gt;
dated version of the client - &lt;a href="http://0.1.2.18" \
target="_blank"&gt;0.1.2.18&lt;/a&gt;.&lt;br&gt; &lt;br&gt;
Thanks&lt;br&gt;
&lt;font color="#888888"&gt;Sambuddho&lt;br&gt;
&lt;br&gt;
&lt;/font&gt;&lt;/blockquote&gt;&lt;/div&gt;&lt;br&gt;&lt;br clear="all"&gt;&lt;br&gt;-- &lt;br&gt;Nathan Evans&lt;br&gt;Research \
Assistant&lt;br&gt;Department of Computer Science&lt;br&gt;University of Denver&lt;br&gt;



</body></email><email><emailId>20081202222204</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-12-02 22:22:04-0400</timestampReceived><subject>Proposal 157: Make certificate downloads specific</subject><body>

Here's a pretty simple proposal I wrote to fix one of the issues in
bug 854.

Filename: 157-specific-cert-download.txt
Title: Make certificate downloads specific
Version: $Revision: 17448 $
Last-Modified: $Date: 2008-12-02 17:20:47 -0500 (Tue, 02 Dec 2008) $
Author: Nick Mathewson
Created: 2-Dec-2008
Status: Open
Target: 0.2.1.x

Overview:

  Tor's directory specification gives two ways to download a certificate:
  by its identity fingerprint, or by the digest of its secret key.  Both
  are error-prone.  We propose a new download mechanism to make sure that
  clients get the certificates they want.

Motivation:

  When a client wants a certificate to verify a consensus, it has two choices
  currently:
     - Download by identity key fingerprint.  In this case, the client risks
       getting a certificate for the same authority, but with a different
       signing key than the one used to sign the consensus.

     - Download by signing key fingerprint.  In this case, the client risks
       getting a forged certificate that contains the right signing key
       signed with the wrong identity key.  (Since caches are willing to
       cache certs from authorities they do not themselves recognize, the
       attacker wouldn't need to compromise an authority's key to do this.)

Current solution:

  Clients fetch by identity keys, and re-fetch with backoff if they don't get
  certs with the signing key they want.

Proposed solution:

  Phase 1: Add a URL type for clients to download certs by identity _and_
  signing key fingerprint.  Unless both fields match, the client doesn't
  accept the certificate(s).  Clients begin using this method when their
  randomly chosen directory cache supports it.

  Phase 1A: Simultaneously, add a cross-certification element to
  certificates.

  Phase 2: Once many directory caches support phase 1, clients should prefer
  to fetch certificates using that protocol when available.

  Phase 2A: Once all authorities are generating cross-certified certificates
  as in phase 1A, require cross-certification.

Specification additions:

  The key certificate whose identity key fingerprint is &lt;F&gt; and whose signing
  key fingerprint is &lt;S&gt; should be available at:

      http://&lt;hostname&gt;/tor/keys/fp-sk/&lt;F&gt;-&lt;S&gt;.z

  As usual, clients may request multiple certificates using:

      http://&lt;hostname&gt;/tor/keys/fp-sk/&lt;F1&gt;-&lt;S1&gt;+&lt;F2&gt;-&lt;S2&gt;.z

  Clients SHOULD use this format whenever they know both key fingerprints for
  a desired certificate.


  Certificates SHOULD contain the following field (at most once):

  "cross-cert" NL CrossSignature NL

  where CrossSignature is a signature, made using the certificate's signing
  key, of the digest of the PKCS1-padded hash of the certificate's identity
  key.  For backward compatibility with broken versions of the parser, we
  wrap the base64-encoded signature in -----BEGIN ID SIGNATURE---- and
  -----END ID SIGNATURE----- tags.  (See bug 880.) Implementations MUST allow
  the "ID " portion to be omitted, however.

  When encountering a certificate with a cross-cert entry, implementations
  MUST verify that the

  (In a future version of this specification, cross-cert entries will be
  required.)

Why cross-certify too?

  Cross-certification protects clients who haven't updated yet, by reducing
  the number of caches that are willing to hold and serve bogus certificates.

References:

  This is related to part 2 of bug 854.
</body></email><email><emailId>20081111205456</emailId><senderName>Sambuddho Chakravarty</senderName><senderEmail>sc2516@columbia.edu</senderEmail><timestampReceived>2008-11-11 20:54:56-0400</timestampReceived><subject>Re: determining which are the ORs a Tor circuit is using</subject><body>

I taking the following route 

circuitbuild.c-&gt; circuit_send_next_onionskin-&gt;
		At the point where there is a check for if(!hop)
 		I take the 'circ' pointer and -&gt; crypt_path_t pointer -&gt;
extend_info_t pointer -&gt; nickname/addr

Should that work ?

Thanks
Sambuddho 

On Tue, 2008-11-11 at 12:55 -0700, mrwigglet wrote:
&gt; I know it is saved in the log files, although there may be an easier
&gt; way to do it.  There are lots of paths built that are in a waiting
&gt; state, so you'd have to do some connecting the actual circuit being
&gt; used with when it was built.  I don't know of a built in way of doing
&gt; this.
&gt; 
&gt; 
&gt; On Tue, Nov 11, 2008 at 12:50 PM, Sambuddho Chakravarty
&gt; &lt;sc2516@columbia.edu&gt; wrote:
&gt;         Hello All
&gt;          I have a general question. I am using the default torrc
&gt;         (without
&gt;         specifying which ORs to select and letting the client
&gt;         determine the
&gt;         "best" ones for itself). Is there a way to detect which are
&gt;         the ORs the
&gt;         client picks up for the entry , middleman and exit nodes
&gt;         (rather than
&gt;         hacking into the source code of the tor client). I am using a
&gt;         rather
&gt;         dated version of the client - 0.1.2.18.
&gt;         
&gt;         Thanks
&gt;         Sambuddho
&gt;         
&gt; 
&gt; 
&gt; 
&gt; -- 
&gt; Nathan Evans
&gt; Research Assistant
&gt; Department of Computer Science
&gt; University of Denver

</body></email><email><emailId>20081008142002</emailId><senderName>Lexi Pimenidis</senderName><senderEmail>lexi@i4.informatik.rwth-aachen.de</senderEmail><timestampReceived>2008-10-08 14:20:02-0400</timestampReceived><subject>Re: Brainstorming about Tor, Germany, and data retention</subject><body>

On Wed, Oct 08, 2008 at 03:12:01PM CEST, Roger Dingledine wrote:

Hej,

&gt; Now, part of the challenge here is that there's so much misinformation
&gt; (and lack of information) floating around. Some questions we need
&gt; answered:
&gt; 
&gt; 1) Will ISPs be required to log connection timing information of their
&gt; users? What exactly will the information be -- destination IP address,
&gt; port, timestamp of beginning of connection, timestamp of end? Or more
&gt; than that? Or less?

Less. The logging is rather strict for e-mail and VoIP, but for any other
purpose only the user's real identity and his IP-address has to be logged.
No logging of TCP connections, no logging of HTTP, no logging of IP packets.

&gt; 2) Are there ISPs that plan to not log? If so, how many?

I wondered about this one, too - there are some ISPs how filed law-suites
because logging costs them really a lot of money. There has been recently a
case in Berlin where the ISP won this law suit.

http://www.heise.de/newsticker/Gericht-TK-Anbieter-muss-Vorratsdatenspeicherung-voraussichtlich-nicht-umsetzen-Update--/meldung/116372
 (in German)

&gt; 5) Will Tor relays be required by law to log "stuff" too? If so, is it
&gt; the same stuff as in question #1?

The Jondos people are investing a huge amount of time and effort into gaining
a legal clearing or the situation. I suggest to join them in order to
avoid double work and have a better stand against governmental agencies.

I think the current bottomline is that the effect of the law will be delayed 
for anonymizing nodes for some more time.

&gt; 6) Are there Tor relays that plan to not log? E.g. CCC or Foebud or GPF?
&gt; Is fighting a law by not following it even a normal way of fighting a
&gt; law in Germany? :)

The problem ist that following: if you think that a law is not justified you
can file a law suit against it. But up you still have to adhere to the law
until you won the law suit you filed against it. BTW, there is already a class
act suit against the data retention law on-going (the biggest in German
history).

&gt; The first defense that comes to mind is to never set the Guard flag on
&gt; German Tor relays.

The problem is that you'd have to avoid setting flags on nodes *operated* by
germans. Because the (german) law is valid for nodes operated by germans even
if the nodes are outside germany. Of course - physical location might
correlate.

&gt; Note that German users contacting German websites are always going to
&gt; have a problem; we can't do anything about it if the ISP of the user
&gt; and the ISP of the website both log, and later compare notes.

Taking into account the law, I don;t 

&gt; If we truly believed that the databases these ISPs build will be kept
&gt; secure against all attackers, and we truly believed that the databases
&gt; would never be used for trawling (see question #3 at the top), then it
&gt; might not be so bad. But that's a lot to ask.

The databases at the ISPs will IMHO not harming the anonymity of Tor users
a huge big lot. It looks differently if nodes were forced to log, though.

&gt; Speaking of which, there's another lesson we can learn from the distant
&gt; past. Once upon a time, in my first congress talk about Tor back in
&gt; 21c3, the Wikipedia people stood up and asked how they were supposed to
&gt; deal with anonymous users. My answer at the time was basically "there
&gt; are effectively anonymous users on the Internet already, sorry, you'll
&gt; just have to deal." Their eventual answer was to build a big list of
&gt; anything ever associated with Tor, and block edits from it. If we had
&gt; worked with them from the start, we could have saved a lot of grief by
&gt; giving them precise lists of current exit IP addresses, etc. The lesson
&gt; here is that we need a better answer for both German Tor relay operators
&gt; and for German law enforcement than "sorry, you'll just have to deal",
&gt; since otherwise they *will* come up with answers that we don't like.

I totally agree with this one. IMHO a huge part of the blamingshould not only
be done to the politicians (poor people, they know nothing about technology),
but rather the privacy people -- if they suggested a trade-off which would
have been acceptable to both sides, we were better off right now. Proposing
"any logging is eavil" was for sure destined to bring us the current laws.

&gt; That said, my first reaction is still "Tor relays must not log, even in
&gt; Germany. If you're planning to log, please shut down your relay instead."
&gt; Is there some approach we can take that doesn't result in 1/3 of the Tor
&gt; network disappearing in January?

Hm, making them to middle men nodes and hope that law enforcement will never
show up and ask for some data? Hm, no....

&gt; One thing I missed in the analysis is Internet connections that traverse
&gt; Germany, for example the connection from an Austrian Tor user to a Danish
&gt; Tor entry guard. I don't know how common these paths are, and I don't know
&gt; whether such connections are proposed to be logged under the proposed law.

The DE-CIX in Frankfurt is the second biggest point of data
exchange in Germany =&gt; http://en.wikipedia.org/wiki/DE-CIX
If you want to avoid Germany, you'd effectively cancel out 1/2 of Europe or
so.

But as I said: there will be no logging of single TCP-connections - hence I
don't think that passing Germany is a big problem.


</body></email><email><emailId>20081008143152</emailId><senderName>Lexi Pimenidis</senderName><senderEmail>lexi@i4.informatik.rwth-aachen.de</senderEmail><timestampReceived>2008-10-08 14:31:52-0400</timestampReceived><subject>Re: Brainstorming about Tor, Germany, and data retention</subject><body>

On Wed, Oct 08, 2008 at 04:20:02PM CEST, Lexi Pimenidis wrote:

Sorry - send the e-amil before I finished it :-/

&gt; The DE-CIX in Frankfurt is the second biggest point of data
&gt; exchange in Germany =&gt; http://en.wikipedia.org/wiki/DE-CIX
&gt; If you want to avoid Germany, you'd effectively cancel out 1/2 of Europe or
&gt; so.
&gt; 
&gt; But as I said: there will be no logging of single TCP-connections - hence I
&gt; don't think that passing Germany is a big problem.

That was meant to be "passing through"...

Regards,

	Lexi

PS: sorry for typos, grammar... will make up for it, once thesis is finished.

-- 
Axrq.-Xwtncz. Qobx Rxzowxaxk, Qoicuocoxli tpoc XH-Kxliocioxh
Cspz: IL 8325, Inoqaocqxwkhc. 3, Kxofow, Hoq: +49-271-740-2408
| Isuo wpw, sli! Rixqnknrixo, Ypcxkhocox pwa Zoaxexw,
| Pwa qoxaoc spli Hionqnfxo!  Apclispk khpaxoch, zxh ioxkkoz Uozpoiw.
| As khoi xli wpw, xli sczoc Hnc!  Pwa uxw kn jqpf sqk dxo epvnc;
</body></email><email><emailId>20081008143308</emailId><senderName>Carsten_Krüger</senderName><senderEmail>c.krueger@gmx.org</senderEmail><timestampReceived>2008-10-08 14:33:08-0400</timestampReceived><subject>Re: Brainstorming about Tor, Germany, and data retention</subject><body>

&gt; Directive 2006/24/EC of the European Parliament and of the Council

PS: That's an european problem not only a german one.
Don't know why other countries didn't bring this to public.

greetings
Carsten

</body></email><email><emailId>20081008144607</emailId><senderName>Lexi Pimenidis</senderName><senderEmail>lexi@i4.informatik.rwth-aachen.de</senderEmail><timestampReceived>2008-10-08 14:46:07-0400</timestampReceived><subject>Re: Brainstorming about Tor, Germany, and data retention</subject><body>

On Wed, Oct 08, 2008 at 04:33:08PM CEST, Carsten Krüger wrote:
&gt; &gt; Directive 2006/24/EC of the European Parliament and of the Council
&gt; 
&gt; PS: That's an european problem not only a german one.
&gt; Don't know why other countries didn't bring this to public.

They're working on it:
http://www.timesonline.co.uk/tol/news/uk/article4882600.ece

What I take from this article is that the UK will go vastly beyond 
what we will have in Germany.

-- Lexi

-- 
Xjcw.-Jrikeg. Wmdj Cjgmrjxjs, Wmheqmemjah ivme JT-Sjahmehmjt
Eovg: HA 8325, Hkmwxmewjrste. 3, Sjmzmr, Tmw: +49-271-740-2408
| Hoqm rvr, oah! Chjwkskchjm, Uvejstmemj vrx Gmxjyjr,
| Vrx wmjxme ovah Thmkwkzjm!  Xveahovs stvxjmet, gjt hmjssmg Qmgvmhr.
| Xo stmh jah rvr, jah oegme Tke!  Vrx qjr sk nwvz ows ljm yvbke;
</body></email><email><emailId>20081009042900</emailId><senderName>Smuggler</senderName><senderEmail>smuggler@kryptohippie.com</senderEmail><timestampReceived>2008-10-09 04:29:00-0400</timestampReceived><subject>Re: Brainstorming about Tor, Germany, and data retention</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

The issue is mostly the part of the law that concerns "replacement of
addresses". Basically every node would need to log the original IP and
the new IP of a connection as well as the time when the connection
started and ended.

"Anonymisierungsdienste speichern die ursprüngliche und die neue Angabe
sowie des Zeitpunktes der Umschreibung dieser Angaben nach Datum und
Uhrzeit unter Angabe der zugrunde liegenden Zeitzone"

The problem here is that the "Technische Richtlinie" (technical
directive) has not yet been adapted to the law and/or not yet publicized.



Roger Dingledine wrote:
&gt; Hi folks,
&gt; 
&gt; We need to build a plan for Tor, data retention, and Germany. The data
&gt; retention law in Germany comes into effect Jan 1 2009. Coincidentally,
&gt; this is just after the 25C3 congress, and many people there will be
&gt; asking me about our plan. I hope to do a talk there on Tor's plan wrt
&gt; German data retention. Maybe we should also consider a panel with an
&gt; actual informed German person, like Frank or Julius or Andreas?
&gt; 
&gt; Now, part of the challenge here is that there's so much misinformation
&gt; (and lack of information) floating around. Some questions we need
&gt; answered:
&gt; 
&gt; 1) Will ISPs be required to log connection timing information of their
&gt; users? What exactly will the information be -- destination IP address,
&gt; port, timestamp of beginning of connection, timestamp of end? Or more
&gt; than that? Or less?
&gt; 
&gt; 2) Are there ISPs that plan to not log? If so, how many?
&gt; 
&gt; 3) Do we expect the authorities will only use the logs in a pinpoint
&gt; way, or will they also trawl? That is, will they go to an ISP and say
&gt; "tell me what this user did during this five minute period", or can they
&gt; ask every ISP at once "tell me all your info about every connection to
&gt; amazon.com on Saturday"? As a special case of this, is asking for info
&gt; from 500 Tor relays more like a pinpoint request or more like trawling?
&gt; 
&gt; 4) Is it just each ISP that directly interacts with customers that has
&gt; to log, or is it all the ISPs, all the way up the chain? That is, are
&gt; there tier-1 ISPs that will end up with massive logs, and will there be
&gt; a lot of points you can go if you want to see what a user has been up to?
&gt; 
&gt; 5) Will Tor relays be required by law to log "stuff" too? If so, is it
&gt; the same stuff as in question #1?
&gt; 
&gt; 6) Are there Tor relays that plan to not log? E.g. CCC or Foebud or GPF?
&gt; Is fighting a law by not following it even a normal way of fighting a
&gt; law in Germany? :)
&gt; 
&gt; First, let's recall that Tor is most vulnerable at the endpoints: the
&gt; entry point and the exit point. If an attacker gets data about the middle
&gt; of the circuit, but doesn't get both the entry point and the exit point,
&gt; then they don't really win much.
&gt; 
&gt; There are two categories of users we can consider: people inside
&gt; Germany and people outside Germany. And as Karsten keeps reminding me,
&gt; the third category is relay operators in Germany, who really want some
&gt; advice.
&gt; 
&gt; The first defense that comes to mind is to never set the Guard flag on
&gt; German Tor relays. That means that people outside Germany will never
&gt; reveal their location to a German Tor relay, since their guards will
&gt; always be outside. Folks inside Germany will still have a problem, since
&gt; *their* ISPs will probably still log connection data.
&gt; 
&gt; Note that German users contacting German websites are always going to
&gt; have a problem; we can't do anything about it if the ISP of the user
&gt; and the ISP of the website both log, and later compare notes.
&gt; 
&gt; That said, though, if the logs they keep aren't very precise, then
&gt; comparing them won't actually be very useful. In particular, if they just
&gt; have TLS connection start and stop timestamps from the entry node side,
&gt; then we could adapt Tor so it starts the TLS connection well before
&gt; it needs it (this is already done to a large extent, since we build
&gt; circuits preemptively), and so it stops the TLS connection well after
&gt; it is done with it (we are mostly set up for this already too, since we
&gt; delay a while before closing unused connections -- we just need to make
&gt; that a variable delay rather than a constant delay).
&gt; 
&gt; Of course, if every ISP were to keep logs of the timing of every _packet_
&gt; on every connection, we'd be back in bad shape. But I think such a burden
&gt; is impractical (to say nothing of illegal, even in the current Germany).
&gt; 
&gt; Another catch here is the lesson we learned from the students at U
&gt; Colorado with their PETS paper: even if you only logged one side of a
&gt; conversation, it's still really risky to have that log, because you have
&gt; no idea who *else* happened to log somewhere else on the Tor network
&gt; at the same time. Both parties could be thinking to themselves "hey,
&gt; I've only got half the conversation, this can't hurt anybody", but if
&gt; they both publish then suddenly users are linked.
&gt; 
&gt; If we conclude then that logging even one side of a conversation is
&gt; bad (because you never know who else might have data that matches up),
&gt; then we should be really uncomfortable with exit relays in Germany too.
&gt; After all, their ISPs will have half the conversation logged already. And
&gt; while there's no trivial way to turn a log from an exit relay into
&gt; knowing where the clients are, it's still one of the steps down that path.
&gt; Worse, logs at the exit relay side won't be padded by the above "start
&gt; the TLS connection early and end it late" strategies, since they'll be
&gt; seeing the bare exit connections.
&gt; 
&gt; If we truly believed that the databases these ISPs build will be kept
&gt; secure against all attackers, and we truly believed that the databases
&gt; would never be used for trawling (see question #3 at the top), then it
&gt; might not be so bad. But that's a lot to ask.
&gt; 
&gt; On the other hand, it would be a real shame to withhold both the Guard
&gt; flag and the Exit flag from all Tor relays in Germany. There really isn't
&gt; much left, especially if we plan to experiment with 2-hop paths one day.
&gt; 
&gt; Now, what about the relay operators, and *their* duty to log? First,
&gt; note that from the perspective of an exit relay, the game is already up:
&gt; if the ISP logs connections, it has pretty much everything useful the
&gt; exit relay could be logging anyway.
&gt; 
&gt; (Exception: that isn't the case if the circuit consists entirely of
&gt; German Tor relays. No matter what strategy we conclude here, it seems
&gt; clear that we should disallow circuits like that.)
&gt; 
&gt; I don't mean to say "therefore it is fine for Tor exit relays to log"
&gt; -- I think it is a dark day when anonymity infrastructure operators
&gt; start tracking their users -- but we should recognize that the damage is
&gt; already done here by the ISP, regardless of what the exit relay chooses.
&gt; 
&gt; On the other hand, if we do the "make TLS start and stop times less
&gt; dependent on stream connection times" trick, then what the entry guard
&gt; knows and what the entry guard's ISP knows *are* in fact different. This
&gt; argues for never letting German Tor relays be entry guards, so we don't
&gt; put them in this position.
&gt; 
&gt; Speaking of which, there's another lesson we can learn from the distant
&gt; past. Once upon a time, in my first congress talk about Tor back in
&gt; 21c3, the Wikipedia people stood up and asked how they were supposed to
&gt; deal with anonymous users. My answer at the time was basically "there
&gt; are effectively anonymous users on the Internet already, sorry, you'll
&gt; just have to deal." Their eventual answer was to build a big list of
&gt; anything ever associated with Tor, and block edits from it. If we had
&gt; worked with them from the start, we could have saved a lot of grief by
&gt; giving them precise lists of current exit IP addresses, etc. The lesson
&gt; here is that we need a better answer for both German Tor relay operators
&gt; and for German law enforcement than "sorry, you'll just have to deal",
&gt; since otherwise they *will* come up with answers that we don't like.
&gt; 
&gt; That said, my first reaction is still "Tor relays must not log, even in
&gt; Germany. If you're planning to log, please shut down your relay instead."
&gt; Is there some approach we can take that doesn't result in 1/3 of the Tor
&gt; network disappearing in January?
&gt; 
&gt; For example, if Tor users always avoid German Tor relays for circuit
&gt; positions where they know more than their ISP knows (i.e. entry guard),
&gt; can German relay operators then argue that they don't know any more than
&gt; their ISP does, so if you want logs just go hassle the ISP? If we explain
&gt; the design clearly enough, that puts operators in a better position than
&gt; "sorry, sir, I *could* log that for you, but I have chosen not to."
&gt; 
&gt; Ok, so let's break this down into cases.
&gt; 
&gt; 1) User outside of Germany, entry outside of Germany, exit and destination
&gt; outside of Germany. User is in pretty good shape, other than relatively
&gt; minor "partitioning" attacks coming from people with access to German
&gt; logs being able to rule out a fraction of the Tor network.
&gt; 
&gt; 2) User outside of Germany, entry outside Germany, exit or destination
&gt; inside Germany. User is also in pretty good shape, in that just by
&gt; having exit or destination logs, you don't know where the user could be.
&gt; We're vulnerable to somebody who happened to collect logs of entry
&gt; traffic, and have to hope they never combine them with the German logs,
&gt; but that's a plausible thing to hope.
&gt; 
&gt; 3) User inside Germany, entry outside Germany, exit and destination
&gt; outside Germany. Country-wide logs could enumerate German Tor users
&gt; (if they don't use bridges), but there wouldn't be anything to line up
&gt; to on the exit side.
&gt; 
&gt; 4) User inside Germany, entry outside Germany, exit or destination
&gt; inside Germany. If our TLS start/stop trick is good enough, and there
&gt; are many Tor users in Germany, and the ISP logs can't be fetched in a
&gt; trawling manner ("show me all German users who were connected to the
&gt; Tor network during this time period"), then it's also not easy to line
&gt; up user to exit.
&gt; 
&gt; As an aside, it seems that German Tor users may benefit from using
&gt; (non-German) bridge relays as their first hop, as it complicates the
&gt; "all German users who were connected to the Tor network" step.
&gt; 
&gt; Also, because we can make the "take away the Guard flag" change at the
&gt; directory authorities, clients get the new protection without needing
&gt; to upgrade. This will make it easier to argue that all Tor users are
&gt; choosing paths in the new way.
&gt; 
&gt; One thing I missed in the analysis is Internet connections that traverse
&gt; Germany, for example the connection from an Austrian Tor user to a Danish
&gt; Tor entry guard. I don't know how common these paths are, and I don't know
&gt; whether such connections are proposed to be logged under the proposed law.
&gt; 
&gt; I have also made generous assumptions on the part of the law enforcement,
&gt; as to how rational they will be in evaluating the law. I know we can be
&gt; paranoid and assume the worst, but in that case we might as well excise
&gt; all German Tor relays from the network and be done with it.
&gt; 
&gt; What else did I miss?
&gt; 
&gt; --Roger
&gt; 
&gt; 

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.7 (Darwin)

iD8DBQFI7YiJOMmnRrmEoQkRAp3fAKDNt89f4uLbaGRMmUpmWXsvhSYFpACfYRs4
eGEetiyb+3J/F0AnjJca2n4=
=tX1G
-----END PGP SIGNATURE-----

</body></email><email><emailId>20081009063501</emailId><senderName>Lexi Pimenidis</senderName><senderEmail>lexi@i4.informatik.rwth-aachen.de</senderEmail><timestampReceived>2008-10-09 06:35:01-0400</timestampReceived><subject>Re: Brainstorming about Tor, Germany, and data retention</subject><body>

On Thu, Oct 09, 2008 at 06:29:00AM CEST, Smuggler wrote:

&gt; The issue is mostly the part of the law that concerns "replacement of
&gt; addresses". Basically every node would need to log the original IP and
&gt; the new IP of a connection as well as the time when the connection
&gt; started and ended.
&gt; 
&gt; "Anonymisierungsdienste speichern die ursprüngliche und die neue Angabe
&gt; sowie des Zeitpunktes der Umschreibung dieser Angaben nach Datum und
&gt; Uhrzeit unter Angabe der zugrunde liegenden Zeitzone"
&gt; 
&gt; The problem here is that the "Technische Richtlinie" (technical
&gt; directive) has not yet been adapted to the law and/or not yet publicized.

Although I've heared recently that "small nodes" (like personal devices for 
NAT as used for sharing single DSL-lines) will not fall under the directive.

Maybe it's possible to exploit this loophole?

-- Lexi
</body></email><email><emailId>20081009063800</emailId><senderName>Marcus Wolschon</senderName><senderEmail>marcus@wolschon.biz</senderEmail><timestampReceived>2008-10-09 06:38:00-0400</timestampReceived><subject>Re: Brainstorming about Tor, Germany, and data retention</subject><body>

On Thu, 9 Oct 2008 08:35:01 +0200, Lexi Pimenidis
&lt;lexi@i4.informatik.rwth-aachen.de&gt; wrote:
&gt; Although I've heared recently that "small nodes" (like personal devices
for
&gt; 
&gt; NAT as used for sharing single DSL-lines) will not fall under the
&gt; directive.
&gt; 
&gt; Maybe it's possible to exploit this loophole?

It is not because theyx formulatzed it such that
you are not "small" if you allow an unknown number of anonymous users.

Marcus
</body></email><email><emailId>20081202224057</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-12-02 22:40:57-0400</timestampReceived><subject>Re: Proposal 157: Make certificate downloads specific</subject><body>

(Missing clause.  This is what I get for writing nonlinearly.)

On Tue, Dec 02, 2008 at 05:22:04PM -0500, Nick Mathewson wrote:
&gt;   When encountering a certificate with a cross-cert entry, implementations
&gt;   MUST verify that the

        signature is a correct signature of the hash of the identity key
	using the signing key.


</body></email><email><emailId>20081206131940</emailId><senderName>"Steven J. Murdoch"</senderName><senderEmail>tor+steven.murdoch@cl.cam.ac.uk</senderEmail><timestampReceived>2008-12-06 13:19:40-0400</timestampReceived><subject>Re: Proposal: Avoiding infinite length circuits</subject><body>

On Fri, Dec 05, 2008 at 03:17:19PM -0500, Nick Mathewson wrote:
&gt; Another observation: The usual engineering solution here would be to
&gt; add a "hey, I'm a connection from a Tor server/hey, you are now
&gt; connecting to a Tor server" indicator to the protocol.  But our
&gt; anti-blocking designs make that basically impossible for us to do.  We
&gt; could take a probing-style approach, and have exit servers connect to
&gt; suspect ports, and see whether a Tor server answers, but that seems
&gt; questionable.  In any case, it would hurt the probing-resistance stuff
&gt; we've been kicking around.

If I understand the attack correctly, I'm not sure that the
anti-blocking design does preclude this approach. 

For example, an exit node could add a TCP option to outgoing streams,
to indicate that the connection came from Tor, and OPs could refuse
incoming connections with this flag. There is of course a practical
problem of setting this flag from a non-root process

Another option is an identd style approach -- allow a server to
connect back to the initiator of a TCP connection and ask whether that
came from a Tor exit stream.

The practical problem here is how to tell clients what port this
service runs on. We could put it in the descriptor, but once we assume
that a significant proportion of OPs have the descriptors for exit
nodes, they could already know whether a incoming connection comes
from a Tor node (though not from the Tor process).

Steven.

-- 
w: http://www.cl.cam.ac.uk/users/sjm217/
</body></email><email><emailId>20081207133001</emailId><senderName>Robert Hogan</senderName><senderEmail>robert@roberthogan.net</senderEmail><timestampReceived>2008-12-07 13:30:01-0400</timestampReceived><subject>Re: Empty TLS application records being injected in Tor streams</subject><body>


On Friday 05 December 2008 16:33:24 Ben Laurie wrote:
&lt;..&gt;
&gt;
&gt; Analysis
&gt; --------
&gt;
&gt; For this attack to work, the attacker must be able to control a
&gt; plaintext block for which he knows the preceding ciphertext block,
&gt; C_(j-1). SSL and TLS open up this problem because the IV for each
&gt; packet is the previous packet's final ciphertext block[1].
&gt;

When you say 'packet' here I understand you to mean 'application record'. I 
hope that's correct.There can multiple records in a single TLS network 
packet. 

&gt; Thus, if the attacker can choose plaintext for a TLS packet that
&gt; immediately follows a TLS packet he has observed, he can take a guess
&gt; at the plaintext of any packet he has seen in that ciphertext stream
&gt; and test whether the guess is correct.
&gt;

My understanding is that the chosen plaintext and the plaintext that is 
being guessed at must be adjacent for this to work. And that is why the 
empty 'unpredictable content' records between real application records 
frustrate the attack. P_i and P_j can't be interrupted by an unknown 
plaintext.

My reason for thinking this is that if I observe an empty TLS application 
record and 'know' the record following it contains a Tor VERSIONS command 
then the attack would still hold, unless the attack depended on being able 
to guess the plaintext of the empty application record as well.

I suspect my understanding has fallen down somewhere here.

&gt; Not many applications exist that allow the attacker to do this. In
&gt; particular, if an attacker has an ability to inject plaintext into a
&gt; TLS connection that contains data unknown to him, then the connection
&gt; must contain data not supplied by him.
&gt;
&gt; Therefore any protocol running over TLS that contains data entirely
&gt; controlled by a single party is immune. Note, though, that this does
&gt; not include protocols like POP3 or IMAP, where the payloads are the
&gt; result of many different people sending emails. Nor does it include
&gt; Tor. It does, however, include static web pages.
&gt;

Doesn't predictable content equate to control over content in this 
situation? The early parts of tor circuit construction are fairly 
predictable. So in the absence of empty application records an attacker 
could take a packet dump of a Tor conversation, attack the early part of 
the conversation with guesses at the VERSIONS and NETINFO sections and 
potentially come up with some hits.

A lot of the discussion here and elsewhere deals with real-time inspection 
of the packets. I am missing why the as-it-happens factor is important, 
doesn't the attack apply to recorded sessions for analysis at leisure?


["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20081213180046</emailId><senderName>Jacob Appelbaum</senderName><senderEmail>jacob@appelbaum.net</senderEmail><timestampReceived>2008-12-13 18:00:46-0400</timestampReceived><subject>Re: TBB build</subject><body>

Sebastian Hahn wrote:
&gt; Hey Jake,
&gt; 
&gt; I've followed the process to build a new TBB, and have found a few ways
&gt; to tweak the INSTALL file. Please find a first patch at
&gt; https://sebastianhahn.net/tor/TBB_INSTALL_PATCH_1.diff \
&gt; https://sebastianhahn.net/tor/TBB_INSTALL_PATCH_1.diff.asc 
&gt; 

Ok. That looks reasonable. I'll apply the patch.

&gt; Also, I ran into a rather larger problem. When we actually want to build
&gt; the bundle, the INSTALL file tells you to svn co the torbrowser project
&gt; from svn (including all branches and tags). This means the following
&gt; calls to make don't work.

Hrm. You mean if you cd into the tag you want to to build, you cannot
build a specific tag?

&gt; 
&gt; I tried checking out just the build-scripts directory from svn and then
&gt; running make, but now the vidalia build could not be found (probably
&gt; because the INSTALL file suggests moving the vidalia directory from
&gt; vidalia-0.1.10 to vidalia, but the build script looks for something else).
&gt; 

Which build-scripts? trunk/ or something else? The Makefile has to point
to the right Vidalia, I suspect that may be an issue. ;-)

&gt; This was when I suspected that I maybe shouldn't have just checked out
&gt; the build-scripts dir, or trunk conflicts with the INSTALL file, or
&gt; something else. Can you help clear this up? I need sleep now :)
&gt; 

Yeah, you want to not modify things locally if you want your build to
match my build. The exception is to modify them as the INSTALL document
suggests...

I'll update trunk/ and you should try to build from trunk again. Good luck!

Best,
Jake


</body></email><email><emailId>20081214015655</emailId><senderName>"Alva Doty"</senderName><senderEmail>badbytes@freehaven.net</senderEmail><timestampReceived>2008-12-14 01:56:55-0400</timestampReceived><subject>Take a look at the Cartier watches</subject><body>

Hello Alva

Christmas is the time to get IWC watch, and the only place to get top notch watches \
that look and perform exactly like the originals is http://www.domefor.com/

With top notch customer service and super warranty, we stand behind our watches.
http://www.domefor.com/

Sincerely,
Mr Doty


</body></email><email><emailId>20081215055017</emailId><senderName>"Dorothea Steele"</senderName><senderEmail>badbytes@freehaven.net</senderEmail><timestampReceived>2008-12-15 05:50:17-0400</timestampReceived><subject>Christmas Tag Heuer watches bargain</subject><body>

Hello Dorothea

I had never seen such beautiful and greatly-performing watches like the ones I found online at
http://www.domehas.com/

Take an extra 15% off your purchase during month of December.
http://www.domehas.com/

Sincerely,
Mr Steele

</body></email><email><emailId>20081215184148</emailId><senderName>Justin Samuel</senderName><senderEmail>jsamuel@cs.arizona.edu</senderEmail><timestampReceived>2008-12-15 18:41:48-0400</timestampReceived><subject>Re: Thandy attacks / suggestions</subject><body>

Roger Dingledine wrote:

&gt; 1) Apparently python's urllib doesn't check SSL certs or cert chains.
&gt; So while we may think that handing it https://updates.torproject.org/
&gt; will mean it'll complain if the cert is wrong, apparently we'd be
&gt; mistaken. His suggested fix was to ship our SSL cert with the updater;
&gt; that's no fun if we change our cert or if we add a mirror with a cert,
&gt; though. He didn't have a second suggested fix. At least we know now.  

This might have been a mix of conversations. In any event, coderman
mentioned M2Crypto in his reply and that is the solution many people do
use for ssl cert checking with urllib in python. Possibly coderman
thought M2Crypto was more dated than it is because the first result in
google is, unfortunately, still the old author's homepage. Here is the
current M2Crypto:

http://chandlerproject.org/Projects/MeTooCrypto

For what it's worth, ssl usage will get better with python 2.6:

http://docs.python.org/dev/library/ssl.html

It appears, though, that even with the new ssl module in python 2.6,
M2Crypto will still be the more secure way to do things (ability to
disable SSLv2, require stronger ciphers).

&gt; 7) We had a long discussion about the "what if the attacker gets a copy
&gt; of the timestamp key" worry. This issue seems to be the big remaining
&gt; question in the design: an attacker who can generate his own timestamp
&gt; file and either modify the repository or intercept client requests can
&gt; freeze clients in time, so they never know about updates and never realize
&gt; they're frozen. Since the timestamp file is only signed by the timestamp
&gt; key, he can also mix-and-match which hashes he puts in the timestamp file:
&gt; a keylist from time A, a mirror list from time B, a bundle from time
&gt; C. Some of these attacks are mitigated by having clients never replace
&gt; their current files with older files. But a newly bootstrapping client
&gt; can still be tricked into installing a package that's 18 months obsolete.
&gt;   

For the case where an attacker has the timestamp key, there are two
primary goals. First is that the attacker should not be able to do
anything other than keep the client on the the client's current version
of any files. Second is that the client needs a way to realize at some
point that something is wrong and there may be updates they are not
discovering. In the case of a newly bootstrapping client, this can be
read as the client not accepting initial files that are outdated.

Completely preventing an attacker in control of the timestamp key from
affecting which files the client uses doesn't seem likely. However, what
can be done is to only allow an attacker to provide a snapshot of the
real repository at some point in time (not allowing mix-and-match, as
described by Roger above). --- With proper expiration times on other
files, this snapshot has to be a very recent one.

One option that Justin Cappos and I mentioned to Roger which he asked us
to elaborate on here is that of adding another level of metadata
indirection between the timestamp file and the files referenced in the
timestamp file. The current arrangement of having the hashes/timestamps
of multiple files listed directly in the timestamp file means that the
timestamp key is actually responsible for more than indicating if the
repository contents have changed. Instead, the timestamp key is also
responsible for telling the client more specifically what is available
on the repository.

This ability for an attacker with the timestamp key to mix-and-match
what the client sees can be eliminated by not having the timestamp file
directly list fine-grained details of the repository state. Instead, a
new file whose sole purpose is to provide that information could be the
only file whose hash and timestamp are listed in the timestamp file.

If you think of the current system like this:

timestamp file -&gt; [hash/ts/size of bundleinfos, keys.txt, mirrors.txt]

then adding this extra level of indication would look like this:

timestamp file -&gt; [hash/ts/size of main metadata file]
main metadata file -&gt; [hash/ts/size of bundleinfos, keys.txt, mirrors.txt]

This leaves the more important issue of how the client will know if the
metadata they are getting from the repository is stale, even if the
timestamp file's signature is fresh (i.e. a possible attack by an
attacker who has the timestamp signing key). This comes back to the
importance of making sure all other files besides the timestamp file
have their timestamp and expiration time checked.

Adding the extra level of indirection makes this a bit easier and
increases the expiration time that is safe to use in bundleinfo files
and others. This is because a single file (the "main metadata file"
above) whose signing key is more secure than the timestamp key can have
a shorter expiration time (not as short as the timestamp file's, of
course) and be regularly resigned with more ease than the other files.

This would mean an extra role/key is added to the design. In that sense,
it's similar to "A2" described by Roger, but the form of indirection is
different. It would also make the timestamp file a little smaller.

&gt; C) We should stop letting every mirror serve the timestamp file, but
&gt; instead serve it from a smaller more trusted subset of the mirrors
&gt; (maybe all the ones with the "official" flag set). It's tiny anyway,
&gt; so the only issue this introduces is less robustness in the face of an
&gt; attacker who knocks down mirrors.

Serving the timestamp file from trusted mirrors is a good place to use
SSL with proper certificate checking. It can stop freeze attacks by a
MITM within the expiration time of the timestamp file (which is 6 hours
according to the spec).

-- 
Justin Samuel
https://www.cs.arizona.edu/~jsamuel/
</body></email><email><emailId>20081202201645</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2008-12-02 20:16:45-0400</timestampReceived><subject>Re: Proposal: Avoiding infinite length circuits</subject><body>

On Tue, Mar 13, 2007 at 11:15:47PM -0400, Roger Dingledine wrote:
&gt;   Right now, an attacker can add load to the Tor network by extending a
&gt;   circuit an arbitrary number of times. Every cell that goes down the
&gt;   circuit then adds N times that amount of load in overall bandwidth
&gt;   use. This vulnerability arises because servers don't know their position
&gt;   on the path, so they can't tell how many nodes there are before them
&gt;   on the path.
&gt; 
&gt;   We propose a new set of relay cells that are distinguishable by
&gt;   intermediate hops as permitting extend cells. This approach will allow
&gt;   us to put an upper bound on circuit length relative to the number of
&gt;   colluding adversary nodes; but there are some downsides too.

In talking to Peter Eckersley, he discovered a variation on this attack
that our defense doesn't cover.

Our defense is to let intermediate relays count how many extend operations
could have happened after them on the circuit, and that way we can limit
circuit lengths to (say) 8 hops.

But what if the attacker builds an 8-hop Tor circuit, and then exits to
a Tor entry guard and pretends that it's a Tor client? At that point it
can talk Tor-inside-Tor and build eight more hops. Then repeat.

Peter suggested one way to defend against it would be a latency test --
if you're too slow at answering an extend cell, then we assume we're
being tricked. That seems very brittle though.

Another approach would be to refuse exits to known Tor server IP:ports.
That's also not a complete solution, since a) there is a slight time
lag between when a new relay goes online and when the other relays know
about it, b) we want to one day make it so each relay doesn't need the
complete list of other relays, and c) there are other open proxies out
there (or heck, Tor bridge relays) that can be used as glue between
attacker circuits.

(The flip side of this approach would be to instead refuse incoming TLS
connections from IP addresses that have a Tor relay running, if the TLS
connection doesn't provide a cert saying it's really the relay connecting
to you. I like this approach less though, because it still has the
problems from above but it also impairs usability for relay operators.)

The long-circuit attack becomes a bigger deal when we consider that it's
not just a DoS attack, but it can be leveraged into an anonymity attack
because it makes clogging attacks low-cost again.

Hm.

--Roger

</body></email><email><emailId>20081112022551</emailId><senderName>"Steven J. Murdoch"</senderName><senderEmail>tor+steven.murdoch@cl.cam.ac.uk</senderEmail><timestampReceived>2008-11-12 02:25:51-0400</timestampReceived><subject>Empty TLS application records being injected in Tor streams</subject><body>

Recently I've been looking into how Tor sends packets out on the wire.
My goal is to understand the detail of how the data is packaged up, in
order to improve Tor's traffic analysis and censorship resistance, as
well as performance.

To do so, I've written some code to decode TLS sessions, and patched
my Tor client to save the keys needed to do. I've done two test-runs
so far -- both are from a Tor client with a cached directory, so it's
mainly data downloads. I cleared the guards between the two runs, and
as it happens test run 4 uses the old TLS handshake and run 5 uses the
new one.

The strange thing I noticed about both test runs is that almost every
second application record is empty (only contains a 5 byte TLS header,
20 byte TLS-level MAC, and 12 bytes of padding). It's not every
application record, as for example there are application records with
two cells, and even 6.

From my test case 4, there are 885 empty application records (each
taking up 37 bytes) and 884 non-empty ones. If we dropped the empty
ones we would save about 4% of network traffic. It's not huge, but not
trivial either.

We would save even more if we could coalesce more cells per packet and
application record (currently 72% of non-empty application records
have one cell and 81% of packets have one cell or less).

I am not sure why empty application records are being sent. It is a
good idea to send one at the start, to prevent an attack (see point 2 of
http://www.openssl.org/~bodo/tls-cbc.txt). Maybe we're seeing the
empty application records as a side-effect of this countermeasure.

The data can be seen here:
 http://www.cl.cam.ac.uk/~sjm217/volatile/tor-patches/log-keys/testrun4/
 http://www.cl.cam.ac.uk/~sjm217/volatile/tor-patches/log-keys/testrun5/

testrun4 and testrun5 are the two runs. The Tor log files are there
(debug.log and info.log), the tcpdump file (packet.dump), and the
decrypted TLS application record listing (decoded.txt).

Does anyone have ideas on how to remove the redundant TLS application
records, or otherwise improve the efficiency?

Steven.

-- 
w: http://www.cl.cam.ac.uk/users/sjm217/
</body></email><email><emailId>20081202185504</emailId><senderName>Robert Hogan</senderName><senderEmail>robert@roberthogan.net</senderEmail><timestampReceived>2008-12-02 18:55:04-0400</timestampReceived><subject>Re: Empty TLS application records being injected in Tor streams</subject><body>


On Thursday 20 November 2008 19:54:34 Robert Hogan wrote:
&gt; On Wednesday 12 November 2008 02:25:51 Steven J. Murdoch wrote:
&gt; &gt; Does anyone have ideas on how to remove the redundant TLS application
&gt; &gt; records, or otherwise improve the efficiency?
&gt; &gt;
&gt; &gt; Steven.
&gt;
&gt; http://marc.info/?l=openssl-users&amp;m=115654275717293&amp;w=2
&gt;
&gt; has the answer.
&gt;
&gt; "Sending empty SSL record (I mean record with only MAC) before SSL
&gt; record with real application data guards against some timing CBC attacks
&gt; and is enabled in OpenSSL by default.
&gt; To disable this set SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS with
&gt; SSL_CTX_set_options()."
&gt;
&gt; This corresponds exactly with what you're seeing - the empty record
&gt; always precedes the populated application record.

I looked at this a bit more out of curiosity. The attack the empty records 
defend against is a confirmation attack based on the fact that TLS in CBC 
mode uses the previous cipher block as the IV for encrypting the current 
plaintext. So if the previous cipher block is available to the attacker, 
by just sniffing packets, and they are able to guess the plaintext in both 
the previous and current blocks they can confirm their guess. 
Alternatively they can choose a plaintext, encrypt it with their guess for 
the key, ask for an encrypted version of it and confirm whether they have 
guessed the key correctly if the cipher text matches. (A random IV 
protects against this last one.)

" The attack itself is very simple. Remember that in CBC mode, each 
 plaintext block is XOR'ed with the last ciphertext block and then 
 encrypted to produce the next ciphertext block. Suppose the attacker 
 suspects that plaintext block P_i might be x, and wants to test whether 
 that's the case, he would choose the next plaintext block P_j to be x 
 XOR C_(i-1) XOR C_(j-1). If his guess is correct, then C_j = Encrypt(P_j 
 XOR C_(j-1)) = Encrypt(P_i XOR C_(i-1)) = C_i, and so he can confirm his 
 guess by looking at whether C_j = C_i."

The empty records prevent this attack because each full application record 
(containing encrypted plaintext the attacker might be interested in) is 
interleaved with an empty record (with an unpredictable MAC in it). Since 
the attacker needs to be able to guess two adjacent plaintexts in order to 
perform the attack (P_i and P_j), the empty record with the unpredictable 
MAC will always make this impossible.

So from Tor's point of view the question is whether the CBC confirmation 
attack is practical given the data Tor exchanges in TLS application 
records. Does Tor transmit two guessable plaintexts in a row? VERSIONS and 
NETINFO cells seem to fall into this category. Other cells seem much 
harder to guess.



["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20081205163324</emailId><senderName>Ben Laurie</senderName><senderEmail>ben@links.org</senderEmail><timestampReceived>2008-12-05 16:33:24-0400</timestampReceived><subject>Re: Empty TLS application records being injected in Tor streams</subject><body>

Robert Hogan wrote:
&gt; On Thursday 20 November 2008 19:54:34 Robert Hogan wrote:
&gt;&gt; On Wednesday 12 November 2008 02:25:51 Steven J. Murdoch wrote:
&gt;&gt;&gt; Does anyone have ideas on how to remove the redundant TLS application
&gt;&gt;&gt; records, or otherwise improve the efficiency?
&gt;&gt;&gt;
&gt;&gt;&gt; Steven.
&gt;&gt; http://marc.info/?l=openssl-users&amp;m=115654275717293&amp;w=2
&gt;&gt;
&gt;&gt; has the answer.
&gt;&gt;
&gt;&gt; "Sending empty SSL record (I mean record with only MAC) before SSL
&gt;&gt; record with real application data guards against some timing CBC attacks
&gt;&gt; and is enabled in OpenSSL by default.
&gt;&gt; To disable this set SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS with
&gt;&gt; SSL_CTX_set_options()."
&gt;&gt;
&gt;&gt; This corresponds exactly with what you're seeing - the empty record
&gt;&gt; always precedes the populated application record.
&gt; 
&gt; I looked at this a bit more out of curiosity. The attack the empty records 
&gt; defend against is a confirmation attack based on the fact that TLS in CBC 
&gt; mode uses the previous cipher block as the IV for encrypting the current 
&gt; plaintext. So if the previous cipher block is available to the attacker, 
&gt; by just sniffing packets, and they are able to guess the plaintext in both 
&gt; the previous and current blocks they can confirm their guess. 
&gt; Alternatively they can choose a plaintext, encrypt it with their guess for 
&gt; the key, ask for an encrypted version of it and confirm whether they have 
&gt; guessed the key correctly if the cipher text matches. (A random IV 
&gt; protects against this last one.)
&gt; 
&gt; " The attack itself is very simple. Remember that in CBC mode, each 
&gt;  plaintext block is XOR'ed with the last ciphertext block and then 
&gt;  encrypted to produce the next ciphertext block. Suppose the attacker 
&gt;  suspects that plaintext block P_i might be x, and wants to test whether 
&gt;  that's the case, he would choose the next plaintext block P_j to be x 
&gt;  XOR C_(i-1) XOR C_(j-1). If his guess is correct, then C_j = Encrypt(P_j 
&gt;  XOR C_(j-1)) = Encrypt(P_i XOR C_(i-1)) = C_i, and so he can confirm his 
&gt;  guess by looking at whether C_j = C_i."
&gt; 
&gt; The empty records prevent this attack because each full application record 
&gt; (containing encrypted plaintext the attacker might be interested in) is 
&gt; interleaved with an empty record (with an unpredictable MAC in it). Since 
&gt; the attacker needs to be able to guess two adjacent plaintexts in order to 
&gt; perform the attack (P_i and P_j), the empty record with the unpredictable 
&gt; MAC will always make this impossible.
&gt; 
&gt; So from Tor's point of view the question is whether the CBC confirmation 
&gt; attack is practical given the data Tor exchanges in TLS application 
&gt; records. Does Tor transmit two guessable plaintexts in a row? VERSIONS and 
&gt; NETINFO cells seem to fall into this category. Other cells seem much 
&gt; harder to guess.

Steven asked me to do an analysis of this a while back, which I did,
then forgot to post. Here it is...

-- 
http://www.apache-ssl.org/ben.html           http://www.links.org/

"There is no limit to what a man can do or how far he can go if he
doesn't mind who gets the credit." - Robert Woodruff

["on-tls-empty-record-insertion.txt" (text/plain)]

On TLS Empty Record Insertion
-----------------------------

I was asked by the Tor project whether it was safe to disable the
insertion of empty records, at least in the case of Tor.

I claim that it is safe for a variety of applications, in fact, and,
in practice, is also so for Tor.

Background
----------

OpenSSL prepends an empty record to each outgoing TLS record, in order
to avoid an adaptive plaintext attack. See
http://www.openssl.org/~bodo/tls-cbc.txt. Since that is a rather
convoluted document, I reproduce the attack, which is due to Rogaway,
slightly rephrased for clarity, below:

"Phil Rogaway observed that CBC mode is not secure against
chosen-plaintext attack if the IV is known or can be predicted by the
attacker before he choses his plaintext [1]. Similarly, CBC mode is
not secure if the attacker can observe the last ciphertext block
before choosing the next block of plaintext, because the last block of
ciphertext essentially serves as the IV for the rest of the message.
 
The attack itself is very simple. Remember that in CBC mode, each
plaintext block is XOR'ed with the last ciphertext block and then
encrypted to produce the next ciphertext block. Suppose the attacker
suspects that plaintext block P_i might be x, and wants to test
whether that's the case, he would choose some later plaintext block P_j
to be x XOR C_(i-1) XOR C_(j-1). If his guess is correct, then C_j =
Encrypt(P_j XOR C_(j-1)) = Encrypt(P_i XOR C_(i-1)) = C_i, and so he
can confirm his guess by looking at whether C_j = C_i."

Analysis
--------

For this attack to work, the attacker must be able to control a
plaintext block for which he knows the preceding ciphertext block,
C_(j-1). SSL and TLS open up this problem because the IV for each
packet is the previous packet's final ciphertext block[1].

Thus, if the attacker can choose plaintext for a TLS packet that
immediately follows a TLS packet he has observed, he can take a guess
at the plaintext of any packet he has seen in that ciphertext stream
and test whether the guess is correct.

Not many applications exist that allow the attacker to do this. In
particular, if an attacker has an ability to inject plaintext into a
TLS connection that contains data unknown to him, then the connection
must contain data not supplied by him.

Therefore any protocol running over TLS that contains data entirely
controlled by a single party is immune. Note, though, that this does
not include protocols like POP3 or IMAP, where the payloads are the
result of many different people sending emails. Nor does it include
Tor. It does, however, include static web pages.

The next important requirement is that the very first block of the
plaintext for some TLS packet must be controlled by the attacker,
which means that the protocol wrapped in TLS must contain no preamble
at the start of each TLS packet. So, any protocol that has a preamble
for any attacker-controlled data it sends is also immune. This does
include POP3 and IMAP. Web pages, even with dynamic content, might
appear to be almost certain to be immune, too, because the preamble is
the HTTP header block, or various bits of HTML, but care should be
taken because of protocols like AJAX that can use long-lived HTTP
connections.

Beware, though - if the preamble is short, there may be a statistical
attack that relies on the preamble happening to come out right. Also
beware that buffering might cause natural breaks in the protocol to
not correspond to TLS packet boundaries. The risk from this seems low,
since the exact boundaries of the buffers would seem hard to control
by the attacker, and the buffer would have to be empty at exactly the
right moment.

Tor may be vulnerable to such a statistical attack (this attack is due
to Steven Murdoch). If padding blocks are enabled, then an attacker
can determine if a block is a padding block with (2^128-2^16)/2^128
certainty. The attack works because padding blocks are all zeroes. So,
if the attacker thinks block C_i travelling between nodes A and B may
be a padding block, he can test for this as follows.

The attacker first creates a circuit to A, then extends it to B. He
then waits for a TLS packet with an IV s.t. IV xor C_(i-1) has 0x03 as
the third byte. This is then used as the plaintext for a block the
attacker sends to A over the circuit. Since this block will be a valid
relay cell, when node A receives the block it will modify it by
mapping the first two bytes (the circuit ID) of the incoming packet to
a different value via a lookup table unknown to the attacker. If the
lookup happens to leave these two bytes unaltered, then A's encryption
of the packet will become the "test" packet described above and the
attacker will see C_j = C_i and can conclude that the target packet
was, indeed, a padding packet (with high probability). This means that
the attacker has a 1 in 2^16 chance of detecting the padding packet at
each attempt. Because only one byte (the third byte) of the plaintext
is fixed, the attacker can attempt this attack on 1 in 2^8 TLS
packets. Beacuse the attacker cannot be certain of the value of the
first two plaintext bytes, a plaintext that happens to be all zero
except the first two bytes could trigger a false positive, with
probablity 2^-112, so therefore the attacker knows the block is a
padding block with probability (2^128-2^16)/2^128.

Note that because A modifies the circuit ID, the attacker can choose
any value he likes in the packet he sends to A. This means that after
a successful identification of a padding packet the attacker now knows
one entry in the lookup table. If the desired value of the circuit ID
(i.e. the first two bytes of IV xor C_(i-1)) happens to match in a
future test, then the attacker can use his known value for his ciruit
ID and will then be certain of the value in the plaintext. After each
successful attack with a different circuit ID, the attacker may learn
another entry in this table, so after 2^16 successful attacks the
difficulty of an attack falls from 1 in 2^16 to something closer to 1
in 2.

Because Tor does not currently actually send padding packets, this
attack is not currently applicable. Furthermore, if Tor modified
padding to be random instead of all zeroes, this would counter the attack.

Finally, the attacker must be able to react in a timely way. Having
observed a TLS packet, they must be able to react quickly enough to
construct their new packet and have it be the payload for the next TLS
packet. This means that any multiplexed protocol that is reasonably
heavily loaded is immune. This, in practice, includes Tor.

Other Countermeasures
---------------------

A Nagle-like algorithm would also make attacks harder in general.

Conclusion
----------

Not only is Tor likely to be immune to the attack, in practice,
without the need for record insertion, a variety of other protocols
are, too. The most widely used protocol, HTTPS, in particular, is
immune in most cases.

If Tor enables padding, then an attacker could detect padding as
described above, but with such low probability it is unclear whether
this attack would actually be useful. In any case, randomizing padding
is a simple countermeasure.

Care should be taken to ensure that a protocol and any particular
implementation of that protocol are actually immune as described above
before disabling empty packet insertion.

[1] The defence of including an empty record before each "real" record
works because the attacker is rendered unable to predict the IV for
the record he controls.


</body></email><email><emailId>20081206132556</emailId><senderName>"Steven J. Murdoch"</senderName><senderEmail>tor+steven.murdoch@cl.cam.ac.uk</senderEmail><timestampReceived>2008-12-06 13:25:56-0400</timestampReceived><subject>Re: Empty TLS application records being injected in Tor streams</subject><body>

On Thu, Nov 20, 2008 at 07:54:34PM +0000, Robert Hogan wrote:
&gt; This corresponds exactly with what you're seeing - the empty record always 
&gt; precedes the populated application record.

Yes, you are quite correct. I spoke to Ben about this and he has
followed up with his analysis of the situation. The empty fragment
does need to be before every application record, in the general case,
but some protocols are immune.

The best attack I could come up with on Tor (if the protection was
disabled) was fairly unconvincing -- it only applied to an unsupported
padding configuration (see Ben's analysis document). However, I've not
yet managed to convince myself that there is no better attack.

Steven.

-- 
w: http://www.cl.cam.ac.uk/users/sjm217/
</body></email><email><emailId>20081213080327</emailId><senderName>Sebastian Hahn</senderName><senderEmail>mail@sebastianhahn.net</senderEmail><timestampReceived>2008-12-13 08:03:27-0400</timestampReceived><subject>TBB build</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Hey Jake,

I've followed the process to build a new TBB, and have found a few  
ways to tweak the INSTALL file. Please find a first patch at \
https://sebastianhahn.net/tor/TBB_INSTALL_PATCH_1.diff   \
https://sebastianhahn.net/tor/TBB_INSTALL_PATCH_1.diff.asc

Also, I ran into a rather larger problem. When we actually want to  
build the bundle, the INSTALL file tells you to svn co the torbrowser  
project from svn (including all branches and tags). This means the  
following calls to make don't work.

I tried checking out just the build-scripts directory from svn and  
then running make, but now the vidalia build could not be found  
(probably because the INSTALL file suggests moving the vidalia  
directory from vidalia-0.1.10 to vidalia, but the build script looks  
for something else).

This was when I suspected that I maybe shouldn't have just checked out  
the build-scripts dir, or trunk conflicts with the INSTALL file, or  
something else. Can you help clear this up? I need sleep now :)

Thanks

Sebastian
-----BEGIN PGP SIGNATURE-----

iEYEARECAAYFAklDbFEACgkQCADWu989zuan6ACeMFr0v4sg3e9Fi86/x/uLIbI/
6pMAnjHr/4Qf8S6hfE+jnkwa3L+1THpG
=JKWP
-----END PGP SIGNATURE-----


</body></email><email><emailId>20081208011442</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2008-12-08 01:14:42-0400</timestampReceived><subject>Thandy attacks / suggestions</subject><body>

Hi folks,

I met with Justin Cappos yesterday about our auto-updater draft design.
Justin did his PhD thesis on package management security, and recently
presented a paper at CCS on vulnerabilities and flaws in the package
management infrastructure for Red Hat, Debian, etc.

Overall he was very positive about our design. He thinks it is very
well adapted to our situation, and he wants to help us make it into a
"best of breed" for other groups in a similar context.

He had a number of suggested improvements. I've tried to capture them
here:

1) Apparently python's urllib doesn't check SSL certs or cert chains.
So while we may think that handing it https://updates.torproject.org/
will mean it'll complain if the cert is wrong, apparently we'd be
mistaken. His suggested fix was to ship our SSL cert with the updater;
that's no fun if we change our cert or if we add a mirror with a cert,
though. He didn't have a second suggested fix. At least we know now.

2) Every time we list a hash (e.g. in the timestamp file), we should
also list a file length. Now we can handle "infinite file" attacks,
where a jerk repository just keeps giving us bytes, and we fill up our
disk. (As a bonus, it might also improve our odds a little if somebody
comes up with a fragile way to generate hash collisions, if it's a lot
harder to generate a collision of the same length.)

3) We still have a "trickle attack" to worry about -- the repository gives
us one byte of the file per minute. We should notice that the file isn't
coming in fast enough, and give up so we can retry somewhere/sometime
else. This sounds like a fine "future todo" item.

4) Our strategy for migrating to a new master key (or away from a
compromised one) is that we'll sign with all master keys for a while,
until everybody has migrated to the new set of master keys. This approach
can lead to a (perhaps theoretical) situation where the adversary strips
off some of the signatures: now clients who show up believing in a
certain set of master keys will accept the keylist, and clients who show
up believing a different set won't accept it. Perhaps some partitioning
can result? We don't have an exact attack. This vulnerability happens
because our signatures are independent of each other. We could instead
imagine a signature design where each signature is tied to the others,
so you can't strip some of them and still end up with a valid file. Not
worth worrying about yet imo unless a) somebody comes up with a real
attack or b) somebody comes up with a good clean alternative approach. :)

5) He wanted to make sure that we verify that the timestamp for each file
listed in the timestamps file matches the timestamp listed in that file.
That is, does timestamps-&gt;mirror_timestamp match mirrorfile-&gt;timestamp?

6) We have this paragraph in the spec when looking at the key list:
   The "ts" line describes when the keys file was updated.  Clients
   MUST NOT replace a file with an older one, and SHOULD NOT accept a
   file too far in the future.
This applies to the other files (timestamp file, mirror list, bundle
files) too, right?

7) We had a long discussion about the "what if the attacker gets a copy
of the timestamp key" worry. This issue seems to be the big remaining
question in the design: an attacker who can generate his own timestamp
file and either modify the repository or intercept client requests can
freeze clients in time, so they never know about updates and never realize
they're frozen. Since the timestamp file is only signed by the timestamp
key, he can also mix-and-match which hashes he puts in the timestamp file:
a keylist from time A, a mirror list from time B, a bundle from time
C. Some of these attacks are mitigated by having clients never replace
their current files with older files. But a newly bootstrapping client
can still be tricked into installing a package that's 18 months obsolete.

Some partial solutions:

A) Rotate the timestamp key every month. This limits the rollback window
to a month, if we put an expiration time in the timestamp key. This means
the master keys need to make and sign a new key list every month.

A2) Add another layer of indirection, so there's a timestampsigning key
that signs the timestamp key. That timestampsigning key is listed in
the key file, and it's kept offline. Whoever controls it still generates
a new timestamp every month, but now all the master keys don't need to
be bothered.

B) Put expiration times in the mirror file and bundles too.  Otherwise an
attacker who gets this month's timestamp key can still tell you to use
a mirror file and/or bundle from last year, so long as the signing keys
for those are still in the key list. We could make the expiration times
for those longer, if we want to accept longer attack windows. We should
probably put an expiration time in the key file too, especially if we
go with "A2" above where an attacker can take an old key file with a
compromised timestampsigning key, generate a fresh timestamp key, and
look legit.

Alas, I'm wary of anything that causes clients to decline to update if
we fail to get all the right signatures happening every month. Each of
the above steps adds a lot of recurring hassle.

C) We should stop letting every mirror serve the timestamp file, but
instead serve it from a smaller more trusted subset of the mirrors
(maybe all the ones with the "official" flag set). It's tiny anyway,
so the only issue this introduces is less robustness in the face of an
attacker who knocks down mirrors. I'm not sure how big a change this is
from the spec, which says:
  Every mirror is a copy of some or all of the directory hierarchy
  containing at least the /meta, /bundles/, and /pkginfo directories.

D) We can ship the initial installer with static copies of the meta
files (or just timestamps, but using the files seems simpler), so if
you have a recent installer, you can't be bootstrapped into something
older than those.

Other options?

Overall, I'd say we should aim to resolve #1, #2, #5, #6, and #7C (and
maybe #7D), and keep the rest as open research and future todo items.

Lastly, quoting Justin: "Be aware that when a client downloads files and the
hashes do not match what is in the key file, this is not necessarily
an attack. The files could have been updated during the transfer and
the client might have a mix of old / new files. Assuming you do mirror
updates "atomically" using move and you don't do more than one update
in the amount of time a client is likely to take to do the transfer,
the problem can be fixed either by re-retrieving the key file when you
have a hash mismatch or downloading files by hash instead of name. The
latter does have staleness problems though."

--Roger

</body></email><email><emailId>20081208192549</emailId><senderName>coderman</senderName><senderEmail>coderman@gmail.com</senderEmail><timestampReceived>2008-12-08 19:25:49-0400</timestampReceived><subject>Re: Thandy attacks / suggestions</subject><body>

On Sun, Dec 7, 2008 at 5:14 PM, Roger Dingledine &lt;arma@mit.edu&gt; wrote:
&gt; ...
&gt; 1) Apparently python's urllib doesn't check SSL certs or cert chains.
&gt; ... His suggested fix was to ship our SSL cert with the updater;

how critical is https given the signature checking on the files
downloaded?  it looks like M2crypto or $something would be needed to
do SSL/https correctly.  but M2crytpo is somewhat dated and big...
(how does shipping the cert help, if urllib still doesn't validate correctly?)


&gt; C) We should stop letting every mirror serve the timestamp file, but
&gt; instead serve it from a smaller more trusted subset of the mirrors
&gt; ... I'm not sure how big a change this is
&gt; from the spec, which says:
&gt;  Every mirror is a copy of some or all of the directory hierarchy
&gt;  containing at least the /meta, /bundles/, and /pkginfo directories.

what if clients only download that particular file from the (more)
trusted set?  or should the confusion of a timestamp on a mirror where
it will never be requested be avoided?

best regards,
</body></email><email><emailId>20081208194809</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2008-12-08 19:48:09-0400</timestampReceived><subject>Re: Thandy attacks / suggestions</subject><body>

On Sun, Dec 07, 2008 at 08:14:42PM -0500, Roger Dingledine wrote:
&gt; A2) Add another layer of indirection, so there's a timestampsigning key
&gt; that signs the timestamp key. That timestampsigning key is listed in
&gt; the key file, and it's kept offline. Whoever controls it still generates
&gt; a new timestamp every month, but now all the master keys don't need to
&gt; be bothered.

It occurs to me that an easier variation of this is to keep the
timestamp key on a very secure computer that's separate from the main
repository. Then it generates a new timestamp file periodically and
scp's it over to the main repository.

That way the timestamp key doesn't have to be stored on the same computer
that runs a big complex webserver.

In this day and age of "run a different VM for each task", that's not a
crazy notion.

--Roger

</body></email><email><emailId>20081208195733</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2008-12-08 19:57:33-0400</timestampReceived><subject>Re: Thandy attacks / suggestions</subject><body>

On Mon, Dec 08, 2008 at 11:25:49AM -0800, coderman wrote:
&gt; On Sun, Dec 7, 2008 at 5:14 PM, Roger Dingledine &lt;arma@mit.edu&gt; wrote:
&gt; &gt; ...
&gt; &gt; 1) Apparently python's urllib doesn't check SSL certs or cert chains.
&gt; &gt; ... His suggested fix was to ship our SSL cert with the updater;
&gt; 
&gt; how critical is https given the signature checking on the files
&gt; downloaded?

Checking the cert only matters if a) the client has the wrong time,
and/or b) the attacker gets a copy of the timestamp key. In those
cases being able to mitm the client requests will let the attacker 1)
keep the client from realizing that an upgrade is available, and 2) for
newly bootstrapping clients, choose which versions the client should like.

So it is not critical, but 'defense in depth' is the mantra here.

&gt; &gt; C) We should stop letting every mirror serve the timestamp file, but
&gt; &gt; instead serve it from a smaller more trusted subset of the mirrors
&gt; &gt; ... I'm not sure how big a change this is
&gt; &gt; from the spec, which says:
&gt; &gt;  Every mirror is a copy of some or all of the directory hierarchy
&gt; &gt;  containing at least the /meta, /bundles/, and /pkginfo directories.
&gt; 
&gt; what if clients only download that particular file from the (more)
&gt; trusted set?  or should the confusion of a timestamp on a mirror where
&gt; it will never be requested be avoided?

Sounds fine to me. The mirrors will want the /meta files anyway, to
check the consistency/integrity of the files they're serving.

--Roger

</body></email><email><emailId>20081204173936</emailId><senderName>Paul Syverson</senderName><senderEmail>syverson@itd.nrl.navy.mil</senderEmail><timestampReceived>2008-12-04 17:39:36-0400</timestampReceived><subject>Re: Proposal: Avoiding infinite length circuits</subject><body>

On Tue, Dec 02, 2008 at 03:16:45PM -0500, Roger Dingledine wrote:
&gt; On Tue, Mar 13, 2007 at 11:15:47PM -0400, Roger Dingledine wrote:
&gt; &gt;   Right now, an attacker can add load to the Tor network by extending a
&gt; &gt;   circuit an arbitrary number of times. Every cell that goes down the
&gt; &gt;   circuit then adds N times that amount of load in overall bandwidth
&gt; &gt;   use. This vulnerability arises because servers don't know their position
&gt; &gt;   on the path, so they can't tell how many nodes there are before them
&gt; &gt;   on the path.
&gt; &gt; 
&gt; &gt;   We propose a new set of relay cells that are distinguishable by
&gt; &gt;   intermediate hops as permitting extend cells. This approach will allow
&gt; &gt;   us to put an upper bound on circuit length relative to the number of
&gt; &gt;   colluding adversary nodes; but there are some downsides too.
&gt; 
&gt; In talking to Peter Eckersley, he discovered a variation on this attack
&gt; that our defense doesn't cover.
&gt; 
&gt; Our defense is to let intermediate relays count how many extend operations
&gt; could have happened after them on the circuit, and that way we can limit
&gt; circuit lengths to (say) 8 hops.
&gt; 
&gt; But what if the attacker builds an 8-hop Tor circuit, and then exits to
&gt; a Tor entry guard and pretends that it's a Tor client? At that point it
&gt; can talk Tor-inside-Tor and build eight more hops. Then repeat.
&gt; 
Right. I didn't think the proposal was ever meant to cover that.
What it does is prevent simple indefinite iterative extensions.
More clever ways of building long circuits will always be available
without more complicated protections (and maybe even then).


&gt; Peter suggested one way to defend against it would be a latency test --
&gt; if you're too slow at answering an extend cell, then we assume we're
&gt; being tricked. That seems very brittle though.
&gt; 
&gt; Another approach would be to refuse exits to known Tor server IP:ports.
&gt; That's also not a complete solution, since a) there is a slight time
&gt; lag between when a new relay goes online and when the other relays know
&gt; about it, b) we want to one day make it so each relay doesn't need the
&gt; complete list of other relays, and c) there are other open proxies out
&gt; there (or heck, Tor bridge relays) that can be used as glue between
&gt; attacker circuits.
&gt; 
It may be brittle, but if you are really worried about DoS from this
attack then I think you are stuck with Peter's suggestion, or in any
case something other than what you propose. Given that things (1) not
costing the attacker resources and (2) able to open circuits through
the Tor network, are available---as in your (c)---you will not be able
to prevent indefinite extensions by using anything involving checking
whether a new circuit request is going between known Tor nodes, on
either the exit side (as above) or the entrance side (as below).


&gt; (The flip side of this approach would be to instead refuse incoming TLS
&gt; connections from IP addresses that have a Tor relay running, if the TLS
&gt; connection doesn't provide a cert saying it's really the relay connecting
&gt; to you. I like this approach less though, because it still has the
&gt; problems from above but it also impairs usability for relay operators.)
&gt; 
&gt; The long-circuit attack becomes a bigger deal when we consider that it's
&gt; not just a DoS attack, but it can be leveraged into an anonymity attack
&gt; because it makes clogging attacks low-cost again.
&gt; 
&gt; Hm.

I'll talk to you about clogging attacks on anonymity another time, (I
think they're probably easily addressed, but haven't had too much time
to consider). But, ignoring them, it is indeed a hmmm to ponder
whether it is worth countering just extension attacks for DoS.  What
is to keep someone who wants to DoS the network from setting up just
two zombies and having them open as many connections as they can
between them (even default 3 hop connections, but preferably as long
as can be allowed) and dump as much stuff as they can over
these? (This could be viewed as a variant of the extension attack if
each circuit is dumping into the next one on a given zombie; although
that may be more conceptually nice than the most effective way to do
the DoS).  Now use a botnet of zombie pairs if you want to multiply
this. Admittedly this requires him to obtain some zombies rather than
finding bridges or nonTor open proxies and building circuits himself.
That is harder/riskier. And it would be worse if the zombies could do
indefinite extensions too. But the current idea is easy-to-do,
low-overhead, not (obviously) engendering of other attacks,
etc. Trying to counter more complicated extensions may not be worth it
(unless you are also accomplishing something else thereby besides
reducing the threat of extension-based DoS) given that it seems too
easy to do it in other ways. Thus, e.g., keeping the latency test in
your quiver might make some sense because might facilitate other
resource or QoS management in the network.

-Paul
</body></email><email><emailId>20081223004534</emailId><senderName>coderman</senderName><senderEmail>coderman@gmail.com</senderEmail><timestampReceived>2008-12-23 00:45:34-0400</timestampReceived><subject>bug in address family checking?</subject><body>

xiando was discussing strange messages in the log of the form:
[warn] tor_addr_is_null(): Bug: Called with unknown address family XXX

where XXX is some unexpected value.

in tracing this down, it always appears after
connection_exit_begin_conn() when the DNS resolve returns immediately
(cached name) and connection_exit_connect() is invoked.

based on the order of calls, it appears that connection_init() is
setting conn-&gt;socket_family but is not setting conn-&gt;addr.family
(which is what tor_addr_is_null() is looking for).

attached is a very simply patch to set both in connection_init().
however, i do not know enough about Tor internals or the nature of the
IPv6 changes to know if this is the right fix, or if some other cause
is at fault.

best regards,

["tor-setaddr-family.patch" (text/x-patch)]

diff -Naur orig-tor/src/or/connection.c mod-tor/src/or/connection.c
--- orig-tor/src/or/connection.c	2008-12-18 17:19:04.459856000 +0000
+++ mod-tor/src/or/connection.c	2008-12-23 00:32:51.577993904 +0000
@@ -260,6 +260,7 @@
 
   conn-&gt;type = type;
   conn-&gt;socket_family = socket_family;
+  conn-&gt;addr.family = socket_family;
   if (!connection_is_listener(conn)) { /* listeners never use their buf */
     conn-&gt;inbuf = buf_new();
     conn-&gt;outbuf = buf_new();


</body></email><email><emailId>20081223141631</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-12-23 14:16:31-0400</timestampReceived><subject>Re: bug in address family checking?</subject><body>

On Mon, Dec 22, 2008 at 04:45:34PM -0800, coderman wrote:
&gt; xiando was discussing strange messages in the log of the form:
&gt; [warn] tor_addr_is_null(): Bug: Called with unknown address family XXX
&gt; 
&gt; where XXX is some unexpected value.
&gt; 
&gt; in tracing this down, it always appears after
&gt; connection_exit_begin_conn() when the DNS resolve returns immediately
&gt; (cached name) and connection_exit_connect() is invoked.
&gt; 
&gt; based on the order of calls, it appears that connection_init() is
&gt; setting conn-&gt;socket_family but is not setting conn-&gt;addr.family
&gt; (which is what tor_addr_is_null() is looking for).
&gt; 
&gt; attached is a very simply patch to set both in connection_init().
&gt; however, i do not know enough about Tor internals or the nature of the
&gt; IPv6 changes to know if this is the right fix, or if some other cause
&gt; is at fault.

This shouldn't be necessary.  First off, you shouldn't need to
manipulate an tor_addr_t's internals directly.  Second, everything
that calls connection_init() passes it a chunk of RAM that it got from
tor_malloc_zero, which should also zero out connection-&gt;addr, which
should result in it having addr_family 0, not addr_family 20 (which is
what the user was seeing on IRC).  Right?

If this is happening on a edge_connection after it finds a cached dns
answer, then the addr field has already been changed from its original
value. Check out the code in dns.c around line 688.

To debug this thing, the easiest solution  is probably to use gdb to
a stack trace for when the warning message is triggered, to sew where
exactly it's happening in the code.

-- 
Nick
</body></email><email><emailId>20081205201719</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-12-05 20:17:19-0400</timestampReceived><subject>Re: Proposal: Avoiding infinite length circuits</subject><body>

On Tue, Dec 02, 2008 at 03:16:45PM -0500, Roger Dingledine wrote:
 [...]
&gt; Our defense is to let intermediate relays count how many extend operations
&gt; could have happened after them on the circuit, and that way we can limit
&gt; circuit lengths to (say) 8 hops.
&gt; 
&gt; But what if the attacker builds an 8-hop Tor circuit, and then exits to
&gt; a Tor entry guard and pretends that it's a Tor client? At that point it
&gt; can talk Tor-inside-Tor and build eight more hops. Then repeat.
&gt; 
&gt; Peter suggested one way to defend against it would be a latency test --
&gt; if you're too slow at answering an extend cell, then we assume we're
&gt; being tricked. That seems very brittle though.

An easier-to-implement but still brittle approach would be to refuse
any VERSIONS cell that took too long to arrive after we sent our own
VERSIONS cell.  This would indicate that the TLS connection from the
client to server had a very large latency, perhaps indicating that it
was coming over a tunnel of some kind.

This approach was suggested by "wood" on the #tor IRC channel, along
with this sample patch:

--- command.c	 Wed Aug  6 00:30:42 2008
+++ command.110plus.c	  Fri Dec  5 19:07:22 2008
@@ -558,6 +558,12 @@
     apparent_skew = now - timestamp;
   }
 
+  if (labs(now - conn-&gt;handshake_state-&gt;sent_versions_at) &gt; 5) {
+    log_fn(LOG_PROTOCOL_WARN, LD_OR,
+           "Received a NETINFO cell on high-latency connection;
Closing.");
+    connection_mark_for_close(TO_CONN(conn));
+    return;
+  }
   my_addr_type = (uint8_t) cell-&gt;payload[4];
   my_addr_len = (uint8_t) cell-&gt;payload[5];
   my_addr_ptr = cell-&gt;payload + 6;


Personally, I am unconvinced that there is a setting for the max
latency value that makes this attack ineffective without also stopping
lots of legitimate users.  But let's see.
 
&gt; Another approach would be to refuse exits to known Tor server IP:ports.
&gt; That's also not a complete solution, since a) there is a slight time
&gt; lag between when a new relay goes online and when the other relays know
&gt; about it, b) we want to one day make it so each relay doesn't need the
&gt; complete list of other relays, and c) there are other open proxies out
&gt; there (or heck, Tor bridge relays) that can be used as glue between
&gt; attacker circuits.

It's a pretty good start, though, and would make an attack like this
a bit harder.

&gt; (The flip side of this approach would be to instead refuse incoming TLS
&gt; connections from IP addresses that have a Tor relay running, if the TLS
&gt; connection doesn't provide a cert saying it's really the relay connecting
&gt; to you. I like this approach less though, because it still has the
&gt; problems from above but it also impairs usability for relay operators.)

Agreed.

Another observation: The usual engineering solution here would be to
add a "hey, I'm a connection from a Tor server/hey, you are now
connecting to a Tor server" indicator to the protocol.  But our
anti-blocking designs make that basically impossible for us to do.  We
could take a probing-style approach, and have exit servers connect to
suspect ports, and see whether a Tor server answers, but that seems
questionable.  In any case, it would hurt the probing-resistance stuff
we've been kicking around.


Still another observation: There are two asymmetries that make the
attack work here.  First, bandwidth asymmetry: in an N-hop circuit,
the client uses ~512 bytes of bandwidth to send a cell whereas the
network uses ~512*2*N.  We can't do anything about that.  Second,
computational asymmetry: once the circuit is established, an
ill-behaved client can sent junk cells for the cost of the TLS crypto,
and the network will spend ~2*N TLS operations and ~N AES operations
per cell.  [This is because RELAY cells with bogus contents are
basically undetectable until they reach the end of the circuit.]

We could mitigate the second one if our next protocol version did
something to keep corrupted relay cells from spreading too far down
the circuit.  This might not be worthwhile, though: the bandwidth DoS
could be bad enough to make the CPU DoS irrelevant.

-- 
Nick
</body></email><email><emailId>20081221131442</emailId><senderName>"Kyle Williams"</senderName><senderEmail>kyle.kwilliams@gmail.com</senderEmail><timestampReceived>2008-12-21 13:14:42-0400</timestampReceived><subject>JanusPA - A hardware Privacy Adapter using Tor</subject><body>

Hello Everyone,
I've been working on a project for a couple of months now that I'm sure
would be of interest to some of you.  The goal was to apply the same
transparent model coderman and I  used with JanusVM and Tor VM into
hardware.  I wanted something small that you could connect, power on, and
use.  Literally plug-n-privacy.  After several weeks of searching the web
looking at different hardware configuration, specs, etc, etc, I decided to
go with Gumstix(.com).

The privacy adapter is a ARM 400MHz Xscale CPU with 64MB RAM (@100MHz), 16MB
of Flash memory for storage, and *TWO* 10/100 NICs.  It uses Linux for the
OS.
The first thought that many people get, including myself, have is that it is
not powerful enough to run Tor.  Well, after 2 months of breaking this in,
I'm very happy with the results.
I ran this as a Tor server for about 4 days, and got a good baseline for how
much data it can handle.  As a Tor server, it was pushing about 250KB/sec
(125KB in, 125 KB out).
As a Tor client, the best speed test I got was about 1.2MB/sec.  BTW, that
was after about 45 minutes of "SIGNAL NEWNYM" and speedtest before I found a
fast circuit.

Here's the URL for what I've got so far.
http://www.janusvm.com/goldy/JanusPA/index.html

It is lacking all forms of documentation, and the source code needs to be
cleaned up some.
It does have a general description, the index of the soon to come
documentation, openssl speed test benchmarks, pictures, and stats of when I
tested it as a Tor server.

After about two months of using it, I've never felt more secure and
satisfied when using Tor.  This is a hardware router that routes your
traffic through the Tor network, it's small, and is easy to use.  As for
security, all TCP and DNS are routed through Tor, and everything else is
dropped.  So all the nasty side-channel attacks that us hackers have been
working on to leak your real IP address are rendered useless.

But there is good news and bad news.
The bad news:
The manufacture (Gumstix.com) is "Phasing Out" this particular setup at the
end of DECEMBER 2008!!  That's in 10 days!  Any orders after Dec. 31, 2008
will have to be in bulk orders, which is 120 or more units.  Shitty.
 Because of the short amount of time left to get this hardware, I've jumped
the gun and chosen to notify the Tor community about this hardware before it
is gone or out of a practical price range for most of us.

The good news:
I've been in communication with a very nice gentleman at gumstix who
said "Gumstix
is also working on a netDUO expansion board for Overo, although a release
date has not been announced."  There is reasonable hope that there new
motherboad product line (the Overo) will at some point have a dual NIC
expansion board.

So this is somewhat a conflicting situation.  I've spent months working on
this awesome anonymity adpater, and it's about to be discontinued without
knowing an exact date as to when the new line with have the capabilities to
do what needs to be done.  ugh.  I'm very much looking forward to their new
product line when a dual NIC expansion board is available, but I don't know
when that'll be.  If anyone is interested in this, but cannot afford to buy
hardware at the moment, please contact Don Anderson (don@gumstix.com)and
encourage the idea of extending their phase out date or express and interest
in a dual NIC expansion board for their new Overo product line.

If anyone is interested in getting a hardware based Tor solution, you might
want to consider buying a gumstix soon.
You'll need the following.
Connex 400mx Motherboard:
http://www.gumstix.com/store/catalog/product_info.php?cPath=27&amp;products_id=136
netDUO-mmc/SD expansion board:
http://gumstix.com/store/catalog/product_info.php?cPath=31&amp;products_id=156
4.0v Power Adapter:
http://gumstix.com/store/catalog/product_info.php?cPath=28&amp;products_id=148
Screws and spacer kit:
http://gumstix.com/store/catalog/product_info.php?cPath=28&amp;products_id=161
This will run you $237.00 USD + shipping and handling.

I would also *HIGHLY* recommend the following because flashing the device
over the network is very, very risky and has resulted in me having to
re-flash it through the serial port many, many times.
Serial null-modem cable:
http://gumstix.com/store/catalog/product_info.php?cPath=28&amp;products_id=85
Serial port connector:
http://gumstix.com/store/catalog/product_info.php?cPath=31&amp;products_id=106
This will run you $32.00 USD.

If anyone is seriously thinking about a good hardware based solution for
Tor, I'd buy the gumstix now.  In fact, I just bought a couple more just in
case mine breaks. I'll have the source code up withing a week, two tops  The
FULL documentation will take about a bit longer to get done.

Well, that's about it.  Feedback is welcome.


Best Regards,

Kyle

PS.  Happy Holidays!

[Attachment #3 (text/html)]

Hello Everyone,&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;I've been working on a project for a couple of \
months now that I'm sure would be of interest to some of you.  The goal was \
to apply the same transparent model coderman and I  used with JanusVM and Tor VM \
into hardware.  I wanted something small that you could connect, power on, and \
use.  Literally plug-n-privacy.  After several weeks of searching the web \
looking at different hardware configuration, specs, etc, etc, I decided to \
go with Gumstix(.com).  &lt;/div&gt; &lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;The privacy adapter is a ARM \
400MHz Xscale CPU with 64MB RAM (@100MHz), 16MB of Flash memory for storage, and \
*TWO* 10/100 NICs.  It uses Linux for the OS.&lt;/div&gt;&lt;div&gt;The first thought \
that many people get, including myself, have is that it is not powerful enough to run \
Tor.  Well, after 2 months of breaking this in, I'm very happy with the \
results.&lt;/div&gt; &lt;div&gt;I ran this as a Tor server for about 4 days, and got a good \
baseline for how much data it can handle.  As a Tor server, it was pushing about \
250KB/sec (125KB in, 125 KB out).&lt;/div&gt;&lt;div&gt;As a Tor client, the best speed test I \
got was about 1.2MB/sec.  BTW, that was after about 45 minutes of "SIGNAL \
NEWNYM" and speedtest before I found a fast circuit.&lt;/div&gt; \
&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;Here's the URL for what I've got so \
far.&lt;/div&gt;&lt;div&gt;&lt;a href="http://www.janusvm.com/goldy/JanusPA/index.html"&gt;http://www.janusvm.com/goldy/JanusPA/index.html&lt;/a&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;It \
is lacking all forms of documentation, and the source code needs to be cleaned up \
some.&lt;/div&gt; &lt;div&gt;It does have a general description, the index of the soon to come \
documentation, openssl speed test benchmarks, pictures, and stats of when I tested it \
as a Tor server.&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;After about two months of using it, \
I've never felt more secure and satisfied when using Tor.  This is a \
hardware router that routes your traffic through the Tor network, it's small, and \
is easy to use.  As for security, all TCP and DNS are routed through Tor, and \
everything else is dropped.  So all the nasty side-channel attacks that us \
hackers have been working on to leak your real IP address \
are rendered useless. &lt;/div&gt; &lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;But there is good \
news and bad news.  &lt;/div&gt;&lt;div&gt;The bad news:&lt;/div&gt;&lt;div&gt;The manufacture \
(Gumstix.com) is "Phasing Out" this particular setup at the end of DECEMBER \
2008!!  That's in 10 days!  Any orders after Dec. 31, 2008 will have to \
be in bulk orders, which is 120 or more units.  Shitty.  Because of the \
short amount of time left to get this hardware, I've jumped the gun \
and chosen to notify the Tor community about this hardware before it is \
gone or out of a practical price range for most of us.&lt;/div&gt; &lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;The \
good news:&lt;/div&gt;&lt;div&gt;I've been in communication with a very nice gentleman at \
gumstix who said "&lt;span class="Apple-style-span" style="border-collapse: \
collapse; "&gt;Gumstix is also working on a netDUO expansion board for Overo, although a \
release date has not been announced."  There is reasonable hope that there \
new motherboad product line (the Overo) will at some point have a dual NIC expansion \
board.  &lt;/span&gt;&lt;/div&gt; &lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;So this is somewhat a conflicting \
situation.  I've spent months working on this awesome anonymity adpater, and \
it's about to be discontinued without knowing an exact date as to when the new \
line with have the capabilities to do what needs to be done.  ugh. \
 I'm very much looking forward to their new product line when a dual NIC \
expansion board is available, but I don't know when that'll be.  If \
anyone is interested in this, but cannot afford to buy hardware at the moment, please \
contact Don Anderson (&lt;a href="mailto:don@gumstix.com"&gt;don@gumstix.com&lt;/a&gt;)and \
encourage the idea of extending their phase out date or express and interest in a \
dual NIC expansion board for their new Overo product line.&lt;/div&gt; \
&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;If anyone is interested in getting a hardware based Tor solution, \
you might want to consider buying a gumstix soon.&lt;/div&gt;&lt;div&gt;You'll need the \
following.&lt;/div&gt;&lt;div&gt;Connex 400mx Motherboard:  &lt;a \
href="http://www.gumstix.com/store/catalog/product_info.php?cPath=27&amp;products_id=1 \
36"&gt;http://www.gumstix.com/store/catalog/product_info.php?cPath=27&amp;products_id=136&lt;/a&gt;&lt;/div&gt;
 &lt;div&gt;netDUO-mmc/SD expansion board:  &lt;a \
href="http://gumstix.com/store/catalog/product_info.php?cPath=31&amp;products_id=156"&gt; \
http://gumstix.com/store/catalog/product_info.php?cPath=31&amp;products_id=156&lt;/a&gt;&lt;/div&gt;&lt;div&gt;4.0v \
Power Adapter:  &lt;a \
href="http://gumstix.com/store/catalog/product_info.php?cPath=28&amp;products_id=148"&gt; \
http://gumstix.com/store/catalog/product_info.php?cPath=28&amp;products_id=148&lt;/a&gt;&lt;/div&gt;
 &lt;div&gt;Screws and spacer kit:  &lt;a \
href="http://gumstix.com/store/catalog/product_info.php?cPath=28&amp;products_id=161"&gt; \
http://gumstix.com/store/catalog/product_info.php?cPath=28&amp;products_id=161&lt;/a&gt;&lt;/div&gt;&lt;div&gt;This \
will run you $237.00 USD + shipping and handling.&lt;/div&gt; &lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;I would \
also *HIGHLY* recommend the following because flashing the device over the network is \
very, very risky and has resulted in me having to re-flash it through the serial port \
many, many times.&lt;/div&gt; &lt;div&gt;Serial null-modem cable:  &lt;a \
href="http://gumstix.com/store/catalog/product_info.php?cPath=28&amp;products_id=85"&gt;h \
ttp://gumstix.com/store/catalog/product_info.php?cPath=28&amp;products_id=85&lt;/a&gt;&lt;/div&gt;&lt;div&gt;Serial \
port connector:  &lt;a \
href="http://gumstix.com/store/catalog/product_info.php?cPath=31&amp;products_id=106"&gt; \
http://gumstix.com/store/catalog/product_info.php?cPath=31&amp;products_id=106&lt;/a&gt;&lt;/div&gt;
 &lt;div&gt;This will run you $32.00 USD.&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;If anyone is seriously \
thinking about a good hardware based solution for Tor, I'd buy the gumstix now. \
 In fact, I just bought a couple more just in case mine breaks. I'll have \
the source code up withing a week, two tops  The FULL documentation will take \
about a bit longer to get done.   &lt;/div&gt; &lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Well, \
that's about it.  Feedback is \
welcome.&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Best \
Regards,&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Kyle&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;PS.  Happy \
Holidays!  &lt;/div&gt;



</body></email><email><emailId>20081227050905</emailId><senderName>coderman</senderName><senderEmail>coderman@gmail.com</senderEmail><timestampReceived>2008-12-27 05:09:05-0400</timestampReceived><subject>Re: [or-cvs] r17790: {tor} Refactor tor_addr_t manipulation functions so that as few as (tor/trunk/s</subject><body>

On Fri, Dec 26, 2008 at 1:26 PM,  &lt;nickm@seul.org&gt; wrote:
&gt;...
&gt;       } else if (ent-&gt;h_addrtype == AF_INET6) {
&gt; -        memcpy(&amp;addr-&gt;addr.in6_addr, ent-&gt;h_addr, sizeof(struct in6_addr));
&gt; +        tor_addr_from_in(addr, (struct in6_addr*) ent-&gt;h_addr);

hi nick, a slight typo.  this should be tor_addr_from_in6:

["tor-addrfix.patch" (text/x-patch)]

diff -Naur orig-tor/src/common/address.c mod-tor/src/common/address.c
--- orig-tor/src/common/address.c	2008-12-26 21:26:05.484122000 +0000
+++ mod-tor/src/common/address.c	2008-12-27 05:03:31.497964848 +0000
@@ -225,7 +225,7 @@
       if (ent-&gt;h_addrtype == AF_INET) {
         tor_addr_from_in(addr, (struct in_addr*) ent-&gt;h_addr);
       } else if (ent-&gt;h_addrtype == AF_INET6) {
-        tor_addr_from_in(addr, (struct in6_addr*) ent-&gt;h_addr);
+        tor_addr_from_in6(addr, (struct in6_addr*) ent-&gt;h_addr);
       } else {
         tor_assert(0); /* gethostbyname() returned a bizarre addrtype */
       }


</body></email><email><emailId>20081227091910</emailId><senderName>coderman</senderName><senderEmail>coderman@gmail.com</senderEmail><timestampReceived>2008-12-27 09:19:10-0400</timestampReceived><subject>Re: [or-cvs] r17790: {tor} Refactor tor_addr_t manipulation functions so that as few as (tor/trunk/s</subject><body>

2008/12/26 coderman &lt;coderman@gmail.com&gt;:
&gt; ...

next up is:
connection.c: In function `retry_listeners':
connection.c:1423: error: invalid application of `sizeof' to
incomplete type `sockaddr_un'

not sure if this should be wrapped if a #ifndef MS_WINDOWS or other.
AF_UNIX appears to be defined, just no sockaddr_un...
</body></email><email><emailId>20081223150016</emailId><senderName>dante</senderName><senderEmail>dante@virtualblueness.net</senderEmail><timestampReceived>2008-12-23 15:00:16-0400</timestampReceived><subject>Re: JanusPA - A hardware Privacy Adapter using Tor</subject><body>

Hi Kyle,

Very nice work.

You might be interested in something I did a little while ago.  I got a
tor server running on a wireless Linksys WRT54g router.  This allows me
to use tor at home with my laptops wirelessly.

Here's a quick howto since I never published on my site:

1) Get a MIPS I (little endian) environment up.  I used qemu and
installed debian-mipsel.  I started with the ramdisk image
mipsel-test-0.2.tar.gz from http://bellard.org/qemu/download.html and
bootstrapped into a fully functional debian system.

2) I compiled tor statically linked. (CFLAGS="-static" ./configure)

3) I got into my linksys using "Linux on WRTG54g" ...
http://www.batbox.org/wrt54g-linux.html

4) I used ftpget to upload tor, configure and start it up.

It works fine, but you run out of memory fast because you have to use
ramdisk to store tor's cache files.

Tony Basile
http://opensource.dyc.edu



Kyle Williams wrote:
&gt; If anyone is seriously thinking about a good hardware based solution for
&gt; Tor, I'd buy the gumstix now.  In fact, I just bought a couple more just in
&gt; case mine breaks. I'll have the source code up withing a week, two tops  The
&gt; FULL documentation will take about a bit longer to get done.
&gt;
&gt; Well, that's about it.  Feedback is welcome.
&gt;
&gt;
&gt; Best Regards,
&gt;
&gt; Kyle
&gt;
&gt; PS.  Happy Holidays!
&gt;
&gt;   

</body></email><email><emailId>20081223161826</emailId><senderName>"Jonathan Yu"</senderName><senderEmail>jonathan.i.yu@gmail.com</senderEmail><timestampReceived>2008-12-23 16:18:26-0400</timestampReceived><subject>Re: JanusPA - A hardware Privacy Adapter using Tor</subject><body>

Hi:

What about the Soekris boards?

The lowest end board, net4501, with a case is $173 USD.

https://www.soekris.com/shop/product_info.php?products_id=75

133 Mhz CPU, 64 Mbyte SDRAM, 3 Ethernet, 2 Serial, CF socket, 1
Mini-PCI socket, 3.3V PCI connector.

The low processor speed may hinder encryption, but other than that, it
looks like it would make a pretty good replacement for Gumstix.
Probably not as small, though.

It might be nice to note that these boards have been in production for
a pretty long time and continue to be so. Also some firmwares like
DD-WRT support this hardware.

Cheers,

Jon

On Sun, Dec 21, 2008 at 8:14 AM, Kyle Williams &lt;kyle.kwilliams@gmail.com&gt; wrote:
&gt; Hello Everyone,
&gt; I've been working on a project for a couple of months now that I'm sure
&gt; would be of interest to some of you.  The goal was to apply the same
&gt; transparent model coderman and I  used with JanusVM and Tor VM into
&gt; hardware.  I wanted something small that you could connect, power on, and
&gt; use.  Literally plug-n-privacy.  After several weeks of searching the web
&gt; looking at different hardware configuration, specs, etc, etc, I decided to
&gt; go with Gumstix(.com).
&gt; The privacy adapter is a ARM 400MHz Xscale CPU with 64MB RAM (@100MHz), 16MB
&gt; of Flash memory for storage, and *TWO* 10/100 NICs.  It uses Linux for the
&gt; OS.
&gt; The first thought that many people get, including myself, have is that it is
&gt; not powerful enough to run Tor.  Well, after 2 months of breaking this in,
&gt; I'm very happy with the results.
&gt; I ran this as a Tor server for about 4 days, and got a good baseline for how
&gt; much data it can handle.  As a Tor server, it was pushing about 250KB/sec
&gt; (125KB in, 125 KB out).
&gt; As a Tor client, the best speed test I got was about 1.2MB/sec.  BTW, that
&gt; was after about 45 minutes of "SIGNAL NEWNYM" and speedtest before I found a
&gt; fast circuit.
&gt; Here's the URL for what I've got so far.
&gt; http://www.janusvm.com/goldy/JanusPA/index.html
&gt; It is lacking all forms of documentation, and the source code needs to be
&gt; cleaned up some.
&gt; It does have a general description, the index of the soon to come
&gt; documentation, openssl speed test benchmarks, pictures, and stats of when I
&gt; tested it as a Tor server.
&gt; After about two months of using it, I've never felt more secure and
&gt; satisfied when using Tor.  This is a hardware router that routes your
&gt; traffic through the Tor network, it's small, and is easy to use.  As for
&gt; security, all TCP and DNS are routed through Tor, and everything else is
&gt; dropped.  So all the nasty side-channel attacks that us hackers have been
&gt; working on to leak your real IP address are rendered useless.
&gt; But there is good news and bad news.
&gt; The bad news:
&gt; The manufacture (Gumstix.com) is "Phasing Out" this particular setup at the
&gt; end of DECEMBER 2008!!  That's in 10 days!  Any orders after Dec. 31, 2008
&gt; will have to be in bulk orders, which is 120 or more units.  Shitty.
&gt;  Because of the short amount of time left to get this hardware, I've jumped
&gt; the gun and chosen to notify the Tor community about this hardware before it
&gt; is gone or out of a practical price range for most of us.
&gt; The good news:
&gt; I've been in communication with a very nice gentleman at gumstix who said
&gt; "Gumstix is also working on a netDUO expansion board for Overo, although a
&gt; release date has not been announced."  There is reasonable hope that there
&gt; new motherboad product line (the Overo) will at some point have a dual NIC
&gt; expansion board.
&gt; So this is somewhat a conflicting situation.  I've spent months working on
&gt; this awesome anonymity adpater, and it's about to be discontinued without
&gt; knowing an exact date as to when the new line with have the capabilities to
&gt; do what needs to be done.  ugh.  I'm very much looking forward to their new
&gt; product line when a dual NIC expansion board is available, but I don't know
&gt; when that'll be.  If anyone is interested in this, but cannot afford to buy
&gt; hardware at the moment, please contact Don Anderson (don@gumstix.com)and
&gt; encourage the idea of extending their phase out date or express and interest
&gt; in a dual NIC expansion board for their new Overo product line.
&gt; If anyone is interested in getting a hardware based Tor solution, you might
&gt; want to consider buying a gumstix soon.
&gt; You'll need the following.
&gt; Connex 400mx Motherboard:
&gt;  http://www.gumstix.com/store/catalog/product_info.php?cPath=27&amp;products_id=136
&gt; netDUO-mmc/SD expansion board:
&gt;  http://gumstix.com/store/catalog/product_info.php?cPath=31&amp;products_id=156
&gt; 4.0v Power Adapter:
&gt;  http://gumstix.com/store/catalog/product_info.php?cPath=28&amp;products_id=148
&gt; Screws and spacer kit:
&gt;  http://gumstix.com/store/catalog/product_info.php?cPath=28&amp;products_id=161
&gt; This will run you $237.00 USD + shipping and handling.
&gt; I would also *HIGHLY* recommend the following because flashing the device
&gt; over the network is very, very risky and has resulted in me having to
&gt; re-flash it through the serial port many, many times.
&gt; Serial null-modem cable:
&gt;  http://gumstix.com/store/catalog/product_info.php?cPath=28&amp;products_id=85
&gt; Serial port connector:
&gt;  http://gumstix.com/store/catalog/product_info.php?cPath=31&amp;products_id=106
&gt; This will run you $32.00 USD.
&gt; If anyone is seriously thinking about a good hardware based solution for
&gt; Tor, I'd buy the gumstix now.  In fact, I just bought a couple more just in
&gt; case mine breaks. I'll have the source code up withing a week, two tops  The
&gt; FULL documentation will take about a bit longer to get done.
&gt; Well, that's about it.  Feedback is welcome.
&gt;
&gt; Best Regards,
&gt; Kyle
&gt; PS.  Happy Holidays!
</body></email><email><emailId>20081223165814</emailId><senderName>"Kyle Williams"</senderName><senderEmail>kyle.kwilliams@gmail.com</senderEmail><timestampReceived>2008-12-23 16:58:14-0400</timestampReceived><subject>Re: JanusPA - A hardware Privacy Adapter using Tor</subject><body>

Hi Tony,
I'm curious as to how well it performed.  How much RAM and CPU did the
Linksys WRT54G have?
I was worried that the linksys/netgear/dlink brands would not be that fast.
 I could be wrong though...

Ah, so it did run out of memory.  That's one of the two major problems I
thought would happen with a "brand name" router.

I ran a Tor server for about 3 to 4 days to try and get a good baseline of
performance.  Do you have any performance stats?
If so, I would love to see them.


- Kyle


On Tue, Dec 23, 2008 at 7:00 AM, dante &lt;dante@virtualblueness.net&gt; wrote:

&gt; Hi Kyle,
&gt;
&gt; Very nice work.
&gt;
&gt; You might be interested in something I did a little while ago.  I got a
&gt; tor server running on a wireless Linksys WRT54g router.  This allows me
&gt; to use tor at home with my laptops wirelessly.
&gt;
&gt; Here's a quick howto since I never published on my site:
&gt;
&gt; 1) Get a MIPS I (little endian) environment up.  I used qemu and
&gt; installed debian-mipsel.  I started with the ramdisk image
&gt; mipsel-test-0.2.tar.gz from http://bellard.org/qemu/download.html and
&gt; bootstrapped into a fully functional debian system.
&gt;
&gt; 2) I compiled tor statically linked. (CFLAGS="-static" ./configure)
&gt;
&gt; 3) I got into my linksys using "Linux on WRTG54g" ...
&gt; http://www.batbox.org/wrt54g-linux.html
&gt;
&gt; 4) I used ftpget to upload tor, configure and start it up.
&gt;
&gt; It works fine, but you run out of memory fast because you have to use
&gt; ramdisk to store tor's cache files.
&gt;
&gt; Tony Basile
&gt; http://opensource.dyc.edu
&gt;
&gt;
&gt;
&gt; Kyle Williams wrote:
&gt; &gt; If anyone is seriously thinking about a good hardware based solution for
&gt; &gt; Tor, I'd buy the gumstix now.  In fact, I just bought a couple more just
&gt; in
&gt; &gt; case mine breaks. I'll have the source code up withing a week, two tops
&gt;  The
&gt; &gt; FULL documentation will take about a bit longer to get done.
&gt; &gt;
&gt; &gt; Well, that's about it.  Feedback is welcome.
&gt; &gt;
&gt; &gt;
&gt; &gt; Best Regards,
&gt; &gt;
&gt; &gt; Kyle
&gt; &gt;
&gt; &gt; PS.  Happy Holidays!
&gt; &gt;
&gt; &gt;
&gt;
&gt;

[Attachment #3 (text/html)]

Hi Tony,&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;I'm curious as to how well it performed.  How \
much RAM and CPU did the Linksys WRT54G have?  &lt;/div&gt;&lt;div&gt;I was worried that the \
linksys/netgear/dlink brands would not be that fast.  I could be wrong \
though...&lt;/div&gt; &lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Ah, so it did run out of memory.  That's \
one of the two major problems I thought would happen with a "brand name" \
router.&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;I ran a Tor server for about 3 to 4 days to try and \
get a good baseline of performance.  Do you have any performance stats? \
 &lt;/div&gt; &lt;div&gt;If so, I would love to see \
them.&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;- Kyle&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;br&gt;&lt;div \
class="gmail_quote"&gt;On Tue, Dec 23, 2008 at 7:00 AM, dante &lt;span dir="ltr"&gt;&lt;&lt;a \
href="mailto:dante@virtualblueness.net"&gt;dante@virtualblueness.net&lt;/a&gt;&gt;&lt;/span&gt; \
wrote:&lt;br&gt; &lt;blockquote class="gmail_quote" style="margin:0 0 0 .8ex;border-left:1px \
#ccc solid;padding-left:1ex;"&gt;Hi Kyle,&lt;br&gt; &lt;br&gt;
Very nice work.&lt;br&gt;
&lt;br&gt;
You might be interested in something I did a little while ago.  I got a&lt;br&gt;
tor server running on a wireless Linksys WRT54g router.  This allows me&lt;br&gt;
to use tor at home with my laptops wirelessly.&lt;br&gt;
&lt;br&gt;
Here's a quick howto since I never published on my site:&lt;br&gt;
&lt;br&gt;
1) Get a MIPS I (little endian) environment up.  I used qemu and&lt;br&gt;
installed debian-mipsel.  I started with the ramdisk image&lt;br&gt;
mipsel-test-0.2.tar.gz from &lt;a href="http://bellard.org/qemu/download.html" \
target="_blank"&gt;http://bellard.org/qemu/download.html&lt;/a&gt; and&lt;br&gt; bootstrapped into a \
fully functional debian system.&lt;br&gt; &lt;br&gt;
2) I compiled tor statically linked. (CFLAGS="-static" ./configure)&lt;br&gt;
&lt;br&gt;
3) I got into my linksys using "Linux on WRTG54g" ...&lt;br&gt;
&lt;a href="http://www.batbox.org/wrt54g-linux.html" \
target="_blank"&gt;http://www.batbox.org/wrt54g-linux.html&lt;/a&gt;&lt;br&gt; &lt;br&gt;
4) I used ftpget to upload tor, configure and start it up.&lt;br&gt;
&lt;br&gt;
It works fine, but you run out of memory fast because you have to use&lt;br&gt;
ramdisk to store tor's cache files.&lt;br&gt;
&lt;br&gt;
Tony Basile&lt;br&gt;
&lt;a href="http://opensource.dyc.edu" target="_blank"&gt;http://opensource.dyc.edu&lt;/a&gt;&lt;br&gt;
&lt;div&gt;&lt;div&gt;&lt;/div&gt;&lt;div class="Wj3C7c"&gt;&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
Kyle Williams wrote:&lt;br&gt;
&gt; If anyone is seriously thinking about a good hardware based solution for&lt;br&gt;
&gt; Tor, I'd buy the gumstix now.  In fact, I just bought a couple more \
just in&lt;br&gt; &gt; case mine breaks. I'll have the source code up withing a week, \
two tops  The&lt;br&gt; &gt; FULL documentation will take about a bit longer to get \
done.&lt;br&gt; &gt;&lt;br&gt;
&gt; Well, that's about it.  Feedback is welcome.&lt;br&gt;
&gt;&lt;br&gt;
&gt;&lt;br&gt;
&gt; Best Regards,&lt;br&gt;
&gt;&lt;br&gt;
&gt; Kyle&lt;br&gt;
&gt;&lt;br&gt;
&gt; PS.  Happy Holidays!&lt;br&gt;
&gt;&lt;br&gt;
&gt;&lt;br&gt;
&lt;br&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/blockquote&gt;&lt;/div&gt;&lt;br&gt;&lt;/div&gt;



</body></email><email><emailId>20081223170308</emailId><senderName>"Kyle Williams"</senderName><senderEmail>kyle.kwilliams@gmail.com</senderEmail><timestampReceived>2008-12-23 17:03:08-0400</timestampReceived><subject>Re: JanusPA - A hardware Privacy Adapter using Tor</subject><body>

Hi John,
Yeah, the 133MHz CPU just isn't going to be fast enough for my needs, plus
the extra ports is a bit over kill for this specific application.  I know
the gumstix is a higher price, but it is exactly what I needed.  Thanks for
the feedback though.  All this neat hardware that people are sharing is
giving me ideas for future projects.

- Kyle

On Tue, Dec 23, 2008 at 8:18 AM, Jonathan Yu &lt;jonathan.i.yu@gmail.com&gt;wrote:

&gt; Hi:
&gt;
&gt; What about the Soekris boards?
&gt;
&gt; The lowest end board, net4501, with a case is $173 USD.
&gt;
&gt; https://www.soekris.com/shop/product_info.php?products_id=75
&gt;
&gt; 133 Mhz CPU, 64 Mbyte SDRAM, 3 Ethernet, 2 Serial, CF socket, 1
&gt; Mini-PCI socket, 3.3V PCI connector.
&gt;
&gt; The low processor speed may hinder encryption, but other than that, it
&gt; looks like it would make a pretty good replacement for Gumstix.
&gt; Probably not as small, though.
&gt;
&gt; It might be nice to note that these boards have been in production for
&gt; a pretty long time and continue to be so. Also some firmwares like
&gt; DD-WRT support this hardware.
&gt;
&gt; Cheers,
&gt;
&gt; Jon
&gt;
&gt; On Sun, Dec 21, 2008 at 8:14 AM, Kyle Williams &lt;kyle.kwilliams@gmail.com&gt;
&gt; wrote:
&gt; &gt; Hello Everyone,
&gt; &gt; I've been working on a project for a couple of months now that I'm sure
&gt; &gt; would be of interest to some of you.  The goal was to apply the same
&gt; &gt; transparent model coderman and I  used with JanusVM and Tor VM into
&gt; &gt; hardware.  I wanted something small that you could connect, power on, and
&gt; &gt; use.  Literally plug-n-privacy.  After several weeks of searching the web
&gt; &gt; looking at different hardware configuration, specs, etc, etc, I decided
&gt; to
&gt; &gt; go with Gumstix(.com).
&gt; &gt; The privacy adapter is a ARM 400MHz Xscale CPU with 64MB RAM (@100MHz),
&gt; 16MB
&gt; &gt; of Flash memory for storage, and *TWO* 10/100 NICs.  It uses Linux for
&gt; the
&gt; &gt; OS.
&gt; &gt; The first thought that many people get, including myself, have is that it
&gt; is
&gt; &gt; not powerful enough to run Tor.  Well, after 2 months of breaking this
&gt; in,
&gt; &gt; I'm very happy with the results.
&gt; &gt; I ran this as a Tor server for about 4 days, and got a good baseline for
&gt; how
&gt; &gt; much data it can handle.  As a Tor server, it was pushing about 250KB/sec
&gt; &gt; (125KB in, 125 KB out).
&gt; &gt; As a Tor client, the best speed test I got was about 1.2MB/sec.  BTW,
&gt; that
&gt; &gt; was after about 45 minutes of "SIGNAL NEWNYM" and speedtest before I
&gt; found a
&gt; &gt; fast circuit.
&gt; &gt; Here's the URL for what I've got so far.
&gt; &gt; http://www.janusvm.com/goldy/JanusPA/index.html
&gt; &gt; It is lacking all forms of documentation, and the source code needs to be
&gt; &gt; cleaned up some.
&gt; &gt; It does have a general description, the index of the soon to come
&gt; &gt; documentation, openssl speed test benchmarks, pictures, and stats of when
&gt; I
&gt; &gt; tested it as a Tor server.
&gt; &gt; After about two months of using it, I've never felt more secure and
&gt; &gt; satisfied when using Tor.  This is a hardware router that routes your
&gt; &gt; traffic through the Tor network, it's small, and is easy to use.  As for
&gt; &gt; security, all TCP and DNS are routed through Tor, and everything else is
&gt; &gt; dropped.  So all the nasty side-channel attacks that us hackers have been
&gt; &gt; working on to leak your real IP address are rendered useless.
&gt; &gt; But there is good news and bad news.
&gt; &gt; The bad news:
&gt; &gt; The manufacture (Gumstix.com) is "Phasing Out" this particular setup at
&gt; the
&gt; &gt; end of DECEMBER 2008!!  That's in 10 days!  Any orders after Dec. 31,
&gt; 2008
&gt; &gt; will have to be in bulk orders, which is 120 or more units.  Shitty.
&gt; &gt;  Because of the short amount of time left to get this hardware, I've
&gt; jumped
&gt; &gt; the gun and chosen to notify the Tor community about this hardware before
&gt; it
&gt; &gt; is gone or out of a practical price range for most of us.
&gt; &gt; The good news:
&gt; &gt; I've been in communication with a very nice gentleman at gumstix who said
&gt; &gt; "Gumstix is also working on a netDUO expansion board for Overo, although
&gt; a
&gt; &gt; release date has not been announced."  There is reasonable hope that
&gt; there
&gt; &gt; new motherboad product line (the Overo) will at some point have a dual
&gt; NIC
&gt; &gt; expansion board.
&gt; &gt; So this is somewhat a conflicting situation.  I've spent months working
&gt; on
&gt; &gt; this awesome anonymity adpater, and it's about to be discontinued without
&gt; &gt; knowing an exact date as to when the new line with have the capabilities
&gt; to
&gt; &gt; do what needs to be done.  ugh.  I'm very much looking forward to their
&gt; new
&gt; &gt; product line when a dual NIC expansion board is available, but I don't
&gt; know
&gt; &gt; when that'll be.  If anyone is interested in this, but cannot afford to
&gt; buy
&gt; &gt; hardware at the moment, please contact Don Anderson (don@gumstix.com)and
&gt; &gt; encourage the idea of extending their phase out date or express and
&gt; interest
&gt; &gt; in a dual NIC expansion board for their new Overo product line.
&gt; &gt; If anyone is interested in getting a hardware based Tor solution, you
&gt; might
&gt; &gt; want to consider buying a gumstix soon.
&gt; &gt; You'll need the following.
&gt; &gt; Connex 400mx Motherboard:
&gt; &gt;
&gt; http://www.gumstix.com/store/catalog/product_info.php?cPath=27&amp;products_id=136
&gt; &gt; netDUO-mmc/SD expansion board:
&gt; &gt;
&gt; http://gumstix.com/store/catalog/product_info.php?cPath=31&amp;products_id=156
&gt; &gt; 4.0v Power Adapter:
&gt; &gt;
&gt; http://gumstix.com/store/catalog/product_info.php?cPath=28&amp;products_id=148
&gt; &gt; Screws and spacer kit:
&gt; &gt;
&gt; http://gumstix.com/store/catalog/product_info.php?cPath=28&amp;products_id=161
&gt; &gt; This will run you $237.00 USD + shipping and handling.
&gt; &gt; I would also *HIGHLY* recommend the following because flashing the device
&gt; &gt; over the network is very, very risky and has resulted in me having to
&gt; &gt; re-flash it through the serial port many, many times.
&gt; &gt; Serial null-modem cable:
&gt; &gt;
&gt; http://gumstix.com/store/catalog/product_info.php?cPath=28&amp;products_id=85
&gt; &gt; Serial port connector:
&gt; &gt;
&gt; http://gumstix.com/store/catalog/product_info.php?cPath=31&amp;products_id=106
&gt; &gt; This will run you $32.00 USD.
&gt; &gt; If anyone is seriously thinking about a good hardware based solution for
&gt; &gt; Tor, I'd buy the gumstix now.  In fact, I just bought a couple more just
&gt; in
&gt; &gt; case mine breaks. I'll have the source code up withing a week, two tops
&gt;  The
&gt; &gt; FULL documentation will take about a bit longer to get done.
&gt; &gt; Well, that's about it.  Feedback is welcome.
&gt; &gt;
&gt; &gt; Best Regards,
&gt; &gt; Kyle
&gt; &gt; PS.  Happy Holidays!
&gt;

[Attachment #3 (text/html)]

Hi John,&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Yeah, the 133MHz CPU just isn't going to be fast \
enough for my needs, plus the extra ports is a bit over kill for this specific \
application.  I know the gumstix is a higher price, but it is exactly what I \
needed.  Thanks for the feedback though.  All this neat hardware that \
people are sharing is giving me ideas for future projects.&lt;/div&gt; \
&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;- Kyle&lt;br&gt;&lt;br&gt;&lt;div class="gmail_quote"&gt;On Tue, Dec 23, 2008 at \
8:18 AM, Jonathan Yu &lt;span dir="ltr"&gt;&lt;&lt;a \
href="http://jonathan.i.yu"&gt;jonathan.i.yu&lt;/a&gt;@&lt;a \
href="http://gmail.com"&gt;gmail.com&lt;/a&gt;&gt;&lt;/span&gt; wrote:&lt;br&gt; &lt;blockquote \
class="gmail_quote" style="margin:0 0 0 .8ex;border-left:1px #ccc \
solid;padding-left:1ex;"&gt;Hi:&lt;br&gt; &lt;br&gt;
What about the Soekris boards?&lt;br&gt;
&lt;br&gt;
The lowest end board, net4501, with a case is $173 USD.&lt;br&gt;
&lt;br&gt;
&lt;a href="https://www.soekris.com/shop/product_info.php?products_id=75" \
target="_blank"&gt;https://www.soekris.com/shop/product_info.php?products_id=75&lt;/a&gt;&lt;br&gt; \
&lt;br&gt; 133 Mhz CPU, 64 Mbyte SDRAM, 3 Ethernet, 2 Serial, CF socket, 1&lt;br&gt;
Mini-PCI socket, 3.3V PCI connector.&lt;br&gt;
&lt;br&gt;
The low processor speed may hinder encryption, but other than that, it&lt;br&gt;
looks like it would make a pretty good replacement for Gumstix.&lt;br&gt;
Probably not as small, though.&lt;br&gt;
&lt;br&gt;
It might be nice to note that these boards have been in production for&lt;br&gt;
a pretty long time and continue to be so. Also some firmwares like&lt;br&gt;
DD-WRT support this hardware.&lt;br&gt;
&lt;br&gt;
Cheers,&lt;br&gt;
&lt;br&gt;
Jon&lt;br&gt;
&lt;div&gt;&lt;div&gt;&lt;/div&gt;&lt;div class="Wj3C7c"&gt;&lt;br&gt;
On Sun, Dec 21, 2008 at 8:14 AM, Kyle Williams &lt;&lt;a \
href="mailto:kyle.kwilliams@gmail.com"&gt;kyle.kwilliams@gmail.com&lt;/a&gt;&gt; wrote:&lt;br&gt; \
&gt; Hello Everyone,&lt;br&gt; &gt; I've been working on a project for a couple of \
months now that I'm sure&lt;br&gt; &gt; would be of interest to some of you.  The \
goal was to apply the same&lt;br&gt; &gt; transparent model coderman and I  used with \
JanusVM and Tor VM into&lt;br&gt; &gt; hardware.  I wanted something small that you \
could connect, power on, and&lt;br&gt; &gt; use.  Literally plug-n-privacy. \
 After several weeks of searching the web&lt;br&gt; &gt; looking at different hardware \
configuration, specs, etc, etc, I decided to&lt;br&gt; &gt; go with Gumstix(.com).&lt;br&gt;
&gt; The privacy adapter is a ARM 400MHz Xscale CPU with 64MB RAM (@100MHz), 16MB&lt;br&gt;
&gt; of Flash memory for storage, and *TWO* 10/100 NICs.  It uses Linux for \
the&lt;br&gt; &gt; OS.&lt;br&gt;
&gt; The first thought that many people get, including myself, have is that it is&lt;br&gt;
&gt; not powerful enough to run Tor.  Well, after 2 months of breaking this \
in,&lt;br&gt; &gt; I'm very happy with the results.&lt;br&gt;
&gt; I ran this as a Tor server for about 4 days, and got a good baseline for how&lt;br&gt;
&gt; much data it can handle.  As a Tor server, it was pushing about \
250KB/sec&lt;br&gt; &gt; (125KB in, 125 KB out).&lt;br&gt;
&gt; As a Tor client, the best speed test I got was about 1.2MB/sec.  BTW, \
that&lt;br&gt; &gt; was after about 45 minutes of "SIGNAL NEWNYM" and speedtest \
before I found a&lt;br&gt; &gt; fast circuit.&lt;br&gt;
&gt; Here's the URL for what I've got so far.&lt;br&gt;
&gt; &lt;a href="http://www.janusvm.com/goldy/JanusPA/index.html" \
target="_blank"&gt;http://www.janusvm.com/goldy/JanusPA/index.html&lt;/a&gt;&lt;br&gt; &gt; It is \
lacking all forms of documentation, and the source code needs to be&lt;br&gt; &gt; cleaned \
up some.&lt;br&gt; &gt; It does have a general description, the index of the soon to \
come&lt;br&gt; &gt; documentation, openssl speed test benchmarks, pictures, and stats of \
when I&lt;br&gt; &gt; tested it as a Tor server.&lt;br&gt;
&gt; After about two months of using it, I've never felt more secure and&lt;br&gt;
&gt; satisfied when using Tor.  This is a hardware router that routes your&lt;br&gt;
&gt; traffic through the Tor network, it's small, and is easy to use.  As \
for&lt;br&gt; &gt; security, all TCP and DNS are routed through Tor, and everything else \
is&lt;br&gt; &gt; dropped.  So all the nasty side-channel attacks that us hackers have \
been&lt;br&gt; &gt; working on to leak your real IP address are rendered useless.&lt;br&gt;
&gt; But there is good news and bad news.&lt;br&gt;
&gt; The bad news:&lt;br&gt;
&gt; The manufacture (Gumstix.com) is "Phasing Out" this particular setup \
at the&lt;br&gt; &gt; end of DECEMBER 2008!!  That's in 10 days!  Any orders \
after Dec. 31, 2008&lt;br&gt; &gt; will have to be in bulk orders, which is 120 or more \
units.  Shitty.&lt;br&gt; &gt;  Because of the short amount of time left to get \
this hardware, I've jumped&lt;br&gt; &gt; the gun and chosen to notify the Tor \
community about this hardware before it&lt;br&gt; &gt; is gone or out of a practical price \
range for most of us.&lt;br&gt; &gt; The good news:&lt;br&gt;
&gt; I've been in communication with a very nice gentleman at gumstix who \
said&lt;br&gt; &gt; "Gumstix is also working on a netDUO expansion board for Overo, \
although a&lt;br&gt; &gt; release date has not been announced."  There is \
reasonable hope that there&lt;br&gt; &gt; new motherboad product line (the Overo) will at \
some point have a dual NIC&lt;br&gt; &gt; expansion board.&lt;br&gt;
&gt; So this is somewhat a conflicting situation.  I've spent months working \
on&lt;br&gt; &gt; this awesome anonymity adpater, and it's about to be discontinued \
without&lt;br&gt; &gt; knowing an exact date as to when the new line with have the \
capabilities to&lt;br&gt; &gt; do what needs to be done.  ugh.  I'm very much \
looking forward to their new&lt;br&gt; &gt; product line when a dual NIC expansion board is \
available, but I don't know&lt;br&gt; &gt; when that'll be.  If anyone is \
interested in this, but cannot afford to buy&lt;br&gt; &gt; hardware at the moment, please \
contact Don Anderson (&lt;a href="mailto:don@gumstix.com"&gt;don@gumstix.com&lt;/a&gt;)and&lt;br&gt; \
&gt; encourage the idea of extending their phase out date or express and interest&lt;br&gt; \
&gt; in a dual NIC expansion board for their new Overo product line.&lt;br&gt; &gt; If \
anyone is interested in getting a hardware based Tor solution, you might&lt;br&gt; &gt; \
want to consider buying a gumstix soon.&lt;br&gt; &gt; You'll need the following.&lt;br&gt;
&gt; Connex 400mx Motherboard:&lt;br&gt;
&gt;  &lt;a href="http://www.gumstix.com/store/catalog/product_info.php?cPath=27&amp;products_id=136" \
target="_blank"&gt;http://www.gumstix.com/store/catalog/product_info.php?cPath=27&amp;products_id=136&lt;/a&gt;&lt;br&gt;
 &gt; netDUO-mmc/SD expansion board:&lt;br&gt;
&gt;  &lt;a href="http://gumstix.com/store/catalog/product_info.php?cPath=31&amp;products_id=156" \
target="_blank"&gt;http://gumstix.com/store/catalog/product_info.php?cPath=31&amp;products_id=156&lt;/a&gt;&lt;br&gt;
 &gt; 4.0v Power Adapter:&lt;br&gt;
&gt;  &lt;a href="http://gumstix.com/store/catalog/product_info.php?cPath=28&amp;products_id=148" \
target="_blank"&gt;http://gumstix.com/store/catalog/product_info.php?cPath=28&amp;products_id=148&lt;/a&gt;&lt;br&gt;
 &gt; Screws and spacer kit:&lt;br&gt;
&gt;  &lt;a href="http://gumstix.com/store/catalog/product_info.php?cPath=28&amp;products_id=161" \
target="_blank"&gt;http://gumstix.com/store/catalog/product_info.php?cPath=28&amp;products_id=161&lt;/a&gt;&lt;br&gt;
 &gt; This will run you $237.00 USD + shipping and handling.&lt;br&gt;
&gt; I would also *HIGHLY* recommend the following because flashing the device&lt;br&gt;
&gt; over the network is very, very risky and has resulted in me having to&lt;br&gt;
&gt; re-flash it through the serial port many, many times.&lt;br&gt;
&gt; Serial null-modem cable:&lt;br&gt;
&gt;  &lt;a href="http://gumstix.com/store/catalog/product_info.php?cPath=28&amp;products_id=85" \
target="_blank"&gt;http://gumstix.com/store/catalog/product_info.php?cPath=28&amp;products_id=85&lt;/a&gt;&lt;br&gt;
 &gt; Serial port connector:&lt;br&gt;
&gt;  &lt;a href="http://gumstix.com/store/catalog/product_info.php?cPath=31&amp;products_id=106" \
target="_blank"&gt;http://gumstix.com/store/catalog/product_info.php?cPath=31&amp;products_id=106&lt;/a&gt;&lt;br&gt;
 &gt; This will run you $32.00 USD.&lt;br&gt;
&gt; If anyone is seriously thinking about a good hardware based solution for&lt;br&gt;
&gt; Tor, I'd buy the gumstix now.  In fact, I just bought a couple more \
just in&lt;br&gt; &gt; case mine breaks. I'll have the source code up withing a week, \
two tops  The&lt;br&gt; &gt; FULL documentation will take about a bit longer to get \
done.&lt;br&gt; &gt; Well, that's about it.  Feedback is welcome.&lt;br&gt;
&gt;&lt;br&gt;
&gt; Best Regards,&lt;br&gt;
&gt; Kyle&lt;br&gt;
&gt; PS.  Happy Holidays!&lt;br&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/blockquote&gt;&lt;/div&gt;&lt;br&gt;&lt;/div&gt;



</body></email><email><emailId>20081223213630</emailId><senderName>coderman</senderName><senderEmail>coderman@gmail.com</senderEmail><timestampReceived>2008-12-23 21:36:30-0400</timestampReceived><subject>Re: bug in address family checking?</subject><body>

On Tue, Dec 23, 2008 at 6:16 AM, Nick Mathewson &lt;nickm@freehaven.net&gt; wrote:
&gt; ... everything
&gt; that calls connection_init() passes it a chunk of RAM that it got from
&gt; tor_malloc_zero, which should also zero out connection-&gt;addr, which
&gt; should result in it having addr_family 0, not addr_family 20 (which is
&gt; what the user was seeing on IRC).  Right?

correct.  (there were some other high values set that appeared to be
uninitialized or corrupted a few times as well)


&gt; If this is happening on a edge_connection after it finds a cached dns
&gt; answer, then the addr field has already been changed from its original
&gt; value. Check out the code in dns.c around line 688.

i see that now.  thanks!


&gt; To debug this thing, the easiest solution  is probably to use gdb to
&gt; a stack trace for when the warning message is triggered, to sew where
&gt; exactly it's happening in the code.

sounds good.  that would also allow inspection of values to see if
there is corruption going on or some other issue.

best regards,
</body></email><email><emailId>20081223232849</emailId><senderName>dante</senderName><senderEmail>dante@virtualblueness.net</senderEmail><timestampReceived>2008-12-23 23:28:49-0400</timestampReceived><subject>Re: JanusPA - A hardware Privacy Adapter using Tor</subject><body>

Hi Kyle,

(Sorry I sent my second post before I read your response to my first.)

The Linksys WRT54g has a 125-MHz Broadcom BCM4710 cpu with 16MB ram. 
The performance is poor, but it does work.  It eventually runs out of
memory, at which point, I can restart the router, rerun the hack
scripts, etc.  It is fun to play with, but too annoying for practical
use.  I haven't run it for a while, but I'm going to again so I can get
a better feel for its limits.

The boards I wrote about in my second post should be able to handle the
loads for a tor client (and perhaps a small tor relay).  In my work with
tor-ramdisk (tor in a micro linux ramdisk distro), I did try a 400 MHz
i686 cpu with 128 MB ram as a tor client --- no problems (I used one of
our lab's thin clients - HP Compaq t5135).  The 64 MB of ram set aside
for the ramdisk was able to accomodate the cached files in /var/lib/tor
which grew to about 27MB after many days of usage.  The t5135 is
comparable to the RB433 to RB433AH router boards I quoted earlier.

As a relay or exit node, cpu/ram usage grows with BandwidthRate, but I
don't know of any good studies.  The only data I have are far outside of
the realm of what you are trying to do, but we can scale it down: node
"simba" runs tor-ramdisk, but it has 4 x 2.5 GHz i686 and 4 GB of ram. 
Its a relay only node with BandwidthRate 150 KB/s, but it could handle a
lot more bandwidth.  Its cpu usage is typically below 5%.  Scaling down
this means 5% of 4x2500 MHz = 500 MHz, again in the range above.  The
ram is total overkill.

I know my information is not systematic, but I hope it helps.

--Tony Basile
http://opensourc.dyc.edu


Kyle Williams wrote:
&gt; Hi Tony,
&gt; I'm curious as to how well it performed.  How much RAM and CPU did the
&gt; Linksys WRT54G have?
&gt; I was worried that the linksys/netgear/dlink brands would not be that fast.
&gt;  I could be wrong though...
&gt;
&gt; Ah, so it did run out of memory.  That's one of the two major problems I
&gt; thought would happen with a "brand name" router.
&gt;
&gt; I ran a Tor server for about 3 to 4 days to try and get a good baseline of
&gt; performance.  Do you have any performance stats?
&gt; If so, I would love to see them.
&gt;
&gt;
&gt; - Kyle
&gt;
&gt;
&gt; On Tue, Dec 23, 2008 at 7:00 AM, dante &lt;dante@virtualblueness.net&gt; wrote:
&gt;
&gt;   
&gt;&gt; Hi Kyle,
&gt;&gt;
&gt;&gt; Very nice work.
&gt;&gt;
&gt;&gt; You might be interested in something I did a little while ago.  I got a
&gt;&gt; tor server running on a wireless Linksys WRT54g router.  This allows me
&gt;&gt; to use tor at home with my laptops wirelessly.
&gt;&gt;
&gt;&gt; Here's a quick howto since I never published on my site:
&gt;&gt;
&gt;&gt; 1) Get a MIPS I (little endian) environment up.  I used qemu and
&gt;&gt; installed debian-mipsel.  I started with the ramdisk image
&gt;&gt; mipsel-test-0.2.tar.gz from http://bellard.org/qemu/download.html and
&gt;&gt; bootstrapped into a fully functional debian system.
&gt;&gt;
&gt;&gt; 2) I compiled tor statically linked. (CFLAGS="-static" ./configure)
&gt;&gt;
&gt;&gt; 3) I got into my linksys using "Linux on WRTG54g" ...
&gt;&gt; http://www.batbox.org/wrt54g-linux.html
&gt;&gt;
&gt;&gt; 4) I used ftpget to upload tor, configure and start it up.
&gt;&gt;
&gt;&gt; It works fine, but you run out of memory fast because you have to use
&gt;&gt; ramdisk to store tor's cache files.
&gt;&gt;
&gt;&gt; Tony Basile
&gt;&gt; http://opensource.dyc.edu
&gt;&gt;
&gt;&gt;
&gt;&gt;
&gt;&gt; Kyle Williams wrote:
&gt;&gt;     
&gt;&gt;&gt; If anyone is seriously thinking about a good hardware based solution for
&gt;&gt;&gt; Tor, I'd buy the gumstix now.  In fact, I just bought a couple more just
&gt;&gt;&gt;       
&gt;&gt; in
&gt;&gt;     
&gt;&gt;&gt; case mine breaks. I'll have the source code up withing a week, two tops
&gt;&gt;&gt;       
&gt;&gt;  The
&gt;&gt;     
&gt;&gt;&gt; FULL documentation will take about a bit longer to get done.
&gt;&gt;&gt;
&gt;&gt;&gt; Well, that's about it.  Feedback is welcome.
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; Best Regards,
&gt;&gt;&gt;
&gt;&gt;&gt; Kyle
&gt;&gt;&gt;
&gt;&gt;&gt; PS.  Happy Holidays!
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt;       
&gt;&gt;     
&gt;
&gt;   

</body></email><email><emailId>20081224210714</emailId><senderName>"Steven J. Murdoch"</senderName><senderEmail>tor+steven.murdoch@cl.cam.ac.uk</senderEmail><timestampReceived>2008-12-24 21:07:14-0400</timestampReceived><subject>Re: Random note from TODO.021</subject><body>

On Mon, Nov 24, 2008 at 07:10:40PM +0000, Steven J. Murdoch wrote:
&gt; I'll try some more combinations, and if I can't break it, I'll ship
&gt; the next version with "AllowMultipleInstances=true". It's not perfect,
&gt; but it seems better than the current situation.

I tried it, and it even made it into a release (1.1.5). Unfortunately
it has a problem, and so Jacob removed it in 1.1.6 :-(

The issue is that Vidalia relies on FirefoxPortable to know when
Firefox has exited. The way FirefoxPortable does this is to poll on
the process list, and when there are no "firefox.exe" applications
running, it exits. Vidalia detects this and exits itself (after
terminating Tor and Polipo).

This strategy obviously doesn't work when there are multiple instances
of Firefox running, hence FirefoxPortable simply waits until Firefox
exits, before exiting itself. 

This is generally fine, but sometimes Firefox does something, starts a
child process, and the parent exits. In these cases FirefoxPortable
exits along with the parent and so does Vidalia. The child Firefox
then appears, and finds that Tor has already exited.

What I'm currently doing is modifying Vidalia to be more intelligent
about when Firefox has exited. The trick will be to find the most
elegant and reliable way to tell when the Firefox it started has
exited, without becoming confused with other ones.

A nasty way would to rename the Firefox executable from firefox.exe
to something random, and then periodically check for this in the
process list. A more elegant approach would be to find the location
of the binary, and see if it is part of the TBB. Or maybe we can tell
from the process tree, which Firefox was started by Vidalia.

Steven.

-- 
w: http://www.cl.cam.ac.uk/users/sjm217/
</body></email><email><emailId>20081225200543</emailId><senderName>"Steven J. Murdoch"</senderName><senderEmail>tor+steven.murdoch@cl.cam.ac.uk</senderEmail><timestampReceived>2008-12-25 20:05:43-0400</timestampReceived><subject>Running Tor Browser Bundle at the same time as Firefox</subject><body>

A long running problem with the Tor Browser bundle is that it cannot
be run at the same time as a non-Tor Firefox. There have been attempts
to fix this (e.g. [1]) while still using the FirefoxPortable launcher,
but they haven't worked too well.

So I've been experimenting with launching Firefox directly from
Vidalia. This now works (more or less), so I'd be interested in other
peoples' experiences of it. It's not ready for wide-scale use though,
as it's using an old version of Vidalia and might leave more traces
than the current Tor Browser Bundle.

If you're interested in trying it out, you can download it from:

 http://www.cl.cam.ac.uk/~sjm217/volatile/tor/tor-browser-1.1.8-altlauncher_en-US.exe

The source code is in the Vidalia subversion repository (alt-launcher
branch). That server appears to be down, so for now I've put the most
recent changes here:

 http://www.cl.cam.ac.uk/~sjm217/volatile/tor/vidalia-altlauncher.patch

I'd be very interested in comments and bug reports.

Thanks, and have a merry Christmas :-)

Steven.

[1] http://archives.seul.org/or/dev/Oct-2008/msg00012.html
    http://archives.seul.org/or/dev/Nov-2008/msg00016.html
    http://archives.seul.org/or/dev/Dec-2008/msg00026.html 

-- 
w: http://www.cl.cam.ac.uk/users/sjm217/
</body></email><email><emailId>20081227154719</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2008-12-27 15:47:19-0400</timestampReceived><subject>Re: [or-cvs] r17790: {tor} Refactor tor_addr_t manipulation functions so that as few as (tor/trunk/s</subject><body>

On Sat, Dec 27, 2008 at 01:19:10AM -0800, coderman wrote:
&gt; 2008/12/26 coderman &lt;coderman@gmail.com&gt;:
&gt; &gt; ...
&gt; 
&gt; next up is:
&gt; connection.c: In function `retry_listeners':
&gt; connection.c:1423: error: invalid application of `sizeof' to
&gt; incomplete type `sockaddr_un'
&gt; 
&gt; not sure if this should be wrapped if a #ifndef MS_WINDOWS or other.
&gt; AF_UNIX appears to be defined, just no sockaddr_un...

Thanks; these should both be fixed now.
</body></email><email><emailId>20081230111451</emailId><senderName>Robert Hogan</senderName><senderEmail>robert@roberthogan.net</senderEmail><timestampReceived>2008-12-30 11:14:51-0400</timestampReceived><subject>Tor 'dissector' for Wireshark</subject><body>


For those who are interested, here is a HOWTO for capturing, decrypting and 
viewing Tor traffic with wireshark. It's still a work in progress but is 
already useful I hope:

http://roberthogan.net/stuff/dissector/tordissector-README.txt




["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>200811112054560</emailId><senderName>Sambuddho Chakravarty</senderName><senderEmail>sc2516@columbia.edu</senderEmail><timestampReceived>2008-11-11 20:54:56-0400</timestampReceived><subject>Re: determining which are the ORs a Tor circuit is using</subject><body>

I taking the following route 

circuitbuild.c-&gt; circuit_send_next_onionskin-&gt;
		At the point where there is a check for if(!hop)
 		I take the 'circ' pointer and -&gt; crypt_path_t pointer -&gt;
extend_info_t pointer -&gt; nickname/addr

Should that work ?

Thanks
Sambuddho 

On Tue, 2008-11-11 at 12:55 -0700, mrwigglet wrote:
&gt; I know it is saved in the log files, although there may be an easier
&gt; way to do it.  There are lots of paths built that are in a waiting
&gt; state, so you'd have to do some connecting the actual circuit being
&gt; used with when it was built.  I don't know of a built in way of doing
&gt; this.
&gt; 
&gt; 
&gt; On Tue, Nov 11, 2008 at 12:50 PM, Sambuddho Chakravarty
&gt; &lt;sc2516@columbia.edu&gt; wrote:
&gt;         Hello All
&gt;          I have a general question. I am using the default torrc
&gt;         (without
&gt;         specifying which ORs to select and letting the client
&gt;         determine the
&gt;         "best" ones for itself). Is there a way to detect which are
&gt;         the ORs the
&gt;         client picks up for the entry , middleman and exit nodes
&gt;         (rather than
&gt;         hacking into the source code of the tor client). I am using a
&gt;         rather
&gt;         dated version of the client - 0.1.2.18.
&gt;         
&gt;         Thanks
&gt;         Sambuddho
&gt;         
&gt; 
&gt; 
&gt; 
&gt; -- 
&gt; Nathan Evans
&gt; Research Assistant
&gt; Department of Computer Science
&gt; University of Denver

</body></email><email><emailId>20081112092707</emailId><senderName>"Kyle Williams"</senderName><senderEmail>kyle.kwilliams@gmail.com</senderEmail><timestampReceived>2008-11-12 09:27:07-0400</timestampReceived><subject>=?WINDOWS-1252?Q?[Announce]_Introducing_Tor_V?= =?WINDOWS-1252?Q?M_=96_Tor_in_a_virtual_machine.?=</subject><body>

http://www.janusvm.com/tor_vm/


 Tor VM is a small virtual machine that acts as a router and redirects your
TCP traffic and DNS request through Tor while filtering out protocols that
could jeopardize your anonymity. Tor VM is built using all open source
software and is free.


 There are many advantages to running Tor in a virtual machine. Any
application on any operating system that uses TCP for communication is
routed over Tor. By using a small virtual machine that acts as a router,
protocols such as UDP and ICMP are filtered, preventing a compromise of your
anonymity. Placing Tor in a virtual machine separates Tor from potentially
insecure applications that could compromises Tor's integrity and your
security.


 The Tor VM ISO is designed to be run in a virtual machine, not on physical
hardware. The ISO requires two virtual NICs to be used; one bridged
interface, one OpenVPN Tun/Tap adapter. The Windows build of Tor VM is
portable and includes QEMU to run the virtual machine, but requires
Administrator privileges to install the Tap32 adapter. Traffic is routed
through the Tap interface, into the VM, TCP and DNS are directed to Tor's
Transport while other protocols are discarded, then Tor does it's magic with
your traffic. More details can be found in the design documentation.


 Lots of people are going to ask "What's the difference between JanusVM and
Tor VM?", so I'll address this now. JanusVM was designed to be used by
multiple users, runs HTTP traffic through Squid and Privoxy, and was build
on top of Debian packages. Tor VM is built from entirely 100% open source
software, is pre-configured to support only a single user, is much smaller
in size, uses less memory than JanusVM, and works with QEMU. Is Tor VM going
to replace JanusVM?? It's too soon to tell.


 This software is in the late alpha stages of development; work is still in
progress. For the time being, Tor VM is being hosted on the JanusVM server.
Martin and I would appreciate it if a few of you would give Tor VM a go and
provide us with your feedback. Feel free to review the We look forward to
hearing from the community.


 One last thing. Mad props to coderman! Martin did an amazing job hacking
QEMU and the WinPCAP drivers in order to create an interface that is a raw
bridge into the existing network card. This is just as good as VMware bridge
service, if not better! It's Amazing work; make sure to take a close look at
what is under the hood. Tor VM wouldn't have been possible if it wasn't for
his insane amount of knowledge and skill. Let me be the first to say it;
Thank You. :)



 Best Regards,


 Kyle Williams

[Attachment #3 (text/html)]

&lt;meta http-equiv="CONTENT-TYPE" content="text/html; \
charset=utf-8"&gt;&lt;title&gt;&lt;/title&gt;&lt;meta name="GENERATOR" content="OpenOffice.org 2.4  \
(Win32)"&gt;&lt;style type="text/css"&gt;  &lt;!--
		@page { size: 8.5in 11in; margin: 0.79in }
		P { margin-bottom: 0.08in }
	--&gt;
	&lt;/style&gt;
&lt;p style="margin-bottom: 0in;"&gt;&lt;font size="3"&gt;&lt;a \
href="http://www.janusvm.com/tor_vm/"&gt;http://www.janusvm.com/tor_vm/&lt;/a&gt;&lt;/font&gt;&lt;/p&gt; \
&lt;p style="margin-bottom: 0in;"&gt;&lt;br&gt; &lt;/p&gt;
&lt;p style="margin-bottom: 0in;"&gt;&lt;font size="3"&gt;	Tor VM is a small virtual
machine that acts as a router and redirects your TCP traffic and DNS
request through Tor while filtering out protocols that could
jeopardize your anonymity.  Tor VM is built using all open source
software and is free.&lt;/font&gt;&lt;/p&gt;
&lt;p style="margin-bottom: 0in;"&gt;&lt;br&gt;
&lt;/p&gt;
&lt;p style="margin-bottom: 0in;"&gt;&lt;font size="3"&gt;	There are many advantages
to running Tor in a virtual machine.  Any application on any
operating system that uses TCP for communication is routed over Tor. 
By using a small virtual machine that acts as a router, protocols
such as UDP and ICMP are filtered, preventing a compromise of your
anonymity.  Placing Tor in a virtual machine separates Tor from
potentially insecure applications that could compromises Tor's
integrity and your security.  &lt;/font&gt;
&lt;/p&gt;
&lt;p style="margin-bottom: 0in;"&gt;&lt;br&gt;
&lt;/p&gt;
&lt;p style="margin-bottom: 0in;"&gt;&lt;font size="3"&gt;	The Tor VM ISO is
designed to be run in a virtual machine, not on physical hardware. 
The ISO requires two virtual NICs to be used; one bridged interface,
one OpenVPN Tun/Tap adapter.  The Windows build of Tor VM is portable
and includes QEMU to run the virtual machine, but requires
Administrator privileges to install the Tap32 adapter.  Traffic is
routed through the Tap interface, into the VM, TCP and DNS are
directed to Tor's Transport while other protocols are discarded, then
Tor does it's magic with your traffic.  More details can be found in
the design documentation.&lt;/font&gt;&lt;/p&gt;
&lt;p style="margin-bottom: 0in;"&gt;&lt;br&gt;
&lt;/p&gt;
&lt;p style="margin-bottom: 0in;"&gt;&lt;font size="3"&gt;	Lots of people are going
to ask "What's the difference between JanusVM and Tor VM?", so
I'll address this now.  JanusVM was designed to be used by multiple
users, runs HTTP traffic through Squid and Privoxy, and was build on
top of Debian packages.  Tor VM is built from entirely 100% open
source software, is pre-configured to support only a single user, is
much smaller in size, uses less memory than JanusVM, and works with
QEMU.  Is Tor VM going to replace JanusVM??  It's too soon to tell.&lt;/font&gt;&lt;/p&gt;
&lt;p style="margin-bottom: 0in;"&gt;&lt;br&gt;
&lt;/p&gt;
&lt;p style="margin-bottom: 0in;"&gt;&lt;font size="3"&gt;	This software is in the
late alpha stages of development; work is still in progress.  For the
time being, Tor VM is being hosted on the JanusVM server.  Martin and
I would appreciate it if a few of you would give Tor VM a go and
provide us with your feedback.  Feel free to review the We look
forward to hearing from the community.  &lt;/font&gt;
&lt;/p&gt;
&lt;p style="margin-bottom: 0in;"&gt;&lt;br&gt;
&lt;/p&gt;
&lt;p style="margin-bottom: 0in;"&gt;&lt;font size="3"&gt;	One last thing.  Mad
props to coderman! Martin did an amazing job hacking QEMU and the
WinPCAP drivers in order to create an interface that is a raw bridge
into the existing network card.  This is just as good as VMware
bridge service, if not better!  It's Amazing work; make sure to take
a close look at what is under the hood.  Tor VM wouldn't have been
possible if it wasn't for his insane amount of knowledge and skill. 
Let me be the first to say it; Thank You.  :)&lt;/font&gt;&lt;/p&gt;

&lt;p style="margin-bottom: 0in;"&gt;&lt;br&gt;
&lt;/p&gt;
&lt;p style="margin-bottom: 0in;"&gt;&lt;br&gt;
&lt;/p&gt;
&lt;p style="margin-bottom: 0in;"&gt;&lt;font size="3"&gt;Best Regards,&lt;/font&gt;&lt;/p&gt;
&lt;p style="margin-bottom: 0in;"&gt;&lt;br&gt;
&lt;/p&gt;
&lt;p style="margin-bottom: 0in;"&gt;&lt;font size="3"&gt;Kyle Williams&lt;/font&gt;&lt;/p&gt;



</body></email><email><emailId>20081120195434</emailId><senderName>Robert Hogan</senderName><senderEmail>robert@roberthogan.net</senderEmail><timestampReceived>2008-11-20 19:54:34-0400</timestampReceived><subject>Re: Empty TLS application records being injected in Tor streams</subject><body>


On Wednesday 12 November 2008 02:25:51 Steven J. Murdoch wrote:
&gt;
&gt; Does anyone have ideas on how to remove the redundant TLS application
&gt; records, or otherwise improve the efficiency?
&gt;
&gt; Steven.

http://marc.info/?l=openssl-users&amp;m=115654275717293&amp;w=2

has the answer.

"Sending empty SSL record (I mean record with only MAC) before SSL record
with real application data guards against some timing CBC attacks
and is enabled in OpenSSL by default.
To disable this set SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS with
SSL_CTX_set_options()."

This corresponds exactly with what you're seeing - the empty record always 
precedes the populated application record.

["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20081122080855</emailId><senderName>"Kyle Williams"</senderName><senderEmail>kyle.kwilliams@gmail.com</senderEmail><timestampReceived>2008-11-22 08:08:55-0400</timestampReceived><subject>=?WINDOWS-1252?Q?Re:_[Announce]_Introducing_Tor?= =?WINDOWS-1252?Q?_VM_=96_Tor_in_a_virtual_machine.</subject><body>

Thank you for reporting back!
We'll take a look at that and get back to you when we have an answer.

Thank you for your patience. :)

- Kyle



On Sat, Nov 22, 2008 at 12:03 AM, Dmitriy Kazimirov &lt;dkazimirow@gmail.com&gt;wrote:

&gt; At least one issue:
&gt; It does not work on windows xp sp2 with Intel Pro/Wireless 2200BG WiFi card
&gt; saying that it cannot switch to promisc mode
&gt;
&gt;
&gt; 2008/11/22 Kyle Williams &lt;kyle.kwilliams@gmail.com&gt;
&gt;
&gt; It's been over a week, and I've seen several dozen downloads since I posted
&gt;&gt; this. Does anyone have any feedback?
&gt;&gt;
&gt;&gt; - Kyle
&gt;&gt;
&gt;&gt; On Wed, Nov 12, 2008 at 1:27 AM, Kyle Williams &lt;kyle.kwilliams@gmail.com&gt;wrote:
&gt;&gt;
&gt;&gt;&gt; http://www.janusvm.com/tor_vm/
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt;  Tor VM is a small virtual machine that acts as a router and redirects
&gt;&gt;&gt; your TCP traffic and DNS request through Tor while filtering out protocols
&gt;&gt;&gt; that could jeopardize your anonymity. Tor VM is built using all open source
&gt;&gt;&gt; software and is free.
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt;  There are many advantages to running Tor in a virtual machine. Any
&gt;&gt;&gt; application on any operating system that uses TCP for communication is
&gt;&gt;&gt; routed over Tor. By using a small virtual machine that acts as a router,
&gt;&gt;&gt; protocols such as UDP and ICMP are filtered, preventing a compromise of your
&gt;&gt;&gt; anonymity. Placing Tor in a virtual machine separates Tor from potentially
&gt;&gt;&gt; insecure applications that could compromises Tor's integrity and your
&gt;&gt;&gt; security.
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt;  The Tor VM ISO is designed to be run in a virtual machine, not on
&gt;&gt;&gt; physical hardware. The ISO requires two virtual NICs to be used; one bridged
&gt;&gt;&gt; interface, one OpenVPN Tun/Tap adapter. The Windows build of Tor VM is
&gt;&gt;&gt; portable and includes QEMU to run the virtual machine, but requires
&gt;&gt;&gt; Administrator privileges to install the Tap32 adapter. Traffic is routed
&gt;&gt;&gt; through the Tap interface, into the VM, TCP and DNS are directed to Tor's
&gt;&gt;&gt; Transport while other protocols are discarded, then Tor does it's magic with
&gt;&gt;&gt; your traffic. More details can be found in the design documentation.
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt;  Lots of people are going to ask "What's the difference between JanusVM
&gt;&gt;&gt; and Tor VM?", so I'll address this now. JanusVM was designed to be used by
&gt;&gt;&gt; multiple users, runs HTTP traffic through Squid and Privoxy, and was build
&gt;&gt;&gt; on top of Debian packages. Tor VM is built from entirely 100% open source
&gt;&gt;&gt; software, is pre-configured to support only a single user, is much smaller
&gt;&gt;&gt; in size, uses less memory than JanusVM, and works with QEMU. Is Tor VM going
&gt;&gt;&gt; to replace JanusVM?? It's too soon to tell.
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt;  This software is in the late alpha stages of development; work is still
&gt;&gt;&gt; in progress. For the time being, Tor VM is being hosted on the JanusVM
&gt;&gt;&gt; server. Martin and I would appreciate it if a few of you would give Tor VM a
&gt;&gt;&gt; go and provide us with your feedback. Feel free to review the We look
&gt;&gt;&gt; forward to hearing from the community.
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt;  One last thing. Mad props to coderman! Martin did an amazing job
&gt;&gt;&gt; hacking QEMU and the WinPCAP drivers in order to create an interface that is
&gt;&gt;&gt; a raw bridge into the existing network card. This is just as good as VMware
&gt;&gt;&gt; bridge service, if not better! It's Amazing work; make sure to take a close
&gt;&gt;&gt; look at what is under the hood. Tor VM wouldn't have been possible if it
&gt;&gt;&gt; wasn't for his insane amount of knowledge and skill. Let me be the first to
&gt;&gt;&gt; say it; Thank You. :)
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt;  Best Regards,
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt;  Kyle Williams
&gt;&gt;&gt;
&gt;&gt;
&gt;&gt;
&gt;
&gt;
&gt; --
&gt; --
&gt; Best Regards,
&gt; Dmitriy Kazimirov,
&gt; Senior C++/C# Developer
&gt; of ISS Art, Ltd., Omsk, Russia
&gt; Web: http://www.issart.com
&gt; E-mail: dkazimirov@issart.com
&gt;

[Attachment #3 (text/html)]

Thank you for reporting back!  &lt;br&gt;We'll take a look at that and get back to \
you when we have an answer.&lt;br&gt;&lt;br&gt;Thank you for your patience. :)&lt;br&gt;&lt;br&gt;- \
Kyle&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;div class="gmail_quote"&gt;On Sat, Nov 22, 2008 at 12:03 AM, \
Dmitriy Kazimirov &lt;span dir="ltr"&gt;&lt;&lt;a \
href="mailto:dkazimirow@gmail.com"&gt;dkazimirow@gmail.com&lt;/a&gt;&gt;&lt;/span&gt; wrote:&lt;br&gt; \
&lt;blockquote class="gmail_quote" style="border-left: 1px solid rgb(204, 204, 204); \
margin: 0pt 0pt 0pt 0.8ex; padding-left: 1ex;"&gt;At least one issue:&lt;br&gt;It does not \
work on windows xp sp2 with Intel Pro/Wireless 2200BG WiFi card saying that it cannot \
switch to promisc mode&lt;br&gt; &lt;br&gt;&lt;br&gt;&lt;div class="gmail_quote"&gt;2008/11/22 Kyle Williams \
&lt;span dir="ltr"&gt;&lt;&lt;a href="mailto:kyle.kwilliams@gmail.com" \
target="_blank"&gt;kyle.kwilliams@gmail.com&lt;/a&gt;&gt;&lt;/span&gt;&lt;div&gt;&lt;div&gt;&lt;/div&gt;&lt;div \
class="Wj3C7c"&gt;&lt;br&gt; &lt;blockquote class="gmail_quote" style="border-left: 1px solid \
rgb(204, 204, 204); margin: 0pt 0pt 0pt 0.8ex; padding-left: 1ex;"&gt;It's been over \
a week, and I've seen several dozen downloads since I posted this.&lt;div&gt;

Does anyone have any feedback?&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;font color="#888888"&gt;&lt;div&gt;- \
Kyle&lt;/div&gt;&lt;/font&gt;&lt;div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;br&gt;&lt;div class="gmail_quote"&gt;On Wed, Nov \
12, 2008 at 1:27 AM, Kyle Williams &lt;span dir="ltr"&gt;&lt;&lt;a \
href="mailto:kyle.kwilliams@gmail.com" \
target="_blank"&gt;kyle.kwilliams@gmail.com&lt;/a&gt;&gt;&lt;/span&gt; wrote:&lt;br&gt;


&lt;blockquote class="gmail_quote" style="border-left: 1px solid rgb(204, 204, 204); \
margin: 0pt 0pt 0pt 0.8ex; padding-left: 1ex;"&gt; &lt;p style="margin-bottom: 0in;"&gt;&lt;font \
size="3"&gt;&lt;a href="http://www.janusvm.com/tor_vm/" \
target="_blank"&gt;http://www.janusvm.com/tor_vm/&lt;/a&gt;&lt;/font&gt;&lt;/p&gt; &lt;p \
style="margin-bottom: 0in;"&gt;&lt;br&gt; &lt;/p&gt;
&lt;p style="margin-bottom: 0in;"&gt;&lt;font size="3"&gt;	Tor VM is a small virtual
machine that acts as a router and redirects your TCP traffic and DNS
request through Tor while filtering out protocols that could
jeopardize your anonymity.  Tor VM is built using all open source
software and is free.&lt;/font&gt;&lt;/p&gt;
&lt;p style="margin-bottom: 0in;"&gt;&lt;br&gt;
&lt;/p&gt;
&lt;p style="margin-bottom: 0in;"&gt;&lt;font size="3"&gt;	There are many advantages
to running Tor in a virtual machine.  Any application on any
operating system that uses TCP for communication is routed over Tor. 
By using a small virtual machine that acts as a router, protocols
such as UDP and ICMP are filtered, preventing a compromise of your
anonymity.  Placing Tor in a virtual machine separates Tor from
potentially insecure applications that could compromises Tor's
integrity and your security.  &lt;/font&gt;
&lt;/p&gt;
&lt;p style="margin-bottom: 0in;"&gt;&lt;br&gt;
&lt;/p&gt;
&lt;p style="margin-bottom: 0in;"&gt;&lt;font size="3"&gt;	The Tor VM ISO is
designed to be run in a virtual machine, not on physical hardware. 
The ISO requires two virtual NICs to be used; one bridged interface,
one OpenVPN Tun/Tap adapter.  The Windows build of Tor VM is portable
and includes QEMU to run the virtual machine, but requires
Administrator privileges to install the Tap32 adapter.  Traffic is
routed through the Tap interface, into the VM, TCP and DNS are
directed to Tor's Transport while other protocols are discarded, then
Tor does it's magic with your traffic.  More details can be found in
the design documentation.&lt;/font&gt;&lt;/p&gt;
&lt;p style="margin-bottom: 0in;"&gt;&lt;br&gt;
&lt;/p&gt;
&lt;p style="margin-bottom: 0in;"&gt;&lt;font size="3"&gt;	Lots of people are going
to ask "What's the difference between JanusVM and Tor VM?", so
I'll address this now.  JanusVM was designed to be used by multiple
users, runs HTTP traffic through Squid and Privoxy, and was build on
top of Debian packages.  Tor VM is built from entirely 100% open
source software, is pre-configured to support only a single user, is
much smaller in size, uses less memory than JanusVM, and works with
QEMU.  Is Tor VM going to replace JanusVM??  It's too soon to tell.&lt;/font&gt;&lt;/p&gt;
&lt;p style="margin-bottom: 0in;"&gt;&lt;br&gt;
&lt;/p&gt;
&lt;p style="margin-bottom: 0in;"&gt;&lt;font size="3"&gt;	This software is in the
late alpha stages of development; work is still in progress.  For the
time being, Tor VM is being hosted on the JanusVM server.  Martin and
I would appreciate it if a few of you would give Tor VM a go and
provide us with your feedback.  Feel free to review the We look
forward to hearing from the community.  &lt;/font&gt;
&lt;/p&gt;
&lt;p style="margin-bottom: 0in;"&gt;&lt;br&gt;
&lt;/p&gt;
&lt;p style="margin-bottom: 0in;"&gt;&lt;font size="3"&gt;	One last thing.  Mad
props to coderman! Martin did an amazing job hacking QEMU and the
WinPCAP drivers in order to create an interface that is a raw bridge
into the existing network card.  This is just as good as VMware
bridge service, if not better!  It's Amazing work; make sure to take
a close look at what is under the hood.  Tor VM wouldn't have been
possible if it wasn't for his insane amount of knowledge and skill. 
Let me be the first to say it; Thank You.  :)&lt;/font&gt;&lt;/p&gt;

&lt;p style="margin-bottom: 0in;"&gt;&lt;br&gt;
&lt;/p&gt;
&lt;p style="margin-bottom: 0in;"&gt;&lt;br&gt;
&lt;/p&gt;
&lt;p style="margin-bottom: 0in;"&gt;&lt;font size="3"&gt;Best Regards,&lt;/font&gt;&lt;/p&gt;
&lt;p style="margin-bottom: 0in;"&gt;&lt;br&gt;
&lt;/p&gt;
&lt;p style="margin-bottom: 0in;"&gt;&lt;font size="3"&gt;Kyle Williams&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;/div&gt;&lt;br&gt;&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/blockquote&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;br&gt;&lt;br clear="all"&gt;&lt;br&gt;-- &lt;br&gt;&lt;font \
color="#888888"&gt;--&lt;br&gt;Best Regards,&lt;br&gt;Dmitriy Kazimirov,&lt;br&gt;Senior C++/C# \
Developer&lt;br&gt;of ISS Art, Ltd., Omsk, Russia&lt;br&gt;Web: &lt;a href="http://www.issart.com" \
target="_blank"&gt;http://www.issart.com&lt;/a&gt;&lt;br&gt;

E-mail: &lt;a href="mailto:dkazimirov@issart.com" \
target="_blank"&gt;dkazimirov@issart.com&lt;/a&gt;&lt;br&gt; &lt;/font&gt;&lt;/blockquote&gt;&lt;/div&gt;&lt;br&gt;



</body></email><email><emailId>20081124005538</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2008-11-24 00:55:38-0400</timestampReceived><subject>Re: Tracking Blocked Ports</subject><body>

On Tue, Oct 14, 2008 at 11:16:12PM +0100, Robert Hogan wrote:
&gt; Motivation:
&gt; Tor clients that are behind extremely restrictive firewalls can end up waiting
&gt; a while for their first successful OR connection to a node on the network.

Added as proposal 156:
https://svn.torproject.org/svn/tor/trunk/doc/spec/proposals/156-tracking-blocked-ports.txt
so we don't lose track of it.

My understanding is that the next step here is to a) decide if this
overall approach is the right approach, and b) revise the patch to be
more memory-friendly.

Thanks!
--Roger

</body></email><email><emailId>20081124191040</emailId><senderName>"Steven J. Murdoch"</senderName><senderEmail>tor+steven.murdoch@cl.cam.ac.uk</senderEmail><timestampReceived>2008-11-24 19:10:40-0400</timestampReceived><subject>Re: Random note from TODO.021</subject><body>

Hi John,

On Fri, Oct 10, 2008 at 07:29:47PM -0600, John Brooks wrote:
&gt; [FirefoxPortable]
&gt; AllowMultipleInstances=true
&gt; 
&gt; When set to true, this will allow multiple copies of firefox (from the
&gt; same or different binaries) to start, and does not need to be set on
&gt; any other copies of firefox that are used.

Thanks for the suggestion. I do recall trying this out when I first
built the browser bundle, and had some problems. I don't remember the
exact details though (and that was with an older version of Firefox
Portable).

I tried it again, and it does seem promising. As far as I can tell, it
does the right thing to allow a normal installed Firefox to co-exist
with Firefox Portable.

There is a problem running an independent FirefoxPortable with Tor
Browser Bundle. When starting the second one, the error message
"Another instance of Firefox is already running". Still, this isn't
hopefully such a common case.

I'll try some more combinations, and if I can't break it, I'll ship
the next version with "AllowMultipleInstances=true". It's not perfect,
but it seems better than the current situation.

Steven.

-- 
w: http://www.cl.cam.ac.uk/users/sjm217/
</body></email><email><emailId>20081129114332</emailId><senderName>coderman</senderName><senderEmail>coderman@gmail.com</senderEmail><timestampReceived>2008-11-29 11:43:32-0400</timestampReceived><subject>Re: PATCH: preliminary support for MSI based package builds via WiX toolset</subject><body>

ok arma, this should be good to commit.  changes from previous: remove
the annoying default EULA and other unnecessary dialog prompts during
install.  this is a slightly modified copy of the open source Mondo UI
extension in the WiX sources / UI library. (Common Public License 1.0)

a test build of the MSI installer produced is here:
https://data.peertech.org/torbld/build/Tor-mod-svn-Thandy/1227956476

best regards,


On Fri, Nov 28, 2008 at 10:25 AM, coderman &lt;coderman@gmail.com&gt; wrote:
&gt; ... i have attached an updated copy...

["tor-wixmsi.patch" (text/x-patch)]

diff -Naur orig-tor/configure.in mod-tor/configure.in
--- orig-tor/configure.in	2008-11-09 23:32:38.649936000 +0000
+++ mod-tor/configure.in	2008-11-27 03:42:31.335943536 +0000
@@ -818,7 +818,7 @@
 
 CPPFLAGS="$CPPFLAGS $TOR_CPPFLAGS_libevent $TOR_CPPFLAGS_openssl $TOR_CPPFLAGS_zlib"
 
-AC_CONFIG_FILES([Makefile tor.spec Doxyfile contrib/tor.sh contrib/torctl \
contrib/torify contrib/tor.logrotate contrib/Makefile contrib/osx/Makefile \
contrib/osx/TorBundleDesc.plist contrib/osx/TorBundleInfo.plist \
contrib/osx/TorDesc.plist contrib/osx/TorInfo.plist contrib/osx/TorStartupDesc.plist \
src/config/torrc.sample doc/tor.1 src/Makefile doc/Makefile doc/design-paper/Makefile \
doc/spec/Makefile src/config/Makefile src/common/Makefile src/or/Makefile \
src/win32/Makefile src/tools/Makefile contrib/suse/Makefile contrib/suse/tor.sh]) \
+AC_CONFIG_FILES([Makefile tor.spec Doxyfile contrib/tor.sh contrib/torctl \
contrib/torify contrib/tor.logrotate contrib/Makefile contrib/osx/Makefile \
contrib/osx/TorBundleDesc.plist contrib/osx/TorBundleInfo.plist \
contrib/osx/TorDesc.plist contrib/osx/TorInfo.plist contrib/osx/TorStartupDesc.plist \
src/config/torrc.sample doc/tor.1 src/Makefile doc/Makefile doc/design-paper/Makefile \
doc/spec/Makefile src/config/Makefile src/common/Makefile src/or/Makefile \
src/win32/Makefile src/tools/Makefile contrib/suse/Makefile contrib/suse/tor.sh \
contrib/tor.wxs])  AC_OUTPUT
 
 if test -x /usr/bin/perl &amp;&amp; test -x ./contrib/updateVersions.pl ; then
diff -Naur orig-tor/contrib/WixUI_Tor.wxs mod-tor/contrib/WixUI_Tor.wxs
--- orig-tor/contrib/WixUI_Tor.wxs	1970-01-01 00:00:00.000000000 +0000
+++ mod-tor/contrib/WixUI_Tor.wxs	2008-11-29 11:10:12.019905912 +0000
@@ -0,0 +1,62 @@
+&lt;?xml version="1.0" encoding="UTF-8"?&gt;
+&lt;!--
+    Copyright (c) Microsoft Corporation.  All rights reserved.
+    
+    The use and distribution terms for this software are covered by the
+    Common Public License 1.0 (http://opensource.org/licenses/cpl.php)
+    which can be found in the file CPL.TXT at the root of this distribution.
+    By using this software in any fashion, you are agreeing to be bound by
+    the terms of this license.
+    
+    You must not remove this notice, or any other, from this software.
+
+    This is modified from WixUI_Mondo to omit EULA and other parts not necessary
+    for Tor installation.
+--&gt;
+&lt;Wix xmlns="http://schemas.microsoft.com/wix/2006/wi"&gt;
+    &lt;Fragment&gt;
+        &lt;UI Id="WixUI_Tor"&gt;
+            &lt;TextStyle Id="WixUI_Font_Normal" FaceName="Tahoma" Size="8" /&gt;
+            &lt;TextStyle Id="WixUI_Font_Bigger" FaceName="Tahoma" Size="12" /&gt;
+            &lt;TextStyle Id="WixUI_Font_Title" FaceName="Tahoma" Size="9" Bold="yes" \
/&gt; +
+            &lt;Property Id="DefaultUIFont" Value="WixUI_Font_Normal" /&gt;
+            &lt;Property Id="WixUI_Mode" Value="Tor" /&gt;
+
+            &lt;DialogRef Id="ErrorDlg" /&gt;
+            &lt;DialogRef Id="FatalError" /&gt;
+            &lt;DialogRef Id="FilesInUse" /&gt;
+            &lt;DialogRef Id="MsiRMFilesInUse" /&gt;
+            &lt;DialogRef Id="PrepareDlg" /&gt;
+            &lt;DialogRef Id="ProgressDlg" /&gt;
+            &lt;DialogRef Id="ResumeDlg" /&gt;
+            &lt;DialogRef Id="UserExit" /&gt;
+
+            &lt;Publish Dialog="ExitDialog" Control="Finish" Event="EndDialog" \
Value="Return" Order="999"&gt;1&lt;/Publish&gt; +
+            &lt;Publish Dialog="WelcomeDlg" Control="Next" Event="NewDialog" \
Value="SetupTypeDlg"&gt;1&lt;/Publish&gt; +
+            &lt;Publish Dialog="SetupTypeDlg" Control="Back" Event="NewDialog" \
Value="WelcomeDlg"&gt;1&lt;/Publish&gt; +            &lt;Publish Dialog="SetupTypeDlg" \
Control="TypicalButton" Event="NewDialog" Value="VerifyReadyDlg"&gt;1&lt;/Publish&gt; +        \
&lt;Publish Dialog="SetupTypeDlg" Control="CustomButton" Event="NewDialog" \
Value="CustomizeDlg"&gt;1&lt;/Publish&gt; +
+            &lt;Publish Dialog="CustomizeDlg" Control="Back" Event="NewDialog" \
Value="MaintenanceTypeDlg" Order="1"&gt;WixUI_InstallMode = "Change"&lt;/Publish&gt; +         \
&lt;Publish Dialog="CustomizeDlg" Control="Back" Event="NewDialog" Value="SetupTypeDlg" \
Order="2"&gt;WixUI_InstallMode = "InstallCustom"&lt;/Publish&gt; +            &lt;Publish \
Dialog="CustomizeDlg" Control="Next" Event="NewDialog" \
Value="VerifyReadyDlg"&gt;1&lt;/Publish&gt; +
+            &lt;Publish Dialog="VerifyReadyDlg" Control="Back" Event="NewDialog" \
Value="CustomizeDlg" Order="1"&gt;WixUI_InstallMode = "InstallCustom"&lt;/Publish&gt; +        \
&lt;Publish Dialog="VerifyReadyDlg" Control="Back" Event="NewDialog" \
Value="SetupTypeDlg" Order="2"&gt;WixUI_InstallMode = "InstallTypical" OR \
WixUI_InstallMode = "InstallComplete"&lt;/Publish&gt; +            &lt;Publish \
Dialog="VerifyReadyDlg" Control="Back" Event="NewDialog" Value="CustomizeDlg" \
Order="3"&gt;WixUI_InstallMode = "Change"&lt;/Publish&gt; +            &lt;Publish \
Dialog="VerifyReadyDlg" Control="Back" Event="NewDialog" Value="MaintenanceTypeDlg" \
Order="4"&gt;WixUI_InstallMode = "Repair" OR WixUI_InstallMode = "Remove"&lt;/Publish&gt; +
+            &lt;Publish Dialog="MaintenanceWelcomeDlg" Control="Next" Event="NewDialog" \
Value="MaintenanceTypeDlg"&gt;1&lt;/Publish&gt; +
+            &lt;Publish Dialog="MaintenanceTypeDlg" Control="ChangeButton" \
Event="NewDialog" Value="CustomizeDlg"&gt;1&lt;/Publish&gt; +            &lt;Publish \
Dialog="MaintenanceTypeDlg" Control="RepairButton" Event="NewDialog" \
Value="VerifyReadyDlg"&gt;1&lt;/Publish&gt; +            &lt;Publish Dialog="MaintenanceTypeDlg" \
Control="RemoveButton" Event="NewDialog" Value="VerifyReadyDlg"&gt;1&lt;/Publish&gt; +         \
&lt;Publish Dialog="MaintenanceTypeDlg" Control="Back" Event="NewDialog" \
Value="MaintenanceWelcomeDlg"&gt;1&lt;/Publish&gt; +        &lt;/UI&gt;
+
+        &lt;UIRef Id="WixUI_Common" /&gt;
+    &lt;/Fragment&gt;
+&lt;/Wix&gt;
diff -Naur orig-tor/contrib/tor.wxs.in mod-tor/contrib/tor.wxs.in
--- orig-tor/contrib/tor.wxs.in	1970-01-01 00:00:00.000000000 +0000
+++ mod-tor/contrib/tor.wxs.in	2008-11-29 11:12:43.043946768 +0000
@@ -0,0 +1,245 @@
+&lt;?xml version="1.0" encoding="Windows-1252" ?&gt;
+&lt;!-- 
+  WiX is a Microsoft Installer tool that parses an installation specification XML \
document +  and produces an MSI package for use on updated Windows 2000 and newer \
systems. +
+  The MSI package format provides some advantages over the existing NSIS packages \
when used +  in an automated fashion.  A modified version of the Mondo UI installer \
is included without +  EULA and other unnecessary dialogs.  You must update the UIRef \
element below to change UI. +
+  Compile MSI installer via WiX: 
+    candle.exe contrib/*.wxs
+    light.exe *.wixobj -out tor.msi -ext C:\Path\to\Wix\bin\WixUIExtension.dll
+
+  A silent installation can be performed with a /quiet option passed.
+    misexec /i tor.msi INSTALLDIR=C:\path\to\install\to /qn
+
+  A repair operation can be performed with /f and remove via /x
+
+  More msiexec command line details at: \
http://technet.microsoft.com/en-us/library/cc759262.aspx + --&gt;
+&lt;Wix xmlns="http://schemas.microsoft.com/wix/2006/wi"&gt;
+  &lt;Product
+    Name="Tor"
+    Id="1449ef81-e295-43e5-91ac-81b7da0e2024"
+    UpgradeCode="64323a0c-9712-4a7a-8db8-d3c5c0b963df"
+    Version="0.2.1.7"
+    Manufacturer="The Tor Project, Inc."
+    Language="1033" Codepage="1252"&gt;
+   
+    &lt;!-- Commong package definitions.  Most of these elements are self explanatory \
or do not need modification. +         Note that there is no support for signature \
verification nor patched upgrades at this time. +      --&gt; 
+    &lt;Package
+      Id="*"
+      Keywords="Installer"
+      Description="Tor Installer"
+      Manufacturer="The Tor Project, Inc."
+      Compressed="yes"
+      InstallerVersion="100"
+      Languages="1033"
+      SummaryCodepage="1252"
+    /&gt;
+    &lt;Media
+      Id="1"
+      Cabinet="Tor.cab"
+      CompressionLevel="high"
+      EmbedCab="yes"
+      DiskPrompt="na"
+    /&gt;
+    &lt;Property
+      Id="DiskPrompt"
+      Value="Tor Installation"
+    /&gt;
+
+    &lt;!-- Most of the installation directives are for populating the "Program Files" \
directory +         with the Tor binaries, dynamic link libraries, configuration \
files, and other documents. +      --&gt;
+    &lt;Directory Id="TARGETDIR" Name="SourceDir"&gt;
+      &lt;Directory Id="ProgramFilesFolder" Name="ProgramFilesDir"&gt;
+        &lt;Directory Id="INSTALLDIR" Name="Tor"&gt;
+
+          &lt;!-- Tor application file --&gt;
+          &lt;Component Id="TorExecutable" Guid="219e0538-7f7f-4445-8406-e4f06ba22417"&gt;
+            &lt;File
+              Id="TorExe"
+              Name="Tor.exe"
+              Source="bin\tor.exe"
+              Vital="yes"
+              DiskId="1"
+            /&gt;
+          &lt;/Component&gt;
+
+          &lt;!-- Tor configuration files
+               The sample config is always kept up to date and the torrc is left as \
is +               if it exists and copied from the sample config otherwise.
+            --&gt;
+          &lt;Component Id="TorConfigFile" Guid="1dae9705-0bef-4588-be36-d8a5df5e47cc"&gt;
+            &lt;File
+              Id="TorSampleConfig"
+              Name="torrc.sample"
+              Source="src\config\torrc.sample"
+              Vital="yes"
+              ReadOnly="yes"
+              DiskId="1"
+            &gt;
+              &lt;CopyFile
+                Id="TorConfig"
+                DestinationName="torrc"
+              /&gt;
+            &lt;/File&gt;
+          &lt;/Component&gt;
+
+          &lt;!-- Tor OpenSSL shared libraries
+               This optional component is required for shared builds of Tor.  For \
static builds it is ignored. +            --&gt;
+          &lt;Component Id="OpenSSLLibrary" \
Guid="4d99fd44-dc24-46c6-8825-25b9e5916b85"&gt; +            &lt;File
+              Id="cryptoeay32dll"
+              Name="cryptoeay32-0.9.8.dll"
+              Source="bin/cryptoeay32-0.9.8.dll"
+              DiskId="1"
+            /&gt;
+            &lt;File
+              Id="ssleay32dll"
+              Name="ssleay32-0.9.8.dll"
+              Source="bin/ssleay32-0.9.8.dll"
+              DiskId="1"
+            /&gt;
+          &lt;/Component&gt;
+
+          &lt;!-- msys shared libraries 
+               This optional component is required for shared builds of Tor.  For \
static builds it is ignored. +            --&gt;
+          &lt;Component Id="MSYSLibrary" Guid="451ffc02-2666-410e-984f-35fb303b05a2"&gt;
+            &lt;File
+              Id="msyszdll"
+              Name="msys-z.dll"
+              Source="bin/msys-z.dll"
+              DiskId="1"
+            /&gt;
+            &lt;File
+              Id="msys10dll"
+              Name="msys-1.0.dll"
+              Source="bin/msys-1.0.dll"
+              DiskId="1"
+            /&gt;
+          &lt;/Component&gt;
+
+          &lt;!-- Tor docs --&gt;
+          &lt;Component Id="TorDocuments" Guid="3def35f6-70a0-44af-813a-f96bc8462748"&gt;
+            &lt;File
+              Id="TorReadme"
+              Name="README"
+              Source="README"
+              DiskId="1"
+            /&gt;
+            &lt;File
+              Id="TorAuthors"
+              Name="Authors"
+              Source="Authors"
+              DiskId="1"
+            /&gt;
+            &lt;File
+              Id="TorChangelog"
+              Name="ChangeLog"
+              Source="ChangeLog"
+              DiskId="1"
+            /&gt;
+            &lt;File
+              Id="TorLicense"
+              Name="LICENSE"
+              Source="LICENSE"
+              DiskId="1"
+            /&gt;
+          &lt;/Component&gt;
+        &lt;/Directory&gt;
+      &lt;/Directory&gt;
+
+      &lt;!-- Create shortcuts if requested
+           Remember that shortcuts must always be tied to a "key" registry value for \
proper repair and removal. +        --&gt;
+      &lt;Directory Id="ProgramMenuFolder" Name="Programs"&gt;
+        &lt;Directory Id="ShortcutFolder" Name="Tor"&gt;
+          &lt;Component Id="AddTorToStartMenu" \
Guid="a318c037-e1ed-481c-983d-4a0ad3810ba0"&gt; +            &lt;RegistryKey Root="HKCU" \
Key="Software\Tor" Action="createAndRemoveOnUninstall"&gt; +              &lt;RegistryValue \
Name="StartMenuShortcut" Value="1" Type="integer" KeyPath="yes" /&gt; +            \
&lt;/RegistryKey&gt; +            &lt;Shortcut Id="TorStartMenuShortcut"
+                      Name="Tor" Target="[INSTALLDIR]tor.exe"
+                      Directory="ShortcutFolder" WorkingDirectory="INSTALLDIR"
+                      Icon="tor.ico" IconIndex="0" /&gt;
+            &lt;RemoveFolder Id="RemoveShortcutFolder" On="uninstall" /&gt;
+          &lt;/Component&gt;
+        &lt;/Directory&gt;
+      &lt;/Directory&gt;
+
+      &lt;Directory Id="DesktopFolder" Name="Desktop"&gt;
+        &lt;Component Id="AddTorToDesktop" Guid="9a00d5c1-1d5d-4a62-864e-f53f79b3c77a"&gt;
+          &lt;RegistryKey Root="HKCU" Key="Software\Tor" \
Action="createAndRemoveOnUninstall"&gt; +            &lt;RegistryValue \
Name="DesktopShortcut" Value="1" Type="integer" KeyPath="yes" /&gt; +          \
&lt;/RegistryKey&gt; +          &lt;Shortcut Id="TorDesktopShortcut"
+                    Name="Tor" Target="[INSTALLDIR]tor.exe"
+                    Directory="DesktopFolder" WorkingDirectory="INSTALLDIR"
+                    Icon="tor.ico" IconIndex="0" /&gt;
+        &lt;/Component&gt;
+      &lt;/Directory&gt;
+
+      &lt;!-- Current version registry info
+           This value can be used by third party applications to query for the \
current version installed on the system. +        --&gt;
+      &lt;Component Id="TorRegistry" Guid="575de318-a649-49fe-95e5-ee091f6cb8c6"&gt;
+        &lt;RegistryKey Root="HKLM" Key="SOFTWARE\Microsoft\Windows\CurrentVersion\Tor"
+          Action="createAndRemoveOnUninstall"&gt;
+          &lt;RegistryValue Name="Version" Value="@VERSION@" Type="string" \
KeyPath="yes" /&gt; +        &lt;/RegistryKey&gt;
+      &lt;/Component&gt;
+
+    &lt;/Directory&gt;
+
+    &lt;!-- Define list of application features available for install
+         There are two main sections to this list.  The "MainApplication" section \
which defines a core +         set of mandatory files and setup and the other \
optional components like shortcuts which are not +         required for functional \
installation. +      --&gt;
+    &lt;Feature Id="Complete" Title="Tor"
+             Level="1" Display="expand" ConfigurableDirectory="INSTALLDIR"
+             Description="Tor is an implementation of Onion Routing. You can read \
more at https://www.torproject.org/"&gt; +
+      &lt;!-- Core files and setup tasks that must always be included in installation \
--&gt; +      &lt;Feature Id="MainApplication" Title="Tor Application"
+               AllowAdvertise="no" Absent="disallow" Level="1"
+               Description="Main Tor application"&gt;
+        &lt;ComponentRef Id="TorExecutable" /&gt;
+        &lt;ComponentRef Id="TorConfigFile" /&gt;
+        &lt;ComponentRef Id="OpenSSLLibrary" /&gt;
+        &lt;ComponentRef Id="MSYSLibrary" /&gt;
+        &lt;ComponentRef Id="TorDocuments" /&gt;
+        &lt;ComponentRef Id="TorRegistry" /&gt; 
+      &lt;/Feature&gt;
+
+      &lt;!-- Shorcuts on the Start Menu and Desktop are optional but provided by \
default. --&gt; +      &lt;Feature Id="Shortcuts" Title="Shortcuts"
+               AllowAdvertise="no" Absent="allow" Level="1"
+               Description="Add shortcuts to Tor."&gt;
+        &lt;Feature Id="StartMenuShortcuts" Title="Add to Start menu"
+                 AllowAdvertise="no" Absent="allow" Level="1"
+                 Description="Add Tor to your Start menu"&gt;
+          &lt;ComponentRef Id="AddTorToStartMenu" /&gt;
+        &lt;/Feature&gt;
+        &lt;Feature Id="DesktopShortcuts" Title="Add to Desktop"
+                 AllowAdvertise="no" Absent="allow" Level="1"
+                 Description="Add Tor to your Desktop"&gt;
+          &lt;ComponentRef Id="AddTorToDesktop" /&gt;
+        &lt;/Feature&gt;
+      &lt;/Feature&gt;
+    &lt;/Feature&gt;
+
+    &lt;!-- Set the UI options
+         Use a custom UI sequence to avoid EULA and other extraneous parts of Mondo \
and other GUIs +      --&gt;
+    &lt;UIRef Id="WixUI_Tor" /&gt;
+    &lt;Icon Id="tor.ico" SourceFile="contrib/tor.ico" /&gt;
+  &lt;/Product&gt;
+&lt;/Wix&gt;



</body></email><email><emailId>20081009115757</emailId><senderName>Smuggler</senderName><senderEmail>smuggler@kryptohippie.com</senderEmail><timestampReceived>2008-10-09 11:57:57-0400</timestampReceived><subject>Re: Brainstorming about Tor, Germany, and data retention</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Lexi Pimenidis wrote:
&gt; On Thu, Oct 09, 2008 at 06:29:00AM CEST, Smuggler wrote:
&gt; 
&gt;&gt; The issue is mostly the part of the law that concerns "replacement of
&gt;&gt; addresses". Basically every node would need to log the original IP and
&gt;&gt; the new IP of a connection as well as the time when the connection
&gt;&gt; started and ended.
&gt;&gt;
&gt;&gt; "Anonymisierungsdienste speichern die ursprüngliche und die neue Angabe
&gt;&gt; sowie des Zeitpunktes der Umschreibung dieser Angaben nach Datum und
&gt;&gt; Uhrzeit unter Angabe der zugrunde liegenden Zeitzone"
&gt;&gt;
&gt;&gt; The problem here is that the "Technische Richtlinie" (technical
&gt;&gt; directive) has not yet been adapted to the law and/or not yet publicized.
&gt; 
&gt; Although I've heared recently that "small nodes" (like personal devices for 
&gt; NAT as used for sharing single DSL-lines) will not fall under the directive.
&gt; 
&gt; Maybe it's possible to exploit this loophole?
&gt; 
&gt; -- Lexi
&gt; 

The law is for "public telecommunications providers". A personal/company
NAT gateway is not public. A wifi hotspot is not public if it can only
be reached from the premises of the provider.
So... not a loophole for Tor :(
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.7 (Darwin)

iD8DBQFI7fHCOMmnRrmEoQkRAjBMAKDCPHaA2U0vDkunWAFAV72pd10rcQCg0LMo
XuUsr98DJvgtG2ugcx8osFo=
=Nynw
-----END PGP SIGNATURE-----

</body></email><email><emailId>20081009143911</emailId><senderName>Camilo Viecco</senderName><senderEmail>cviecco@anml.iu.edu</senderEmail><timestampReceived>2008-10-09 14:39:11-0400</timestampReceived><subject>udp transport (take 2)</subject><body>

There is a new version of the udp tor POC code. Again this is a
demonstration of how I think things could be done, to have better
performance.

For the people new in this list. The code presented here is a POC of an
anonymity system that uses end-to-end TCP congestion
control to have better network performance (in latency) and fairer (as
in fair as TCP is)  use of the network resources of TOR.
As it is it provides less anonymity than tor but is a work in progress.

As client, the system creates a virtual tunnel through which anonymous
communication will pass. At the other end of the
tunnel a socks server handles communication.

To test the  goodness: try downloading several large files (say some
linux distros) while googling for something. The interactive browsing
will not be (significantly) affected by the load of the udp-tor network.

Impovements:
- Tested now in Linux 2.6 (386,x86_64,MIPS) and OSX (ppc (10.4) and i386
(10.5))
- Primitive filtering of TCP options
- Dynamic network -&gt; downloadable network status and network updates.
- Transparent socks (for packets routed through the virtual interface
and not destined to the SOCKS server)
- More sane output (still too verbose).

Fixes:
- No need to patch broken libdnet (wrapped broken functions)
- Faster cleanup of stale state.

Things to do:
- Add udp transport (for vpn like functionality, no need to worry about
dns leaks)
 -Add TCP ssl entry for servers.
- Add autentication of network updates.
- Add rate limiting of non responsive circuits.
- Make it workable under win32/vista (long term).


Currently the exit nodes are COTS 'home routers' (WRT54GL) each
providing up to 212KB/sec throughput.

Code is available at:
http://www.cs.indiana.edu/~cviecco/oscode/tdor/tdor-0.0.6.tar.gz
http://www.cs.indiana.edu/~cviecco/oscode/tdor/tdor-0.0.6.tar.gz.asc


Have a nice day and please try the system, you will pleasantly surprised
by how well it performs

Camilo Viecco
/***************************************************
Key fingerprint = 0781 10A0 44CC C441 594F  E5A9 858A 173E 3EC5 EA42
**************************************************/


</body></email><email><emailId>20081011012947</emailId><senderName>"John Brooks"</senderName><senderEmail>aspecialj@gmail.com</senderEmail><timestampReceived>2008-10-11 01:29:47-0400</timestampReceived><subject>Random note from TODO.021</subject><body>

One of the items in TODO.021 (under Steven) is:

  - Figure out (or give up on) how to run Tor Browser and ordinary
    Firefox side-by-side.

If this is still unsolved, I can provide the answer - I had the same
problem awhile ago with my own PortableFirefox/Tor setup. Firefox
reads some settings when it starts from a .ini in the same directory
and with the same name as the firefox binary (i.e.
FirefoxPortable.ini, or Firefox.ini). Create that file if it doesn't
exist. The setting you want is:

[FirefoxPortable]
AllowMultipleInstances=true

When set to true, this will allow multiple copies of firefox (from the
same or different binaries) to start, and does not need to be set on
any other copies of firefox that are used.

Hope that helps.

- John Brooks
</body></email><email><emailId>20081015213552</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2008-10-15 21:35:52-0400</timestampReceived><subject>Re: Patches for proposal 155: Four Improvements of Hidden Service Performance</subject><body>

On Wed, Oct 15, 2008 at 10:33:00AM +0200, Karsten Loesing wrote:
&gt; &gt;&gt; Index: /home/karsten/tor/tor-trunk-155-patch2/ChangeLog
&gt; &gt; 
&gt; &gt; Isn't this patch a smaller version of patch4? That is, if we started
&gt; &gt; enough circuits to begin with, can we just skip this step? It seems
&gt; &gt; odd to apply both patch2 and patch4, and it seems like patch4 is the
&gt; &gt; more general.
&gt; 
&gt; Ah no, this patch affects circuit extension to an introduction point on
&gt; client side, whereas patch 4 deals with establishing introduction points
&gt; by the service.

Ah ha. I've clarified the changelog entries then, and committed it.

&gt; &gt;&gt; Index: /home/karsten/tor/tor-trunk-155-patch3/ChangeLog
&gt; 
&gt; All in all, I'd say we hold back this patch for now until we know better
&gt; whether this is a problem at all. It probably wouldn't hurt to add it.
&gt; But it doesn't make sense to add this much new complexity (your proposed
&gt; code change reduces that to some extend, but still) for an uncertain effect.

Ok. We'll skip it for now.

&gt; &gt;&gt; Index: /home/karsten/tor/tor-trunk-155-patch4/ChangeLog
&gt; &gt;&gt; ===================================================================
&gt; &gt;&gt; +    - Start building more server-side introduction circuits than needed
&gt; &gt;&gt; +      (five), pick the first three that succeed, and use the others as
&gt; &gt;&gt; +      general-purpose circuits.
&gt; &gt; 
&gt; &gt; Looks plausible. I'm going to review the patch more tomorrow and then
&gt; &gt; check it (or something like it) in.

I've checked it in, along with a clarifying comment so the next person
to try to figure out this crazy design has a prayer. :)
http://archives.seul.org/or/cvs/Oct-2008/msg00089.html

Thanks!
--Roger

</body></email><email><emailId>20081021201251</emailId><senderName>Robert Hogan</senderName><senderEmail>robert@roberthogan.net</senderEmail><timestampReceived>2008-10-21 20:12:51-0400</timestampReceived><subject>Re: Tracking Blocked Ports</subject><body>


Just a note on the patch, storing the digest of each router that uses the port 
is a bit of a memory hog, and its only real purpose is to provide a count of 
routers using that port when warning the user. That could be achieved when 
warning the user by iterating through the routerlist instead.

On Tuesday 14 October 2008 23:16:12 Robert Hogan wrote:
&gt; Motivation:
&gt; Tor clients that are behind extremely restrictive firewalls can end up
&gt; waiting a while for their first successful OR connection to a node on the
&gt; network. Worse, the more restrictive their firewall the more susceptible
&gt; they are to an attacker guessing their entry nodes. Tor routers that are
&gt; behind extremely restrictive firewalls can only offer a limited,
&gt; 'partitioned' service to other routers and clients on the network. Exit
&gt; nodes behind extremely restrictive firewalls may advertise ports that they
&gt; are actually not able to connect to, wasting network resources in circuit
&gt; constructions that are doomed to fail at the last hop on first use.
&gt;
&gt; Proposal:
&gt;
&gt; When a client attempts to connect to an entry guard it should avoid further
&gt; attempts on ports that fail once until it has connected to at least one
&gt; entry guard successfully. (Maybe it should wait for more than one failure
&gt; to reduce the skew on the first node selection.) Thereafter it should
&gt; select entry guards regardless of port and warn the user if it observes
&gt; that connections to a given port have failed every multiple of 5 times
&gt; without success or since the last success.
&gt;
&gt; Tor should warn the operators of exit, middleman and entry nodes if it
&gt; observes that connections to a given port have failed a multiple of 5 times
&gt; without success or since the last success. If attempts on a port fail 20 or
&gt; more times without or since success, Tor should add the port to a
&gt; 'blocked-ports' entry in its descriptor's extra-info. Some thought needs to
&gt; be given to what the authorities might do with this information.
&gt;
&gt; Related TODO item:
&gt;     "- Automatically determine what ports are reachable and start using
&gt;       those, if circuits aren't working and it's a pattern we
&gt;       recognize ("port 443 worked once and port 9001 keeps not
&gt;       working")."
&gt;
&gt;
&gt; I've had a go at implementing all of this in the attached.



["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20081121235516</emailId><senderName>"Kyle Williams"</senderName><senderEmail>kyle.kwilliams@gmail.com</senderEmail><timestampReceived>2008-11-21 23:55:16-0400</timestampReceived><subject>=?WINDOWS-1252?Q?Re:_[Announce]_Introducing_Tor?= =?WINDOWS-1252?Q?_VM_=96_Tor_in_a_virtual_machine.</subject><body>

It's been over a week, and I've seen several dozen downloads since I posted
this.Does anyone have any feedback?

- Kyle

On Wed, Nov 12, 2008 at 1:27 AM, Kyle Williams &lt;kyle.kwilliams@gmail.com&gt;wrote:

&gt; http://www.janusvm.com/tor_vm/
&gt;
&gt;
&gt;  Tor VM is a small virtual machine that acts as a router and redirects
&gt; your TCP traffic and DNS request through Tor while filtering out protocols
&gt; that could jeopardize your anonymity. Tor VM is built using all open source
&gt; software and is free.
&gt;
&gt;
&gt;  There are many advantages to running Tor in a virtual machine. Any
&gt; application on any operating system that uses TCP for communication is
&gt; routed over Tor. By using a small virtual machine that acts as a router,
&gt; protocols such as UDP and ICMP are filtered, preventing a compromise of your
&gt; anonymity. Placing Tor in a virtual machine separates Tor from potentially
&gt; insecure applications that could compromises Tor's integrity and your
&gt; security.
&gt;
&gt;
&gt;  The Tor VM ISO is designed to be run in a virtual machine, not on
&gt; physical hardware. The ISO requires two virtual NICs to be used; one bridged
&gt; interface, one OpenVPN Tun/Tap adapter. The Windows build of Tor VM is
&gt; portable and includes QEMU to run the virtual machine, but requires
&gt; Administrator privileges to install the Tap32 adapter. Traffic is routed
&gt; through the Tap interface, into the VM, TCP and DNS are directed to Tor's
&gt; Transport while other protocols are discarded, then Tor does it's magic with
&gt; your traffic. More details can be found in the design documentation.
&gt;
&gt;
&gt;  Lots of people are going to ask "What's the difference between JanusVM
&gt; and Tor VM?", so I'll address this now. JanusVM was designed to be used by
&gt; multiple users, runs HTTP traffic through Squid and Privoxy, and was build
&gt; on top of Debian packages. Tor VM is built from entirely 100% open source
&gt; software, is pre-configured to support only a single user, is much smaller
&gt; in size, uses less memory than JanusVM, and works with QEMU. Is Tor VM going
&gt; to replace JanusVM?? It's too soon to tell.
&gt;
&gt;
&gt;  This software is in the late alpha stages of development; work is still
&gt; in progress. For the time being, Tor VM is being hosted on the JanusVM
&gt; server. Martin and I would appreciate it if a few of you would give Tor VM a
&gt; go and provide us with your feedback. Feel free to review the We look
&gt; forward to hearing from the community.
&gt;
&gt;
&gt;  One last thing. Mad props to coderman! Martin did an amazing job hacking
&gt; QEMU and the WinPCAP drivers in order to create an interface that is a raw
&gt; bridge into the existing network card. This is just as good as VMware bridge
&gt; service, if not better! It's Amazing work; make sure to take a close look at
&gt; what is under the hood. Tor VM wouldn't have been possible if it wasn't for
&gt; his insane amount of knowledge and skill. Let me be the first to say it;
&gt; Thank You. :)
&gt;
&gt;
&gt;
&gt;  Best Regards,
&gt;
&gt;
&gt;  Kyle Williams
&gt;

[Attachment #3 (text/html)]

It's been over a week, and I've seen several dozen downloads since I posted \
this.&lt;div&gt;Does anyone have any feedback?&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;- \
Kyle&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;div class="gmail_quote"&gt;On Wed, Nov 12, 2008 at 1:27 AM, Kyle \
Williams &lt;span dir="ltr"&gt;&lt;&lt;a \
href="mailto:kyle.kwilliams@gmail.com"&gt;kyle.kwilliams@gmail.com&lt;/a&gt;&gt;&lt;/span&gt; \
wrote:&lt;br&gt; &lt;blockquote class="gmail_quote" style="margin:0 0 0 .8ex;border-left:1px \
#ccc solid;padding-left:1ex;"&gt; &lt;p style="margin-bottom:0in"&gt;&lt;font size="3"&gt;&lt;a \
href="http://www.janusvm.com/tor_vm/" \
target="_blank"&gt;http://www.janusvm.com/tor_vm/&lt;/a&gt;&lt;/font&gt;&lt;/p&gt; &lt;p \
style="margin-bottom:0in"&gt;&lt;br&gt; &lt;/p&gt;
&lt;p style="margin-bottom:0in"&gt;&lt;font size="3"&gt;	Tor VM is a small virtual
machine that acts as a router and redirects your TCP traffic and DNS
request through Tor while filtering out protocols that could
jeopardize your anonymity.  Tor VM is built using all open source
software and is free.&lt;/font&gt;&lt;/p&gt;
&lt;p style="margin-bottom:0in"&gt;&lt;br&gt;
&lt;/p&gt;
&lt;p style="margin-bottom:0in"&gt;&lt;font size="3"&gt;	There are many advantages
to running Tor in a virtual machine.  Any application on any
operating system that uses TCP for communication is routed over Tor. 
By using a small virtual machine that acts as a router, protocols
such as UDP and ICMP are filtered, preventing a compromise of your
anonymity.  Placing Tor in a virtual machine separates Tor from
potentially insecure applications that could compromises Tor's
integrity and your security.  &lt;/font&gt;
&lt;/p&gt;
&lt;p style="margin-bottom:0in"&gt;&lt;br&gt;
&lt;/p&gt;
&lt;p style="margin-bottom:0in"&gt;&lt;font size="3"&gt;	The Tor VM ISO is
designed to be run in a virtual machine, not on physical hardware. 
The ISO requires two virtual NICs to be used; one bridged interface,
one OpenVPN Tun/Tap adapter.  The Windows build of Tor VM is portable
and includes QEMU to run the virtual machine, but requires
Administrator privileges to install the Tap32 adapter.  Traffic is
routed through the Tap interface, into the VM, TCP and DNS are
directed to Tor's Transport while other protocols are discarded, then
Tor does it's magic with your traffic.  More details can be found in
the design documentation.&lt;/font&gt;&lt;/p&gt;
&lt;p style="margin-bottom:0in"&gt;&lt;br&gt;
&lt;/p&gt;
&lt;p style="margin-bottom:0in"&gt;&lt;font size="3"&gt;	Lots of people are going
to ask "What's the difference between JanusVM and Tor VM?", so
I'll address this now.  JanusVM was designed to be used by multiple
users, runs HTTP traffic through Squid and Privoxy, and was build on
top of Debian packages.  Tor VM is built from entirely 100% open
source software, is pre-configured to support only a single user, is
much smaller in size, uses less memory than JanusVM, and works with
QEMU.  Is Tor VM going to replace JanusVM??  It's too soon to tell.&lt;/font&gt;&lt;/p&gt;
&lt;p style="margin-bottom:0in"&gt;&lt;br&gt;
&lt;/p&gt;
&lt;p style="margin-bottom:0in"&gt;&lt;font size="3"&gt;	This software is in the
late alpha stages of development; work is still in progress.  For the
time being, Tor VM is being hosted on the JanusVM server.  Martin and
I would appreciate it if a few of you would give Tor VM a go and
provide us with your feedback.  Feel free to review the We look
forward to hearing from the community.  &lt;/font&gt;
&lt;/p&gt;
&lt;p style="margin-bottom:0in"&gt;&lt;br&gt;
&lt;/p&gt;
&lt;p style="margin-bottom:0in"&gt;&lt;font size="3"&gt;	One last thing.  Mad
props to coderman! Martin did an amazing job hacking QEMU and the
WinPCAP drivers in order to create an interface that is a raw bridge
into the existing network card.  This is just as good as VMware
bridge service, if not better!  It's Amazing work; make sure to take
a close look at what is under the hood.  Tor VM wouldn't have been
possible if it wasn't for his insane amount of knowledge and skill. 
Let me be the first to say it; Thank You.  :)&lt;/font&gt;&lt;/p&gt;

&lt;p style="margin-bottom:0in"&gt;&lt;br&gt;
&lt;/p&gt;
&lt;p style="margin-bottom:0in"&gt;&lt;br&gt;
&lt;/p&gt;
&lt;p style="margin-bottom:0in"&gt;&lt;font size="3"&gt;Best Regards,&lt;/font&gt;&lt;/p&gt;
&lt;p style="margin-bottom:0in"&gt;&lt;br&gt;
&lt;/p&gt;
&lt;p style="margin-bottom:0in"&gt;&lt;font size="3"&gt;Kyle Williams&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;/div&gt;&lt;br&gt;&lt;/div&gt;



</body></email><email><emailId>20081122080353</emailId><senderName>"Dmitriy Kazimirov"</senderName><senderEmail>dkazimirow@gmail.com</senderEmail><timestampReceived>2008-11-22 08:03:53-0400</timestampReceived><subject>=?WINDOWS-1252?Q?Re:_[Announce]_Introducing_Tor?= =?WINDOWS-1252?Q?_VM_=96_Tor_in_a_virtual_machine.</subject><body>

At least one issue:
It does not work on windows xp sp2 with Intel Pro/Wireless 2200BG WiFi card
saying that it cannot switch to promisc mode


2008/11/22 Kyle Williams &lt;kyle.kwilliams@gmail.com&gt;

&gt; It's been over a week, and I've seen several dozen downloads since I posted
&gt; this.Does anyone have any feedback?
&gt;
&gt; - Kyle
&gt;
&gt; On Wed, Nov 12, 2008 at 1:27 AM, Kyle Williams &lt;kyle.kwilliams@gmail.com&gt;wrote:
&gt;
&gt;&gt; http://www.janusvm.com/tor_vm/
&gt;&gt;
&gt;&gt;
&gt;&gt;  Tor VM is a small virtual machine that acts as a router and redirects
&gt;&gt; your TCP traffic and DNS request through Tor while filtering out protocols
&gt;&gt; that could jeopardize your anonymity. Tor VM is built using all open source
&gt;&gt; software and is free.
&gt;&gt;
&gt;&gt;
&gt;&gt;  There are many advantages to running Tor in a virtual machine. Any
&gt;&gt; application on any operating system that uses TCP for communication is
&gt;&gt; routed over Tor. By using a small virtual machine that acts as a router,
&gt;&gt; protocols such as UDP and ICMP are filtered, preventing a compromise of your
&gt;&gt; anonymity. Placing Tor in a virtual machine separates Tor from potentially
&gt;&gt; insecure applications that could compromises Tor's integrity and your
&gt;&gt; security.
&gt;&gt;
&gt;&gt;
&gt;&gt;  The Tor VM ISO is designed to be run in a virtual machine, not on
&gt;&gt; physical hardware. The ISO requires two virtual NICs to be used; one bridged
&gt;&gt; interface, one OpenVPN Tun/Tap adapter. The Windows build of Tor VM is
&gt;&gt; portable and includes QEMU to run the virtual machine, but requires
&gt;&gt; Administrator privileges to install the Tap32 adapter. Traffic is routed
&gt;&gt; through the Tap interface, into the VM, TCP and DNS are directed to Tor's
&gt;&gt; Transport while other protocols are discarded, then Tor does it's magic with
&gt;&gt; your traffic. More details can be found in the design documentation.
&gt;&gt;
&gt;&gt;
&gt;&gt;  Lots of people are going to ask "What's the difference between JanusVM
&gt;&gt; and Tor VM?", so I'll address this now. JanusVM was designed to be used by
&gt;&gt; multiple users, runs HTTP traffic through Squid and Privoxy, and was build
&gt;&gt; on top of Debian packages. Tor VM is built from entirely 100% open source
&gt;&gt; software, is pre-configured to support only a single user, is much smaller
&gt;&gt; in size, uses less memory than JanusVM, and works with QEMU. Is Tor VM going
&gt;&gt; to replace JanusVM?? It's too soon to tell.
&gt;&gt;
&gt;&gt;
&gt;&gt;  This software is in the late alpha stages of development; work is still
&gt;&gt; in progress. For the time being, Tor VM is being hosted on the JanusVM
&gt;&gt; server. Martin and I would appreciate it if a few of you would give Tor VM a
&gt;&gt; go and provide us with your feedback. Feel free to review the We look
&gt;&gt; forward to hearing from the community.
&gt;&gt;
&gt;&gt;
&gt;&gt;  One last thing. Mad props to coderman! Martin did an amazing job hacking
&gt;&gt; QEMU and the WinPCAP drivers in order to create an interface that is a raw
&gt;&gt; bridge into the existing network card. This is just as good as VMware bridge
&gt;&gt; service, if not better! It's Amazing work; make sure to take a close look at
&gt;&gt; what is under the hood. Tor VM wouldn't have been possible if it wasn't for
&gt;&gt; his insane amount of knowledge and skill. Let me be the first to say it;
&gt;&gt; Thank You. :)
&gt;&gt;
&gt;&gt;
&gt;&gt;
&gt;&gt;  Best Regards,
&gt;&gt;
&gt;&gt;
&gt;&gt;  Kyle Williams
&gt;&gt;
&gt;
&gt;


-- 
--
Best Regards,
Dmitriy Kazimirov,
Senior C++/C# Developer
of ISS Art, Ltd., Omsk, Russia
Web: http://www.issart.com
E-mail: dkazimirov@issart.com

[Attachment #3 (text/html)]

At least one issue:&lt;br&gt;It does not work on windows xp sp2 with Intel Pro/Wireless \
2200BG WiFi card saying that it cannot switch to promisc mode&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;div \
class="gmail_quote"&gt;2008/11/22 Kyle Williams &lt;span dir="ltr"&gt;&lt;&lt;a \
href="mailto:kyle.kwilliams@gmail.com"&gt;kyle.kwilliams@gmail.com&lt;/a&gt;&gt;&lt;/span&gt;&lt;br&gt; \
&lt;blockquote class="gmail_quote" style="border-left: 1px solid rgb(204, 204, 204); \
margin: 0pt 0pt 0pt 0.8ex; padding-left: 1ex;"&gt;It's been over a week, and \
I've seen several dozen downloads since I posted this.&lt;div&gt; Does anyone have any \
feedback?&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;font color="#888888"&gt;&lt;div&gt;- \
Kyle&lt;/div&gt;&lt;/font&gt;&lt;div&gt;&lt;div&gt;&lt;/div&gt;&lt;div class="Wj3C7c"&gt;&lt;div&gt;&lt;br&gt;&lt;div \
class="gmail_quote"&gt;On Wed, Nov 12, 2008 at 1:27 AM, Kyle Williams &lt;span \
dir="ltr"&gt;&lt;&lt;a href="mailto:kyle.kwilliams@gmail.com" \
target="_blank"&gt;kyle.kwilliams@gmail.com&lt;/a&gt;&gt;&lt;/span&gt; wrote:&lt;br&gt;

&lt;blockquote class="gmail_quote" style="border-left: 1px solid rgb(204, 204, 204); \
margin: 0pt 0pt 0pt 0.8ex; padding-left: 1ex;"&gt; &lt;p style="margin-bottom: 0in;"&gt;&lt;font \
size="3"&gt;&lt;a href="http://www.janusvm.com/tor_vm/" \
target="_blank"&gt;http://www.janusvm.com/tor_vm/&lt;/a&gt;&lt;/font&gt;&lt;/p&gt; &lt;p \
style="margin-bottom: 0in;"&gt;&lt;br&gt; &lt;/p&gt;
&lt;p style="margin-bottom: 0in;"&gt;&lt;font size="3"&gt;	Tor VM is a small virtual
machine that acts as a router and redirects your TCP traffic and DNS
request through Tor while filtering out protocols that could
jeopardize your anonymity.  Tor VM is built using all open source
software and is free.&lt;/font&gt;&lt;/p&gt;
&lt;p style="margin-bottom: 0in;"&gt;&lt;br&gt;
&lt;/p&gt;
&lt;p style="margin-bottom: 0in;"&gt;&lt;font size="3"&gt;	There are many advantages
to running Tor in a virtual machine.  Any application on any
operating system that uses TCP for communication is routed over Tor. 
By using a small virtual machine that acts as a router, protocols
such as UDP and ICMP are filtered, preventing a compromise of your
anonymity.  Placing Tor in a virtual machine separates Tor from
potentially insecure applications that could compromises Tor's
integrity and your security.  &lt;/font&gt;
&lt;/p&gt;
&lt;p style="margin-bottom: 0in;"&gt;&lt;br&gt;
&lt;/p&gt;
&lt;p style="margin-bottom: 0in;"&gt;&lt;font size="3"&gt;	The Tor VM ISO is
designed to be run in a virtual machine, not on physical hardware. 
The ISO requires two virtual NICs to be used; one bridged interface,
one OpenVPN Tun/Tap adapter.  The Windows build of Tor VM is portable
and includes QEMU to run the virtual machine, but requires
Administrator privileges to install the Tap32 adapter.  Traffic is
routed through the Tap interface, into the VM, TCP and DNS are
directed to Tor's Transport while other protocols are discarded, then
Tor does it's magic with your traffic.  More details can be found in
the design documentation.&lt;/font&gt;&lt;/p&gt;
&lt;p style="margin-bottom: 0in;"&gt;&lt;br&gt;
&lt;/p&gt;
&lt;p style="margin-bottom: 0in;"&gt;&lt;font size="3"&gt;	Lots of people are going
to ask "What's the difference between JanusVM and Tor VM?", so
I'll address this now.  JanusVM was designed to be used by multiple
users, runs HTTP traffic through Squid and Privoxy, and was build on
top of Debian packages.  Tor VM is built from entirely 100% open
source software, is pre-configured to support only a single user, is
much smaller in size, uses less memory than JanusVM, and works with
QEMU.  Is Tor VM going to replace JanusVM??  It's too soon to tell.&lt;/font&gt;&lt;/p&gt;
&lt;p style="margin-bottom: 0in;"&gt;&lt;br&gt;
&lt;/p&gt;
&lt;p style="margin-bottom: 0in;"&gt;&lt;font size="3"&gt;	This software is in the
late alpha stages of development; work is still in progress.  For the
time being, Tor VM is being hosted on the JanusVM server.  Martin and
I would appreciate it if a few of you would give Tor VM a go and
provide us with your feedback.  Feel free to review the We look
forward to hearing from the community.  &lt;/font&gt;
&lt;/p&gt;
&lt;p style="margin-bottom: 0in;"&gt;&lt;br&gt;
&lt;/p&gt;
&lt;p style="margin-bottom: 0in;"&gt;&lt;font size="3"&gt;	One last thing.  Mad
props to coderman! Martin did an amazing job hacking QEMU and the
WinPCAP drivers in order to create an interface that is a raw bridge
into the existing network card.  This is just as good as VMware
bridge service, if not better!  It's Amazing work; make sure to take
a close look at what is under the hood.  Tor VM wouldn't have been
possible if it wasn't for his insane amount of knowledge and skill. 
Let me be the first to say it; Thank You.  :)&lt;/font&gt;&lt;/p&gt;

&lt;p style="margin-bottom: 0in;"&gt;&lt;br&gt;
&lt;/p&gt;
&lt;p style="margin-bottom: 0in;"&gt;&lt;br&gt;
&lt;/p&gt;
&lt;p style="margin-bottom: 0in;"&gt;&lt;font size="3"&gt;Best Regards,&lt;/font&gt;&lt;/p&gt;
&lt;p style="margin-bottom: 0in;"&gt;&lt;br&gt;
&lt;/p&gt;
&lt;p style="margin-bottom: 0in;"&gt;&lt;font size="3"&gt;Kyle Williams&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;/div&gt;&lt;br&gt;&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/blockquote&gt;&lt;/div&gt;&lt;br&gt;&lt;br clear="all"&gt;&lt;br&gt;-- &lt;br&gt;--&lt;br&gt;Best \
Regards,&lt;br&gt;Dmitriy Kazimirov,&lt;br&gt;Senior C++/C# Developer&lt;br&gt;of ISS Art, Ltd., Omsk, \
                Russia&lt;br&gt;Web: &lt;a \
                href="http://www.issart.com"&gt;http://www.issart.com&lt;/a&gt;&lt;br&gt;
E-mail: &lt;a href="mailto:dkazimirov@issart.com"&gt;dkazimirov@issart.com&lt;/a&gt;&lt;br&gt;



</body></email><email><emailId>20081127043906</emailId><senderName>coderman</senderName><senderEmail>coderman@gmail.com</senderEmail><timestampReceived>2008-11-27 04:39:06-0400</timestampReceived><subject>PATCH: preliminary support for MSI based package builds via WiX toolset</subject><body>

attached is a patch for preliminary MSI installer support via WiX.
you will need a copy of visual studio (2005, 2008 of any flavor
including Express) to build the MSI package.

a test of this installer can be performed using one of the development
snapshots compiled at:
http://peertech.org/torbld/info/Tor-mod-svn-Thandy
just copy and invoke the tor.msi file on the detail page for a
successful build and follow the prompts.

A silent installation can be performed with a /quiet option passed:
ec /i tor.msi /qn

A repair operation can be performed with /f and remove via /x

More msiexec command line details at:
http://technet.microsoft.com/en-us/library/cc759262.aspx

best regards,

["tor-wixmsi.patch" (text/x-patch)]

diff -Naur orig-tor/configure.in mod-tor/configure.in
--- orig-tor/configure.in	2008-11-09 23:32:38.649936000 +0000
+++ mod-tor/configure.in	2008-11-27 03:42:31.335943536 +0000
@@ -818,7 +818,7 @@
 
 CPPFLAGS="$CPPFLAGS $TOR_CPPFLAGS_libevent $TOR_CPPFLAGS_openssl $TOR_CPPFLAGS_zlib"
 
-AC_CONFIG_FILES([Makefile tor.spec Doxyfile contrib/tor.sh contrib/torctl \
contrib/torify contrib/tor.logrotate contrib/Makefile contrib/osx/Makefile \
contrib/osx/TorBundleDesc.plist contrib/osx/TorBundleInfo.plist \
contrib/osx/TorDesc.plist contrib/osx/TorInfo.plist contrib/osx/TorStartupDesc.plist \
src/config/torrc.sample doc/tor.1 src/Makefile doc/Makefile doc/design-paper/Makefile \
doc/spec/Makefile src/config/Makefile src/common/Makefile src/or/Makefile \
src/win32/Makefile src/tools/Makefile contrib/suse/Makefile contrib/suse/tor.sh]) \
+AC_CONFIG_FILES([Makefile tor.spec Doxyfile contrib/tor.sh contrib/torctl \
contrib/torify contrib/tor.logrotate contrib/Makefile contrib/osx/Makefile \
contrib/osx/TorBundleDesc.plist contrib/osx/TorBundleInfo.plist \
contrib/osx/TorDesc.plist contrib/osx/TorInfo.plist contrib/osx/TorStartupDesc.plist \
src/config/torrc.sample doc/tor.1 src/Makefile doc/Makefile doc/design-paper/Makefile \
doc/spec/Makefile src/config/Makefile src/common/Makefile src/or/Makefile \
src/win32/Makefile src/tools/Makefile contrib/suse/Makefile contrib/suse/tor.sh \
contrib/tor.wxs])  AC_OUTPUT
 
 if test -x /usr/bin/perl &amp;&amp; test -x ./contrib/updateVersions.pl ; then
diff -Naur orig-tor/contrib/tor.wxs.in mod-tor/contrib/tor.wxs.in
--- orig-tor/contrib/tor.wxs.in	1970-01-01 00:00:00.000000000 +0000
+++ mod-tor/contrib/tor.wxs.in	2008-11-27 04:18:15.385998384 +0000
@@ -0,0 +1,212 @@
+&lt;?xml version='1.0' encoding='Windows-1252' ?&gt;
+&lt;!-- 
+  Compile MSI installer via WiX: 
+    candle.exe contrib/tor.wxs
+    light.exe contrib/tor.wixobj -out tor.msi -ext \
C:\Path\to\Wix\bin\WixUIExtension.dll +
+  A silent installation can be performed with a /quiet option passed.
+    misexec /i tor.msi INSTALLDIR=C:\path\to\install\to /qn
+
+  A repair operation can be performed with /f and remove via /x
+
+  More msiexec command line details at: \
http://technet.microsoft.com/en-us/library/cc759262.aspx + --&gt;
+&lt;Wix xmlns='http://schemas.microsoft.com/wix/2006/wi'&gt;
+  &lt;Product
+    Name='Tor'
+    Id='1449ef81-e295-43e5-91ac-81b7da0e2024'
+    UpgradeCode='64323a0c-9712-4a7a-8db8-d3c5c0b963df'
+    &lt;!-- due to MSI spec this must be of the dotted form int.int.int.int without any \
non-integer parts in any quad value --&gt; +    Version='0.2.1.7'
+    Manufacturer='The Tor Project, Inc.'
+    Language='1033' Codepage='1252'&gt;
+    
+    &lt;Package
+      Id='*'
+      Keywords='Installer'
+      Description='Tor Installer'
+      Manufacturer='The Tor Project, Inc.'
+      InstallerVersion='100'
+      Compressed='yes'
+      Languages='1033'
+      SummaryCodepage='1252'
+    /&gt;
+    &lt;Media
+      Id='1'
+      Cabinet='Tor.cab'
+      CompressionLevel='high'
+      EmbedCab='yes'
+      DiskPrompt='na'
+    /&gt;
+    &lt;Property
+      Id='DiskPrompt'
+      Value='Tor Installation'
+    /&gt;
+
+    &lt;Directory Id='TARGETDIR' Name='SourceDir'&gt;
+      &lt;Directory Id='ProgramFilesFolder' Name='ProgramFilesDir'&gt;
+        &lt;Directory Id='INSTALLDIR' Name='Tor'&gt;
+
+          &lt;!-- Tor application file --&gt;
+          &lt;Component Id='TorExecutable' Guid='219e0538-7f7f-4445-8406-e4f06ba22417'&gt;
+            &lt;File
+              Id='TorExe'
+              Name='Tor.exe'
+              Source='bin\tor.exe'
+              Vital='yes'
+              DiskId='1'
+            /&gt;
+          &lt;/Component&gt;
+
+          &lt;!-- Tor configuration files --&gt;
+          &lt;Component Id='TorConfigFile' Guid='1dae9705-0bef-4588-be36-d8a5df5e47cc'&gt;
+            &lt;File
+              Id='TorSampleConfig'
+              Name='torrc.sample'
+              Source='src\config\torrc.sample'
+              Vital='yes'
+              ReadOnly='yes'
+              DiskId='1'
+            &gt;
+              &lt;CopyFile
+                Id='TorConfig'
+                DestinationName='torrc'
+              /&gt;
+            &lt;/File&gt;
+          &lt;/Component&gt;
+
+          &lt;!-- Tor OpenSSL shared libraries --&gt;
+          &lt;Component Id='OpenSSLLibrary' \
Guid='4d99fd44-dc24-46c6-8825-25b9e5916b85'&gt; +            &lt;File
+              Id='cryptoeay32dll'
+              Name='cryptoeay32-0.9.8.dll'
+              Source='bin/cryptoeay32-0.9.8.dll'
+              DiskId='1'
+            /&gt;
+            &lt;File
+              Id='ssleay32dll'
+              Name='ssleay32-0.9.8.dll'
+              Source='bin/ssleay32-0.9.8.dll'
+              DiskId='1'
+            /&gt;
+          &lt;/Component&gt;
+
+          &lt;!-- msys shared libraries --&gt;
+          &lt;Component Id='MSYSLibrary' Guid='451ffc02-2666-410e-984f-35fb303b05a2'&gt;
+            &lt;File
+              Id='msyszdll'
+              Name='msys-z.dll'
+              Source='bin/msys-z.dll'
+              DiskId='1'
+            /&gt;
+            &lt;File
+              Id='msys10dll'
+              Name='msys-1.0.dll'
+              Source='bin/msys-1.0.dll'
+              DiskId='1'
+            /&gt;
+          &lt;/Component&gt;
+
+          &lt;!-- Tor docs --&gt;
+          &lt;Component Id='TorDocuments' Guid='3def35f6-70a0-44af-813a-f96bc8462748'&gt;
+            &lt;File
+              Id='TorReadme'
+              Name='README'
+              Source='README'
+              DiskId='1'
+            /&gt;
+            &lt;File
+              Id='TorAuthors'
+              Name='Authors'
+              Source='Authors'
+              DiskId='1'
+            /&gt;
+            &lt;File
+              Id='TorChangelog'
+              Name='ChangeLog'
+              Source='ChangeLog'
+              DiskId='1'
+            /&gt;
+            &lt;File
+              Id='TorLicense'
+              Name='LICENSE'
+              Source='LICENSE'
+              DiskId='1'
+            /&gt;
+          &lt;/Component&gt;
+        &lt;/Directory&gt;
+      &lt;/Directory&gt;
+
+      &lt;!-- Create shortcuts if needed --&gt;
+      &lt;Directory Id='ProgramMenuFolder' Name='Programs'&gt;
+        &lt;Directory Id='ShortcutFolder' Name='Tor'&gt;
+          &lt;Component Id='AddTorToStartMenu' \
Guid='a318c037-e1ed-481c-983d-4a0ad3810ba0'&gt; +            &lt;RegistryKey Root='HKCU' \
Key='Software\Tor' Action='createAndRemoveOnUninstall'&gt; +              &lt;RegistryValue \
Name='StartMenuShortcut' Value='1' Type='integer' KeyPath='yes' /&gt; +            \
&lt;/RegistryKey&gt; +            &lt;Shortcut Id='TorStartMenuShortcut'
+                      Name='Tor' Target='[INSTALLDIR]tor.exe'
+                      Directory='ShortcutFolder' WorkingDirectory='INSTALLDIR'
+                      Icon='tor.ico' IconIndex='0' /&gt;
+            &lt;RemoveFolder Id='RemoveShortcutFolder' On='uninstall' /&gt;
+          &lt;/Component&gt;
+        &lt;/Directory&gt;
+      &lt;/Directory&gt;
+
+      &lt;Directory Id='DesktopFolder' Name='Desktop'&gt;
+        &lt;Component Id='AddTorToDesktop' Guid='9a00d5c1-1d5d-4a62-864e-f53f79b3c77a'&gt;
+          &lt;RegistryKey Root='HKCU' Key='Software\Tor' \
Action='createAndRemoveOnUninstall'&gt; +            &lt;RegistryValue \
Name='DesktopShortcut' Value='1' Type='integer' KeyPath='yes' /&gt; +          \
&lt;/RegistryKey&gt; +          &lt;Shortcut Id='TorDesktopShortcut'
+                    Name='Tor' Target='[INSTALLDIR]tor.exe'
+                    Directory='DesktopFolder' WorkingDirectory='INSTALLDIR'
+                    Icon='tor.ico' IconIndex='0' /&gt;
+        &lt;/Component&gt;
+      &lt;/Directory&gt;
+
+      &lt;!-- Current version registry info --&gt;
+      &lt;Component Id='TorRegistry' Guid='575de318-a649-49fe-95e5-ee091f6cb8c6'&gt;
+        &lt;RegistryKey Root='HKLM' Key='SOFTWARE\Microsoft\Windows\CurrentVersion\Tor'
+          Action='createAndRemoveOnUninstall'&gt;
+          &lt;RegistryValue Name='Version' Value='@VERSION@' Type='string' \
KeyPath='yes' /&gt; +        &lt;/RegistryKey&gt;
+      &lt;/Component&gt;
+
+    &lt;/Directory&gt;
+
+    &lt;!-- Application features available --&gt;
+    &lt;Feature Id='Complete' Title='Tor'
+             Level='1' Display='expand' ConfigurableDirectory='INSTALLDIR'
+             Description='Tor is an implementation of Onion Routing. You can read \
more at https://www.torproject.org/'&gt; +      &lt;Feature Id='MainApplication' Title='Tor \
Application' +               AllowAdvertise='no' Absent='disallow' Level='1'
+               Description='Main Tor application'&gt;
+        &lt;ComponentRef Id='TorExecutable' /&gt;
+        &lt;ComponentRef Id='TorConfigFile' /&gt;
+        &lt;ComponentRef Id='OpenSSLLibrary' /&gt;
+        &lt;ComponentRef Id='MSYSLibrary' /&gt;
+        &lt;ComponentRef Id='TorDocuments' /&gt;
+        &lt;ComponentRef Id='TorRegistry' /&gt; 
+      &lt;/Feature&gt;
+      &lt;Feature Id='Shortcuts' Title='Shortcuts'
+               AllowAdvertise='no' Absent='allow' Level='1'
+               Description='Add shortcuts to Tor.'&gt;
+        &lt;Feature Id='StartMenuShortcuts' Title='Add to Start menu'
+                 AllowAdvertise='no' Absent='allow' Level='1'
+                 Description='Add Tor to your Start menu'&gt;
+          &lt;ComponentRef Id='AddTorToStartMenu' /&gt;
+        &lt;/Feature&gt;
+        &lt;Feature Id='DesktopShortcuts' Title='Add to Desktop'
+                 AllowAdvertise='no' Absent='allow' Level='1'
+                 Description='Add Tor to your Desktop'&gt;
+          &lt;ComponentRef Id='AddTorToDesktop' /&gt;
+        &lt;/Feature&gt;
+      &lt;/Feature&gt;
+    &lt;/Feature&gt;
+
+    &lt;!-- Set the UI options, this should probably be "Minimal" until Mondo is better \
supported here --&gt; +    &lt;UIRef Id='WixUI_Mondo' /&gt;
+    &lt;Icon Id='tor.ico' SourceFile='contrib/tor.ico' /&gt;
+  &lt;/Product&gt;
+&lt;/Wix&gt;



</body></email><email><emailId>20081127053323</emailId><senderName>coderman</senderName><senderEmail>coderman@gmail.com</senderEmail><timestampReceived>2008-11-27 05:33:23-0400</timestampReceived><subject>Re: PATCH: preliminary support for MSI based package builds via WiX toolset</subject><body>

i have attached an updated copy that includes some additional comments
about the content of the wxs installer specification document.

it should be noted that this is only a preliminary version not ready
for production use.  there are additional changes to be made before a
end user friendly installer is completed but roger hates it when i
keep large changes out of tree forever.
[and sometimes i hate it too *g* ...]

best regards,


On Wed, Nov 26, 2008 at 8:39 PM, coderman &lt;coderman@gmail.com&gt; wrote:
&gt; attached is a patch for preliminary MSI installer support via WiX.

["tor-wixmsi.patch" (text/x-patch)]

diff -Naur orig-tor/configure.in mod-tor/configure.in
--- orig-tor/configure.in	2008-11-09 23:32:38.649936000 +0000
+++ mod-tor/configure.in	2008-11-27 03:42:31.335943536 +0000
@@ -818,7 +818,7 @@
 
 CPPFLAGS="$CPPFLAGS $TOR_CPPFLAGS_libevent $TOR_CPPFLAGS_openssl $TOR_CPPFLAGS_zlib"
 
-AC_CONFIG_FILES([Makefile tor.spec Doxyfile contrib/tor.sh contrib/torctl \
contrib/torify contrib/tor.logrotate contrib/Makefile contrib/osx/Makefile \
contrib/osx/TorBundleDesc.plist contrib/osx/TorBundleInfo.plist \
contrib/osx/TorDesc.plist contrib/osx/TorInfo.plist contrib/osx/TorStartupDesc.plist \
src/config/torrc.sample doc/tor.1 src/Makefile doc/Makefile doc/design-paper/Makefile \
doc/spec/Makefile src/config/Makefile src/common/Makefile src/or/Makefile \
src/win32/Makefile src/tools/Makefile contrib/suse/Makefile contrib/suse/tor.sh]) \
+AC_CONFIG_FILES([Makefile tor.spec Doxyfile contrib/tor.sh contrib/torctl \
contrib/torify contrib/tor.logrotate contrib/Makefile contrib/osx/Makefile \
contrib/osx/TorBundleDesc.plist contrib/osx/TorBundleInfo.plist \
contrib/osx/TorDesc.plist contrib/osx/TorInfo.plist contrib/osx/TorStartupDesc.plist \
src/config/torrc.sample doc/tor.1 src/Makefile doc/Makefile doc/design-paper/Makefile \
doc/spec/Makefile src/config/Makefile src/common/Makefile src/or/Makefile \
src/win32/Makefile src/tools/Makefile contrib/suse/Makefile contrib/suse/tor.sh \
contrib/tor.wxs])  AC_OUTPUT
 
 if test -x /usr/bin/perl &amp;&amp; test -x ./contrib/updateVersions.pl ; then
diff -Naur orig-tor/contrib/tor.wxs.in mod-tor/contrib/tor.wxs.in
--- orig-tor/contrib/tor.wxs.in	1970-01-01 00:00:00.000000000 +0000
+++ mod-tor/contrib/tor.wxs.in	2008-11-27 05:27:44.131252776 +0000
@@ -0,0 +1,246 @@
+&lt;?xml version='1.0' encoding='Windows-1252' ?&gt;
+&lt;!-- 
+  WiX is a Microsoft Installer tool that parses an installation specification XML \
document +  and produces an MSI package for use on updated Windows 2000 and newer \
systems. +
+  The MSI package format provides some advantages over the existing NSIS packages \
when used +  in an automated fashion.
+
+  Compile MSI installer via WiX: 
+    candle.exe contrib/tor.wxs
+    light.exe contrib/tor.wixobj -out tor.msi -ext \
C:\Path\to\Wix\bin\WixUIExtension.dll +
+  A silent installation can be performed with a /quiet option passed.
+    misexec /i tor.msi INSTALLDIR=C:\path\to\install\to /qn
+
+  A repair operation can be performed with /f and remove via /x
+
+  More msiexec command line details at: \
http://technet.microsoft.com/en-us/library/cc759262.aspx + --&gt;
+&lt;Wix xmlns='http://schemas.microsoft.com/wix/2006/wi'&gt;
+  &lt;Product
+    Name='Tor'
+    Id='1449ef81-e295-43e5-91ac-81b7da0e2024'
+    UpgradeCode='64323a0c-9712-4a7a-8db8-d3c5c0b963df'
+    &lt;!-- Due to MSI spec this must be of the dotted form int.int.int.int without any \
non-integer parts in any quad value --&gt; +    Version='0.2.1.7'
+    Manufacturer='The Tor Project, Inc.'
+    Language='1033' Codepage='1252'&gt;
+   
+    &lt;!-- Commong package definitions.  Most of these elements are self explanatory \
or do not need modification. +      -- Note that there is no support for signature \
verification nor patched upgrades at this time. +      --&gt; 
+    &lt;Package
+      Id='*'
+      Keywords='Installer'
+      Description='Tor Installer'
+      Manufacturer='The Tor Project, Inc.'
+      Compressed='yes'
+      InstallerVersion='100'
+      Languages='1033'
+      SummaryCodepage='1252'
+    /&gt;
+    &lt;Media
+      Id='1'
+      Cabinet='Tor.cab'
+      CompressionLevel='high'
+      EmbedCab='yes'
+      DiskPrompt='na'
+    /&gt;
+    &lt;Property
+      Id='DiskPrompt'
+      Value='Tor Installation'
+    /&gt;
+
+    &lt;!-- Most of the installation directives are for populating the "Program Files" \
directory +      -- with the Tor binaries, dynamic link libraries, configuration \
files, and other documents. +      --&gt;
+    &lt;Directory Id='TARGETDIR' Name='SourceDir'&gt;
+      &lt;Directory Id='ProgramFilesFolder' Name='ProgramFilesDir'&gt;
+        &lt;Directory Id='INSTALLDIR' Name='Tor'&gt;
+
+          &lt;!-- Tor application file --&gt;
+          &lt;Component Id='TorExecutable' Guid='219e0538-7f7f-4445-8406-e4f06ba22417'&gt;
+            &lt;File
+              Id='TorExe'
+              Name='Tor.exe'
+              Source='bin\tor.exe'
+              Vital='yes'
+              DiskId='1'
+            /&gt;
+          &lt;/Component&gt;
+
+          &lt;!-- Tor configuration files
+            -- The sample config is always kept up to date and the torrc is left as \
is +            -- if it exists and copied from the sample config otherwise.
+            --&gt;
+          &lt;Component Id='TorConfigFile' Guid='1dae9705-0bef-4588-be36-d8a5df5e47cc'&gt;
+            &lt;File
+              Id='TorSampleConfig'
+              Name='torrc.sample'
+              Source='src\config\torrc.sample'
+              Vital='yes'
+              ReadOnly='yes'
+              DiskId='1'
+            &gt;
+              &lt;CopyFile
+                Id='TorConfig'
+                DestinationName='torrc'
+              /&gt;
+            &lt;/File&gt;
+          &lt;/Component&gt;
+
+          &lt;!-- Tor OpenSSL shared libraries
+            -- This optional component is required for shared builds of Tor.  For \
static builds it is ignored. +            --&gt;
+          &lt;Component Id='OpenSSLLibrary' \
Guid='4d99fd44-dc24-46c6-8825-25b9e5916b85'&gt; +            &lt;File
+              Id='cryptoeay32dll'
+              Name='cryptoeay32-0.9.8.dll'
+              Source='bin/cryptoeay32-0.9.8.dll'
+              DiskId='1'
+            /&gt;
+            &lt;File
+              Id='ssleay32dll'
+              Name='ssleay32-0.9.8.dll'
+              Source='bin/ssleay32-0.9.8.dll'
+              DiskId='1'
+            /&gt;
+          &lt;/Component&gt;
+
+          &lt;!-- msys shared libraries 
+            -- This optional component is required for shared builds of Tor.  For \
static builds it is ignored. +            --&gt;
+          &lt;Component Id='MSYSLibrary' Guid='451ffc02-2666-410e-984f-35fb303b05a2'&gt;
+            &lt;File
+              Id='msyszdll'
+              Name='msys-z.dll'
+              Source='bin/msys-z.dll'
+              DiskId='1'
+            /&gt;
+            &lt;File
+              Id='msys10dll'
+              Name='msys-1.0.dll'
+              Source='bin/msys-1.0.dll'
+              DiskId='1'
+            /&gt;
+          &lt;/Component&gt;
+
+          &lt;!-- Tor docs --&gt;
+          &lt;Component Id='TorDocuments' Guid='3def35f6-70a0-44af-813a-f96bc8462748'&gt;
+            &lt;File
+              Id='TorReadme'
+              Name='README'
+              Source='README'
+              DiskId='1'
+            /&gt;
+            &lt;File
+              Id='TorAuthors'
+              Name='Authors'
+              Source='Authors'
+              DiskId='1'
+            /&gt;
+            &lt;File
+              Id='TorChangelog'
+              Name='ChangeLog'
+              Source='ChangeLog'
+              DiskId='1'
+            /&gt;
+            &lt;File
+              Id='TorLicense'
+              Name='LICENSE'
+              Source='LICENSE'
+              DiskId='1'
+            /&gt;
+          &lt;/Component&gt;
+        &lt;/Directory&gt;
+      &lt;/Directory&gt;
+
+      &lt;!-- Create shortcuts if requested
+        -- Remember that shortcuts must always be tied to a "key" registry value for \
proper repair and removal. +        --&gt;
+      &lt;Directory Id='ProgramMenuFolder' Name='Programs'&gt;
+        &lt;Directory Id='ShortcutFolder' Name='Tor'&gt;
+          &lt;Component Id='AddTorToStartMenu' \
Guid='a318c037-e1ed-481c-983d-4a0ad3810ba0'&gt; +            &lt;RegistryKey Root='HKCU' \
Key='Software\Tor' Action='createAndRemoveOnUninstall'&gt; +              &lt;RegistryValue \
Name='StartMenuShortcut' Value='1' Type='integer' KeyPath='yes' /&gt; +            \
&lt;/RegistryKey&gt; +            &lt;Shortcut Id='TorStartMenuShortcut'
+                      Name='Tor' Target='[INSTALLDIR]tor.exe'
+                      Directory='ShortcutFolder' WorkingDirectory='INSTALLDIR'
+                      Icon='tor.ico' IconIndex='0' /&gt;
+            &lt;RemoveFolder Id='RemoveShortcutFolder' On='uninstall' /&gt;
+          &lt;/Component&gt;
+        &lt;/Directory&gt;
+      &lt;/Directory&gt;
+
+      &lt;Directory Id='DesktopFolder' Name='Desktop'&gt;
+        &lt;Component Id='AddTorToDesktop' Guid='9a00d5c1-1d5d-4a62-864e-f53f79b3c77a'&gt;
+          &lt;RegistryKey Root='HKCU' Key='Software\Tor' \
Action='createAndRemoveOnUninstall'&gt; +            &lt;RegistryValue \
Name='DesktopShortcut' Value='1' Type='integer' KeyPath='yes' /&gt; +          \
&lt;/RegistryKey&gt; +          &lt;Shortcut Id='TorDesktopShortcut'
+                    Name='Tor' Target='[INSTALLDIR]tor.exe'
+                    Directory='DesktopFolder' WorkingDirectory='INSTALLDIR'
+                    Icon='tor.ico' IconIndex='0' /&gt;
+        &lt;/Component&gt;
+      &lt;/Directory&gt;
+
+      &lt;!-- Current version registry info
+        -- This value can be used by third party applications to query for the \
current version installed on the system. +        --&gt;
+      &lt;Component Id='TorRegistry' Guid='575de318-a649-49fe-95e5-ee091f6cb8c6'&gt;
+        &lt;RegistryKey Root='HKLM' Key='SOFTWARE\Microsoft\Windows\CurrentVersion\Tor'
+          Action='createAndRemoveOnUninstall'&gt;
+          &lt;RegistryValue Name='Version' Value='@VERSION@' Type='string' \
KeyPath='yes' /&gt; +        &lt;/RegistryKey&gt;
+      &lt;/Component&gt;
+
+    &lt;/Directory&gt;
+
+    &lt;!-- Define list of application features available for install
+      -- There are two main sections to this list.  The "MainApplication" section \
which defines a core +      -- set of mandatory files and setup and the other \
optional components like shortcuts which are not +      -- required for functional \
installation. +      --&gt;
+    &lt;Feature Id='Complete' Title='Tor'
+             Level='1' Display='expand' ConfigurableDirectory='INSTALLDIR'
+             Description='Tor is an implementation of Onion Routing. You can read \
more at https://www.torproject.org/'&gt; +
+      &lt;!-- Core files and setup tasks that must always be included in installation \
--&gt; +      &lt;Feature Id='MainApplication' Title='Tor Application'
+               AllowAdvertise='no' Absent='disallow' Level='1'
+               Description='Main Tor application'&gt;
+        &lt;ComponentRef Id='TorExecutable' /&gt;
+        &lt;ComponentRef Id='TorConfigFile' /&gt;
+        &lt;ComponentRef Id='OpenSSLLibrary' /&gt;
+        &lt;ComponentRef Id='MSYSLibrary' /&gt;
+        &lt;ComponentRef Id='TorDocuments' /&gt;
+        &lt;ComponentRef Id='TorRegistry' /&gt; 
+      &lt;/Feature&gt;
+
+      &lt;!-- Shorcuts on the Start Menu and Desktop are optional but provided by \
default. --&gt; +      &lt;Feature Id='Shortcuts' Title='Shortcuts'
+               AllowAdvertise='no' Absent='allow' Level='1'
+               Description='Add shortcuts to Tor.'&gt;
+        &lt;Feature Id='StartMenuShortcuts' Title='Add to Start menu'
+                 AllowAdvertise='no' Absent='allow' Level='1'
+                 Description='Add Tor to your Start menu'&gt;
+          &lt;ComponentRef Id='AddTorToStartMenu' /&gt;
+        &lt;/Feature&gt;
+        &lt;Feature Id='DesktopShortcuts' Title='Add to Desktop'
+                 AllowAdvertise='no' Absent='allow' Level='1'
+                 Description='Add Tor to your Desktop'&gt;
+          &lt;ComponentRef Id='AddTorToDesktop' /&gt;
+        &lt;/Feature&gt;
+      &lt;/Feature&gt;
+    &lt;/Feature&gt;
+
+    &lt;!-- Set the UI options
+      -- The Mondo UI provides a number of common defaults for a generic \
installation process. +      -- There are also Minimal and Custom installation UI \
modes if needed. +      --&gt;
+    &lt;UIRef Id='WixUI_Mondo' /&gt;
+    &lt;Icon Id='tor.ico' SourceFile='contrib/tor.ico' /&gt;
+  &lt;/Product&gt;
+&lt;/Wix&gt;



</body></email><email><emailId>20081128182547</emailId><senderName>coderman</senderName><senderEmail>coderman@gmail.com</senderEmail><timestampReceived>2008-11-28 18:25:47-0400</timestampReceived><subject>Re: PATCH: preliminary support for MSI based package builds via WiX toolset</subject><body>

another syntax update, switch to double quotes from single (make more
parsers happy) and changed from the Mondo UI to the FeatureTree.  this
omits some needless installation type prompts that aren't needed
(yet).

On Wed, Nov 26, 2008 at 9:33 PM, coderman &lt;coderman@gmail.com&gt; wrote:
&gt; i have attached an updated copy...

["tor-wixmsi.patch" (text/x-patch)]

diff -Naur orig-tor/configure.in mod-tor/configure.in
--- orig-tor/configure.in	2008-11-09 23:32:38.649936000 +0000
+++ mod-tor/configure.in	2008-11-27 03:42:31.335943536 +0000
@@ -818,7 +818,7 @@
 
 CPPFLAGS="$CPPFLAGS $TOR_CPPFLAGS_libevent $TOR_CPPFLAGS_openssl $TOR_CPPFLAGS_zlib"
 
-AC_CONFIG_FILES([Makefile tor.spec Doxyfile contrib/tor.sh contrib/torctl \
contrib/torify contrib/tor.logrotate contrib/Makefile contrib/osx/Makefile \
contrib/osx/TorBundleDesc.plist contrib/osx/TorBundleInfo.plist \
contrib/osx/TorDesc.plist contrib/osx/TorInfo.plist contrib/osx/TorStartupDesc.plist \
src/config/torrc.sample doc/tor.1 src/Makefile doc/Makefile doc/design-paper/Makefile \
doc/spec/Makefile src/config/Makefile src/common/Makefile src/or/Makefile \
src/win32/Makefile src/tools/Makefile contrib/suse/Makefile contrib/suse/tor.sh]) \
+AC_CONFIG_FILES([Makefile tor.spec Doxyfile contrib/tor.sh contrib/torctl \
contrib/torify contrib/tor.logrotate contrib/Makefile contrib/osx/Makefile \
contrib/osx/TorBundleDesc.plist contrib/osx/TorBundleInfo.plist \
contrib/osx/TorDesc.plist contrib/osx/TorInfo.plist contrib/osx/TorStartupDesc.plist \
src/config/torrc.sample doc/tor.1 src/Makefile doc/Makefile doc/design-paper/Makefile \
doc/spec/Makefile src/config/Makefile src/common/Makefile src/or/Makefile \
src/win32/Makefile src/tools/Makefile contrib/suse/Makefile contrib/suse/tor.sh \
contrib/tor.wxs])  AC_OUTPUT
 
 if test -x /usr/bin/perl &amp;&amp; test -x ./contrib/updateVersions.pl ; then
diff -Naur orig-tor/contrib/tor.wxs.in mod-tor/contrib/tor.wxs.in
--- orig-tor/contrib/tor.wxs.in	1970-01-01 00:00:00.000000000 +0000
+++ mod-tor/contrib/tor.wxs.in	2008-11-28 18:22:20.119032200 +0000
@@ -0,0 +1,245 @@
+&lt;?xml version="1.0" encoding="Windows-1252" ?&gt;
+&lt;!-- 
+  WiX is a Microsoft Installer tool that parses an installation specification XML \
document +  and produces an MSI package for use on updated Windows 2000 and newer \
systems. +
+  The MSI package format provides some advantages over the existing NSIS packages \
when used +  in an automated fashion.
+
+  Compile MSI installer via WiX: 
+    candle.exe contrib/tor.wxs
+    light.exe contrib/tor.wixobj -out tor.msi -ext \
C:\Path\to\Wix\bin\WixUIExtension.dll +
+  A silent installation can be performed with a /quiet option passed.
+    misexec /i tor.msi INSTALLDIR=C:\path\to\install\to /qn
+
+  A repair operation can be performed with /f and remove via /x
+
+  More msiexec command line details at: \
http://technet.microsoft.com/en-us/library/cc759262.aspx + --&gt;
+&lt;Wix xmlns="http://schemas.microsoft.com/wix/2006/wi"&gt;
+  &lt;Product
+    Name="Tor"
+    Id="1449ef81-e295-43e5-91ac-81b7da0e2024"
+    UpgradeCode="64323a0c-9712-4a7a-8db8-d3c5c0b963df"
+    Version="0.2.1.7"
+    Manufacturer="The Tor Project, Inc."
+    Language="1033" Codepage="1252"&gt;
+   
+    &lt;!-- Commong package definitions.  Most of these elements are self explanatory \
or do not need modification. +         Note that there is no support for signature \
verification nor patched upgrades at this time. +      --&gt; 
+    &lt;Package
+      Id="*"
+      Keywords="Installer"
+      Description="Tor Installer"
+      Manufacturer="The Tor Project, Inc."
+      Compressed="yes"
+      InstallerVersion="100"
+      Languages="1033"
+      SummaryCodepage="1252"
+    /&gt;
+    &lt;Media
+      Id="1"
+      Cabinet="Tor.cab"
+      CompressionLevel="high"
+      EmbedCab="yes"
+      DiskPrompt="na"
+    /&gt;
+    &lt;Property
+      Id="DiskPrompt"
+      Value="Tor Installation"
+    /&gt;
+
+    &lt;!-- Most of the installation directives are for populating the "Program Files" \
directory +         with the Tor binaries, dynamic link libraries, configuration \
files, and other documents. +      --&gt;
+    &lt;Directory Id="TARGETDIR" Name="SourceDir"&gt;
+      &lt;Directory Id="ProgramFilesFolder" Name="ProgramFilesDir"&gt;
+        &lt;Directory Id="INSTALLDIR" Name="Tor"&gt;
+
+          &lt;!-- Tor application file --&gt;
+          &lt;Component Id="TorExecutable" Guid="219e0538-7f7f-4445-8406-e4f06ba22417"&gt;
+            &lt;File
+              Id="TorExe"
+              Name="Tor.exe"
+              Source="bin\tor.exe"
+              Vital="yes"
+              DiskId="1"
+            /&gt;
+          &lt;/Component&gt;
+
+          &lt;!-- Tor configuration files
+               The sample config is always kept up to date and the torrc is left as \
is +               if it exists and copied from the sample config otherwise.
+            --&gt;
+          &lt;Component Id="TorConfigFile" Guid="1dae9705-0bef-4588-be36-d8a5df5e47cc"&gt;
+            &lt;File
+              Id="TorSampleConfig"
+              Name="torrc.sample"
+              Source="src\config\torrc.sample"
+              Vital="yes"
+              ReadOnly="yes"
+              DiskId="1"
+            &gt;
+              &lt;CopyFile
+                Id="TorConfig"
+                DestinationName="torrc"
+              /&gt;
+            &lt;/File&gt;
+          &lt;/Component&gt;
+
+          &lt;!-- Tor OpenSSL shared libraries
+               This optional component is required for shared builds of Tor.  For \
static builds it is ignored. +            --&gt;
+          &lt;Component Id="OpenSSLLibrary" \
Guid="4d99fd44-dc24-46c6-8825-25b9e5916b85"&gt; +            &lt;File
+              Id="cryptoeay32dll"
+              Name="cryptoeay32-0.9.8.dll"
+              Source="bin/cryptoeay32-0.9.8.dll"
+              DiskId="1"
+            /&gt;
+            &lt;File
+              Id="ssleay32dll"
+              Name="ssleay32-0.9.8.dll"
+              Source="bin/ssleay32-0.9.8.dll"
+              DiskId="1"
+            /&gt;
+          &lt;/Component&gt;
+
+          &lt;!-- msys shared libraries 
+               This optional component is required for shared builds of Tor.  For \
static builds it is ignored. +            --&gt;
+          &lt;Component Id="MSYSLibrary" Guid="451ffc02-2666-410e-984f-35fb303b05a2"&gt;
+            &lt;File
+              Id="msyszdll"
+              Name="msys-z.dll"
+              Source="bin/msys-z.dll"
+              DiskId="1"
+            /&gt;
+            &lt;File
+              Id="msys10dll"
+              Name="msys-1.0.dll"
+              Source="bin/msys-1.0.dll"
+              DiskId="1"
+            /&gt;
+          &lt;/Component&gt;
+
+          &lt;!-- Tor docs --&gt;
+          &lt;Component Id="TorDocuments" Guid="3def35f6-70a0-44af-813a-f96bc8462748"&gt;
+            &lt;File
+              Id="TorReadme"
+              Name="README"
+              Source="README"
+              DiskId="1"
+            /&gt;
+            &lt;File
+              Id="TorAuthors"
+              Name="Authors"
+              Source="Authors"
+              DiskId="1"
+            /&gt;
+            &lt;File
+              Id="TorChangelog"
+              Name="ChangeLog"
+              Source="ChangeLog"
+              DiskId="1"
+            /&gt;
+            &lt;File
+              Id="TorLicense"
+              Name="LICENSE"
+              Source="LICENSE"
+              DiskId="1"
+            /&gt;
+          &lt;/Component&gt;
+        &lt;/Directory&gt;
+      &lt;/Directory&gt;
+
+      &lt;!-- Create shortcuts if requested
+           Remember that shortcuts must always be tied to a "key" registry value for \
proper repair and removal. +        --&gt;
+      &lt;Directory Id="ProgramMenuFolder" Name="Programs"&gt;
+        &lt;Directory Id="ShortcutFolder" Name="Tor"&gt;
+          &lt;Component Id="AddTorToStartMenu" \
Guid="a318c037-e1ed-481c-983d-4a0ad3810ba0"&gt; +            &lt;RegistryKey Root="HKCU" \
Key="Software\Tor" Action="createAndRemoveOnUninstall"&gt; +              &lt;RegistryValue \
Name="StartMenuShortcut" Value="1" Type="integer" KeyPath="yes" /&gt; +            \
&lt;/RegistryKey&gt; +            &lt;Shortcut Id="TorStartMenuShortcut"
+                      Name="Tor" Target="[INSTALLDIR]tor.exe"
+                      Directory="ShortcutFolder" WorkingDirectory="INSTALLDIR"
+                      Icon="tor.ico" IconIndex="0" /&gt;
+            &lt;RemoveFolder Id="RemoveShortcutFolder" On="uninstall" /&gt;
+          &lt;/Component&gt;
+        &lt;/Directory&gt;
+      &lt;/Directory&gt;
+
+      &lt;Directory Id="DesktopFolder" Name="Desktop"&gt;
+        &lt;Component Id="AddTorToDesktop" Guid="9a00d5c1-1d5d-4a62-864e-f53f79b3c77a"&gt;
+          &lt;RegistryKey Root="HKCU" Key="Software\Tor" \
Action="createAndRemoveOnUninstall"&gt; +            &lt;RegistryValue \
Name="DesktopShortcut" Value="1" Type="integer" KeyPath="yes" /&gt; +          \
&lt;/RegistryKey&gt; +          &lt;Shortcut Id="TorDesktopShortcut"
+                    Name="Tor" Target="[INSTALLDIR]tor.exe"
+                    Directory="DesktopFolder" WorkingDirectory="INSTALLDIR"
+                    Icon="tor.ico" IconIndex="0" /&gt;
+        &lt;/Component&gt;
+      &lt;/Directory&gt;
+
+      &lt;!-- Current version registry info
+           This value can be used by third party applications to query for the \
current version installed on the system. +        --&gt;
+      &lt;Component Id="TorRegistry" Guid="575de318-a649-49fe-95e5-ee091f6cb8c6"&gt;
+        &lt;RegistryKey Root="HKLM" Key="SOFTWARE\Microsoft\Windows\CurrentVersion\Tor"
+          Action="createAndRemoveOnUninstall"&gt;
+          &lt;RegistryValue Name="Version" Value="@VERSION@" Type="string" \
KeyPath="yes" /&gt; +        &lt;/RegistryKey&gt;
+      &lt;/Component&gt;
+
+    &lt;/Directory&gt;
+
+    &lt;!-- Define list of application features available for install
+         There are two main sections to this list.  The "MainApplication" section \
which defines a core +         set of mandatory files and setup and the other \
optional components like shortcuts which are not +         required for functional \
installation. +      --&gt;
+    &lt;Feature Id="Complete" Title="Tor"
+             Level="1" Display="expand" ConfigurableDirectory="INSTALLDIR"
+             Description="Tor is an implementation of Onion Routing. You can read \
more at https://www.torproject.org/"&gt; +
+      &lt;!-- Core files and setup tasks that must always be included in installation \
--&gt; +      &lt;Feature Id="MainApplication" Title="Tor Application"
+               AllowAdvertise="no" Absent="disallow" Level="1"
+               Description="Main Tor application"&gt;
+        &lt;ComponentRef Id="TorExecutable" /&gt;
+        &lt;ComponentRef Id="TorConfigFile" /&gt;
+        &lt;ComponentRef Id="OpenSSLLibrary" /&gt;
+        &lt;ComponentRef Id="MSYSLibrary" /&gt;
+        &lt;ComponentRef Id="TorDocuments" /&gt;
+        &lt;ComponentRef Id="TorRegistry" /&gt; 
+      &lt;/Feature&gt;
+
+      &lt;!-- Shorcuts on the Start Menu and Desktop are optional but provided by \
default. --&gt; +      &lt;Feature Id="Shortcuts" Title="Shortcuts"
+               AllowAdvertise="no" Absent="allow" Level="1"
+               Description="Add shortcuts to Tor."&gt;
+        &lt;Feature Id="StartMenuShortcuts" Title="Add to Start menu"
+                 AllowAdvertise="no" Absent="allow" Level="1"
+                 Description="Add Tor to your Start menu"&gt;
+          &lt;ComponentRef Id="AddTorToStartMenu" /&gt;
+        &lt;/Feature&gt;
+        &lt;Feature Id="DesktopShortcuts" Title="Add to Desktop"
+                 AllowAdvertise="no" Absent="allow" Level="1"
+                 Description="Add Tor to your Desktop"&gt;
+          &lt;ComponentRef Id="AddTorToDesktop" /&gt;
+        &lt;/Feature&gt;
+      &lt;/Feature&gt;
+    &lt;/Feature&gt;
+
+    &lt;!-- Set the UI options
+         The Mondo UI provides a number of common defaults for a generic \
installation process. +         The FeatureTree UI omits some of the installation \
level and other prompts from Mondo. +      --&gt;
+    &lt;UIRef Id="WixUI_FeatureTree" /&gt;
+    &lt;Icon Id="tor.ico" SourceFile="contrib/tor.ico" /&gt;
+  &lt;/Product&gt;
+&lt;/Wix&gt;



</body></email><email><emailId>20081008115749</emailId><senderName>Karsten Loesing</senderName><senderEmail>karsten.loesing@gmx.net</senderEmail><timestampReceived>2008-10-08 11:57:49-0400</timestampReceived><subject>Patches for proposal 155: Four Improvements of Hidden Service Performance</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Hi Nick,

here are the four patches for proposal 155.

I also put some thoughts into generalizing parallel circuit
establishment to all circuits, but for the moment I'd rather stick to
the simple patch 2 here. The two code changes in that patch are exactly
what is needed for on-demand circuit creation; for pre-established
circuits this might be different. Anyway, I hope that the code changes
in patch 2 will give hints for the implementation of a similar behavior
for general circuits.

Thanks,
- --Karsten
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFI7KA70M+WPffBEmURAha6AJ9RubChK9KgQYSfrHpKGNpQrdQBDACgh/ym
9EFy7LAlgtrbcv/rcXrDcx8=
=498Z
-----END PGP SIGNATURE-----

["patch-155-1a.txt" (text/plain)]

Index: /home/karsten/tor/tor-trunk-155-patch1/ChangeLog
===================================================================
--- /home/karsten/tor/tor-trunk-155-patch1/ChangeLog	(revision 17050)
+++ /home/karsten/tor/tor-trunk-155-patch1/ChangeLog	(working copy)
@@ -3,6 +3,8 @@
     - Now NodeFamily and MyFamily config options allow spaces in
       identity fingerprints, so it's easier to paste them in.
       Suggested by Lucky Green.
+    - Reduce extension timeout for introduction circuits from 60 to 30
+      seconds.
 
 
 Changes in version 0.2.1.6-alpha - 2008-09-30
Index: /home/karsten/tor/tor-trunk-155-patch1/src/or/circuituse.c
===================================================================
--- /home/karsten/tor/tor-trunk-155-patch1/src/or/circuituse.c	(revision 17050)
+++ /home/karsten/tor/tor-trunk-155-patch1/src/or/circuituse.c	(working copy)
@@ -251,8 +251,11 @@
 circuit_expire_building(time_t now)
 {
   circuit_t *victim, *circ = global_circuitlist;
-  time_t cutoff = now - get_options()-&gt;CircuitBuildTimeout;
+  time_t cutoff;
+  time_t general_cutoff = now - get_options()-&gt;CircuitBuildTimeout;
   time_t begindir_cutoff = now - get_options()-&gt;CircuitBuildTimeout/2;
+#define REND_INTRO_CIRC_TIMEOUT 30
+  time_t introrend_cutoff = now - REND_INTRO_CIRC_TIMEOUT;
   cpath_build_state_t *build_state;
 
   while (circ) {
@@ -263,11 +266,21 @@
       continue;
 
     build_state = TO_ORIGIN_CIRCUIT(victim)-&gt;build_state;
-    if (victim-&gt;timestamp_created &gt;
-        ((build_state &amp;&amp; build_state-&gt;onehop_tunnel) ?
-         begindir_cutoff : cutoff))
+    if (build_state &amp;&amp; build_state-&gt;onehop_tunnel)
+      cutoff = begindir_cutoff;
+    else if (victim-&gt;purpose == CIRCUIT_PURPOSE_C_INTRODUCING)
+      cutoff = introrend_cutoff;
+    else
+      cutoff = general_cutoff;
+    if (victim-&gt;timestamp_created &gt; cutoff)
       continue; /* it's still young, leave it alone */
 
+    if (victim-&gt;purpose == CIRCUIT_PURPOSE_C_INTRODUCING &amp;&amp;
+        victim-&gt;timestamp_created &lt;= introrend_cutoff &amp;&amp;
+        victim-&gt;timestamp_created &gt; general_cutoff)
+      log_info(LD_REND|LD_CIRC, "Timing out introduction circuit which we "
+               "would not have done if it had been a general circuit.");
+
 #if 0
     /* some debug logs, to help track bugs */
     if (victim-&gt;purpose &gt;= CIRCUIT_PURPOSE_C_INTRODUCING &amp;&amp;


["patch-155-2.txt" (text/plain)]

Index: /home/karsten/tor/tor-trunk-155-patch2/ChangeLog
===================================================================
--- /home/karsten/tor/tor-trunk-155-patch2/ChangeLog	(revision 17050)
+++ /home/karsten/tor/tor-trunk-155-patch2/ChangeLog	(working copy)
@@ -3,6 +3,8 @@
     - Now NodeFamily and MyFamily config options allow spaces in
       identity fingerprints, so it's easier to paste them in.
       Suggested by Lucky Green.
+    - Start extending introduction circuits in parallel after a delay of
+      15 seconds (based on work by Christian Wilms).
 
 
 Changes in version 0.2.1.6-alpha - 2008-09-30
Index: /home/karsten/tor/tor-trunk-155-patch2/src/or/circuituse.c
===================================================================
--- /home/karsten/tor/tor-trunk-155-patch2/src/or/circuituse.c	(revision 17050)
+++ /home/karsten/tor/tor-trunk-155-patch2/src/or/circuituse.c	(working copy)
@@ -194,6 +194,7 @@
 {
   circuit_t *circ, *best=NULL;
   time_t now = time(NULL);
+  int intro_going_on_but_too_old = 0;
 
   tor_assert(conn);
 
@@ -202,9 +203,16 @@
              purpose == CIRCUIT_PURPOSE_C_REND_JOINED);
 
   for (circ=global_circuitlist;circ;circ = circ-&gt;next) {
+#define REND_PARALLEL_INTRO_DELAY 15
     if (!circuit_is_acceptable(circ,conn,must_be_open,purpose,
                                need_uptime,need_internal,now))
       continue;
+    else if (purpose == CIRCUIT_PURPOSE_C_INTRODUCE_ACK_WAIT &amp;&amp;
+             !must_be_open &amp;&amp; circ-&gt;state != CIRCUIT_STATE_OPEN &amp;&amp;
+             circ-&gt;timestamp_created + REND_PARALLEL_INTRO_DELAY &lt; now) {
+      intro_going_on_but_too_old = 1;
+      continue;
+    }
 
     /* now this is an acceptable circ to hand back. but that doesn't
      * mean it's the *best* circ to hand back. try to decide.
@@ -213,6 +221,10 @@
       best = circ;
   }
 
+  if (!best &amp;&amp; intro_going_on_but_too_old)
+    log_info(LD_REND|LD_CIRC, "There is an intro circuit being created "
+             "right now, but it has already taken quite a while. Starting "
+             "one in parallel.");
   return best ? TO_ORIGIN_CIRCUIT(best) : NULL;
 }
 
@@ -1436,6 +1448,7 @@
 
     if (retval &gt; 0) {
       /* one has already sent the intro. keep waiting. */
+      circuit_t *c = NULL;
       tor_assert(introcirc);
       log_info(LD_REND, "Intro circ %d present and awaiting ack (rend %d). "
                "Stalling. (stream %d sec old)",
@@ -1442,6 +1455,20 @@
                introcirc-&gt;_base.n_circ_id,
                rendcirc ? rendcirc-&gt;_base.n_circ_id : 0,
                conn_age);
+      /* abort parallel intro circs, if any */
+      for (c = global_circuitlist; c; c = c-&gt;next) {
+        if (c-&gt;purpose == CIRCUIT_PURPOSE_C_INTRODUCING &amp;&amp;
+            CIRCUIT_IS_ORIGIN(c)) {
+          origin_circuit_t *oc = TO_ORIGIN_CIRCUIT(c);
+          if (oc-&gt;rend_data &amp;&amp;
+              !rend_cmp_service_ids(conn-&gt;rend_data-&gt;onion_address,
+                                    oc-&gt;rend_data-&gt;onion_address)) {
+            log_info(LD_REND|LD_CIRC, "Closing introduction circuit that we "
+                     "built in parallel.");
+            circuit_mark_for_close(c, END_CIRC_REASON_TIMEOUT);
+          }
+        }
+      }
       return 0;
     }
 


["patch-155-3.txt" (text/plain)]

Index: /home/karsten/tor/tor-trunk-155-patch3/ChangeLog
===================================================================
--- /home/karsten/tor/tor-trunk-155-patch3/ChangeLog	(revision 17050)
+++ /home/karsten/tor/tor-trunk-155-patch3/ChangeLog	(working copy)
@@ -3,6 +3,8 @@
     - Now NodeFamily and MyFamily config options allow spaces in
       identity fingerprints, so it's easier to paste them in.
       Suggested by Lucky Green.
+    - Increase number of server-side introduction points based on number
+      of recent hidden service requests (based on work by Christian Wilms).
 
 
 Changes in version 0.2.1.6-alpha - 2008-09-30
Index: /home/karsten/tor/tor-trunk-155-patch3/src/or/circuituse.c
===================================================================
--- /home/karsten/tor/tor-trunk-155-patch3/src/or/circuituse.c	(revision 17050)
+++ /home/karsten/tor/tor-trunk-155-patch3/src/or/circuituse.c	(working copy)
@@ -464,7 +464,8 @@
   }
 
   /* Third, see if we need any more hidden service (server) circuits. */
-  if (num_rend_services() &amp;&amp; num_uptime_internal &lt; 3) {
+  if (num_rend_services() &amp;&amp;
+      num_uptime_internal &lt; rend_internal_circuits_needed()) {
     flags = (CIRCLAUNCH_NEED_CAPACITY | CIRCLAUNCH_NEED_UPTIME |
              CIRCLAUNCH_IS_INTERNAL);
     log_info(LD_CIRC,
Index: /home/karsten/tor/tor-trunk-155-patch3/src/or/main.c
===================================================================
--- /home/karsten/tor/tor-trunk-155-patch3/src/or/main.c	(revision 17050)
+++ /home/karsten/tor/tor-trunk-155-patch3/src/or/main.c	(working copy)
@@ -841,6 +841,7 @@
   static time_t time_to_recheck_bandwidth = 0;
   static time_t time_to_check_for_expired_networkstatus = 0;
   static time_t time_to_dump_geoip_stats = 0;
+  static time_t time_to_update_request_history = 0;
   or_options_t *options = get_options();
   int i;
   int have_dir_info;
@@ -1169,6 +1170,14 @@
 #define BRIDGE_STATUSFILE_INTERVAL (30*60)
     time_to_write_bridge_status_file = now+BRIDGE_STATUSFILE_INTERVAL;
   }
+
+  /** 11. Update history of requests to our hidden services, so that
+   * we can better estimate the number of internal circuits. */
+  if (time_to_update_request_history &lt; now) {
+    rend_update_request_history(now);
+#define REND_REQUEST_HISTORY_UPDATE_INTERVAL (5 * 60)
+    time_to_update_request_history = now+REND_REQUEST_HISTORY_UPDATE_INTERVAL;
+  }
 }
 
 /** Libevent timer: used to invoke second_elapsed_callback() once per
Index: /home/karsten/tor/tor-trunk-155-patch3/src/or/or.h
===================================================================
--- /home/karsten/tor/tor-trunk-155-patch3/src/or/or.h	(revision 17050)
+++ /home/karsten/tor/tor-trunk-155-patch3/src/or/or.h	(working copy)
@@ -4038,6 +4038,10 @@
 void rend_service_dump_stats(int severity);
 void rend_service_free_all(void);
 
+int rend_internal_circuits_needed(void);
+void rend_update_request_history(time_t now);
+void rend_service_request_history_free_all(void);
+
 /********************************* rendmid.c *******************************/
 int rend_mid_establish_intro(or_circuit_t *circ, const char *request,
                              size_t request_len);
Index: /home/karsten/tor/tor-trunk-155-patch3/src/or/rendservice.c
===================================================================
--- /home/karsten/tor/tor-trunk-155-patch3/src/or/rendservice.c	(revision 17050)
+++ /home/karsten/tor/tor-trunk-155-patch3/src/or/rendservice.c	(working copy)
@@ -831,6 +831,87 @@
   } DIGESTMAP_FOREACH_END;
 }
 
+/*
+ * Logic to record requests to our hidden services and set the number
+ * of pre-established internal circuits appropriately.
+ */
+
+/** The duration of our hidden service request history that we use to
+ * better predict the number of internal circuits. */
+#define REND_REQUEST_HISTORY_PERIOD (15 * 60)
+
+/** Number of requests per minute that justify an additional internal
+ * circuit. */
+#define REND_REQUESTS_INTERNAL_CIRCUITS_RATIO 5
+
+/** The maximum number of internal circuits. */
+#define REND_INTERNAL_CIRCUITS_MAX 12
+
+/** History of request to any of our hidden services that is used to help
+ * predict the number of pre-established internal circuits. */
+static smartlist_t *request_history = NULL;
+
+/** Release all the storage held in last_hid_serv_requests.
+ */
+void
+rend_service_request_history_free_all(void)
+{
+  if (!request_history) {
+    return;
+  }
+  SMARTLIST_FOREACH(request_history, time_t *, r, tor_free(r););
+  request_history = NULL;
+}
+
+/** The number of internal circuits that we should hold in stock as a
+ * function of requests. */
+static int internal_circuits_needed = 3;
+
+/** Add a request to one of our hidden services to the request history. */
+static void
+rend_add_request(time_t now)
+{
+  time_t *request_ptr;
+  if (!request_history)
+    request_history = smartlist_create();
+  request_ptr = tor_malloc_zero(sizeof(time_t *));
+  *request_ptr = now;
+  smartlist_add(request_history, request_ptr);
+}
+
+/** Determine the number of internal circuits that we should hold in stock
+ * in the future and prune too old requests. */
+void
+rend_update_request_history(time_t now)
+{
+  time_t cutoff = 0;
+  int num_requests = 0;
+  if (!request_history)
+    return;
+  cutoff = now - REND_REQUEST_HISTORY_PERIOD;
+  SMARTLIST_FOREACH(request_history, time_t *, t, {
+    if (*t &lt; cutoff) {
+      tor_free(t);
+      SMARTLIST_DEL_CURRENT(request_history, t);
+    } else
+      num_requests++;
+  });
+  internal_circuits_needed = 3 + (num_requests /
+                             (REND_REQUEST_HISTORY_PERIOD / 60 *
+                             REND_REQUESTS_INTERNAL_CIRCUITS_RATIO));
+  if (internal_circuits_needed &gt; REND_INTERNAL_CIRCUITS_MAX)
+    internal_circuits_needed = REND_INTERNAL_CIRCUITS_MAX;
+  log_info(LD_REND, "Setting the number of pre-built internal circuits to %d",
+           internal_circuits_needed);
+}
+
+/** Return the number of internal circuits that we should hold in stock. */
+int
+rend_internal_circuits_needed(void)
+{
+  return internal_circuits_needed;
+}
+
 /******
  * Handle cells
  ******/
@@ -1114,6 +1195,10 @@
   /* help predict this next time */
   rep_hist_note_used_internal(time(NULL), circ_needs_uptime, 1);
 
+  /* Remember service request to better predict the required number
+   * of internal circuits in the future. */
+  rend_add_request(time(NULL));
+
   /* Launch a circuit to alice's chosen rendezvous point.
    */
   for (i=0;i&lt;MAX_REND_FAILURES;i++) {


["patch-155-4.txt" (text/plain)]

Index: /home/karsten/tor/tor-trunk-155-patch4/ChangeLog
===================================================================
--- /home/karsten/tor/tor-trunk-155-patch4/ChangeLog	(revision 17050)
+++ /home/karsten/tor/tor-trunk-155-patch4/ChangeLog	(working copy)
@@ -3,6 +3,9 @@
     - Now NodeFamily and MyFamily config options allow spaces in
       identity fingerprints, so it's easier to paste them in.
       Suggested by Lucky Green.
+    - Start building more server-side introduction circuits than needed
+      (five), pick the first three that succeed, and use the others as
+      general-purpose circuits.
 
 
 Changes in version 0.2.1.6-alpha - 2008-09-30
Index: /home/karsten/tor/tor-trunk-155-patch4/src/or/circuitlist.c
===================================================================
--- /home/karsten/tor/tor-trunk-155-patch4/src/or/circuitlist.c	(revision 17050)
+++ /home/karsten/tor/tor-trunk-155-patch4/src/or/circuitlist.c	(working copy)
@@ -860,6 +860,28 @@
                                      DIGEST_LEN);
 }
 
+/** Return the number of introduction points that are or have been
+ * established for the given service address and rendezvous version. */
+int
+circuit_get_num_intro_points(const char *query, int rend_version)
+{
+  int num_ipos = 0;
+  circuit_t *circ;
+  for (circ = global_circuitlist; circ; circ = circ-&gt;next) {
+    if (!circ-&gt;marked_for_close &amp;&amp;
+        circ-&gt;state == CIRCUIT_STATE_OPEN &amp;&amp;
+        (circ-&gt;purpose == CIRCUIT_PURPOSE_S_ESTABLISH_INTRO ||
+         circ-&gt;purpose == CIRCUIT_PURPOSE_S_INTRO)) {
+      origin_circuit_t *oc = TO_ORIGIN_CIRCUIT(circ);
+      if (oc-&gt;rend_data &amp;&amp;
+          oc-&gt;rend_data-&gt;rend_desc_version == rend_version &amp;&amp;
+          !rend_cmp_service_ids(query, oc-&gt;rend_data-&gt;onion_address))
+        num_ipos++;
+    }
+  }
+  return num_ipos;
+}
+
 /** Return a circuit that is open, is CIRCUIT_PURPOSE_C_GENERAL,
  * has a timestamp_dirty value of 0, has flags matching the CIRCLAUNCH_*
  * flags in &lt;b&gt;flags&lt;/b&gt;, and if info is defined, does not already use info
Index: /home/karsten/tor/tor-trunk-155-patch4/src/or/or.h
===================================================================
--- /home/karsten/tor/tor-trunk-155-patch4/src/or/or.h	(revision 17050)
+++ /home/karsten/tor/tor-trunk-155-patch4/src/or/or.h	(working copy)
@@ -2725,6 +2725,7 @@
                                          const char *digest, uint8_t purpose);
 or_circuit_t *circuit_get_rendezvous(const char *cookie);
 or_circuit_t *circuit_get_intro_point(const char *digest);
+int circuit_get_num_intro_points(const char *query, int rend_version);
 origin_circuit_t *circuit_find_to_cannibalize(uint8_t purpose,
                                               extend_info_t *info, int flags);
 void circuit_mark_all_unused_circs(void);
Index: /home/karsten/tor/tor-trunk-155-patch4/src/or/rendservice.c
===================================================================
--- /home/karsten/tor/tor-trunk-155-patch4/src/or/rendservice.c	(revision 17050)
+++ /home/karsten/tor/tor-trunk-155-patch4/src/or/rendservice.c	(working copy)
@@ -1307,6 +1307,18 @@
     goto err;
   }
 
+  /* If we already have enough introduction circuits, redefine this
+   * one as a general circuit. */
+  if (circuit_get_num_intro_points(serviceid,
+          circuit-&gt;rend_data-&gt;rend_desc_version) &gt; NUM_INTRO_POINTS) {
+    log_info(LD_CIRC|LD_REND, "We have just finished an introduction "
+             "circuit, but we already have enough. Redefining purpose to "
+             "general.");
+    TO_CIRCUIT(circuit)-&gt;purpose = CIRCUIT_PURPOSE_C_GENERAL;
+    circuit_has_opened(circuit);
+    return;
+  }
+
   log_info(LD_REND,
            "Established circuit %d as introduction point for service %s",
            circuit-&gt;_base.n_circ_id, serviceid);
@@ -1823,9 +1835,12 @@
 
     /* Remember how many introduction circuits we started with. */
     prev_intro_nodes = smartlist_len(service-&gt;intro_nodes);
-
-    /* The directory is now here. Pick three ORs as intro points. */
-    for (j=prev_intro_nodes; j &lt; NUM_INTRO_POINTS; ++j) {
+    /* The directory is now here. Pick three ORs as intro points (plus, if
+     * we currently have none at all, two more so that we can pick the first
+     * three afterwards). */
+#define NUM_INTRO_POINTS_INIT (NUM_INTRO_POINTS + 2)
+    for (j=prev_intro_nodes; j &lt; (prev_intro_nodes == 0 ?
+             NUM_INTRO_POINTS_INIT : NUM_INTRO_POINTS); ++j) {
       router_crn_flags_t flags = CRN_NEED_UPTIME;
       if (get_options()-&gt;_AllowInvalid &amp; ALLOW_INVALID_INTRODUCTION)
         flags |= CRN_ALLOW_INVALID;


["patch-155-1a.txt.sig" (application/octet-stream)]
["patch-155-2.txt.sig" (application/octet-stream)]
["patch-155-3.txt.sig" (application/octet-stream)]
["patch-155-4.txt.sig" (application/octet-stream)]

</body></email><email><emailId>20081014221612</emailId><senderName>Robert Hogan</senderName><senderEmail>robert@roberthogan.net</senderEmail><timestampReceived>2008-10-14 22:16:12-0400</timestampReceived><subject>Tracking Blocked Ports</subject><body>

[Attachment #2 (multipart/mixed)]


Motivation:
Tor clients that are behind extremely restrictive firewalls can end up waiting
a while for their first successful OR connection to a node on the network.
Worse, the more restrictive their firewall the more susceptible they are to
an attacker guessing their entry nodes. Tor routers that are behind extremely
restrictive firewalls can only offer a limited, 'partitioned' service to other
routers and clients on the network. Exit nodes behind extremely restrictive
firewalls may advertise ports that they are actually not able to connect to,
wasting network resources in circuit constructions that are doomed to fail at
the last hop on first use.

Proposal:

When a client attempts to connect to an entry guard it should avoid further
attempts on ports that fail once until it has connected to at least one entry
guard successfully. (Maybe it should wait for more than one failure
to reduce the skew on the first node selection.) Thereafter it should
select entry guards regardless of port and warn the user if it observes that
connections to a given port have failed every multiple of 5 times without
success or since the last success.

Tor should warn the operators of exit, middleman and entry nodes if it observes
that connections to a given port have failed a multiple of 5 times without 
success or since the last success. If attempts on a port fail 20 or more times 
without or since success, Tor should add the port to a 'blocked-ports' entry 
in its descriptor's extra-info. Some thought needs to be given to what the 
authorities might do with this information.

Related TODO item:
    "- Automatically determine what ports are reachable and start using
      those, if circuits aren't working and it's a pattern we
      recognize ("port 443 worked once and port 9001 keeps not
      working")."


I've had a go at implementing all of this in the attached.


["porttracking.diff" (text/x-diff)]

Index: src/or/connection_or.c
===================================================================
--- src/or/connection_or.c	(revision 17104)
+++ src/or/connection_or.c	(working copy)
@@ -502,6 +502,9 @@
 connection_or_connect_failed(or_connection_t *conn,
                              int reason, const char *msg)
 {
+  if ((reason == END_OR_CONN_REASON_NO_ROUTE) ||
+      (reason == END_OR_CONN_REASON_REFUSED))
+    or_port_hist_failure(conn-&gt;identity_digest,TO_CONN(conn)-&gt;port);
   control_event_or_conn_status(conn, OR_CONN_EVENT_FAILED, reason);
   if (!authdir_mode_tests_reachability(get_options()))
     control_event_bootstrap_problem(msg, reason);
@@ -580,6 +583,7 @@
     /* already marked for close */
     return NULL;
   }
+
   return conn;
 }
 
@@ -909,6 +913,7 @@
   control_event_or_conn_status(conn, OR_CONN_EVENT_CONNECTED, 0);
 
   if (started_here) {
+    or_port_hist_success(TO_CONN(conn)-&gt;port);
     rep_hist_note_connect_succeeded(conn-&gt;identity_digest, now);
     if (entry_guard_register_connect_status(conn-&gt;identity_digest,
                                             1, now) &lt; 0) {
Index: src/or/rephist.c
===================================================================
--- src/or/rephist.c	(revision 17104)
+++ src/or/rephist.c	(working copy)
@@ -18,6 +18,7 @@
 static void bw_arrays_init(void);
 static void predicted_ports_init(void);
 static void hs_usage_init(void);
+static void or_port_hist_init(void);
 
 /** Total number of bytes currently allocated in fields used by rephist.c. */
 uint64_t rephist_total_alloc=0;
@@ -89,6 +90,25 @@
   digestmap_t *link_history_map;
 } or_history_t;
 
+/** or_port_hist_t contains our router/client's knowledge of
+    all OR ports offered on the network, and how many servers with each port we
+    have succeeded or failed to connect to. */
+typedef struct {
+  /** The port this entry is tracking. */
+  uint16_t or_port;
+  /** Have we ever connected to this port on another OR?. */
+  unsigned int success:1;
+  /** The ORs using this port. */
+  digestmap_t *ids;
+  /** The ORs using this port we have failed to connect to. */
+  digestmap_t *failure_ids;
+  /** Are we excluding ORs with this port during entry selection?*/
+  unsigned int excluded;
+} or_port_hist_t;
+
+static unsigned int still_searching = 0;
+static smartlist_t *or_port_hists;
+
 /** When did we last multiply all routers' weighted_run_length and
  * total_run_weights by STABILITY_ALPHA? */
 static time_t stability_last_downrated = 0;
@@ -164,6 +184,16 @@
   tor_free(hist);
 }
 
+/** Helper: free storage held by a single OR port history entry. */
+static void
+or_port_hist_free(or_port_hist_t *p)
+{
+  tor_assert(p);
+  digestmap_free(p-&gt;ids,NULL);
+  digestmap_free(p-&gt;failure_ids,NULL);
+  tor_free(p);
+}
+
 /** Update an or_history_t object &lt;b&gt;hist&lt;/b&gt; so that its uptime/downtime
  * count is up-to-date as of &lt;b&gt;when&lt;/b&gt;.
  */
@@ -1639,7 +1669,7 @@
     tmp_time = smartlist_get(predicted_ports_times, i);
     if (*tmp_time + PREDICTED_CIRCS_RELEVANCE_TIME &lt; now) {
       tmp_port = smartlist_get(predicted_ports_list, i);
-      log_debug(LD_CIRC, "Expiring predicted port %d", *tmp_port);
+      log_debug(LD_HIST, "Expiring predicted port %d", *tmp_port);
       smartlist_del(predicted_ports_list, i);
       smartlist_del(predicted_ports_times, i);
       rephist_total_alloc -= sizeof(uint16_t)+sizeof(time_t);
@@ -1821,6 +1851,12 @@
   tor_free(last_stability_doc);
   built_last_stability_doc_at = 0;
   predicted_ports_free();
+  if (or_port_hists) {
+    SMARTLIST_FOREACH(or_port_hists, or_port_hist_t *, p,
+                      or_port_hist_free(p));
+    smartlist_free(or_port_hists);
+    or_port_hists = NULL;
+  }
 }
 
 /****************** hidden service usage statistics ******************/
@@ -2356,3 +2392,225 @@
   tor_free(fname);
 }
 
+/** Create a new entry in the port tracking cache for the or_port in
+  * &lt;b&gt;ri&lt;/b&gt;. */
+void
+or_port_hist_new(const routerinfo_t *ri)
+{
+  or_port_hist_t *result;
+  const char *id=ri-&gt;cache_info.identity_digest;
+
+  if (!or_port_hists)
+    or_port_hist_init();
+
+  SMARTLIST_FOREACH(or_port_hists, or_port_hist_t *, tp,
+    {
+      /* Cope with routers that change their advertised OR port or are
+         dropped from the networkstatus. We don't discard the failures of
+         dropped routers because they are still valid when counting
+         consecutive failures on a port.*/
+      if (digestmap_get(tp-&gt;ids, id) &amp;&amp; (tp-&gt;or_port != ri-&gt;or_port)) {
+        digestmap_remove(tp-&gt;ids, id);
+      }
+      if (tp-&gt;or_port == ri-&gt;or_port) {
+        if (!(digestmap_get(tp-&gt;ids, id)))
+          digestmap_set(tp-&gt;ids, id, (void*)1);
+        return;
+      }
+    });
+
+  result = tor_malloc_zero(sizeof(or_port_hist_t));
+  result-&gt;or_port=ri-&gt;or_port;
+  result-&gt;success=0;
+  result-&gt;ids=digestmap_new();
+  digestmap_set(result-&gt;ids, id, (void*)1);
+  result-&gt;failure_ids=digestmap_new();
+  result-&gt;excluded=0;
+  smartlist_add(or_port_hists, result);
+}
+
+/** Create the port tracking cache. */
+/*XXX: need to call this when we rebuild/update our network status */
+static void
+or_port_hist_init(void)
+{
+  routerlist_t *rl = router_get_routerlist();
+
+  if (!or_port_hists)
+    or_port_hists=smartlist_create();
+
+  if (rl &amp;&amp; rl-&gt;routers) {
+    SMARTLIST_FOREACH(rl-&gt;routers, routerinfo_t *, ri,
+    {
+      or_port_hist_new(ri);
+    });
+  }
+}
+
+#define NOT_BLOCKED 0
+#define FAILURES_OBSERVED 1
+#define POSSIBLY_BLOCKED 5
+#define PROBABLY_BLOCKED 10
+/** Return the list of blocked ports for our router's extra-info.*/
+char *
+or_port_hist_get_blocked_ports(void)
+{
+  char blocked_ports[2048];
+  char *bp;
+  
+  tor_snprintf(blocked_ports,sizeof(blocked_ports),"blocked-ports");
+  SMARTLIST_FOREACH(or_port_hists, or_port_hist_t *, tp,
+    {
+      if (digestmap_size(tp-&gt;failure_ids) &gt;= PROBABLY_BLOCKED)
+        tor_snprintf(blocked_ports+strlen(blocked_ports),
+                     sizeof(blocked_ports)," %u,",tp-&gt;or_port);
+    });
+  if (strlen(blocked_ports) == 13)
+    return NULL;
+  bp=tor_strdup(blocked_ports);
+  bp[strlen(bp)-1]='\n';
+  bp[strlen(bp)]='\0';
+  return bp;
+}
+
+/** Revert to client-only mode if we have seen to many failures on a port or
+  * range of ports.*/
+static void
+or_port_hist_report_block(unsigned int min_severity)
+{
+  or_options_t *options=get_options();
+  char failures_observed[2048],possibly_blocked[2048],probably_blocked[2048];
+  char port[1024];
+
+  memset(failures_observed,0,sizeof(failures_observed));
+  memset(possibly_blocked,0,sizeof(possibly_blocked));
+  memset(probably_blocked,0,sizeof(probably_blocked));
+
+  SMARTLIST_FOREACH(or_port_hists, or_port_hist_t *, tp,
+    {
+      unsigned int failures = digestmap_size(tp-&gt;failure_ids);
+      if (failures &gt;= min_severity) {
+        tor_snprintf(port, sizeof(port), " %u (%u failures %s out of %u on the"
+                     " network)",tp-&gt;or_port,failures,
+                     (!tp-&gt;success)?"and no successes": "since last success",
+                     digestmap_size(tp-&gt;ids));
+        if (failures &gt;= PROBABLY_BLOCKED) {
+          strlcat(probably_blocked, port, sizeof(probably_blocked));
+        } else if (failures &gt;= POSSIBLY_BLOCKED)
+          strlcat(possibly_blocked, port, sizeof(possibly_blocked));
+        else if (failures &gt;= FAILURES_OBSERVED)
+          strlcat(failures_observed, port, sizeof(failures_observed));
+      }
+    });
+
+  log_warn(LD_HIST,"%s%s%s%s%s%s%s%s",
+           server_mode(options) &amp;&amp;
+           ((min_severity==FAILURES_OBSERVED) || strlen(probably_blocked))?
+           "You should consider disabling your Tor server.":"",
+           (min_severity==FAILURES_OBSERVED)?
+           "Tor appears to be blocked from connecting to a range of ports "
+           "with the result that it cannot connect to one tenth of the Tor "
+           "network. ":"",
+           strlen(failures_observed)?
+           "Tor has observed failures on the following ports: ":"",
+           failures_observed,
+           strlen(possibly_blocked)?
+           "Tor is possibly blocked on the following ports: ":"",
+           possibly_blocked,
+           strlen(probably_blocked)?
+           "Tor is almost certainly blocked on the following ports: ":"",
+           probably_blocked);
+
+}
+
+/** Record the success of our connection to &lt;b&gt;digest&lt;/b&gt;'s
+  * OR port. */
+void
+or_port_hist_success(uint16_t or_port)
+{
+  SMARTLIST_FOREACH(or_port_hists, or_port_hist_t *, tp,
+    {
+      if (tp-&gt;or_port != or_port)
+        continue;
+      /*Reset our failure stats so we can notice if this port ever gets
+        blocked again.*/
+      tp-&gt;success=1;
+      if (digestmap_size(tp-&gt;failure_ids)) {
+        digestmap_free(tp-&gt;failure_ids,NULL);
+        tp-&gt;failure_ids=digestmap_new();
+      }
+      if (still_searching) {
+        still_searching=0;
+        SMARTLIST_FOREACH(or_port_hists,or_port_hist_t *,t,t-&gt;excluded=0;);
+      }
+      return;
+    });
+}
+/** Record the failure of our connection to &lt;b&gt;digest&lt;/b&gt;'s
+  * OR port. Warn, exclude the port from future entry guard selection, or
+  * add port to blocked-ports in our server's extra-info as appropriate. */
+void
+or_port_hist_failure(const char *digest, uint16_t or_port)
+{
+  int total_failures=0, ports_excluded=0, report_block=0;
+  int total_routers=smartlist_len(router_get_routerlist()-&gt;routers);
+
+  SMARTLIST_FOREACH(or_port_hists, or_port_hist_t *, tp,
+    {
+      ports_excluded += tp-&gt;excluded;
+      total_failures+=digestmap_size(tp-&gt;failure_ids);
+      if (tp-&gt;or_port != or_port)
+        continue;
+      /* We're only interested in unique failures */
+      if (digestmap_get(tp-&gt;failure_ids, digest))
+        return;
+
+      total_failures++;
+      digestmap_set(tp-&gt;failure_ids, digest, (void*)1);
+      if (still_searching &amp;&amp; !tp-&gt;success) {
+        tp-&gt;excluded=1;
+        ports_excluded++;
+      }
+      if ((digestmap_size(tp-&gt;ids) &gt;= POSSIBLY_BLOCKED) &amp;&amp;
+         !(digestmap_size(tp-&gt;failure_ids) % POSSIBLY_BLOCKED))
+        report_block=POSSIBLY_BLOCKED;
+    });
+
+  if (total_failures &gt;= (int)(total_routers/10))
+    or_port_hist_report_block(FAILURES_OBSERVED);
+  else if (report_block)
+    or_port_hist_report_block(report_block);
+
+  if (ports_excluded &gt;= smartlist_len(or_port_hists)) {
+    log_warn(LD_HIST,"During entry node selection Tor tried every port "
+             "offered on the network on at least one server "
+             "and didn't manage a single "
+             "successful connection. This suggests you are behind an "
+             "extremely restrictive firewall. Tor will keep trying to find "
+             "a reachable entry node.");
+    SMARTLIST_FOREACH(or_port_hists, or_port_hist_t *, tp, tp-&gt;excluded=0;);
+  }
+}
+
+/** Add any ports marked as excluded in or_port_hist_t to &lt;b&gt;rt&lt;/b&gt; */
+void
+or_port_hist_exclude(routerset_t *rt)
+{
+  SMARTLIST_FOREACH(or_port_hists, or_port_hist_t *, tp,
+    {
+      char portpolicy[9];
+      if (tp-&gt;excluded) {
+        tor_snprintf(portpolicy,sizeof(portpolicy),"*:%u", tp-&gt;or_port);
+        log_warn(LD_HIST,"Port %u may be blocked, excluding it temporarily "
+                          "from entry guard selection.", tp-&gt;or_port);
+        routerset_parse(rt, portpolicy, "Ports");
+      }
+    });
+}
+
+/** Allow the exclusion of ports during our search for an entry node. */
+void
+or_port_hist_search_again(void)
+{
+    still_searching=1;
+}
Index: src/or/or.h
===================================================================
--- src/or/or.h	(revision 17104)
+++ src/or/or.h	(working copy)
@@ -3864,6 +3864,13 @@
 int any_predicted_circuits(time_t now);
 int rep_hist_circbuilding_dormant(time_t now);
 
+void or_port_hist_failure(const char *digest, uint16_t or_port);
+void or_port_hist_success(uint16_t or_port);
+void or_port_hist_new(const routerinfo_t *ri);
+void or_port_hist_exclude(routerset_t *rt);
+void or_port_hist_search_again(void);
+char *or_port_hist_get_blocked_ports(void);
+
 /** Possible public/private key operations in Tor: used to keep track of where
  * we're spending our time. */
 typedef enum {
Index: src/or/routerparse.c
===================================================================
--- src/or/routerparse.c	(revision 17104)
+++ src/or/routerparse.c	(working copy)
@@ -1401,6 +1401,8 @@
     goto err;
   }
 
+  or_port_hist_new(router);
+
   if (!router-&gt;platform) {
     router-&gt;platform = tor_strdup("&lt;unknown&gt;");
   }
Index: src/or/router.c
===================================================================
--- src/or/router.c	(revision 17104)
+++ src/or/router.c	(working copy)
@@ -1818,6 +1818,7 @@
   char published[ISO_TIME_LEN+1];
   char digest[DIGEST_LEN];
   char *bandwidth_usage;
+  char *blocked_ports;
   int result;
   size_t len;
 
@@ -1825,7 +1826,6 @@
                 extrainfo-&gt;cache_info.identity_digest, DIGEST_LEN);
   format_iso_time(published, extrainfo-&gt;cache_info.published_on);
   bandwidth_usage = rep_hist_get_bandwidth_lines(1);
-
   result = tor_snprintf(s, maxlen,
                         "extra-info %s %s\n"
                         "published %s\n%s",
@@ -1835,6 +1835,16 @@
   if (result&lt;0)
     return -1;
 
+  blocked_ports = or_port_hist_get_blocked_ports();
+  if (blocked_ports) {
+      result = tor_snprintf(s+strlen(s), maxlen-strlen(s),
+                            "%s",
+                            blocked_ports);
+      tor_free(blocked_ports);
+      if (result&lt;0)
+        return -1;
+  }
+
   if (should_record_bridge_info(options)) {
     static time_t last_purged_at = 0;
     char *geoip_summary;
Index: src/or/circuitbuild.c
===================================================================
--- src/or/circuitbuild.c	(revision 17104)
+++ src/or/circuitbuild.c	(working copy)
@@ -62,6 +62,7 @@
 
 static void entry_guards_changed(void);
 static time_t start_of_month(time_t when);
+static int num_live_entry_guards(void);
 
 /** Iterate over values of circ_id, starting from conn-\&gt;next_circ_id,
  * and with the high bit specified by conn-\&gt;circ_id_type, until we get
@@ -1627,12 +1628,14 @@
   smartlist_t *excluded;
   or_options_t *options = get_options();
   router_crn_flags_t flags = 0;
+  routerset_t *_ExcludeNodes;
 
   if (state &amp;&amp; options-&gt;UseEntryGuards &amp;&amp;
       (purpose != CIRCUIT_PURPOSE_TESTING || options-&gt;BridgeRelay)) {
     return choose_random_entry(state);
   }
 
+  _ExcludeNodes = routerset_new();
   excluded = smartlist_create();
 
   if (state &amp;&amp; (r = build_state_get_exit_router(state))) {
@@ -1670,12 +1673,18 @@
   if (options-&gt;_AllowInvalid &amp; ALLOW_INVALID_ENTRY)
     flags |= CRN_ALLOW_INVALID;
 
+  if (options-&gt;ExcludeNodes)
+    routerset_union(_ExcludeNodes,options-&gt;ExcludeNodes);
+
+  or_port_hist_exclude(_ExcludeNodes);
+
   choice = router_choose_random_node(
            NULL,
            excluded,
-           options-&gt;ExcludeNodes,
+           _ExcludeNodes,
            flags);
   smartlist_free(excluded);
+  routerset_free(_ExcludeNodes);
   return choice;
 }
 
@@ -2727,6 +2736,7 @@
 entry_guards_update_state(or_state_t *state)
 {
   config_line_t **next, *line;
+  unsigned int have_reachable_entry=0;
   if (! entry_guards_dirty)
     return;
 
@@ -2740,6 +2750,7 @@
       char dbuf[HEX_DIGEST_LEN+1];
       if (!e-&gt;made_contact)
         continue; /* don't write this one to disk */
+      have_reachable_entry=1;
       *next = line = tor_malloc_zero(sizeof(config_line_t));
       line-&gt;key = tor_strdup("EntryGuard");
       line-&gt;value = tor_malloc(HEX_DIGEST_LEN+MAX_NICKNAME_LEN+2);
@@ -2785,6 +2796,11 @@
   if (!get_options()-&gt;AvoidDiskWrites)
     or_state_mark_dirty(get_or_state(), 0);
   entry_guards_dirty = 0;
+
+  /* XXX: Is this the place to decide that we no longer have any reachable
+    guards? */
+  if (!have_reachable_entry)
+    or_port_hist_search_again();
 }
 
 /** If &lt;b&gt;question&lt;/b&gt; is the string "entry-guards", then dump

["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20081015054813</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2008-10-15 05:48:13-0400</timestampReceived><subject>Re: Patches for proposal 155: Four Improvements of Hidden Service Performance</subject><body>

On Wed, Oct 08, 2008 at 01:57:49PM +0200, Karsten Loesing wrote:
&gt; Index: /home/karsten/tor/tor-trunk-155-patch1/ChangeLog
&gt; ===================================================================
&gt; --- /home/karsten/tor/tor-trunk-155-patch1/ChangeLog	(revision 17050)
&gt; +++ /home/karsten/tor/tor-trunk-155-patch1/ChangeLog	(working copy)
&gt; @@ -3,6 +3,8 @@
&gt;      - Now NodeFamily and MyFamily config options allow spaces in
&gt;        identity fingerprints, so it's easier to paste them in.
&gt;        Suggested by Lucky Green.
&gt; +    - Reduce extension timeout for introduction circuits from 60 to 30
&gt; +      seconds.

Applied and in. I changed it a bit, but not in any substantial way
I think.

&gt; Index: /home/karsten/tor/tor-trunk-155-patch2/ChangeLog
&gt; ===================================================================
&gt; --- /home/karsten/tor/tor-trunk-155-patch2/ChangeLog	(revision 17050)
&gt; +++ /home/karsten/tor/tor-trunk-155-patch2/ChangeLog	(working copy)
&gt; @@ -3,6 +3,8 @@
&gt;      - Now NodeFamily and MyFamily config options allow spaces in
&gt;        identity fingerprints, so it's easier to paste them in.
&gt;        Suggested by Lucky Green.
&gt; +    - Start extending introduction circuits in parallel after a delay of
&gt; +      15 seconds (based on work by Christian Wilms).

Isn't this patch a smaller version of patch4? That is, if we started
enough circuits to begin with, can we just skip this step? It seems
odd to apply both patch2 and patch4, and it seems like patch4 is the
more general.

&gt; Index: /home/karsten/tor/tor-trunk-155-patch3/ChangeLog
&gt; ===================================================================
&gt; --- /home/karsten/tor/tor-trunk-155-patch3/ChangeLog	(revision 17050)
&gt; +++ /home/karsten/tor/tor-trunk-155-patch3/ChangeLog	(working copy)
&gt; @@ -3,6 +3,8 @@
&gt;      - Now NodeFamily and MyFamily config options allow spaces in
&gt;        identity fingerprints, so it's easier to paste them in.
&gt;        Suggested by Lucky Green.
&gt; +    - Increase number of server-side introduction points based on number
&gt; +      of recent hidden service requests (based on work by Christian Wilms).

I think this is a very useful change, since we really do want our hidden
services to adapt the number of preemptive circuits they hold open to
the amount of attention they get. But the patch here looks much more
complex than it needs to be.

Rather than keeping a whole history with exact timestamps and everything,
why not keep a counter and a timestamp in rephist (or rend*), and let
the counter decay over time.

That is, when a circuit is requested we call a function to increment the
counter (but never past some cap), and when we're considering making
a new circuit we call a function to get the current counter value,
and every time either of these functions is called we check a static
time_t and move the counter value down by 1 (but not less than 0) for
every interval that's passed since we last called one of the functions.

It's not quite as precise, but it's way less code. :)

&gt; Index: /home/karsten/tor/tor-trunk-155-patch4/ChangeLog
&gt; ===================================================================
&gt; --- /home/karsten/tor/tor-trunk-155-patch4/ChangeLog	(revision 17050)
&gt; +++ /home/karsten/tor/tor-trunk-155-patch4/ChangeLog	(working copy)
&gt; @@ -3,6 +3,9 @@
&gt;      - Now NodeFamily and MyFamily config options allow spaces in
&gt;        identity fingerprints, so it's easier to paste them in.
&gt;        Suggested by Lucky Green.
&gt; +    - Start building more server-side introduction circuits than needed
&gt; +      (five), pick the first three that succeed, and use the others as
&gt; +      general-purpose circuits.

Looks plausible. I'm going to review the patch more tomorrow and then
check it (or something like it) in.

&gt;      /* Remember how many introduction circuits we started with. */
&gt;      prev_intro_nodes = smartlist_len(service-&gt;intro_nodes);
&gt; -
&gt; -    /* The directory is now here. Pick three ORs as intro points. */
&gt; -    for (j=prev_intro_nodes; j &lt; NUM_INTRO_POINTS; ++j) {
&gt; +    /* The directory is now here. Pick three ORs as intro points (plus, if
&gt; +     * we currently have none at all, two more so that we can pick the first
&gt; +     * three afterwards). */
&gt; +#define NUM_INTRO_POINTS_INIT (NUM_INTRO_POINTS + 2)
&gt; +    for (j=prev_intro_nodes; j &lt; (prev_intro_nodes == 0 ?
&gt; +             NUM_INTRO_POINTS_INIT : NUM_INTRO_POINTS); ++j) {
&gt;        router_crn_flags_t flags = CRN_NEED_UPTIME;
&gt;        if (get_options()-&gt;_AllowInvalid &amp; ALLOW_INVALID_INTRODUCTION)
&gt;          flags |= CRN_ALLOW_INVALID;

This is the part that makes me nervous still. We make 5 intro points,
and as soon as three are ready, we discard (change to general) any others
that finish. What if the three that are ready are at the end of the intro
points list? Don't we need to remove the intro point from the list too,
if we decide not to use its intro circuit?

--Roger

</body></email><email><emailId>20081015083300</emailId><senderName>Karsten Loesing</senderName><senderEmail>karsten.loesing@gmx.net</senderEmail><timestampReceived>2008-10-15 08:33:00-0400</timestampReceived><subject>Re: Patches for proposal 155: Four Improvements of Hidden Service</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Roger Dingledine wrote:
&gt;&gt; Index: /home/karsten/tor/tor-trunk-155-patch1/ChangeLog
&gt;&gt; ===================================================================
&gt;&gt; +    - Reduce extension timeout for introduction circuits from 60 to 30
&gt;&gt; +      seconds.
&gt; 
&gt; Applied and in. I changed it a bit, but not in any substantial way
&gt; I think.

Yay, looks good!


&gt;&gt; Index: /home/karsten/tor/tor-trunk-155-patch2/ChangeLog
&gt;&gt; ===================================================================
&gt;&gt; +    - Start extending introduction circuits in parallel after a delay of
&gt;&gt; +      15 seconds (based on work by Christian Wilms).
&gt; 
&gt; Isn't this patch a smaller version of patch4? That is, if we started
&gt; enough circuits to begin with, can we just skip this step? It seems
&gt; odd to apply both patch2 and patch4, and it seems like patch4 is the
&gt; more general.

Ah no, this patch affects circuit extension to an introduction point on
client side, whereas patch 4 deals with establishing introduction points
by the service. On client side, this process needs to be done on demand,
because the client cannot know the introduction point to build a circuit
to in advance. That's why this step is one of the most critical in the
protocol where we lose up to an entire minute when establishing a
connection (or half a minute with patch 1).


&gt;&gt; Index: /home/karsten/tor/tor-trunk-155-patch3/ChangeLog
&gt;&gt; ===================================================================
&gt;&gt; +    - Increase number of server-side introduction points based on number
&gt;&gt; +      of recent hidden service requests (based on work by Christian Wilms).
&gt; 
&gt; I think this is a very useful change, since we really do want our hidden
&gt; services to adapt the number of preemptive circuits they hold open to
&gt; the amount of attention they get. But the patch here looks much more
&gt; complex than it needs to be.
&gt; 
&gt; Rather than keeping a whole history with exact timestamps and everything,
&gt; why not keep a counter and a timestamp in rephist (or rend*), and let
&gt; the counter decay over time.
&gt; 
&gt; That is, when a circuit is requested we call a function to increment the
&gt; counter (but never past some cap), and when we're considering making
&gt; a new circuit we call a function to get the current counter value,
&gt; and every time either of these functions is called we check a static
&gt; time_t and move the counter value down by 1 (but not less than 0) for
&gt; every interval that's passed since we last called one of the functions.
&gt; 
&gt; It's not quite as precise, but it's way less code. :)

Alas, I have to say that I'm not convinced of the usefulness of this
change anymore. It sounds like a good idea to be adaptive with the
number of pre-built circuits, but it does not reflect current reality.
The improvements are based on two assumptions, that might be wrong:

First, we assumed that a popular hidden service cannot make use of
cannibalization and therefore needs to extend all hops of a circuit to a
rendezvous point. That's right, but we forgot that extending a
previously cannibalized circuit takes time, too. That means that the
performance improvement is not as high as expected.

Second, the hidden service needs to be really popular for being in a
situation where he doesn't have circuits ready for client requests. With
this patch a hidden service needs to see 300 requests per hour to build
a 4th internal circuit instead of only 3. Given the average number of
fetch requests to the directory, I'd guess that there is not a single
hidden service out there which has this load. And the choice of 300 (or
5 per minute) is probably still low to see an effect of the additional
circuit at all.

All in all, I'd say we hold back this patch for now until we know better
whether this is a problem at all. It probably wouldn't hurt to add it.
But it doesn't make sense to add this much new complexity (your proposed
code change reduces that to some extend, but still) for an uncertain effect.


&gt;&gt; Index: /home/karsten/tor/tor-trunk-155-patch4/ChangeLog
&gt;&gt; ===================================================================
&gt;&gt; +    - Start building more server-side introduction circuits than needed
&gt;&gt; +      (five), pick the first three that succeed, and use the others as
&gt;&gt; +      general-purpose circuits.
&gt; 
&gt; Looks plausible. I'm going to review the patch more tomorrow and then
&gt; check it (or something like it) in.
&gt; 
&gt;&gt;      /* Remember how many introduction circuits we started with. */
&gt;&gt;      prev_intro_nodes = smartlist_len(service-&gt;intro_nodes);
&gt;&gt; -
&gt;&gt; -    /* The directory is now here. Pick three ORs as intro points. */
&gt;&gt; -    for (j=prev_intro_nodes; j &lt; NUM_INTRO_POINTS; ++j) {
&gt;&gt; +    /* The directory is now here. Pick three ORs as intro points (plus, if
&gt;&gt; +     * we currently have none at all, two more so that we can pick the first
&gt;&gt; +     * three afterwards). */
&gt;&gt; +#define NUM_INTRO_POINTS_INIT (NUM_INTRO_POINTS + 2)
&gt;&gt; +    for (j=prev_intro_nodes; j &lt; (prev_intro_nodes == 0 ?
&gt;&gt; +             NUM_INTRO_POINTS_INIT : NUM_INTRO_POINTS); ++j) {
&gt;&gt;        router_crn_flags_t flags = CRN_NEED_UPTIME;
&gt;&gt;        if (get_options()-&gt;_AllowInvalid &amp; ALLOW_INVALID_INTRODUCTION)
&gt;&gt;          flags |= CRN_ALLOW_INVALID;
&gt; 
&gt; This is the part that makes me nervous still. We make 5 intro points,
&gt; and as soon as three are ready, we discard (change to general) any others
&gt; that finish. What if the three that are ready are at the end of the intro
&gt; points list? Don't we need to remove the intro point from the list too,
&gt; if we decide not to use its intro circuit?

Ah, the idea is to build 5 introduction *circuits* and use the first 3
to establish introduction points, not to establish 5 introduction
*points* and throw away 2 of them. That's a big difference---in my
personal vocabulary that I apparently missed to share with you. ;) That
means that we only send ESTABLISH_INTRO cells to the first 3 completed
circuits, not to the 2 other circuits. As an effect, those 2 don't make
it to the introduction points list at all. They are declared as general
circuits, so that they might be used for other purposes---including
being cannibalized soon after if one of the introduction point should fail.

Best,
- --Karsten
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFI9aq80M+WPffBEmURAtwVAJ4nBSPgcX33fZ7WfOKD8HReDyUTrgCeJjuj
yTE6lqlbdCcvZfzgun0oMTI=
=v+NX
-----END PGP SIGNATURE-----
</body></email></emails>