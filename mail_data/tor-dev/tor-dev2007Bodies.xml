<?xml version="1.0" encoding="utf-8"?>
<emails><email><emailId>20070416185140</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-04-16 18:51:40-0400</timestampReceived><subject>Re: Plan for proposal 104 (was: New system for modifying Tor protocol)</subject><body>

On Sat, Apr 14, 2007 at 05:32:09PM -0400, Nick Mathewson wrote:
&gt; I've also clarified a couple of other points in the proposal.  Let's
&gt; get this one done soon.

Looks plausible. Anything else we'll have to learn through trying to
build it rather than through thinking hard.

Thanks!
--Roger


</body></email><email><emailId>20070420204853</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-04-20 20:48:53-0400</timestampReceived><subject>How to remove directory authorities</subject><body>

Hi folks,

In a few weeks, the moria1 and moria2 directory authorities are likely
to change IP addresses. Such a thing has never happened to Tor before,
so we don't have a precise plan for dealing.

Part 1.

  Here is the impact as I understand it of having moria1 and moria2
  disappear.

  Tor versions prior to 0.1.0.12 and prior to 0.1.1.2-alpha will have
  zero running authorities (prior to those versions, tor26 listened on
  an old IP address and it no longer listens there).

  Tor versions 0.1.1.2-alpha to 0.1.1.7-alpha will still function but
  in a degraded fashion: they will try to fetch the v1 directory and
  running-routers from moria1,moria2,tor26, and eventually they will get
  one from tor26.

  Tor versions 0.1.1.8-alpha through 0.1.1.17-rc will not function,
  because they demand a majority of authorities before the
  client will believe it.

  Tor 0.1.1.18-rc up until present ship with 5 directory authorities,
  so a majority can still exist, assuming all three remaining authorities
  are running all the time.

  Tor 0.1.0.12 and 0.1.1.2-alpha and later will have one functional hidden
  service authority (i.e. tor26), and since we don't replicate hidden
  service descriptors or round robin very well, they will experience
  significantly degraded service when trying to fetch service descriptors.

Part 2.

  What if we remove moria1 and moria2 from the default DirServers list
  now, but leave them running for a few weeks?

  Old Tors will continue to work fine as they do now.

  Versions with the new DirServers lines will then have three authorities
  (tor26, lefkada, dizum), and believe anything that two or more of them
  claim. There will be a partitioning opportunity because while the old
  dir authorities are still publishing network statuses, as the new Tors
  will potentially make different decisions than the old Tors.

  New Tors will only try to fetch hidden service descriptors from tor26,
  so if it goes down or reboots, well, they are at its mercy. Worse,
  new Tors will only publish hidden service descriptors to tor26, so old
  Tors will have difficulty fetching the descriptors. (They'll have to
  click an expected three times in order to find the right authority.)

  One compromise to resolve the interim hidden service concern would
  be to leave moria1 and moria2 in the DirServers line but *only* as
  HS authorities. That way new Tors won't believe them as far as v1
  or v2 dirs go, but new Tors will still publish/fetch hidden service
  descriptors to/from them.

Other thoughts:

I will likely put one of the morias back up on the same day as the old
ones go away, though it will have a new location. Port forwarding from
the old location might be feasible for a while; I will investigate that.
(If we don't do port forwarding, we could take this opportunity to
rotate its identity key, which is probably a good move.)

We should eventually add a lot more dir authorities, so we don't run
up against the "not a majority" edge case as easily. We've been putting
that off until we get dir voting (proposal 101) in place in 0.2.0, and I
think that's a fine plan to continue. But we may want to add a few more
to replace the ones we've lost.

We're probably going to want to put out an update to 0.1.2.x stable with
an updated (reduced) set of dir authorities, but we have never tried
removing dir authorities before, and we may encounter new bugs. We need
to do some broad testing somewhere in here. :)

It occurs to me that we could "fake" the continued existence of both dir
authorities by publishing signed network status objects and getting them
cached throughout the rest of the network. That would be quite a hack,
but it may be worth thinking harder about.

Ok. What did I miss?

--Roger

</body></email><email><emailId>20070416191821</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-04-16 19:18:21-0400</timestampReceived><subject>Re: Plan for proposal 104 (was: New system for modifying Tor protocol)</subject><body>

On Mon, Apr 16, 2007 at 02:51:40PM -0400, Roger Dingledine wrote:
&gt; Looks plausible. Anything else we'll have to learn through trying to
&gt; build it rather than through thinking hard.

I take it back. Here's another underspecified part:

In section 3, it says "authorities receiving an extra-info
document should verify..."

What does it do if one of these properties is false? In particular,
I am thinking about if the first or third property is false.

Is the answer just "dump it" because we require the server to publish
the descriptor right before publishing the extra_info? Do we care if
the two posts are in the same directory connection or different ones?

--Roger


</body></email><email><emailId>20070416212243</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-04-16 21:22:43-0400</timestampReceived><subject>Re: Plan for proposal 104 (was: New system for modifying Tor protocol)</subject><body>


On Mon, Apr 16, 2007 at 03:18:21PM -0400, Roger Dingledine wrote:
&gt; On Mon, Apr 16, 2007 at 02:51:40PM -0400, Roger Dingledine wrote:
&gt; &gt; Looks plausible. Anything else we'll have to learn through trying to
&gt; &gt; build it rather than through thinking hard.
&gt; 
&gt; I take it back. Here's another underspecified part:
&gt; 
&gt; In section 3, it says "authorities receiving an extra-info
&gt; document should verify..."
&gt; 
&gt; What does it do if one of these properties is false? In particular,
&gt; I am thinking about if the first or third property is false.
&gt; 
&gt; Is the answer just "dump it" because we require the server to publish
&gt; the descriptor right before publishing the extra_info?

I'm going with "dump it" If the server publishes wrong, that's the
server's problem.  The way I'm coding this up, we retain an extra-info
document for as long as we retain the corresponding router-info.

&gt; Do we care if
&gt; the two posts are in the same directory connection or different ones?

No.

Assuming that this looks plausible to you, I'll make the right changes
to 104.

-- 
Nick Mathewson

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070419014534</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-04-19 01:45:34-0400</timestampReceived><subject>Re: Plan for proposal 104 (was: New system for modifying Tor protocol)</subject><body>

On Mon, Apr 16, 2007 at 05:22:43PM -0400, Nick Mathewson wrote:
&gt; &gt; Is the answer just "dump it" because we require the server to publish
&gt; &gt; the descriptor right before publishing the extra_info?
&gt; 
&gt; I'm going with "dump it" If the server publishes wrong, that's the
&gt; server's problem.  The way I'm coding this up, we retain an extra-info
&gt; document for as long as we retain the corresponding router-info.
&gt; 
&gt; Assuming that this looks plausible to you, I'll make the right changes
&gt; to 104.

Sounds great. Thanks.
--Roger

</body></email><email><emailId>20070420070047</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-04-20 07:00:47-0400</timestampReceived><subject>Re: Encrypting content of hidden service descriptors</subject><body>

On Sat, Apr 14, 2007 at 08:01:21PM +0200, Karsten Loesing wrote:
&gt; The reason why I asked the question is, that I am rethinking the format
&gt; of rendezvous service descriptors at the moment. And there still is this
&gt; idea around of encrypting the descriptor content which is, as you wrote,
&gt; not completely solved.

Right. I remember a discussion a couple years ago about how to encrypt
the hidden service descriptors. I wanted three things at once:

a) The places that store and serve the descriptors can't learn the
introduction points,
b) But they can make sure they're signed correctly and can pick out the
newest descriptor.
c) Select clients can learn them through some extra key or whatever
they're given.

Doing all three of these with just one key (or derivatives of that key)
seems hard. It probably requires crypto magic that I don't have.

An easier option might be to use two keys. I haven't worked out the
details, which means all the hard work still remains ;), but the idea
would be that we'd have a signing key which is publicly known, and
the name, timestamp, signing key, and signing key signature would be
clearly visible to everybody. The rest of the descriptor would be the
introduction points, encrypted with the second (encryption) key. Then
the client would be given both keys (e.g. x-y.onion), whereas the public
only knows the signing key.

The next step would be fixing it up so knowing the encryption key doesn't
necessarily mean you can always decrypt things in the future. Rotating
the encryption key periodically might do it, or we could do something
more complex.

But of course, if the rest of the protocol remains the same, then
the adversary can still enumerate introduction points pretty easily
by attempting to introduce himself at each Tor server one by one
using the public onion name. Fixing that starts to make things more
complicated. Hm.

&gt; The question is, though, whether we need to solve it now. When
&gt; distributing the directory for hidden service descriptors, everyone
&gt; could be responsible for storing a descriptor and could read it, if it
&gt; is unencrypted. At the moment you as hidden service provider need to
&gt; trust only the five directory authorities, in a decentralized design you
&gt; further need to trust each of the 500 DHT nodes...

Right. We do need to clarify our threat model and goals here. (By the way,
it's only 3 directory authorities: just the ones that offer the HS flag,
which coincidentally are the ones that offer the V1 flag.)

When we originally designed this, we had no intention of keeping
descriptors private. Putting them on the dirservers was just a hack
because I didn't have anywhere better to put them. But the notion that the
dirservers give them more "secrecy" has gradually sprung up since then. So
the question is: so what? What happens if all descriptors are public?

First, you can DoS the intro points of a hidden service, even if the
hidden service hasn't revealed itself to you. This is an issue, but if
you want to enumerate hidden services, you have other options -- a less
efficient approach would be to run a bunch of stable nodes and hope you
get picked as an intro point a lot.

Second, you can visit a hidden service, even if it hasn't revealed itself
to you. You won't know what ports it supports, but you can portscan the
whole thing, and besides it's probably just on port 80 anyway. Is the
answer that hidden services that want authorization should implement
it end-to-end (e.g. http auth) and not try to keep their address itself
a secret?

What other issues are there if each hidden service descriptor is public?
Rather than postponing this mail another day while I sleep, I'm going to
send it and hope other people bring up the other issues. :)

Thanks,
--Roger

</body></email><email><emailId>20070420212659</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-04-20 21:26:59-0400</timestampReceived><subject>Re: How to remove directory authorities</subject><body>


On Fri, Apr 20, 2007 at 04:48:53PM -0400, Roger Dingledine wrote:
&gt; Hi folks,
&gt; 
&gt; In a few weeks, the moria1 and moria2 directory authorities are likely
&gt; to change IP addresses. Such a thing has never happened to Tor before,
&gt; so we don't have a precise plan for dealing.
&gt;
&gt; Part 1.
&gt; 
&gt;   Here is the impact as I understand it of having moria1 and moria2
&gt;   disappear.
&gt; 
&gt;   Tor versions prior to 0.1.0.12 and prior to 0.1.1.2-alpha will have
&gt;   zero running authorities (prior to those versions, tor26 listened on
&gt;   an old IP address and it no longer listens there).

This is only a problem when these tor versions try to go straight to
the authorities for a copy of their directory information.  If they go
to a cache, the cache can give them an up-to-date directory.  So long
as the up-to-date directory is signed with an identity key they
recognize, they will accept it.  The only times these versions will
try to go straight to an authority are: if they are servers, or if
they are clients starting up again after being down for a long time.

As far as I can tell from my directory cache, there are no running
servers using a version of Tor earlier than 0.1.0.15.  That's probably
good; these versions are very obsolete for other reasons; I wouldn't
worry too much about them.

(There is one router, "mysosecretname", running 0.1.0.15.  All others
are 0.1.0.16 or later.)

&gt;   Tor versions 0.1.1.2-alpha to 0.1.1.7-alpha will still function but
&gt;   in a degraded fashion: they will try to fetch the v1 directory and
&gt;   running-routers from moria1,moria2,tor26, and eventually they will get
&gt;   one from tor26.

Again, this only matters when trying to get info straight from the
authorities: caches running these versions will fumble around until
they eventually get a v1 directory from tor26.  Clients running these
versions will just go to a cache, which will serve them a v1 directory.

(My cache has no routers running these versions, so no caches should
be affected.)

&gt;   Tor versions 0.1.1.8-alpha through 0.1.1.17-rc will not function,
&gt;   because they demand a majority of authorities before the
&gt;   client will believe it.

Actually, I think they will be fine, assuming that moria1 and moria2
keep the same keys as before.

Clients will fetch networkstatus info _by identity key digest_ from
caches.  (They'll go to an authority if they don't know any caches,
and eventually they'll find tor26.)  Caches will go to an authority
and request "all network status documents" (eventually finding Tor26).
Assuming tor26 knows where to find moria1 and moria2, the network
doesn't fall oever This will degrade performance as the clients/caches
look for an authority/cache that has the info they need, but not too
badly.

&gt;   Tor 0.1.1.18-rc up until present ship with 5 directory authorities,
&gt;   so a majority can still exist, assuming all three remaining authorities
&gt;   are running all the time.
&gt; 
&gt;   Tor 0.1.0.12 and 0.1.1.2-alpha and later will have one functional hidden
&gt;   service authority (i.e. tor26), and since we don't replicate hidden
&gt;   service descriptors or round robin very well, they will experience
&gt;   significantly degraded service when trying to fetch service descriptors.
&gt; 
&gt; Part 2.
&gt; 
&gt;   What if we remove moria1 and moria2 from the default DirServers list
&gt;   now, but leave them running for a few weeks?

I'll suggest an alternative below; as noted above, it's probably
important to keep at least one of moria1 and moria2 running with the
same key, if not on the same IP.

&gt;   Old Tors will continue to work fine as they do now.
&gt; 
&gt;   Versions with the new DirServers lines will then have three authorities
&gt;   (tor26, lefkada, dizum), and believe anything that two or more of them
&gt;   claim. There will be a partitioning opportunity because while the old
&gt;   dir authorities are still publishing network statuses, as the new Tors
&gt;   will potentially make different decisions than the old Tors.
&gt; 
&gt;   New Tors will only try to fetch hidden service descriptors from tor26,
&gt;   so if it goes down or reboots, well, they are at its mercy. Worse,
&gt;   new Tors will only publish hidden service descriptors to tor26, so old
&gt;   Tors will have difficulty fetching the descriptors. (They'll have to
&gt;   click an expected three times in order to find the right authority.)
&gt; 
&gt;   One compromise to resolve the interim hidden service concern would
&gt;   be to leave moria1 and moria2 in the DirServers line but *only* as
&gt;   HS authorities. That way new Tors won't believe them as far as v1
&gt;   or v2 dirs go, but new Tors will still publish/fetch hidden service
&gt;   descriptors to/from them.
&gt; 
&gt; Other thoughts:
&gt; 
&gt; I will likely put one of the morias back up on the same day as the old
&gt; ones go away, though it will have a new location. Port forwarding from
&gt; the old location might be feasible for a while; I will investigate that.
&gt; (If we don't do port forwarding, we could take this opportunity to
&gt; rotate its identity key, which is probably a good move.)
&gt;
&gt; We should eventually add a lot more dir authorities, so we don't run
&gt; up against the "not a majority" edge case as easily. We've been putting
&gt; that off until we get dir voting (proposal 101) in place in 0.2.0, and I
&gt; think that's a fine plan to continue. But we may want to add a few more
&gt; to replace the ones we've lost.

I think the right thing to do is to use new signing keys when we
transition to directory voting, and continue using the old identity
keys for v1 and v2 directories.  This way, we don't gratuitously break
old software, but we get to move beyond the key management sins of the
past.  We can also change the _set_ of authorities when we transition
to dir-voting.

Remember, nothing in proposal 101 requires that the keys used to sign
votes and consensus directories have anything at all to do with the
keys used to sign v1 directories and v2 networkstatus objects.

That would also be a fine time to consider proposal 103 ("multilevel
keys"), so that we can have a rarely used identity key that is kept
encrypted and used only to certify a frequently used signing key.

&gt;
&gt; We're probably going to want to put out an update to 0.1.2.x stable with
&gt; an updated (reduced) set of dir authorities, but we have never tried
&gt; removing dir authorities before, and we may encounter new bugs. We need
&gt; to do some broad testing somewhere in here. :)
&gt; 
&gt; It occurs to me that we could "fake" the continued existence of both dir
&gt; authorities by publishing signed network status objects and getting them
&gt; cached throughout the rest of the network. That would be quite a hack,
&gt; but it may be worth thinking harder about.

See above: so long as the authorities know where moria1 and moria2
are, they can fetch their signed network-status documents and serve
them to old caches.  (Caches, remember, go to a randomly chosen
authority and say "give me all networkstatus documents.")  All caches
will happily serve their signed network-status documents to clients.

&gt;
&gt; Ok. What did I miss?

We should switch to DNS, or to fallback-to-DNS, for directory
authority addresses, so we don't need to do this ever again. :)

peace,
-- 
Nick Mathewson

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070423125549</emailId><senderName>Karsten Loesing</senderName><senderEmail>karsten.loesing@gmx.net</senderEmail><timestampReceived>2007-04-23 12:55:49-0400</timestampReceived><subject>Re: A Java-based Tor simulator -- where can I share it?</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Hi,

&gt; very nice! im very looking forward to this one .. 
&gt; how is traffic generated in the simulation? do you have sort of a rule
&gt; based generator or do i still need manual interaction?

At the moment you can just start a thread that performs one request in
the background. But of course you can start many of those threads with
your own timing pattern to implement your own traffic generator. In
fact, this might be one of the first additions. So if you have
implemented such a traffic generator, please contribute it! :)

&gt;&gt; We are happy to add projects like this to the Tor SVN repository when it
&gt;&gt; makes sense (and in this case it probably does). The usual approach is
&gt;&gt; for the author to put a tarball up somewhere first, so we can grab it and
&gt;&gt; look through it to see what it actually is, whether it's ready or wants
&gt;&gt; a lot of revision before it goes 'live', etc. If you don't have any place
&gt;&gt; to post a tarball, let me know and I can give you some web space on moria.

I put it on

    http://88.84.144.63/puppetor.tar

where it will be available for the next two weeks or so. I hope that we
will find a better solution during this time.

&gt;&gt; We'll probably want to make a new module in SVN for this, and for other
&gt;&gt; projects as they come up. We don't really have a formal process for
&gt;&gt; picking names for new modules, since we've only done it a handful of
&gt;&gt; times so far, so the current plan is to continue winging it. :)

OK.

&gt;&gt; I'm not clear on what your question is here. Our favorite license
&gt;&gt; currently is the 3-clause BSD license, and the rest of the projects in Tor
&gt;&gt; SVN use that license too. If you want to use 3-clause BSD too, feel free
&gt;&gt; to grab the text of it from a Tor tarball, change the names, years, etc,
&gt;&gt; and now you have your own shiny new license. Is this what you were asking?

Yes, that was what I was asking. I copied some files and changed them.
If I messed things up, please tell me.

- --Karsten
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.7 (MingW32)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFGLKzV0M+WPffBEmURAtpHAKDKT6gWpEjYARUIdTVa07IIvBVJLwCfaAlP
qJEQEYl4wUYa+yrVM4sEZNI=
=CvP1
-----END PGP SIGNATURE-----
</body></email><email><emailId>20070426050826</emailId><senderName>Mike Perry</senderName><senderEmail>mikeperry@fscked.org</senderEmail><timestampReceived>2007-04-26 05:08:26-0400</timestampReceived><subject>Re: Proposal: Bring Back PathlenCoinWeight</subject><body>

Thus spake Roger Dingledine (arma@mit.edu):

&gt; So this proposal isn't about bringing back the old behavior. It appears
&gt; rather to be some combination of:
&gt; 
&gt; a) We should let people choose two hops if they want, for better
&gt;    performance and to reduce the overall load on the network.
&gt; b) We should make path length have a random component, so it's hard
&gt;    to tell if a given user prefers two-hop paths or three-hop paths.
&gt; c) We should change our policy for dropping guards based on when they
&gt;    fail.

Yes. Bingo. My proposal really had little to do with
PathlenCoinWeight, other than the fact that I think it would be nice
to have that flexibility in case it proved worthwhile elsewhere (for
example, Johannes's work or an attack I realized the other day
detailed below). 

&gt; Letting each user choose his own random weight is probably a recipe
&gt; for disaster, in that it adds complexity to the system and to analysis
&gt; and doesn't really provide any clear win. So giving people a couple of
&gt; weights to choose from (0, 1, and maybe a few more) seems a smarter move.

I don't think we should worry about our typical user mucking with
torrc and making themselves insecure. Torrc is an experts tool.
Instead we should allow the flexibility to be there for some
controller later to decide if it is useful.

&gt; &gt;   Furthermore, when blocking resistance measures insert an extra relay
&gt; &gt;   hop into the equation, 4 hops will certainly be completely unusable 
&gt; &gt;   for these users, especially since it will be considerably more
&gt; &gt;   difficult to balance the load across a dark relay net than balancing
&gt; &gt;   the load on Tor itself (which today is still not without its flaws).
&gt; 
&gt; I believe the blocking-resistance plan is to have 3 hops also -- the
&gt; bridge acts quite like an entry guard, and then two more. But all of
&gt; that is up for more thorough analysis too.

I think 3 hops is reasonable for people who have to traverse agressive
content filters that actively block Tor - for the sole reason that it
is hard to authenticate a darknet IP as a Tor node or not, and doing
so would thus require 1 hop paths. I agree we really probably don't
want to give the adversary anything tangible by confiscating or
ordering (or in some less free countries-*ahem*-abitrarily inserting)
a pen register tap on to a single Tor node..

However, for rapid prototyping of blocking resistance mechanisms (and
as you have pointed out elsewhere, we DO want to rapid prototype as
many as possible), it would be nice to be able to leverage as much of
the existing Tor code as possible (ie not have to build 2-hop paths
via controller, etc). So that would actually mean disabling guards
alltogether from Tor's point of view, and letting the controller take
over that aspect only. If we can eliminate Tor's network fingerprints
other than IP address, we can build all sorts of crazy darknets using
just http proxies and Tor's config option for this toggled via
controller.

&gt; &gt;   I believe currently guards are rotated if circuits fail, which does 
&gt; &gt;   provide some protection,
&gt; 
&gt; Actually, no. Guards are marked as inactive if the initial connection
&gt; to them fails, or the create cell to them fails. If a circuit through
&gt; them fails, we don't mark anything.
&gt; 
&gt; Guards are only actually dropped from the guard list if they are inactive
&gt; for many weeks. Otherwise we try them again as soon as the directory
&gt; authorities tell us they're running again. Section 5 of path-spec.txt
&gt; has a few more details.

What I meant by "rotated" is a different guard (from the guard list)
is chosen randomly for the next circuit upon a complete circuit
failure, so a guard can't just keep failing circuits with the
guarantee that it will be able to own a connection. At least this was
my impression from a glance at the source (choose_good_entry_server())
and seems to be neither confirmed nor denied by path-spec :).

&gt; &gt; Why not fix Pathlen=2?:
&gt; &gt; 
&gt; &gt;   The main reason I am not advocating that we always use 2 hops is that 
&gt; &gt;   in some situations, timing correlation evidence by itself may not be 
&gt; &gt;   considered as solid and convincing as an actual, uninterrupted, fully 
&gt; &gt;   traced path. Are these timing attacks as effective on a real network 
&gt; &gt;   as they are in simulation? Would an extralegal adversary or authoritarian 
&gt; &gt;   government even care? In the face of these situation-dependent unknowns, 
&gt; &gt;   it should be up to the user to decide if this is a concern for them or not.
&gt; 
&gt; Fair enough. How do the above anonymity-breaking attacks look to you, in
&gt; this light?
&gt;
&gt; In fact, assuming Alice uses Tor a lot, it doesn't even need to
&gt; fail every single "safe" circuit. It can just take advantage of the
&gt; circuits where it wins, and/or maybe fail a few to help that along.
&gt; Note that it's trivial for it to recognize which circuits are the
&gt; winners, so there's no synchronization or communication needed
&gt; except when it's a sure bet.

I think this is the best argument against the proposal because it is
the only attack that is a sure kill if successful and the adversay can
just be patient and be assured of some success (perhaps to make an
example of). Yet at the same time even this underscores that it should
be up to the user to decide.  Much of the Tor userbase is not at risk
for simply viewing censored content, and so doesn't really require
maximum anonymity at the cost of speed and load. Even China rarely if
ever jails or harms those who simply view content. They are concerned
with suppressing publishers, and just blocking all of Tor.

Furtheremore, if we agree about the effectiveness of timing attacks,
then there is no real barrier other than implementation details. An
adversary with the resources to mount this attack against the network
via C nodes can also afford a rentacoder post to get the extra timing
work done ;)

And of course there are the scores of users in more permissive
societies that simply don't want the long-term association of things
like Google queries being tied to their IP (but who also click on
well-placed relevant ads, oh ye beloved, benevolent and omniscient
sponsor :). These users don't need the full anonymity Tor provides by
default, yet want more reliability and safety than random proxies.

I think the major risks can be conveyed in a sentence or two in a
radio button choice, with a bit more info in the help. Users who risk
the adversary mounting even low-cost (let alone long-term) attacks to
circumvent Tor rather than just block Tor entirely for them will know
who they are. And there will be plenty of paranoids out there who will
keep them company :)

Incidentally, I strongly believe that the most damaging attacks
against anonymity for users who need it come not via Tor, or even from
browser leaks or misconfigurations. They come from the fact that they
are the only people in their workplace, profession, skillset, city,
state, or even circumstance that use Tor. The only thing that will
fix this is more users. Thankfully, the censors, marketers, and data
warehousing companies really REALLY want to help us out on that one.
We should help them help us :)

&gt; &gt; Partitioning attacks form another concern. Since Tor uses
&gt; &gt; telescoping to build circuits, it is possible to tell a user
&gt; &gt; is constructing only two hop paths at the entry node. It is
&gt; &gt; questionable if this data is actually worth anything
&gt; &gt; though, especially if the majority of users have easy
&gt; &gt; access to this option, and do actually choose their path
&gt; &gt; lengths semi-randomly.                                                      
&gt;                                                                                 
&gt; Agreed. The possibility that an entry guard could learn that its user           
&gt; is a 2-hop user doesn't bother me very much. At least not until it              
&gt; turns into a deeper attack. 

Hrmm, so a possible deeper attack is for an adversay to watch
connections into Tor and say "Hrmm, these Tor users are using 3 hop
circuits, they are the evil Tor users. They have something to hide!
Get 'em!/Watch them Closer!".

There are two defenses for this:
 1. Use PathlenCoinWeight to BUILD circuits, but have 
    a secondary StreamlenCoinWeight that chooses them for use. Since
    many circuits will share the same guard, it will be non-trivial for
    the (local external) adversary to tell which hop length is being
    used.
 2. Make a RELAY_SHISHKABOB cell that has onionskins for N nodes to
    set up a circuit in one pass. This is obviously more work than #1,
    but will cover guard node aversaries also.

&gt; Another worry is the local network triggering repeated failures only
&gt; for Alice. But actually, Alice should be able to distinguish failures
&gt; on her local network from authenticated messages from the guards saying
&gt; that an extend failed.
&gt; 
&gt; Hm. What other issues are there with abandoning guards after failure? One
&gt; issue is that we could more quickly rotate away from honest guards onto
&gt; bad guards; so we would need to make sure that the bar for failure is
&gt; sufficiently high that it doesn't trigger except during one of these
&gt; attacks. This part needs more thought.

I will experimentally evaluate this via TorFlow sometime in the next 2
weeks or so. So long as it is represented as a failure rate rather
than total failure count, guard turnover should be minimized.
Hopefully the Tor circuit failure rate is low. Last time I measured
it, it was around 20%, but that was a bunch of rickety perl doing the
measuring.


-- 
Mike Perry
Mad Computer Scientist
fscked.org evil labs
</body></email><email><emailId>20070427170051</emailId><senderName>Peter Palfrader</senderName><senderEmail>peter@palfrader.org</senderEmail><timestampReceived>2007-04-27 17:00:51-0400</timestampReceived><subject>Re: Simplifying directory authority administration</subject><body>

On Sat, 21 Apr 2007, nickm@seul.org wrote:

&gt; --- tor/trunk/doc/spec/proposals/113-fast-authority-interface.txt	2007-04-21 17:48:45 UTC (rev 9999)
&gt; +++ tor/trunk/doc/spec/proposals/113-fast-authority-interface.txt	2007-04-21 17:48:50 UTC (rev 10000)
&gt; @@ -0,0 +1,80 @@
&gt; +Filename: 113-fast-authority-interface.txt
&gt; +Title: Simplifying directory authority administration
&gt; +Last-Modified: $Date: 2007-04-16T19:11:29.511998Z $

&gt; +Possible solution #2: Self-binding names.
&gt; +
&gt; +  Peter Palfrader has proposed that names be assigned automatically to nodes
&gt; +  that have been up and running and valid for a while.
&gt; +
&gt; +Possible solution #3: Self-maintaining approved-routers file
&gt; +
&gt; +  Mixminion alpha has a neat feature where whenever a new server is seen,
&gt; +  a stub line gets added to a configuration file.  For Tor, it could look
&gt; +  something like this:
&gt; +
&gt; +    ## First seen with this key on 2007-04-21 13:13:14
&gt; +    ## Stayed up for at least 12 hours on IP 192.168.10.10
&gt; +    #RouterName AAAABBBBCCCCDDDDEFEF
&gt; +
&gt; +  (Note that the implementation needs to parse commented lines to make sure
&gt; +  that it doesn't add duplicates, but that's not so hard.)
&gt; +
&gt; +  To add a router as named, administrators would only need to uncomment the
&gt; +  entry.  This automatically maintained file could be kept separately from a
&gt; +  manually maintained one.

This is only useful if authority admins are expected to actually check
something before uncommenting lines.  If we are supposed to check stuff
then it's still a lot of work (tho better), if we can just blindly
uncomment it using sed or similar then what's the point of this step
anyway?

Having a separate file for auto-approved routers is probably a good
idea tho.

Maybe a means for the operator to say "never bind a server (named
$foo|with fpr $bar|from the netblock ip/pl)" would come in handy.


Also, if you are really going to parse comments maybe it'ld make sense
to introduce a second comment character, like ';', to distinguish
between parsed and not-parsed comments.

Peter
-- 
                           |  .''`.  ** Debian GNU/Linux **
      Peter Palfrader      | : :' :      The  universal
 http://www.palfrader.org/ | `. `'      Operating System
                           |   `-    http://www.debian.org/
</body></email><email><emailId>20070427195304</emailId><senderName>Watson Ladd</senderName><senderEmail>watsonbladd@gmail.com</senderEmail><timestampReceived>2007-04-27 19:53:04-0400</timestampReceived><subject>Re: [or-cvs] r9993: Describe a simpler implementation for proposal</subject><body>


&gt; Actually, I chose "up for an entire day" as a minimum quantum for a
&gt; reason.  The main problem with router instability isn't the fraction
&gt; of time it's down; if you try to connect to a router that isn't there,
&gt; that's not a big deal.  The problem with router instability is the
&gt; likelihood that it will _go_ down and drop all your circuits.
Why not compute the probability that the router will go down in the next
10 minutes based on 5 days worth of data? This dependent the number of
transitions in ten minutes on average and that is easy to compute. If we
want to discount the past we could "erase" transitions, that is count
\alpha of a transition for two days ago, \alpha^2 of a transition for
three days ago, etc.

Watson Ladd


["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20070430092210</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-04-30 09:22:10-0400</timestampReceived><subject>Re: (FWD) Re: architectural proposal &amp; technical problems</subject><body>

&gt;   2. option to tell Tor, that it should not construct any circuits by itself, similar
&gt;      to __LeaveStreamsUnattached, example: SETCONF __IdleCircuits=0

You don't really want to disable all circuit construction -- this would
break hidden services publishing, and it would break reachability testing
for servers.

I just added a new config option __DisablePredictedCircuits that should
do what you want: http://archives.seul.org/or/cvs/Apr-2007/msg00135.html

It simply doesn't build the preemptive "extra" circuits, so you don't
have random circuits appearing. Is this what you had in mind?

--Roger

</body></email><email><emailId>20070430094126</emailId><senderName>Peter Palfrader</senderName><senderEmail>peter@palfrader.org</senderEmail><timestampReceived>2007-04-30 09:41:26-0400</timestampReceived><subject>Re: Packaging vidalia and tor permissions</subject><body>

On Mon, 30 Apr 2007, Alessandro Tanasi wrote:

&gt; I am packaging Vidalia (http://vidalia-project.net/), a front-end for
&gt; Tor, for Ubuntu and Debian.
&gt; 
&gt; Vidalia need access to /var/lib/tor that is 700 owned by debian-tor.
&gt; So I need access to this directory for packaging Vidalia.
&gt; 
&gt; Can you add group permission? Or i must set Vidalia setuid?

Could you please explain to me what vidalia wants in that directory?
Especially since all the files there are created without any group or
world permissions anyway.

And no, setuid probably is not the solution you are looking for.

Peter
[PS: I think or-dev only lets subscribed people post, but you should be
on that list anyway, if you package a tor-frontend.
http://tor.eff.org/documentation.html.en#MailingLists ]
-- 
                           |  .''`.  ** Debian GNU/Linux **
      Peter Palfrader      | : :' :      The  universal
 http://www.palfrader.org/ | `. `'      Operating System
                           |   `-    http://www.debian.org/
</body></email><email><emailId>20070430111630</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-04-30 11:16:30-0400</timestampReceived><subject>Re: architectural proposal &amp; technical problems</subject><body>

On Fri, Apr 27, 2007 at 12:39:13PM -0400, Nick Mathewson wrote:
&gt; &gt;    Having the possibility to choose arbitrary exits within one
&gt; &gt;    circuit would also enable us to do the measurements on
&gt; &gt;    partial circuits. What do you think about that?
&gt; 
&gt; This should be do-able by modifying the control protocol to adding an
&gt; extra flag to ATTACHSTREAM, right?
&gt; 
&gt; That is, you'd have a controller listen for circuit and stream events.
&gt; You'd tell the controller to build a circuit.  Then you'd launch a
&gt; stream to localost and say something like,
&gt; 
&gt;    ATTACHSTREAM (yourstream) (yourcircuit) HOP=2
&gt; 
&gt; to attach the stream to the second hop.  Then you'd time the delay
&gt; between the ATTACHSTREAM and receiving the END cell.

I just implemented this:
http://archives.seul.org/or/cvs/Apr-2007/msg00137.html

It's not quite what Johannes wanted, because we currently still refuse to
attach to a 1-hop circuit, and now we also refuse to attach to the 1st
hop of a circuit. This is to discourage people from using Tor as a one
hop proxy, for the safety of our server operators (see paragraph 3 of
http://wiki.noreply.org/noreply/TheOnionRouter/TorFAQ#VariablePathLength).

Of course, it's not hard to change the code to take that check out
on the client side; and if you're doing the tests from a server
listed in the directory, the other Tor servers will likely let you
use a one-hop circuit. Is that good enough, or should we revisit the
client-disallows-single-hop-circuits-too idea?

Thanks,
--Roger

</body></email><email><emailId>20070430125349</emailId><senderName>Karsten Loesing</senderName><senderEmail>karsten.loesing@gmx.net</senderEmail><timestampReceived>2007-04-30 12:53:49-0400</timestampReceived><subject>Re: Anonymity-preserving collection of usage data of a hidden service</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Hi,

&gt; Looks great as a first step. But since you ask :), here are some code
&gt; comments for a revision of the patch:

Thank you for taking the effort! Really!

I think that I have made all the changes. I replaced the SVN patch at
the old location:

    http://88.84.144.63/hsusage-patch

If there are further changes that I can make, please tell me! (If you
make them by yourself and they don't require a comment, I will see them
in the SVN diff when you commit the code.)

&gt;&gt; Btw: When reading the code I found the command-line option
&gt;&gt; "--ignore-missing-torrc" that I didn't find in the docs.
&gt; 
&gt; Yeah, we don't document our commandline switches like this very
&gt; well. This one was only added recently. Where are the rest of
&gt; them documented? :) We should add this one.

I did not add the documentation for it, because I was not completely
sure what it does. Does it tell to not look in my profile for a torrc
file? Or does it merely ignore the case that I provide a torrc using -f
and that file does not exist? Or maybe something else?

In fact, a few weeks ago I was looking for a way to start Tor without
any dependency on other folders than the working directory. I wanted to
use it for testing purposes as Tor process with default configuration,
regardless of what I configured in my usual environment for anonmyous
surfing. I ended up writing my own torrc file and providing that using -f.

- --Karsten

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFGNebc0M+WPffBEmURAoENAJ9GZeRdOnQ4FZI9g8zdlfN0gsgpOwCgmk7u
qSuhXegl351mWzgdIQ96Zq8=
=SC1g
-----END PGP SIGNATURE-----
</body></email><email><emailId>20070430171613</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-04-30 17:16:13-0400</timestampReceived><subject>Re: 103-multilevel-keys and 101-dir-voting</subject><body>


On Mon, Apr 30, 2007 at 02:22:39AM -0400, Roger Dingledine wrote:

Hi, Roger, and thanks for your comments!  I've cleaned up 103 a bit in
response.

&gt; On Sat, Apr 21, 2007 at 01:48:58PM -0400, nickm@seul.org wrote:
&gt; &gt; Modified: tor/trunk/doc/spec/proposals/103-multilevel-keys.txt
&gt; &gt; ===================================================================
&gt; &gt; --- tor/trunk/doc/spec/proposals/103-multilevel-keys.txt	2007-04-21 17:48:45 UTC (rev 9999)
&gt; &gt; +++ tor/trunk/doc/spec/proposals/103-multilevel-keys.txt	2007-04-21 17:48:50 UTC (rev 10000)
&gt; &gt; +Extensions to Proposal 101.
&gt; &gt; +
&gt; &gt; +  Add the following elements to vote documents:
&gt; &gt; +
&gt; &gt; +     "dir-identity-key": The long-term identity key for this authority.
&gt; 
&gt; Is this a base16 hash, or the whole key? Seems to me that either the
&gt; client knows the identity key already from the keys file we ship, in
&gt; which case a hash is sufficient, or he doesn't, in which case he doesn't
&gt; care what it is because he won't trust it anyway.

It is the whole key.  I was thinking we should do what we do now with
identity keys: the client ships with a hash of all the authorities'
identity keys, but not the actual keys themselves.  Thus, the key
would need to be included so the client can tell what it is, but the
client would recognize bad keys.

(We ship clients with only the hashes for router identity keys because
our configuration system deals with one-line configuration options far
better than with inline keys.  We used to ship with an authority keys
file, but I seem to recall this as having been annoying.)

&gt; &gt; +     "dir-key-published": The time when this directory's signing key was last
&gt; &gt; +         changed.
&gt; 
&gt; I guess the point of this entry is that if we don't have the appropriate
&gt; signing key, yet it was published before the keys.z we have, we won't try
&gt; to fetch a new keys file? Another use would be to be able to recognize
&gt; when a given signing key is older than one we already have, in which
&gt; case we can...we can what?

The point of this entry is to make sure that we have the current
signing key in the key certificate.  When we fetch a bunch of key
certificates, we want to be sure that we don't replace a new key with
an old key.  Having a published time makes this trivial.

I agree that this isn't quite needed for vote processing; it matters
only for the key certificate.

&gt; I'm trying to figure out if this is needed here. Is it just for the
&gt; sake of completeness, and since it's just a vote we don't worry too much
&gt; about efficiency?

Right.  These fields are needed for key certificates.  I put them into
the vote documents because it is vital to have an up-to-date
certificate to process a vote, and because space-efficiency for votes
doesn't matter much.

For expositional reasons, when we merge this into dir-spec-v3.txt, we
should describe key certificates, and _then_ say that they're included
verbatim as part of votes.

&gt; 
&gt; &gt; +     "dir-key-certification": A signature of the fields "fingerprint",
&gt; &gt; +         "dir-key-published", "dir-signing-key", and "dir-identity-key",
&gt; &gt; +         concatenated, in that order.  The signed material extends from the
&gt; &gt; +         beginning of "fingerprint" through the newline after
&gt; &gt; +         "dir-key-certification".  The identity key is used to generate this
&gt; &gt; +         signature.
&gt; 
&gt; &gt; +      The elements "fingerprint", "dir-key-published", "dir-signing-key",
&gt; &gt; +      "dir-identity-key", and "dir-key-certification" together constitute a
&gt; &gt; +      "key certificate".  These are generated offline when starting a v2.1
&gt; &gt; +      authority.
&gt; &gt; +
&gt; &gt; +      The elements "dir-signing-key", "dir-key-published", and
&gt; &gt; +      "dir-identity-key", "dir-key-certification" and MUST NOT appear in
&gt; &gt; +      consensus documents.
&gt; 
&gt; The two 'ands' here, plus the missing 'and', make me nervous that this
&gt; wasn't the list you actually intended to produce. :)

Okay, I'll clean this up, and do the exposition I want.

&gt; 
&gt; &gt; +      The "fingerprint" field is generated based on the identity key, not
&gt; &gt; +      the signing key.
&gt; 
&gt; Doesn't this make it redundant with dir-identity-key?

The "fingerprint" field appears in consensus documents.
dir-identity-key doesn't.

Also, note that we have both fingerprint and identity key in router
descriptors.  The fingerprint is helpful because people often want to
identity a router by fingerprint, but calculating the hash of a key by
hand is not trivial.

&gt; Also, is it useful somewhere to bind the directory identity key to the
&gt; router identity key?

I don't think so.  Can you think of an application for this?

&gt;
&gt; &gt; +  Consensus network statues change as follows:
&gt; &gt; +
&gt; &gt; +      Remove dir-signing-key.
&gt; &gt; +
&gt; &gt; +      Change "directory-signature" to take a fingerprint of the authority's
&gt; &gt; +      identity key rather than the authority's nickname.
&gt; 
&gt; This will affect how we define dir-source too, since it wants the
&gt; dir-source to match the nickname in the directory-signature. Shall we
&gt; just list a hash of the identity key as the dir-source too?

Yes, sure.

&gt; In fact, should we just get rid of dir-source?

I don't think so.  It's useful when tracking which consensus directory
we're actually looking at, and where the authorities are today.

&gt; 
&gt; &gt; +  Add a new document type:
&gt; &gt; +
&gt; &gt; +      A "keys" document contains all currently known key certification
&gt; &gt; +      certificates.  All authorities serve it at
&gt; &gt; +
&gt; &gt; +          http://&lt;hostname&gt;/tor/status/keys.z
&gt; &gt; +
&gt; &gt; +      Caches and clients download the keys document whenever they receive a
&gt; &gt; +      consensus vote that uses a key they do not recognize.  Caches download
&gt; &gt; +      from authorities; clients download from caches.
&gt; &gt; +
&gt; &gt; +  Verification:
&gt; &gt; +
&gt; &gt; +      [XXXX write me]
&gt; 
&gt; What's in the verification section?

This:

  Processing votes:

      When receiving a vote, authorities check to see if the key
      certificate for the voter is different from the one they have.
      If the key certificate _is_ different, and its dir-key-published
      is more recent than the most recently known one, and it is
      well-formed and correctly signed with the correct identity key,
      then authorities remember it as the new canonical key
      certificate for that voter.

  A key certificate is invalid if any of the following hold:
      * The version is unrecognized
      * The fingerprint does not match the identity key.
      * The identity key or the signing key is ill-formed.
      * The published date is very far in the past or future.
      * The signature is not a valid signature of the key certificate
        generated with the identity key.

  When processing the signatures on consensus, clients and caches act
  as follows:

      1. Only consider the directory-signature entries whose identity
         key hashes match trusted authorities.

      2. If any such entries have signing key hashes that match
         unknown signing keys, download a new keys document.

      3. For every entry with a known (identity key,signing key) pair,
         check the signature on the document.

      4. If the document has been signed by more than half of the
         authorities the client recognizes, treat the consensus as
         correctly signed.

         If not, but the number entries with known identity keys but
         unknown signing keys might be enough to make the consensus
         correctly signed, do not use the consensus, but do not
         discard it until we have a new keys document.

&gt; In general, I think we're moving in the right direction here, and it's
&gt; a fine time to start coding if you'd like to (which from talking to you
&gt; it sounds like you do). Let us know if you run into any other troubles
&gt; that are non-obvious.

Okay.  I don't think we have a status for this.  Should we loosen the
status of "Accepted", or add a new "Trying to code" status?

yrs,
-- 
Nick Mathewson

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070422234151</emailId><senderName>Karsten Loesing</senderName><senderEmail>karsten.loesing@gmx.net</senderEmail><timestampReceived>2007-04-22 23:41:51-0400</timestampReceived><subject>A Java-based Tor simulator -- where can I share it?</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Hello,

as a preparatory work for my GSoC project I implemented a Java-based Tor
simulator that might also be useful for others (the other GSoC
students?). Originally, it was intended to analyze behavior of hidden
service requests in public and private Tor networks. But I think it can
be used for other services in Tor, too. At least it can be a start to
generate a first network configuration. If you want to read more, I
attached the first section of the howto to this mail. And maybe you can
read even more in the future......

(and this brings me to my actual question): ...... where? How can I
share this code? Can you host it at your Subversion repository? Or will
Google host it (because it's part of the project)? I could also host it
at the CVS repository at our university, but how would others learn
about it (link)?

The next question is about the code that we GSoCers are going to write
during our projects: do you create a branch for each GSoC project? Or
will we host our projects at Google or by ourselves?

And the last question: What about licenses? What do I have to write to
the code to include it in the license?

- --Karsten


- ---- Introduction section of User's Guide ----

PuppeTor (working title) is a Java framework that facilitates the
configuration of a set of local Tor processes and the execution of
automatic tests based on these processes. The intention is to make it
easier for developers to analyze Tor's behavior in arbitrary network
settings and to measure the effects of changes to the Tor source code.
Due to the automation of configuration and execution, these experiments
can be done in an unsupervised batch fashion.

An application that makes use of this framework starts with setting up a
set of pre-defined Tor processes: proxy, router, and directory. Though
these configurations should work in most settings, they can be altered
by adding or removing configuration entries. After deciding whether the
processes shall either create a private Tor network, or connect to the
public Tor network, processes are started. Now the application can start
clients and servers and perform requests using the local processes. In
doing so, it can measure time intervals between events originating from
Tor processes and it can synchronize with such events. Further, the
application can re-configure processes during their execution using the
Tor controller.

There are two typical situations in which this framework can be useful:

1. Developers need to oversee the effects of their changes to the source
code. Therefore, it is useful to have a clean setting of Tor nodes in a
private network, so that all nodes are under full control of the developer.

2. Developers might want to measure the real-world performance of
certain Tor operations. Hence, they can set up nodes at the edge of the
public Tor network and conduct performance measurements, maybe in a
batch of some hundreds or thousands of runs.

Of course, the applications described here are possible without this
framework. But this framework has certain advantages over writing own
configuration files and test scripts:

1. It provides developers with pre-defined configurations of nodes.
Especially the configuration of nodes in a private network with own
directory nodes is not a trivial task.

2. It takes away the need to implement synchronization of a test
application with events created by Tor processes. This, too, is a
non-trivial task and can, if not done properly, lead to deadlocks or
inconsistent states (yes, this happened during development of the
framework, too).

3. It relieves the developer from the task to collect and merge log
files. Typically, every Tor process produces its own log file, so that
all files might need to be merged in chronological order to identify
causal dependencies.

Originally this framework has been designed to perform experiments on
Tor hidden services. But it should be feasible for experiments on onion
routing and other Tor services, too. If you have found an alternative
usage for it, and maybe have changed or extended it to support your own
application, please feel free to contribute your additions. And please
report bugs.
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.7 (MingW32)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFGK/K+0M+WPffBEmURAs60AJ4g96GSKXmoHx1lhO3oWPPmaamN/gCgz/UK
6wNI6WXNcxuNAO3+1w7XsJc=
=kZbs
-----END PGP SIGNATURE-----
</body></email><email><emailId>20070418213504</emailId><senderName>Mike Perry</senderName><senderEmail>mikepery@fscked.org</senderEmail><timestampReceived>2007-04-18 21:35:04-0400</timestampReceived><subject>Proposal: Bring Back PathlenCoinWeight</subject><body>

Filename: 1xx-PathlenCoinWeight.txt
Title: Pathlen Coin Weight
Version:
Last-Modified:
Author: Mike Perry
Created:
Status: Open


Overview:

  The idea is that users should be able to choose a weight which
  probabilistically chooses their path lengths to be 2 or 3 hops. This
  weight will essentially be a biased coin that indicates an
  additional hop (beyond 2) with probability P. The user should be
  allowed to choose 0 for this weight to always get 2 hops and 1 to
  always get 3. 
  
  This value should be modifiable from the controller, and should be 
  available from Vidalia.


Motivation:

  The Tor network is slow and overloaded. Increasingly often I hear 
  stories about friends and friends of friends who are behind firewalls, 
  annoying censorware, or under surveillance that interferes with their 
  productivity and Internet usage, or chills their speech. These people 
  know about Tor, but they choose to put up with the censorship because 
  Tor is too slow to be usable for them. In fact, to download a fresh, 
  complete copy of levine-timing.pdf for the Anonymity Implications 
  section of this proposal over Tor took me 3 tries.

  There are many ways to improve the speed problem, and of course we 
  should and will implement as many as we can. Johannes's GSoC project 
  and my reputation system are longer term, higher-effort things that 
  will still provide benefit independent of this proposal.

  However, reducing the path length to 2 for those who do not need the
  (questionable) extra anonymity 3 hops provide not only improves
  their Tor experience but also reduces their load on the Tor network by
  33%, and can be done in less than 10 lines of code. That's not just
  Win-Win, it's Win-Win-Win.

  Furthermore, when blocking resistance measures insert an extra relay
  hop into the equation, 4 hops will certainly be completely unusable 
  for these users, especially since it will be considerably more
  difficult to balance the load across a dark relay net than balancing
  the load on Tor itself (which today is still not without its flaws).


Anonymity Implications:
  
  It has long been established that timing attacks against mixed
  networks are extremely effective, and that regardless of path
  length, if the adversary has compromised your first and last 
  hop of your path, you can assume they have compromised your 
  identity for that connection. 
  
  In [1], it is demonstrated that for all but the slowest, lossiest 
  networks, error rates for false positives and false negatives were 
  very near zero. Only for constant streams of traffic over slow and 
  (more importantly) extremely lossy network links did the error rate 
  hit 20%. For loss rates typical to the Internet, even the error rate 
  for slow nodes with constant traffic streams was 13%.

  When you take into account that most Tor streams are not constant,
  but probably much more like their "HomeIP" dataset, which consists
  mostly of web traffic that exists over finite intervals at specific
  times, error rates drop to fractions of 1%, even for the "worst"
  network nodes.

  Therefore, the user has little benefit from the extra hop, assuming
  the adversary does timing correlation on their nodes. The real
  protection is the probability of getting both the first and last hop, 
  and this is constant whether the client chooses 2 hops, 3 hops, or 42.

  Partitioning attacks form another concern. Since Tor uses telescoping
  to build circuits, it is possible to tell a user is constructing only
  two hop paths at the entry node. It is questionable if this data is
  actually worth anything though, especially if the majority of users
  have easy access to this option, and do actually choose their path
  lengths semi-randomly.

  Nick has postulated that exits may also be able to tell that you are
  using only 2 hops by the amount of time between sending their
  RELAY_CONNECTED cell and the first bit of RELAY_DATA traffic they
  see from the OP. I doubt that they will be able to make much use
  of this timing pattern, since it will likely vary widely depending
  upon the type of node selected for that first hop, and the user's
  connection rate to that first hop. It is also questionable if this
  data is worth anything, especially if many users are using this
  option (and I imagine many will).

  Perhaps most seriously, two hop paths do allow malicious guards 
  to easily fail circuits if they do not extend to their colluding peers
  for the exit hop. Since guards can detect the number of hops in a
  path, they could always fail the 3 hop circuits and focus on
  selectively failing the two hop ones until a peer was chosen.

  I believe currently guards are rotated if circuits fail, which does 
  provide some protection, but this could be changed so that an entry 
  guard is completely abandoned after a certain number of extend or 
  general circuit failures, though perhaps this also could be gamed 
  to increase guard turnover. Such a game would be much more noticeable 
  than an individual guard failing circuits, though, since it would
  affect all clients, not just those who chose a particular guard.


Why not fix Pathlen=2?:

  The main reason I am not advocating that we always use 2 hops is that 
  in some situations, timing correlation evidence by itself may not be 
  considered as solid and convincing as an actual, uninterrupted, fully 
  traced path. Are these timing attacks as effective on a real network 
  as they are in simulation? Would an extralegal adversary or authoritarian 
  government even care? In the face of these situation-dependent unknowns, 
  it should be up to the user to decide if this is a concern for them or not.


Implementation:

  new_route_len() can be modified directly with a check of the 
  PathlenCoinWeight option (converted to percent) and a call to 
  crypto_rand_int(0,100) for the weighted coin.

  The Vidalia setting should probably be in the network status window
  as a slider, complete with tooltip, help documentation, and perhaps
  an "Are you Sure?" checkbox.

  The entry_guard_t structure could have a num_circ_failed member
  such that if it exceeds N circuit extend failure to a second hop, 
  it is removed from the entry list. N should be sufficiently high 
  to avoid churn from normal Tor circuit failure, and could possibly be
  represented as a ratio of failed to successful circuits through that
  guard.
  

Migration:

  Phase one: Re-enable config and modify new_route_len() to add an
  extra hop if coin comes up "heads".

  Phase two: Experiment with the proper ratio of circuit failures 
  used to expire garbage or malicious guards.

  Phase three: Make slider or entry box in Vidalia, along with help entry 
  that explains in layman's terms the risks involved.


[1] http://www.cs.umass.edu/~mwright/papers/levine-timing.pdf


-- 
Mike Perry
Mad Computer Scientist
fscked.org evil labs
</body></email><email><emailId>20070419224537</emailId><senderName>Mike Perry</senderName><senderEmail>mikeperry@fscked.org</senderEmail><timestampReceived>2007-04-19 22:45:37-0400</timestampReceived><subject>Re: Proposal: Bring Back PathlenCoinWeight</subject><body>

I love replying to myself. I can't resist doing it. Sorry. "Think twice
post once" is a concept totally lost on me, especially when I'm wrong
the first two times ;)


Thus spake Mike Perry (mikepery@fscked.org):

&gt; Why not fix Pathlen=2?:
&gt; 
&gt;   The main reason I am not advocating that we always use 2 hops is that 
&gt;   in some situations, timing correlation evidence by itself may not be 
&gt;   considered as solid and convincing as an actual, uninterrupted, fully 
&gt;   traced path. Are these timing attacks as effective on a real network 
&gt;   as they are in simulation? Would an extralegal adversary or authoritarian 
&gt;   government even care? In the face of these situation-dependent unknowns, 
&gt;   it should be up to the user to decide if this is a concern for them or not.

Hrmm.. it should probably also be noted that even a false positive
rate of 1% for a 200k concurrent-user network could mean that for a
given node, a given stream could be confused with something like 10
users, assuming ~200 nodes carry most of the traffic (ie 1000 users
each). Though of course to really know for sure, someone needs to do
an attack on a real network, unfortunately.

For this reason this option should instead be represented not as a
slider, but as a straight boolean value, at least in Vidalia.

Perhaps something like a radiobutton: 

 * "I use Tor for Censorship Resistance, not Anonymity. Speed is more
    important to me than Anonymity."
 * "I use Tor for Anonymity. I need extra protection at the cost of speed."

and then some explanation in the help for exactly what this means, and
the risks involved with eliminating the adversary's need for timing attacks 
wrt to false positives, etc.

This radio button can then also be used to toggle Johannes's work,
should it be discovered that using latency/bandwidth measurements
gives the adversary some information as to your location or likely
node choices. Or we can create a series of choices along these lines
as more load balancing/path choice optimizations are developed.

---- 

So what does this change mean wrt to the proposal process? Should I
submit a new proposal? I'm still on the fence if the underlying torrc
option and Tor implementation should be a coin weight or a fixed
value, so at this point really all this changes is the proposed
Vidalia behavior (Vidalia is an imporant part of this proposal,
because it would be nice to take 33% of the load off the network for
all users who do not need 3 hops).


-- 
Mike Perry
Mad Computer Scientist
fscked.org evil labs
</body></email><email><emailId>20070426071633</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-04-26 07:16:33-0400</timestampReceived><subject>Re: Simplifying directory authority administration</subject><body>

On Sat, Apr 21, 2007 at 01:48:58PM -0400, nickm@seul.org wrote:
&gt; Added: tor/trunk/doc/spec/proposals/113-fast-authority-interface.txt
&gt; ===================================================================
&gt; --- tor/trunk/doc/spec/proposals/113-fast-authority-interface.txt	2007-04-21 17:48:45 UTC (rev 9999)
&gt; +++ tor/trunk/doc/spec/proposals/113-fast-authority-interface.txt	2007-04-21 17:48:50 UTC (rev 10000)
&gt; @@ -0,0 +1,80 @@
&gt; +Filename: 113-fast-authority-interface.txt
&gt; +Title: Simplifying directory authority administration
&gt; +Version: $Revision: 12412 $
&gt; +Last-Modified: $Date: 2007-04-16T19:11:29.511998Z $
&gt; +Author: Nick Mathewson
&gt; +Created:
&gt; +Status: Open
&gt; +
&gt; +Overview
&gt; +
&gt; +The problem:
&gt; +
&gt; +  Administering a directory authority is a pain: you need to go through
&gt; +  emails and manually add new nodes as "named".  When bad things come up,
&gt; +  you need to mark nodes (or whole regions) as invalid, badexit, etc.
&gt; +
&gt; +  This means that mostly, authority admins don't: only 2/4 current authority
&gt; +  admins actually bind names or list bad exits, and those two have often
&gt; +  complained about how annoying it is to do so.
&gt; +
&gt; +  Worse, name binding is a common path, but it's a pain in the neck: nobody
&gt; +  has done it for a couple of months.

A related problem is that people register nicknames and then vanish,
and a year or two later somebody picks the same nickname and is locked
out of the network -- in a way that isn't really intuitive to the poor
server operator.

A deeper problem is really that naming isn't very useful anymore. Once
upon a time we imagined that people would refer to servers by nickname,
and an unamed server was not recommended for use. Requiring an email was
in large part a Sybil deterrent. Then we scaled past the point where
that was practical -- so we started letting unnamed servers be used in
ordinary situations, and even let multiple servers with the same nickname
join the network. We migrated to referring to servers by identity key,
because that's the unique identifier now.

So part of the reason that name binding isn't actively done anymore is
that it doesn't (seem to) matter enough.

Indeed, the main reason for answering name registration mail is not to
get the name on record -- it's to make the server operator feel welcome,
and to help catch misconfigurations and confusions early.

While we're listing problems with the Named flag, its utility is also
limited because we're missing an Unnamed flag: if only one directory
authority has a binding for a given nickname, and the named server hasn't
published a descriptor recently, then some other server can arrive in
the meantime with the same nickname and it will be listed by the other
n-1 dir authorities. (But the naive implementation of this lets a single
dir authority cut out any server(s) it chooses from the network; looks
like more research remains here.)

We could also imagine a client-side Naming strategy, where clients bind
keys to nicknames the first time they reference them, and then store
the binding locally.

But in the interest of not expanding this proposal to include all the
issues with name binding, I'm going to try to focus on the easiest and
simplest to deploy that will solve a few of the immediate problems.

&gt; +Digression: who knows what?
&gt; +
&gt; +  It's trivial for Tor to automatically keep track of all of the
&gt; +  following information about a server:
&gt; +    name, fingerprint, IP, last-seen time, first-seen time, declared
&gt; +    contact.
&gt; +
&gt; +  All we need to have the administrator set is:
&gt; +    - Is this name/fingerprint pair bound?
&gt; +    - Is this fingerprint/IP a bad exit?
&gt; +    - Is this fingerprint/IP an invalid node?
&gt; +    - Is this fingerprint/IP to be rejected?
&gt; +
&gt; +  The workflow for authority admins has two parts:
&gt; +    - Periodically, go through tor-ops and add new names.  This doesn't
&gt; +      need to be done urgently.
&gt; +    - Less often, mark badly behaved serves as badly behaved.  This is more
&gt; +      urgent.
&gt; +
&gt; +Possible solution #1: Web-interface for name binding.
&gt; +
&gt; +  Deprecate use of the tor-ops mailing list; instead, have operators go to a
&gt; +  webform and enter their server info.  This would put the information in a
&gt; +  standardized format, thus allowing quick, nearly-automated approval and
&gt; +  reply.

We could do this. But if the goal of the tor-ops mail is to give them a
human contact, it's not effective. And if the goal is to write down the
details, we already pointed out that all of this data can be automatedly
gathered.

So is there some "now I want to be registered" step that it's useful
for a human to go through, and actually has much impact on the network?

The only reason I can see for implementing solution 1 is as a stopgap
solution -- if the other solutions aren't worth the trouble to implement
them.

&gt; +Possible solution #2: Self-binding names.
&gt; +
&gt; +  Peter Palfrader has proposed that names be assigned automatically to nodes
&gt; +  that have been up and running and valid for a while.

This seems to be the closest approximation of what we (used to) do when
naming: when we find a fingerprint in our mail, make sure that the server
is actually running, and then blindly add it to the approved-routers file.

We could also imagine an auto expiry, where a server that hasn't been
seen in a few months loses its Named status.

(Which leads to the original question of what Named is actually for.)

&gt; +Possible solution #3: Self-maintaining approved-routers file
&gt; +
&gt; +  Mixminion alpha has a neat feature where whenever a new server is seen,
&gt; +  a stub line gets added to a configuration file.  For Tor, it could look
&gt; +  something like this:
&gt; +
&gt; +    ## First seen with this key on 2007-04-21 13:13:14
&gt; +    ## Stayed up for at least 12 hours on IP 192.168.10.10
&gt; +    #RouterName AAAABBBBCCCCDDDDEFEF
&gt; +
&gt; +  (Note that the implementation needs to parse commented lines to make sure
&gt; +  that it doesn't add duplicates, but that's not so hard.)
&gt; +
&gt; +  To add a router as named, administrators would only need to uncomment the
&gt; +  entry.  This automatically maintained file could be kept separately from a
&gt; +  manually maintained one.
&gt; +
&gt; +  This could be combined with solution #2, such that Tor would do the hard
&gt; +  work of uncommenting entries for routers that should get Named, but
&gt; +  operators could override its decisions.

Actually, I think this is what weasel had in mind in suggestion #2.

While we're at it, I note that keeping the two files separate lets us
expire the Namedness on the servers that got automatically named without
expiring the ones that got manually named.

&gt; +Possible solution #4: A separate mailing list for authority operators.
&gt; +
&gt; +  Right now, the tor-ops list is very high volume.  There should be another
&gt; +  list that's only for dealing with problems that need prompt action, like
&gt; +  marking a router as !badexit.

I think this covers a separate issue. We could do this, but in practice
we've done fine finding each other on IRC or sending mail directly in
the few cases that fails.

--Roger

</body></email><email><emailId>20070425191628</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-04-25 19:16:28-0400</timestampReceived><subject>Re: [or-cvs] r9993: Describe a simpler implementation for proposal 108, and note (in tor/trunk: . do</subject><body>

On Fri, Apr 20, 2007 at 01:17:15PM -0400, nickm@seul.org wrote:
&gt;    tor/trunk/doc/spec/proposals/108-mtbf-based-stability.txt
[snip]
&gt; +Alternative:
&gt; +
&gt; +   "A router's Stability shall be defined as the sum of $alpha ^ d$ for every
&gt; +   $d$ such that the router was not observed to be unavailable $d$ days ago."
&gt; +
&gt; +   This allows a simpler implementation: every day, we multiply yesterday's
&gt; +   Stability by alpha, and if the router was running for all of today, we add
&gt; +   1.

I don't think you mean quite that. For a server that just appeared,
there are an infinite number of previous days where it was not observed
to be unavailable. Do you mean 'was observed to be available'? And by
available, do we mean available for the entire day?

What are some ways we can choose \alpha?

&gt; +Limitations:
&gt; +
&gt; +   Authorities can have false positives and false negatives when trying to
&gt; +   tell whether a router is up or down.  So long as these aren't terribly
&gt; +   wrong, and so long as they aren't significantly biased, we should be able
&gt; +   to use them to estimate stability pretty well.

I haven't seen any discussion about how the router's declared uptime fits
into this. If a router goes down and then comes up again in between
measurements, the proposed approach will treat it as being up the
whole time -- yet connections through it will be broken. One approach
to handling this would be to notice if the uptime decreases from one
descriptor to the next. This would indicate a self-declared downtime
for the router, and we can just figure that into the calculations.

I'm not sure how we should compute the length of the downtime though:
in some cases it will be just a split second as for a reboot or upgrade,
but in others maybe the computer, network, or Tor process went down
and then came back a long time later. I guess since our computations
are just rough approximations anyway, we can just assume a zero-length
downtime unless our active testing also noticed it.

Speaking of the active testing, here's what we do right now:

Every 10 seconds, we call dirserv_test_reachability(), and it tries making
connections to a different 1/128 of the router list. So a given router
gets tried every 1280 seconds, or a bit over 21 minutes. We declare a
router to be unreachable if it has not been successfully found reachable
within the past 45 minutes. So at least two testing periods not to go
by before a running router is considered to be no longer running.

So our measurements won't be perfect, but I think this approach is a
much better one than just blindly believing the uptime entry in the
router descriptor.

What is our plan for storing (and publishing?) the observed uptime
periods for each router?

--Roger

</body></email><email><emailId>20070424142103</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-04-24 14:21:03-0400</timestampReceived><subject>(FWD) Re: architectural proposal &amp; technical problems</subject><body>

[Forwarding because Johannes isn't subscribed to the list -RD]

----- Forwarded message from owner-or-dev@freehaven.net -----

Date: Tue, 24 Apr 2007 15:11:55 +0200
From: Johannes Renner &lt;renner@i4.informatik.rwth-aachen.de&gt;
To: Mike Perry &lt;mikeperry@fscked.org&gt;
Cc: or-dev@freehaven.net,
	Andriy Panchenko &lt;panchenko@i4.informatik.rwth-aachen.de&gt;,
	Lexi Pimenidis &lt;lexi@i4.informatik.rwth-aachen.de&gt;
Subject: Re: architectural proposal &amp; technical problems

Mike Perry wrote:
&gt; I doubt that bandwidths between routers
&gt; will change very much from minute to minute, and even if they do,
&gt; currently directory descriptors don't refresh fast enough for it to
&gt; matter.

I think that the available bandwidths between routers may actually
change from minute to minute since it depends on how many streams
a link carries and what amounts of data. I'll investigate further,
but you are right, router descriptors don't refresh fast enough and
we actually didn't plan to use them (see below).

&gt; So I'm a bit confused. Will the routers be publishing bandwidth
&gt; information to the directory via opt flags, or will they be publishing
&gt; it to modified clients via the addon?

No, they should not publish any bw-information to the directory, but
just an optional flag, so that clients can see that this router is
running such an addon and thus can request information directly from
it by connecting to an advertised port, e.g. "opt BandwidthInformer 9053".

(btw: does anybody know technically how to set "opt"-flags in a comfortable way?)

The QoS-addon, running together with an OP, could request a BW-status
document from these BandwidthInformer-addons of supporting routers via
this port. This document could consist of a list of all nodes the router
maintains TLS-connections to, together with their available, max and avg
throughput-values. A single entry could look like this, where this
specific entry would describe information about the link from the
node the information comes from to xyz (node, max, avg):

xyz, 10759.1210487, 4395.78653144

max in here is the maximal throughput the link has seen over a single
interval in some recent period. Of course it could possibly carry
also faster, but at least this speed has already been seen. avg is
the average measured value for the last interval, so the difference
of the both shows up to be the available/currently not used throughput
(this example is all bytes/sec). Because this information is averaged
over some time interval it is not that new, that it could be dangerous
for anonymity, but maybe 'new enough' to get used by clients as routing
metrics.

&gt; How do you intend to do the balancing for bandwidth and latency if
&gt; every client were to be using your scheme?

Latencies would be measured locally from within the clients using a
probabilistic selection of nodes, just like selecting nodes for
regular circuits (maybe restricted to the fast percentile of the
routers). This information will not be made available for the others,
so every client will end up with his/her own pool of currently
considered to be fast nodes/links. That will do the load-balancing,
because if all of the clients were using the same nodes, we would
measure bad performance and simply (probabilistic) choose other nodes.

And it will be the same with bandwidth: everyone who is interested
in, queries different (probabilistic chosen) routers in different
moments. Because the best links a router maintains in t+1 can be
different from those in t, every client in the end explores its
own random corner of the network.

&gt; So, is this whole design a prototype, or is it meant to last?

In the begining it will be a prototype, because we surely not know
what is the best practice. It would be good to work on a prototype,
that is designed in a way, that it could become a real-world used
implementation later on.

&gt; why not just get a fast
&gt; link and measure bandwidths AND latencies of two-hop paths
&gt; client-side, and store them yourself to run tests? Speedracer can
&gt; measure 2 hop bandwidths pretty well, and while it is a hack, you can
&gt; do latency measurements via socks and localhost as you mentioned.

The idea is to put as little additional load on the network as possible;
therefore we do not plan to transfer extra files in order to measure the
bandwidth (why not take that info from ORs since it is already available
there?). Otherwise we think that latency measurements will not put too much
load on the network - these are single ping cells.

But we do not understand exactly what you mean with two-hop paths in here.
Why exactly 2? Do you mean to use the EXTEND command to build a two-hop
circuit and use this for measuring? This should be also possible for
one-hop circuits, right?

Well, what we actually would like to have is the possibility to construct
only one three-hop circuit and measure partial circuits regularly (lets say
you have circ through 0-1-2-3 [where 0 is us], we are interested in doing
measurings for 0-1, 0-1-2 and 0-1-2-3).
I also like the PathlenCoinWeight proposal. This could also be useful for
measuring latencies, but the best would be just to be able to exit an existing
3-hop-circuit at any chosen hop in between. So we could measure RTTs of partial
circuits and easily compute values for single used links.
Any of the devels can help us further?

&gt; The other thing to consider is that this information is likely to get
&gt; pretty large if every node participates. You should spend at least
&gt; some time considering doing some form of eigenvector compression (SVD:
&gt; http://en.wikipedia.org/wiki/Singular_value_decomposition, PCA:
&gt; http://en.wikipedia.org/wiki/Principal_components_analysis), and how
&gt; much this compresses the data and at what cost to accuracy and ability
&gt; to detect liars.

True, if you consider a central repository for the data. In this v0
proposal we thought about making only local information available for
the others (see above).

&gt; 1. Do we trust individual nodes to publish their peer latencies and
&gt;    bandwidths?

I think, that we of course cannot trust them individual nodes.
At first we want to check whether the published information reflects the
reality and if it can be useful for clients at all. And then I think this
would be the point where we would need something like reputation?

&gt; 2. If we do not trust individual nodes, how do we deal with the fact
&gt;    that it will soon be very hard to collect these n^2 measurments from
&gt;    the perspective of a central authority?
&gt;    A. Can we divide them into tiers?
&gt;    B. Or perhaps just truncate at some %age of the network where we just assign a constant value to the
&gt;       bandwidth of all peers (perhaps node_capacity/num_peers). But what
&gt;       about latency?
&gt;    C. Or do we do all these measurements on the fly and keep long-term client
&gt;       state around, so Tor gets faster the more you use it. This could
&gt;       work really well for both bandwidth and latency in the 2-hop
&gt;       "Censorship Resistance Only" mode I proposed in Proposal 112.
&gt;       But this is particularly dangerous to anonymity, since clients
&gt;       are likely to learn highly unique views of the network, and is
&gt;       potentially vulnerable to gaming/selective service attacks.

We first want to test and try out and check what information exactly
helps best to improve the performance.
Then, if we know what will be useful we can think more about hiding
stuff for saving as much anonymity as possible.
These are all very interesting, challenging and important questions,
that have to addressed, but for the moment I think 2C sounds good:
The long-term client that makes Tor faster the more you use it.

So for our purposes we would be pleased with a Tor/Tor control protocol
that is extended to the following capabilities:

- Two new configuration options that can be set via SETCONF:

  1. "opt"-entry for descriptor, example: SETCONF OptDescEntry="BandwidthInformer 9053"
  2. option to tell Tor, that it should not construct any circuits by itself, similar
     to __LeaveStreamsUnattached, example: SETCONF __IdleCircuits=0

- One new command that connects over a given circuit to destIP, destPort specifying
  0, 1 or 2 to tell Tor which node of the circuit we want to address for exiting, e.g.:

  "CONNECT" SP circID SP ("0"|"1"|"2") SP destIP SP destPort

This would enable us to implement my favorite method of latency-testing,
but surely needs modifications in Tor and the control protocol. So how
do you do such modifications? Do we have to implement a patch for Tor as
kind of a proposal? What other extensions do you want the control
protocol to implement for your projects? Maybe we can develop it in a way
everybody will like it?

Greetings,
Hannes

----- End forwarded message -----

</body></email><email><emailId>20070422064320</emailId><senderName>Mike Perry</senderName><senderEmail>mikeperry@fscked.org</senderEmail><timestampReceived>2007-04-22 06:43:20-0400</timestampReceived><subject>Re: architectural proposal &amp; technical problems</subject><body>

Sorry for the delayed reply. It got lost in the noise of both
tor-assistants and the spam of my own mailbox.

Moving this discussion to or-dev. In general, I think most dev
discussion of anything tor-related should happen here rather than
tor-assistants, if nothing else for the spam problem. But it is
probably just as good to have more eyeballs on stuff.

Thus spake Johannes Renner (renner@i4.informatik.rwth-aachen.de):

&gt; The first part is an addon for ORs, that is using the Tor
&gt; control protocol to listen for events (mainly ORCONN and/or
&gt; STREAM_BW), records bandwidth-data about single TLS-connections
&gt; the router maintains to other ORs, and simply provides this
&gt; data for requesting clients. The recordings can be done in a
&gt; configurable way and would provide e.g. max observed throughput
&gt; of some period as well as current average of last n minutes
&gt; (just a current value would be much better, but also much worse
&gt; for anonymity). We believe that the difference between max and
&gt; current avg correlates with the still available bandwidth of a link.

I actually think you are best served with max bandwidth seen over any
M minute period over the past H hours, which is both good for
anonymity and good for you. I doubt that bandwidths between routers
will change very much from minute to minute, and even if they do,
currently directory descriptors don't refresh fast enough for it to
matter. Besides, just because a link isn't being used doesn't mean the
capacity isn't there. In fact, it likely means the capacity IS there
for the taking. Unfortunately we can't update fast enough to represent
that either. Or, fortunately, for anonymity's sake : )

&gt; The second part is a QoS-addon for OPs, that will contain the
&gt; algorithms for route selection. It can post requests to receive
&gt; the list of bw-information from an OR-addon. In addition to this
&gt; it does active measurings of latencies/RTTs through Tor and records
&gt; that data. Using these two orthogonal informations we can then
&gt; build fast circuits from here and attach the streams to them
&gt; using the control protocol.

So I'm a bit confused. Will the routers be publishing bandwidth
information to the directory via opt flags, or will they be publishing
it to modified clients via the addon?

How do you intend to do the balancing for bandwidth and latency if
every client were to be using your scheme?

&gt; 1. In OnionCoffee I can do measurings of RTTs in the following way:
&gt;    [Send RELAY_CONNECT cell to localhost, get failed RELAY_END
&gt;    back].

So, is this whole design a prototype, or is it meant to last? If it is
just a prototype (there's nothing wrong with this, since there are a
lot of unknowns that still need answering), why not just get a fast
link and measure bandwidths AND latencies of two-hop paths
client-side, and store them yourself to run tests? Speedracer can
measure 2 hop bandwidths pretty well, and while it is a hack, you can 
do latency measurements via socks and localhost as you mentioned.

The other thing to consider is that this information is likely to get
pretty large if every node participates. You should spend at least
some time considering doing some form of eigenvector compression (SVD:
http://en.wikipedia.org/wiki/Singular_value_decomposition, PCA:
http://en.wikipedia.org/wiki/Principal_components_analysis), and how
much this compresses the data and at what cost to accuracy and ability
to detect liars.

I think the final design choice hinges on a few factors and unsolved
problems, basically:

1. Do we trust individual nodes to publish their peer latencies and
   bandwidths?
   A. What workarounds, spot-checks, peer-verifications, or other
      means exist to reduce the ability of nodes to lie about their
      capacity to peers?
   B. How do we coordinate their vector publishing in a compact, 
      compresible way? Does this affect ability to detect lying?

2. If we do not trust individual nodes, how do we deal with the fact
   that it will soon be very hard to collect these n^2 measurments from
   the perspective of a central authority?
   A. Can we divide them into tiers? 
   B. Or perhaps just truncate at some %age of the network where we just assign a constant value to the
      bandwidth of all peers (perhaps node_capacity/num_peers). But what
      about latency?
   C. Or do we do all these measurements on the fly and keep long-term client 
      state around, so Tor gets faster the more you use it. This could
      work really well for both bandwidth and latency in the 2-hop 
      "Censorship Resistance Only" mode I proposed in Proposal 112.
      But this is particularly dangerous to anonymity, since clients
      are likely to learn highly unique views of the network, and is
      potentially vulnerable to gaming/selective service attacks. 

Note that 2C is particularly attractive for easy migration from
prototype to real implementation, and also scales well with the
network size. Unfortunately it probably destroys anonymity (or maybe
some anonymity can still be salvaged if we are clever?). It may even be
possible to learn this information with two hop circuits and apply it
to three hop circuits, making use of the proposed PathlenCoinWeight
option, if we are really clever about preserving enough anonymity so
that it makese sense to do this.



-- 
Mike Perry
Mad Computer Scientist
fscked.org evil labs

</body></email><email><emailId>20070419025201</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-04-19 02:52:01-0400</timestampReceived><subject>Re: Anonymity-preserving collection of usage data of a hidden service authoritative directory</subject><body>

On Sun, Apr 15, 2007 at 12:43:50AM +0200, Karsten Loesing wrote:
&gt; Bad news first: The disadvantage of defining aggregation of findings
&gt; without knowing the real data is that you cannot find unexpected things
&gt; using explorative data analysis. It's not that I did not think about my
&gt; expected findings, but I cannot say that this list is complete. :(

Right. We should also keep in mind that hidden services suck right now
(performance wise and reliability wise), so the current usage data may
not reflect what people actually want to do.

There are also a lot of artifacts based on the current design -- for
example I expect you will find that there are far more publishing events
than there "should" be, because we never bothered to code dir authorities
to save them to disk, and so we need to republish very frequently in
case an authority restarts and forgets them all.

But I agree, collecting info now could be a useful start, and in any
case getting a data point now will be handy down the road when we get
a data point then and wonder how it compares.

&gt; - --- begin of specification ---

This looks really good to me, actually, in terms of anonymity risks. I
suspect that it will turn out we want some other data (the problem that
comes to mind first is that the 20th percentile will go down if a bunch of
new hidden services spring up briefly, or it will go down if the numbers
are actually going down, and I'm not sure how we'll tell the difference),
but most of the coding and design work will be in aggregating the data
and we can tweak what we actually report once it's all up and working.

The only major change I would suggest is to not publish the list from
the dir port, but instead just write it to a file in the datadir. That
will be easier to code (and less invasive to the Tor code), and it also
will remove some of the feedback to an attacker that uses Nick's "guess
and check" style attacks. It would then be a bit more of a hassle to
operate, but if we don't plan to be running this feature all the time,
that's not so bad.

The rephist.c file is where a lot of the statistics should be kept.
(That's already where we keep other statistics that Tor collects.)
Let me know if you have further questions or ideas. :)

Thanks!
--Roger

</body></email><email><emailId>20070419085002</emailId><senderName>Karsten Loesing</senderName><senderEmail>karsten.loesing@gmx.net</senderEmail><timestampReceived>2007-04-19 08:50:02-0400</timestampReceived><subject>Re: Anonymity-preserving collection of usage data of a hidden service</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Hi Roger,

&gt; the problem that
&gt; comes to mind first is that the 20th percentile will go down if a bunch of
&gt; new hidden services spring up briefly, or it will go down if the numbers
&gt; are actually going down, and I'm not sure how we'll tell the difference

Actually, these measurements are those of which I know fewest of all if
they will show some interesting data. You are right, there are other
facts that have an influence on them. But I think we need to measure
some kind of distribution of request to nodes. Let's try it and see if
we have to modify them afterwards.

&gt; Let me know if you have further questions or ideas. :)

Not at the moment. Looking forward to the Weekend of Code! :)

Thank you,
Karsten
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.7 (MingW32)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFGJy060M+WPffBEmURAgxdAJ9zak7Ii068+k6Yg5//snA7Jh7cXwCgtAsc
HUqx6DBlwmfZXeLfwBAhq78=
=khK6
-----END PGP SIGNATURE-----
</body></email><email><emailId>20070429150955</emailId><senderName>Karsten Loesing</senderName><senderEmail>karsten.loesing@gmx.net</senderEmail><timestampReceived>2007-04-29 15:09:55-0400</timestampReceived><subject>Re: Anonymity-preserving collection of usage data of a hidden service</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Hi,

coming back to the discussion on anonymity-preserving collection of
usage data of a hidden service authoritative directory.

It took me two days, but I think the implementation is finally done now.
:D I uploaded a SVN patch with the necessary changes here:

    http://88.84.144.63/hsusage-patch

It is my first C code, so when reviewing it, could you please tell me
whatever I can do better the next time? I testet my code (of course
using PuppeTor :) ), but maybe there is still some storage leak or
whatever. Thanks!

The refined specification and some implementation notes are at the
bottom of this mail.

Btw: When reading the code I found the command-line option
"--ignore-missing-torrc" that I didn't find in the docs.

- --Karsten



- --- specification ---

This proposal contains a specification and implementation for collecting
data of hidden service authoritative directories.

This data could be vital for designing a decentralized storage of hidden
service descriptors. Are there 10 or 1000 hidden services running at a
time? Are fetch requests distributed equally over all hidden services or
are there hot spots? Those questions cannot be answered without some
real data.

Obviously, such a collection needs to be done in an anonymity-preserving
way. Though the anonymity of hidden services does not rely primarily on
the integrity of the directory operator, it plays a role. The operator
can find out which hidden service is online or attack its introduction
points.

The proposal is to add a new status file "hsusage" that is written in
regular intervals by hidden service authoritative directories to their
data directory. It contains status information comparable to the network
status with entries that are built like write-history and read-history
in server descriptors. For each entry there is one aggregated value per
interval of 900 seconds (15 minutes) for a total of 96 intervals (1 day):

"publish-total-history" YYYY-MM-DD HH:MM:SS (NSEC s) NUM... NL
   total number of valid publish requests observed in the interval

"publish-novel-history" YYYY-MM-DD HH:MM:SS (NSEC s) NUM... NL
   total number of valid publish requests that contain a novel
   descriptor, i.e. one with a currently unknown service ID

"publish-top-5-percent-history" YYYY-MM-DD HH:MM:SS (NSEC s) NUM... NL
"publish-top-10-percent-history" YYYY-MM-DD HH:MM:SS (NSEC s) NUM... NL
"publish-top-20-percent-history" YYYY-MM-DD HH:MM:SS (NSEC s) NUM... NL
   total number of valid publish requests containing a descriptor for
   one of the top 5 (10, 20) percent of all services (ordered by number
   of publish requests); can help to figure out which share of publish
   request (probably non-novel publish requests) comes from the top
   available services

"fetch-total-history" YYYY-MM-DD HH:MM:SS (NSEC s) NUM... NL
   total number of valid fetch requests observed in the interval

"fetch-successful-history" YYYY-MM-DD HH:MM:SS (NSEC s) NUM... NL
   total number of valid and successful fetch requests observed in the
   interval

"fetch-top-5-percent-history" YYYY-MM-DD HH:MM:SS (NSEC s) NUM... NL
"fetch-top-10-percent-history" YYYY-MM-DD HH:MM:SS (NSEC s) NUM... NL
"fetch-top-20-percent-history" YYYY-MM-DD HH:MM:SS (NSEC s) NUM... NL
   total number of valid fetch requests asking for one of the top 5 (10,
   20) percent of all services (ordered by number of fetch requests);
   can help to figure out whether there are hot spots under the services

"desc-total-history"
   total number of current descriptors at the end of the interval

- --- implementation ---

The implementation was done in a way that keeps changes to the current
code small and aggregates most of the extensions at a single place.

These are the changes to existing code:

- - Report fetch requests (directory.c)
- - Report publish requests (rendcommon.c)
- - Lookup descriptor cache size (rendcommon.c)
- - Write statistics to disk in periodical intervals (main.c)
- - Initialize new statistics when initializing reputation history
  (rephist.c)
- - Function prototypes (or.h)

The major part of the implementation is appended to the existing code in
rephist.c.

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.7 (MingW32)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFGNLVD0M+WPffBEmURAoMYAJ94JeEiuCNg32l9y9BCND/2dQeqSQCgoISr
aywUhJ1gML4OYnhtiV6ety4=
=aLIT
-----END PGP SIGNATURE-----
</body></email><email><emailId>20070430062239</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-04-30 06:22:39-0400</timestampReceived><subject>Re: 103-multilevel-keys and 101-dir-voting</subject><body>

On Sat, Apr 21, 2007 at 01:48:58PM -0400, nickm@seul.org wrote:
&gt; Modified: tor/trunk/doc/spec/proposals/103-multilevel-keys.txt
&gt; ===================================================================
&gt; --- tor/trunk/doc/spec/proposals/103-multilevel-keys.txt	2007-04-21 17:48:45 UTC (rev 9999)
&gt; +++ tor/trunk/doc/spec/proposals/103-multilevel-keys.txt	2007-04-21 17:48:50 UTC (rev 10000)
&gt; +Extensions to Proposal 101.
&gt; +
&gt; +  Add the following elements to vote documents:
&gt; +
&gt; +     "dir-identity-key": The long-term identity key for this authority.

Is this a base16 hash, or the whole key? Seems to me that either the
client knows the identity key already from the keys file we ship, in
which case a hash is sufficient, or he doesn't, in which case he doesn't
care what it is because he won't trust it anyway.

&gt; +     "dir-key-published": The time when this directory's signing key was last
&gt; +         changed.

I guess the point of this entry is that if we don't have the appropriate
signing key, yet it was published before the keys.z we have, we won't try
to fetch a new keys file? Another use would be to be able to recognize
when a given signing key is older than one we already have, in which
case we can...we can what?

I'm trying to figure out if this is needed here. Is it just for the
sake of completeness, and since it's just a vote we don't worry too much
about efficiency?

&gt; +     "dir-key-certification": A signature of the fields "fingerprint",
&gt; +         "dir-key-published", "dir-signing-key", and "dir-identity-key",
&gt; +         concatenated, in that order.  The signed material extends from the
&gt; +         beginning of "fingerprint" through the newline after
&gt; +         "dir-key-certification".  The identity key is used to generate this
&gt; +         signature.

&gt; +      The elements "fingerprint", "dir-key-published", "dir-signing-key",
&gt; +      "dir-identity-key", and "dir-key-certification" together constitute a
&gt; +      "key certificate".  These are generated offline when starting a v2.1
&gt; +      authority.
&gt; +
&gt; +      The elements "dir-signing-key", "dir-key-published", and
&gt; +      "dir-identity-key", "dir-key-certification" and MUST NOT appear in
&gt; +      consensus documents.

The two 'ands' here, plus the missing 'and', make me nervous that this
wasn't the list you actually intended to produce. :)

&gt; +      The "fingerprint" field is generated based on the identity key, not
&gt; +      the signing key.

Doesn't this make it redundant with dir-identity-key?

Also, is it useful somewhere to bind the directory identity key to the
router identity key?

&gt; +  Consensus network statues change as follows:
&gt; +
&gt; +      Remove dir-signing-key.
&gt; +
&gt; +      Change "directory-signature" to take a fingerprint of the authority's
&gt; +      identity key rather than the authority's nickname.

This will affect how we define dir-source too, since it wants the
dir-source to match the nickname in the directory-signature. Shall we
just list a hash of the identity key as the dir-source too? In fact,
should we just get rid of dir-source?

&gt; +  Add a new document type:
&gt; +
&gt; +      A "keys" document contains all currently known key certification
&gt; +      certificates.  All authorities serve it at
&gt; +
&gt; +          http://&lt;hostname&gt;/tor/status/keys.z
&gt; +
&gt; +      Caches and clients download the keys document whenever they receive a
&gt; +      consensus vote that uses a key they do not recognize.  Caches download
&gt; +      from authorities; clients download from caches.
&gt; +
&gt; +  Verification:
&gt; +
&gt; +      [XXXX write me]

What's in the verification section?

In general, I think we're moving in the right direction here, and it's
a fine time to start coding if you'd like to (which from talking to you
it sounds like you do). Let us know if you run into any other troubles
that are non-obvious.

Thanks!
--Roger

</body></email><email><emailId>20070521124254</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-05-21 12:42:54-0400</timestampReceived><subject>Re: 103-multilevel-keys and 101-dir-voting</subject><body>

On Mon, Apr 30, 2007 at 01:16:13PM -0400, Nick Mathewson wrote:
&gt; &gt; In general, I think we're moving in the right direction here, and it's
&gt; &gt; a fine time to start coding if you'd like to (which from talking to you
&gt; &gt; it sounds like you do). Let us know if you run into any other troubles
&gt; &gt; that are non-obvious.
&gt; 
&gt; Okay.  I don't think we have a status for this.  Should we loosen the
&gt; status of "Accepted", or add a new "Trying to code" status?

We might call it "Prototype" status, to indicate that the next step is
to start building it and find out what new issues emerge, but that some
are expected and we'll be modifying the proposal based on them.

We might also change "Accepted" in our minds to include the fact that
issues can emerge even on accepted proposals that cause us to change
our mind or need more discussion.

I'm fine with either approach. Pick your favorite and that's the one I
want too.

--Roger

</body></email><email><emailId>20070430073024</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-04-30 07:30:24-0400</timestampReceived><subject>Re: Anonymity-preserving collection of usage data of a hidden service authoritative directory</subject><body>

On Sun, Apr 29, 2007 at 05:09:55PM +0200, Karsten Loesing wrote:
&gt;     http://88.84.144.63/hsusage-patch
&gt; 
&gt; It is my first C code, so when reviewing it, could you please tell me
&gt; whatever I can do better the next time? I testet my code (of course
&gt; using PuppeTor :) ), but maybe there is still some storage leak or
&gt; whatever. Thanks!

Looks great as a first step. But since you ask :), here are some code
comments for a revision of the patch:

a) We should enable this only when a certain config option is set. Nick
suggests the name "HSAuthorityRecordStats". Adding a new config option
is easy -- look at http://archives.seul.org/or/cvs/Sep-2006/msg00015.html
for the basic two steps, and then the optional third step is to look at
options_validate() and add a line like
  if (options-&gt;HSAuthorityRecordStats &amp;&amp; !options-&gt;HSAuthoritativeDir)
    REJECT("HSAuthorityRecordStats is set but we're not running as "
           "a hidden service authority.");
And then it needs an entry in the man page.

b) It needs a free_all() style function. See tor_free_all() in main.c,
and you can model it like rep_hist_free_all() if you want. The goal is
to clean up all your stuff on shutdown, so it's easier to run tools to
detect leaks.

c) We prefer /* comments */ rather than // comments, since we're aiming
to keep C compliant.

d) rend_store_desc() can be called from two different places in
directory.c -- one if it's a newly published descriptor, and one if
we're a HS client fetching a descriptor. I would suggest a new
argument to rend_store_desc called "published" which is 1 if it was
just published to us and 0 otherwise. Then you can do the right thing
inside rend_store_desc.

e) in main.c, use a #define for your "900", e.g. WRITE_HSUSAGE_INTERVAL,
so it fits with the other FOO_INTERVALs.

f) s/occurences/occurrences/g/. And then consider
s/occurrences/count/g. :)

g) Make your patch not complain when you build with './configure
--enable-gcc-warnings', or when you run 'make check-spaces'. I didn't
try the gcc-warnings, but I noticed a few places that check-spaces ought
to complain.

h) When comments for structs start with "A structure for", you can
usually take out that phrase and it will be just as good.

i) In hs_usage_note_publish_total() et al, you can just use time(NULL)
as an arg to hs_usage_add_service_related_observation() rather than
keeping a separate variable for it. In fact, it is probably best to
hand the time in as an arg to hs_usage_note_publish_total() -- the goal
is to make individual functions as independent as possible of their
calling environment, so later we could write some unit tests with these
functions, *tell* them what time they should think it is, and make sure
they behave correctly.

j) Your variables are uint64_t's just in case we get more than 4 billion
hidden service hits or updates in a 15 minute period? That's more than
4 million per second. I guess it doesn't hurt since this code is seldom
used, so it's fine to keep it there. But wow. :)

k) A minor issue -- in your comparisons toward the end of rephist,
e.g. "now&gt;current_period-&gt;start_of_next_period", we try to add spaces
on either side of the &gt;, because &gt; and -&gt; can look quite similar.

l) hs_usage_insert_value() makes me uncomfortable. For example, your
"create first elem" and "append to end" codeblocks are nearly the
same. But again, this stuff isn't called much, so it's just a question
of code bloat and readability.

&gt; The refined specification and some implementation notes are at the
&gt; bottom of this mail.

These look really good.

&gt; Btw: When reading the code I found the command-line option
&gt; "--ignore-missing-torrc" that I didn't find in the docs.

Yeah, we don't document our commandline switches like this very
well. This one was only added recently. Where are the rest of
them documented? :) We should add this one.

Thanks!
--Roger

</body></email><email><emailId>20070501005756</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-05-01 00:57:56-0400</timestampReceived><subject>Re: Anonymity-preserving collection of usage data of a hidden service authoritative directory</subject><body>


On Mon, Apr 30, 2007 at 02:53:49PM +0200, Karsten Loesing wrote:
&gt; -----BEGIN PGP SIGNED MESSAGE-----
&gt; Hash: SHA1
&gt; 
&gt; Hi,
&gt; 
&gt; &gt; Looks great as a first step. But since you ask :), here are some code
&gt; &gt; comments for a revision of the patch:
&gt; 
&gt; Thank you for taking the effort! Really!
&gt; 
&gt; I think that I have made all the changes. I replaced the SVN patch at
&gt; the old location:
&gt; 
&gt;     http://88.84.144.63/hsusage-patch
&gt; 
&gt; If there are further changes that I can make, please tell me! (If you
&gt; make them by yourself and they don't require a comment, I will see them
&gt; in the SVN diff when you commit the code.)

Great; thanks!  I checked it in as r10067, and made some small changes
in r10068.  Roger also tweaked it a bit in r10077.

peace,
-- 
Nick Mathewson

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070501095242</emailId><senderName>Karsten Loesing</senderName><senderEmail>karsten.loesing@gmx.net</senderEmail><timestampReceived>2007-05-01 09:52:42-0400</timestampReceived><subject>Re: Anonymity-preserving collection of usage data of a hidden service</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Hi,

&gt; Great; thanks!  I checked it in as r10067, and made some small changes
&gt; in r10068.  Roger also tweaked it a bit in r10077.

Cool. :) Looking forward to evaluating the first statistics file --
whenever that will be.

Last time I forgot to include the (few) changes to the man page in the
SVN patch. They are at the bottom of this mail.

- --Karsten


- --- begin SVN patch ---

Index: /media/diss/tor/tor-trunk/doc/tor.1.in
===================================================================
- --- /media/diss/tor/tor-trunk/doc/tor.1.in	(revision 10083)
+++ /media/diss/tor/tor-trunk/doc/tor.1.in	(working copy)
@@ -869,6 +869,12 @@
 accepts and serves hidden service descriptors. (Default: 0)
 .LP
 .TP
+\fBHSAuthorityRecordStats \fR\fB0\fR|\fB1\fR\fP
+When this option is set in addition to \fBHSAuthoritativeDir\fP, Tor
+periodically (every 15 minutes) writes statistics about hidden service
usage to
+a file \fBhsusage\fP  in its data directory. (Default: 0)
+.LP
+.TP
 \fBDirPort \fR\fIPORT\fP
 Advertise the directory service on this port.
 .LP
@@ -1076,6 +1082,10 @@
 Used to track bandwidth accounting values (when the current period
starts and ends; how much has been read and written so far this period).
 This file is obsolete, and the data is now stored in the 'state' file
as well.  Only used when bandwidth accounting is enabled.
 .LP
 .TP
+.B \fIDataDirectory\fP/hsusage
+Used to track hidden service usage in terms of fetch and publish
requests to this hidden service authoritative directory. Only used when
recording of statistics is enabled.
+.LP
+.TP
 .B \fIDataDirectory\fP/control_auth_cookie
 Used for cookie authentication with the controller. Regenerated on
startup.  See control-spec.txt for details.  Only used when cookie
authentication is enabled.
 .LP

- --- end SVN patch ---
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFGNw3q0M+WPffBEmURApIGAJ9FfabZ/+5fuC/mz+9ULAM6N1EZhgCfcOjQ
MNyjBv5c5O6f7czj2CAVkrU=
=jO3n
-----END PGP SIGNATURE-----
</body></email><email><emailId>20070501104259</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-05-01 10:42:59-0400</timestampReceived><subject>Re: Anonymity-preserving collection of usage data of a hidden service authoritative directory</subject><body>

On Tue, May 01, 2007 at 11:52:42AM +0200, Karsten Loesing wrote:
&gt; Cool. :) Looking forward to evaluating the first statistics file --
&gt; whenever that will be.

Here are early results from moria1:

publish-total-history 2007-05-01 10:25:27 (900 s) \
257,312,304,318,348,314,293,461,279,369,334,357,229,285,429,304,278,332,307,409,366,30 \
2,332,426,237,338,374,398,308,406,373,382,226,412,347,330,288,364,367,410,368,370,374 \
publish-novel-history 2007-05-01 10:25:27 (900 s) \
196,161,128,173,6,2,11,8,4,4,2,1,9,4,3,3,0,2,3,1,1,5,2,3,3,6,2,6,3,3,6,4,3,3,2,3,2,3,6,3,2,7,4
 publish-top-5-percent-history 2007-05-01 10:25:27 (900 s) \
47,64,58,66,60,57,64,87,56,72,58,69,53,54,86,61,52,74,67,74,56,56,76,100,55,78,76,86,67,91,93,70,39,67,66,62,52,75,84,91,66,83,78
 publish-top-10-percent-history 2007-05-01 10:25:27 (900 s) \
71,94,91,94,93,90,94,138,82,111,93,102,74,80,133,85,82,106,93,113,95,86,105,139,79,114,112,129,100,137,129,110,64,108,103,98,82,111,121,133,105,119,118
 publish-top-20-percent-history 2007-05-01 10:25:27 (900 s) \
101,136,129,122,149,136,123,212,120,171,139,141,97,113,201,112,124,149,132,177,155,130 \
,149,201,115,152,166,189,143,199,180,164,96,174,153,141,120,161,179,189,169,170,175 \
fetch-total-history 2007-05-01 10:25:27 (900 s) \
51,46,34,56,99,88,82,77,50,43,22,16,25,13,23,21,53,31,16,18,13,8,20,24,17,17,21,29,14,17,21,16,29,17,20,26,41,30,29,49,52,75,38
 fetch-successful-history 2007-05-01 10:25:27 (900 s) \
1,10,4,17,24,23,19,16,12,6,18,11,12,4,12,9,20,8,10,4,5,5,5,12,6,5,9,15,6,8,10,4,9,5,7,7,17,10,15,15,16,14,17
 fetch-top-5-percent-history 2007-05-01 10:25:27 (900 s) \
13,10,10,17,52,40,56,41,29,31,5,4,3,5,6,5,17,11,6,5,6,3,4,7,3,2,8,5,4,5,3,3,15,10,7,6,8,5,8,14,12,19,12
 fetch-top-10-percent-history 2007-05-01 10:25:27 (900 s) \
20,16,15,20,58,48,60,45,32,31,10,4,6,5,8,8,23,16,6,7,6,3,7,12,6,4,11,9,6,7,5,5,18,10,9,10,11,8,11,18,16,28,15
 fetch-top-20-percent-history 2007-05-01 10:25:27 (900 s) \
29,26,22,28,66,63,64,53,35,35,12,7,10,8,12,10,30,19,8,9,8,5,9,15,8,6,13,13,7,9,7,7,21,11,10,14,17,12,14,25,26,44,19
 desc-total-history 2007-05-01 10:25:27 (900 s) \
196,357,485,658,664,666,677,685,689,693,695,696,705,709,712,715,715,717,720,721,722,72 \
7,729,732,735,741,743,749,752,755,761,765,768,771,773,776,778,781,787,790,792,799,803

The novel descriptors, and failed fetches, are high at the beginning
because it had just started up so it didn't have any yet. Hard to
guess what steady-state will be. But the first thing to note is that
the total number of fetches are really not that high. The second thing
to note is to start wondering why a few services publish so often --
is it because their intro circuits break often, maybe because they have
a poor network connection, so they feel the need to republish? And the
third is to remember that hidden services suck right now, so we shouldn't
take the current usage pattern to be the requirements for future hidden
services. :)

&gt; Last time I forgot to include the (few) changes to the man page in the
&gt; SVN patch. They are at the bottom of this mail.

Added. Thanks!
--Roger


</body></email><email><emailId>20070502195108</emailId><senderName>Karsten Loesing</senderName><senderEmail>karsten.loesing@gmx.net</senderEmail><timestampReceived>2007-05-02 19:51:08-0400</timestampReceived><subject>Re: Anonymity-preserving collection of usage data of a hidden service</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Hi,

&gt; Here are early results from moria1:

Wow! That was amazingly quick! :)

&gt; The novel descriptors, and failed fetches, are high at the beginning
&gt; because it had just started up so it didn't have any yet. Hard to
&gt; guess what steady-state will be.

Sure, the first 10 rows or so might result from restarting the directory
node. But from there on it looks like it has stabilized. Hidden services
publish their descriptors once an hour, don't they? (Well, that was easy
to see even without looking into the spec by the decreasing number of
novel publications after the first four intervals = 60 minutes.) So it's
very unlikely that there will be many novel publications after the shown
intervals.

The only thing that does not stabilize (yet) is the total number of
descriptors. This should come from the fact that lease times for
descriptors are very much higher than republication times (24 hours vs.
1 hour, right?). Doesn't that mean that the increase in total
descriptors from the fifth interval on only comes from descriptors that
have not been refreshed and represent probably offline hidden services?
That would mean that 145 (=803-658) or 18% of the descriptors in the
last interval are useless (or even more if the total number of
descriptors increases further, what is likely the case). Wouldn't it
make more sense to synchronize publication intervals and lease times?
Was that what you meant with "artifacts"? Why would a client expect that
a hidden service with a 23-hour old descriptor is online if it knows
that it should have republished every hour? In a decentralized design I
suggest to cut down the lease time to one hour (or maybe 1.5 hours).
This saves resources for replicating descriptors in case of
leaving/joining routers.

&gt; But the first thing to note is that
&gt; the total number of fetches are really not that high.

At least the number of fetches needs to be multiplied by five, because
requests should be (more or less) equally distributed among directories.
 Though these numbers still are not as high as I expected, it is very
interesting to have some absolute numbers.

&gt; The second thing
&gt; to note is to start wondering why a few services publish so often --
&gt; is it because their intro circuits break often, maybe because they have
&gt; a poor network connection, so they feel the need to republish?

To be honest, I don't know yet if these numbers are really high or not.
What is high and what is low? Does low mean that all services publish
equally often, and high means that all services but one publish only
once and the remaining service publishes all the other times? I think I
need to read a good statistics book to learn how to evaluate such data.
When writing the spec, the percent-histories were just a goodie, and I
wanted to implement something more complex than a counter in C to see if
I have problems with the implementation stuff. ;) But you are right, if
that number is (too) high, we should try to find out why.

&gt; And the
&gt; third is to remember that hidden services suck right now, so we shouldn't
&gt; take the current usage pattern to be the requirements for future hidden
&gt; services. :)

Then my question is: Why do hidden services suck right now? Do you mean
performance? Yes, that could be improved. In an earlier evaluation I
found that connection establishment after having downloaded the
descriptor takes 5.39 +- 12.4 seconds, i.e. with an acceptable mean, but
a huge variance. Afterwards, message round-trip times were 2.32 +- 1.66
seconds, i.e. acceptable after all.

Or are there other reasons why they suck? Unclear security properties?
Too complicated setup? The need for Tor on the client side? What do you
think?

Anyway, even if the current usage pattern does not really justify to
distribute storage of rendezvous service descriptors, future
applications of hidden services might do so. Or the other way round, new
applications that would not be reasonable in a centralized storage can
be made possible in a decentralized one. That keeps me optimistic. :)

- --Karsten
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFGOOus0M+WPffBEmURAnlbAKCY6btkPWnV3OekkzrdHmKdcOqa7QCdHBAn
b3laZQNu4f72/8SHM3yJyo8=
=m/F/
-----END PGP SIGNATURE-----
</body></email><email><emailId>20070502233623</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-05-02 23:36:23-0400</timestampReceived><subject>Re: Anonymity-preserving collection of usage data of a hidden service authoritative directory</subject><body>

On Wed, May 02, 2007 at 09:51:08PM +0200, Karsten Loesing wrote:
&gt; &gt; Here are early results from moria1:

And here are the more steady-state results, after we've been up a
few days:

publish-total-history 2007-05-02 22:25:27 (900 s) \
451,314,296,356,400,328,279,285,331,307,246,375,459,253,346,218,460,280,344,260,353,30 \
6,351,309,441,228,391,460,397,276,293,352,398,331,375,412,462,328,362,259,435,308,436, \
278,354,408,331,375,382,346,352,417,351,503,290,411,367,495,354,371,405,450,444,331,37 \
7,396,379,285,417,601,373,321,366,339,369,355,403,392,318,315,446,318,419,365,293,468,343,382,428,434,367,349,367,301,379,334
 publish-novel-history 2007-05-02 22:25:27 (900 s) \
1,0,1,1,0,1,0,2,3,1,2,5,0,0,0,0,0,1,0,1,0,0,0,0,4,2,0,3,1,0,2,0,1,0,3,1,0,0,0,0,0,0,2, \
1,1,0,0,3,1,0,2,4,2,0,0,0,0,0,1,4,2,0,0,0,1,1,0,1,2,0,0,0,3,2,0,1,1,1,0,0,1,0,3,1,0,1,0,0,0,0,0,0,0,0,0,0
 publish-top-5-percent-history 2007-05-02 22:25:27 (900 s) \
83,59,60,64,74,56,52,60,68,56,47,58,83,42,55,45,91,64,65,56,65,74,71,68,87,58,75,92,76 \
,56,56,83,99,75,80,77,99,71,81,53,97,74,87,64,91,73,87,79,71,75,80,101,76,98,66,109,86 \
,96,92,92,89,98,96,92,77,101,76,72,91,116,81,65,63,77,68,79,88,86,51,70,84,57,95,67,64,90,72,79,85,79,83,70,73,64,81,64
 publish-top-10-percent-history 2007-05-02 22:25:27 (900 s) \
135,92,88,106,116,86,80,90,105,85,69,102,139,67,91,61,143,92,102,84,100,105,107,98,134 \
,78,114,140,115,85,84,119,135,109,116,123,146,103,118,83,142,107,131,94,124,118,120,11 \
9,114,108,120,145,115,159,96,149,118,159,129,131,128,143,146,126,113,142,114,99,140,19 \
2,118,98,102,111,107,118,131,124,83,102,132,90,148,106,91,132,109,120,130,125,121,111,109,94,119,95
 publish-top-20-percent-history 2007-05-02 22:25:27 (900 s) \
210,136,120,167,175,139,116,129,147,119,96,170,214,101,143,89,226,121,148,119,144,146, \
153,144,200,102,178,218,174,122,124,169,175,161,170,188,217,155,168,121,210,148,200,13 \
5,159,185,153,180,173,156,168,211,162,246,133,202,161,244,177,182,186,209,214,170,164, \
199,173,138,198,303,174,145,156,149,162,175,187,183,127,146,207,137,212,168,124,212,159,178,202,198,172,167,167,136,174,153
 fetch-total-history 2007-05-02 22:25:27 (900 s) \
29,46,42,46,51,49,40,32,33,23,42,40,31,24,31,21,23,21,34,24,22,33,30,26,53,41,43,35,24 \
,42,44,68,34,33,28,36,16,20,30,42,63,30,26,23,24,12,18,26,25,14,41,17,18,20,15,32,26,2 \
2,23,39,15,22,26,34,23,24,14,11,21,26,17,13,12,16,18,13,9,14,14,13,13,33,34,16,24,19,25,31,28,23,36,30,32,52,54,69
 fetch-successful-history 2007-05-02 22:25:27 (900 s) \
15,22,15,20,21,20,23,14,14,16,19,19,17,8,19,14,16,11,16,13,10,24,11,16,23,22,17,20,14, \
23,25,18,16,15,15,22,9,10,21,22,30,13,14,9,14,8,9,10,12,6,19,6,15,10,5,20,16,15,14,24, \
10,12,14,18,12,16,11,8,13,20,8,8,7,11,10,11,7,11,7,9,10,24,23,5,16,11,17,23,17,17,27,16,21,23,37,59
 fetch-top-5-percent-history 2007-05-02 22:25:27 (900 s) \
9,16,14,19,25,23,13,11,8,4,10,7,6,9,9,4,6,5,13,5,4,14,11,6,11,7,8,10,4,8,9,20,6,9,4,8, \
3,3,5,10,17,5,4,7,3,2,5,4,6,3,14,2,4,4,5,12,7,4,3,12,3,4,3,11,3,4,3,3,4,4,7,2,3,6,6,3,2,3,7,3,3,7,9,8,6,4,5,9,6,6,10,8,8,16,22,40
 fetch-top-10-percent-history 2007-05-02 22:25:27 (900 s) \
13,20,22,22,28,27,16,16,15,6,14,10,8,14,12,7,9,8,16,9,8,19,15,9,18,12,12,12,7,11,12,27 \
,8,12,7,11,6,5,9,12,22,8,7,9,5,4,7,7,8,3,18,4,7,7,5,15,10,6,6,14,5,6,6,13,5,7,6,3,6,7,7,4,3,6,6,3,2,5,7,3,3,13,16,8,9,7,10,13,8,9,15,11,12,20,27,46
 fetch-top-20-percent-history 2007-05-02 22:25:27 (900 s) \
15,26,26,27,32,32,21,20,21,8,20,16,12,16,16,10,12,10,18,13,10,21,19,13,24,19,18,16,9,1 \
7,18,39,12,16,10,17,8,8,14,18,32,13,11,11,9,5,9,11,10,6,23,6,10,10,8,17,13,8,10,18,7,1 \
0,10,17,9,11,7,5,8,10,10,6,5,9,11,5,4,7,10,6,6,18,21,11,12,9,13,19,12,12,21,15,15,26,32,51
 desc-total-history 2007-05-02 22:25:27 (900 s) \
883,883,884,885,885,886,886,888,891,892,894,899,899,899,899,899,899,900,900,901,901,90 \
1,901,901,905,907,907,910,911,911,913,913,914,914,917,918,918,918,918,918,918,918,920, \
921,922,922,922,925,926,926,928,932,934,934,934,934,934,934,935,939,941,941,941,941,94 \
2,943,943,944,946,946,946,946,949,951,951,952,953,954,954,954,955,955,958,959,959,960,960,960,960,960,960,960,960,960,960,960


&gt; &gt; The novel descriptors, and failed fetches, are high at the beginning
&gt; &gt; because it had just started up so it didn't have any yet. Hard to
&gt; &gt; guess what steady-state will be.
&gt; 
&gt; Sure, the first 10 rows or so might result from restarting the directory
&gt; node. But from there on it looks like it has stabilized. Hidden services
&gt; publish their descriptors once an hour, don't they?

Yep -- every RendPostPeriod, which is 1 hour by default.

They also republish whenever they consider their descriptor to be
"dirty", which happens when they establish a new introduction point
(rend_service_intro_established()) or give up on and drop an introduction
point (rend_services_introduce()). This 'dirty' part is what I meant
when I was pondering if a few hidden services have unstable connections,
and thus change their intro points a lot.

&gt; (Well, that was easy
&gt; to see even without looking into the spec by the decreasing number of
&gt; novel publications after the first four intervals = 60 minutes.) So it's
&gt; very unlikely that there will be many novel publications after the shown
&gt; intervals.

Yep. They will be people creating a new hidden service, or people
turning on their Tor after it's been off for a while. As we see above,
there are at most a handful in each 15 minute period.

&gt; The only thing that does not stabilize (yet) is the total number of
&gt; descriptors. This should come from the fact that lease times for
&gt; descriptors are very much higher than republication times (24 hours vs.
&gt; 1 hour, right?).

#define REND_CACHE_MAX_AGE (2*24*60*60)
#define REND_CACHE_MAX_SKEW (24*60*60)

  cutoff = time(NULL) - REND_CACHE_MAX_AGE - REND_CACHE_MAX_SKEW;

So that actually appears to be 3 days.

But hey, at least we remove old ones sometime, rather than just collecting
them forever. :)

(Remember that this same logic is used by *clients* to discard old service
descriptors, and we have many fewer guarantees that their clocks are at
all correct. That's what the MAX_SKEW business is about.)

&gt; Doesn't that mean that the increase in total
&gt; descriptors from the fifth interval on only comes from descriptors that
&gt; have not been refreshed and represent probably offline hidden services?
&gt; That would mean that 145 (=803-658) or 18% of the descriptors in the
&gt; last interval are useless (or even more if the total number of
&gt; descriptors increases further, what is likely the case). Wouldn't it
&gt; make more sense to synchronize publication intervals and lease times?
&gt; Was that what you meant with "artifacts"? Why would a client expect that
&gt; a hidden service with a 23-hour old descriptor is online if it knows
&gt; that it should have republished every hour?

Well, if the client's clock is wrong by 23 hours, ...

But you're right, the servers storing the descriptors should be assumed
to have better clocks, and they could just dump old ones to save clients
the trouble.

Of course, the real reason hidden services republish every hour is
because the directory authorities don't store anything to disk and don't
share service descriptors among each other -- so every time we restart
a directory authority it forgets about all hidden services. This means
they need to republish frequently just in case an authority restarts.
If we made some way for service descriptors to survive a restart (e.g.
by storing them to disk, replicating them, or both), then it seems to
me we would reduce the need to republish dramatically.

&gt; In a decentralized design I
&gt; suggest to cut down the lease time to one hour (or maybe 1.5 hours).
&gt; This saves resources for replicating descriptors in case of
&gt; leaving/joining routers.

This is an interesting tradeoff. I'm not sure if it's better to demand
frequent "I'm still here" messages from the hidden services, so you can
quickly drop the ones that don't send one, or to be more flexible and
let them go long periods with the same intro points and never need to
send an update.

I guess if we want to get extra complex then somebody could try connecting
to the hidden service and only dump the descriptor if it's unreachable
-- but that probably doesn't play well with our authentication or
authorization tricks, nor with the valet node and related designs.

&gt; &gt; But the first thing to note is that
&gt; &gt; the total number of fetches are really not that high.
&gt; 
&gt; At least the number of fetches needs to be multiplied by five, because
&gt; requests should be (more or less) equally distributed among directories.

Actually, three. Only "v1" directory authorities handle hidden service
stuff, and that's just moria1, moria2, and tor26 right now.

&gt; Though these numbers still are not as high as I expected, it is very
&gt; interesting to have some absolute numbers.

Yep. This number seems to represent the total count of people interacting
with a given hidden service, but remember that it doesn't represent
the total number of rendezvous attempts -- since clients cache the
descriptors.

Though note in connection_ap_handshake_rewrite_and_attach() that clients
try to refetch a newer descriptor if the one they have cached is more
than 15 minutes old. Are you following all the details so far? :)

&gt; &gt; The second thing
&gt; &gt; to note is to start wondering why a few services publish so often --
&gt; &gt; is it because their intro circuits break often, maybe because they have
&gt; &gt; a poor network connection, so they feel the need to republish?
&gt; 
&gt; To be honest, I don't know yet if these numbers are really high or not.
&gt; What is high and what is low? Does low mean that all services publish
&gt; equally often, and high means that all services but one publish only
&gt; once and the remaining service publishes all the other times?

Yep, that's (the extreme version of) the scenario I had in mind.

&gt; I think I
&gt; need to read a good statistics book to learn how to evaluate such data.
&gt; When writing the spec, the percent-histories were just a goodie, and I
&gt; wanted to implement something more complex than a counter in C to see if
&gt; I have problems with the implementation stuff. ;) But you are right, if
&gt; that number is (too) high, we should try to find out why.
&gt; 
&gt; &gt; And the
&gt; &gt; third is to remember that hidden services suck right now, so we shouldn't
&gt; &gt; take the current usage pattern to be the requirements for future hidden
&gt; &gt; services. :)
&gt; 
&gt; Then my question is: Why do hidden services suck right now? Do you mean
&gt; performance? Yes, that could be improved. In an earlier evaluation I
&gt; found that connection establishment after having downloaded the
&gt; descriptor takes 5.39 +- 12.4 seconds, i.e. with an acceptable mean, but
&gt; a huge variance.

Right, it's this part. There is something that is making the rendezvous
itself be very slow. I'm not sure what it is. There's no need for it
to be as slow as it is. And I think it really reduces the set of people
who think hidden services are neat.

&gt; Afterwards, message round-trip times were 2.32 +- 1.66
&gt; seconds, i.e. acceptable after all.
&gt; 
&gt; Or are there other reasons why they suck? Unclear security properties?
&gt; Too complicated setup? The need for Tor on the client side? What do you
&gt; think?

Well, there are unclear security properties, but I don't think that
bothers most users or most people offering the hidden services. The
setup is really easy on the client side, which is the important part.
I am mainly thinking of the highly variable performance.

&gt; Anyway, even if the current usage pattern does not really justify to
&gt; distribute storage of rendezvous service descriptors, future
&gt; applications of hidden services might do so. Or the other way round, new
&gt; applications that would not be reasonable in a centralized storage can
&gt; be made possible in a decentralized one. That keeps me optimistic. :)

Right.

Also, scaling questions aside, there are other reasons to distribute
hidden service descriptors and improve their availability.

So what more data might we want to collect about current usage patterns?
Or is this enough to move on to the next steps which are to think about an
ascii format for descriptors (rather than the awful binary format I was
dumb enough to use back when we started), think about the implications
of letting strangers see and serve all the descriptors, and think about
a protocol for receiving, serving, and replicating descriptors?

Fun fun,
--Roger


</body></email><email><emailId>20070505101008</emailId><senderName>Karsten Loesing</senderName><senderEmail>karsten.loesing@gmx.net</senderEmail><timestampReceived>2007-05-05 10:10:08-0400</timestampReceived><subject>Re: Anonymity-preserving collection of usage data of a hidden service</subject><body>

Hi,

&gt; They also republish whenever they consider their descriptor to be 
&gt; "dirty", which happens when they establish a new introduction point 
&gt; (rend_service_intro_established()) or give up on and drop an
&gt; introduction point (rend_services_introduce()). This 'dirty' part is
&gt; what I meant when I was pondering if a few hidden services have
&gt; unstable connections, and thus change their intro points a lot.

Maybe it's just a personal feeling (because I did not measure that yet), 
but don't you think that introduction points change quite often? I 
always thought that RSDs are republished so often, because it's anyway 
unlikely that the set of IPos stays the same for more than one hour. 
Thus, an RSD being 23 hours old simply cannot have any working IPos any 
more.

&gt;&gt; So it's very unlikely that there will be
&gt;&gt; many novel publications after the shown intervals.
&gt; 
&gt; Yep. They will be people creating a new hidden service, or people 
&gt; turning on their Tor after it's been off for a while. As we see
&gt; above, there are at most a handful in each 15 minute period.

However, novel publications decreased from 3.72 to 0.81 in the mean when 
comparing the two statistics. Maybe this comes from hidden services that 
were offline for some time less than 3 days and "republish" their 
descriptor. Then it would be an artifact coming from the 3-days-rule, 
because it's rather a novel publication with novel IPos than a 
republication.

&gt; But hey, at least we remove old ones sometime, rather than just
&gt; collecting them forever. :)

In German we call people who keep everything because they don't dare to 
throw anything away "Messies"... But maybe we can "heal" that in Tor. ;)

&gt; (Remember that this same logic is used by *clients* to discard old
&gt; service descriptors, and we have many fewer guarantees that their
&gt; clocks are at all correct. That's what the MAX_SKEW business is
&gt; about.)

&gt;&gt; Why would a client
&gt;&gt; expect that a hidden service with a 23-hour old descriptor is
&gt;&gt; online if it knows that it should have republished every hour?
&gt; 
&gt; Well, if the client's clock is wrong by 23 hours, ...

&gt; But you're right, the servers storing the descriptors should be
&gt; assumed to have better clocks, and they could just dump old ones to
&gt; save clients the trouble.

I am not sure if I get your arguments about clock skew right. Doesn't 
clock skew only address two *different* clocks, e.g. a client's and a 
directory node's clock? Then I agree that there should be some tolerance.

But when a directory node receives an RSD, it can note when that was and 
discard it after 1.5 hours using its own clock. Regardless of a client's 
clock, the descriptor is 1.5 hours old when discarding it and -- 
possibly -- useless. The latter depends on how often IPos change. (I 
think this would be the next thing to measure...)

&gt; Of course, the real reason hidden services republish every hour is 
&gt; because the directory authorities don't store anything to disk and
&gt; don't share service descriptors among each other -- so every time we
&gt; restart a directory authority it forgets about all hidden services.
&gt; This means they need to republish frequently just in case an
&gt; authority restarts. If we made some way for service descriptors to
&gt; survive a restart (e.g. by storing them to disk, replicating them, or
&gt; both), then it seems to me we would reduce the need to republish
&gt; dramatically.

The question is whether it is more likely that a directory node restarts 
or that an introduction point changes.

&gt;&gt; In a decentralized design I suggest to cut down the lease time to
&gt;&gt; one hour (or maybe 1.5 hours). This saves resources for replicating
&gt;&gt; descriptors in case of leaving/joining routers.
&gt; 
&gt; This is an interesting tradeoff. I'm not sure if it's better to
&gt; demand frequent "I'm still here" messages from the hidden services,
&gt; so you can quickly drop the ones that don't send one, or to be more
&gt; flexible and let them go long periods with the same intro points and
&gt; never need to send an update.

Maybe 1 hour is too short. 4 hours? 12 hours? We can negotiate that. ;) 
No, to be serious: What do you think how long a set of introduction 
points stays the same -- after a stabilization phase of say 15 minutes 
after starting the service?

&gt; I guess if we want to get extra complex then somebody could try
&gt; connecting to the hidden service and only dump the descriptor if it's
&gt; unreachable -- but that probably doesn't play well with our
&gt; authentication or authorization tricks, nor with the valet node and
&gt; related designs.

Maybe we can postpone this extension? My first thought would be to 
register 1000 fake hidden services at one directory node and wait for it 
to establish 1000 connections to them. :(

&gt; Actually, three. Only "v1" directory authorities handle hidden
&gt; service stuff, and that's just moria1, moria2, and tor26 right now.

Whoops. Yes, you wrote that in an earlier mail that I did not read in 
whole before writing my last mail...

&gt; Yep. This number seems to represent the total count of people
&gt; interacting with a given hidden service, but remember that it doesn't
&gt; represent the total number of rendezvous attempts -- since clients
&gt; cache the descriptors.

Sure.

&gt; Though note in connection_ap_handshake_rewrite_and_attach() that
&gt; clients try to refetch a newer descriptor if the one they have cached
&gt; is more than 15 minutes old. Are you following all the details so
&gt; far? :)

Now that you ask... :) Why 15 minutes? So, clients consider RSDs to be 
old after 15 minutes, servers after 60 minutes, but directories keep 
them for 3 days?...

&gt; There is something that is making the
&gt; rendezvous itself be very slow. I'm not sure what it is. There's no
&gt; need for it to be as slow as it is. And I think it really reduces the
&gt; set of people who think hidden services are neat.

Then this might be one of the next things to investigate. I think it's 
some timeout being too long or some operations that could/should be 
performed twice/three times in parallel.

&gt; Also, scaling questions aside, there are other reasons to distribute 
&gt; hidden service descriptors and improve their availability.

Right.

&gt; So what more data might we want to collect about current usage
&gt; patterns? Or is this enough to move on to the next steps which are to
&gt; think about an ascii format for descriptors (rather than the awful
&gt; binary format I was dumb enough to use back when we started), think
&gt; about the implications of letting strangers see and serve all the
&gt; descriptors, and think about a protocol for receiving, serving, and
&gt; replicating descriptors?

These are the possible next tasks (arbitrary order):
- Find out why connection establishment is that damn slow.
- Measure how often IPos change.
- Think about the format of RSDs (ASCII vs. binary), encryption of 
contents and the related security implications.
- Describe the protocol to receive/serve/replicate RSDs.

But enough measurements for the moment. I think I should think about 
some concepts now and hence will start with the RSD format.

--Karsten
</body></email><email><emailId>20070507045047</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-05-07 04:50:47-0400</timestampReceived><subject>Re: Anonymity-preserving collection of usage data of a hidden service authoritative directory</subject><body>

On Sat, May 05, 2007 at 12:10:08PM +0200, Karsten Loesing wrote:
&gt; Maybe it's just a personal feeling (because I did not measure that yet), 
&gt; but don't you think that introduction points change quite often? I 
&gt; always thought that RSDs are republished so often, because it's anyway 
&gt; unlikely that the set of IPos stays the same for more than one hour. 
&gt; Thus, an RSD being 23 hours old simply cannot have any working IPos any 
&gt; more.

Below are some data points from the hidden service I run on moria2. I've
filtered out everything except the publishes to tor26, so it's easier
to read. The server was started on May 04 06:25:04.044.

May 04 06:25:55.993 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 04 07:13:55.535 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 04 08:13:57.019 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 04 09:13:57.798 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 04 10:13:58.209 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 04 11:13:59.748 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 04 12:14:00.496 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 04 13:03:12.085 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 04 14:03:12.339 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 04 15:03:13.389 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 04 16:03:14.190 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 04 17:03:15.536 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 04 18:03:16.542 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 04 19:03:17.095 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 04 19:53:47.333 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 04 20:53:48.344 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 04 21:53:50.016 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 04 22:53:50.788 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 04 23:53:52.321 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 05 00:53:53.691 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 05 01:53:54.219 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 05 02:53:55.770 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 05 03:53:57.569 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 05 04:53:58.125 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 05 05:53:58.680 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 05 06:54:00.045 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 05 07:54:00.243 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 05 08:54:01.635 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 05 09:54:02.960 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 05 10:54:03.371 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 05 11:54:04.099 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 05 12:54:05.122 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 05 13:54:06.596 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 05 14:54:07.875 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 05 15:54:08.488 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 05 16:54:09.505 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 05 17:54:10.421 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 05 18:54:11.488 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 05 19:54:12.802 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 05 20:02:11.932 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 05 21:02:12.987 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 05 22:02:13.801 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 05 23:02:14.440 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 06 00:02:15.903 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 06 01:02:16.913 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 06 02:02:17.906 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 06 03:02:18.994 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 06 03:24:43.176 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 06 04:24:45.184 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 06 05:24:46.250 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 06 06:24:46.151 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 06 07:24:48.077 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 06 08:24:48.661 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 06 09:24:49.442 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 06 10:24:51.331 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 06 10:29:51.751 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 06 11:29:52.245 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 06 12:29:53.650 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 06 13:29:54.597 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 06 14:29:55.343 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 06 15:29:56.290 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 06 16:29:57.957 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 06 17:29:58.155 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 06 18:29:59.763 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 06 19:30:00.971 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 06 20:30:01.849 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 06 21:30:02.283 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 06 22:30:03.434 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...
May 06 23:30:04.232 [notice] Making internal anonymized tunnel to 86.59.21.38:80 ...

It looks like we rotate at least one introduction point a few times a
day. But since we establish 3, it could be that at least one of them
lasts for the whole day or maybe much longer. Or not. :)

&gt; &gt;Well, if the client's clock is wrong by 23 hours, ...
&gt; 
&gt; &gt;But you're right, the servers storing the descriptors should be
&gt; &gt;assumed to have better clocks, and they could just dump old ones to
&gt; &gt;save clients the trouble.
&gt; 
&gt; I am not sure if I get your arguments about clock skew right. Doesn't 
&gt; clock skew only address two *different* clocks, e.g. a client's and a 
&gt; directory node's clock? Then I agree that there should be some tolerance.

Well, there are three clocks involved. There's the hidden service
(who puts a timestamp in the rendezvous descriptor and signs it), the
HS directory server (who serves rendezvous descriptors and throws them
away if they're more than 3 days old), and the client.

The reason we're so lax in our clock enforcement is that the clock skew
between the hidden service (some random Tor user) and the client (some
other random Tor user) might be quite high.

But you're right that we could probably throw them out at the HS directory
authority more quickly.

&gt; But when a directory node receives an RSD, it can note when that was and 
&gt; discard it after 1.5 hours using its own clock. Regardless of a client's 
&gt; clock, the descriptor is 1.5 hours old when discarding it and -- 
&gt; possibly -- useless. The latter depends on how often IPos change. (I 
&gt; think this would be the next thing to measure...)

Yep.

&gt; &gt;Though note in connection_ap_handshake_rewrite_and_attach() that
&gt; &gt;clients try to refetch a newer descriptor if the one they have cached
&gt; &gt;is more than 15 minutes old. Are you following all the details so
&gt; &gt;far? :)
&gt; 
&gt; Now that you ask... :) Why 15 minutes? So, clients consider RSDs to be 
&gt; old after 15 minutes, servers after 60 minutes, but directories keep 
&gt; them for 3 days?...

Well, the client doesn't throw it away after 15 minutes. It only pauses
while trying to fetch a new one to see if there is a new one -- if not
it goes ahead and uses the old one.

&gt; &gt;There is something that is making the
&gt; &gt;rendezvous itself be very slow. I'm not sure what it is. There's no
&gt; &gt;need for it to be as slow as it is. And I think it really reduces the
&gt; &gt;set of people who think hidden services are neat.
&gt; 
&gt; Then this might be one of the next things to investigate. I think it's 
&gt; some timeout being too long or some operations that could/should be 
&gt; performed twice/three times in parallel.

Yep. I think it's due to extremely high congestion on a few of the links
in the Tor network, which causes the rendezvous or introduction circuit
to fail and maybe we don't try again aggressively or quickly enough. The
"cannibalizing" step was supposed to take care of a lot of that, and
maybe it did, but there is still something wrong.

&gt; These are the possible next tasks (arbitrary order):
&gt; - Find out why connection establishment is that damn slow.
&gt; - Measure how often IPos change.
&gt; - Think about the format of RSDs (ASCII vs. binary), encryption of 
&gt; contents and the related security implications.
&gt; - Describe the protocol to receive/serve/replicate RSDs.
&gt; 
&gt; But enough measurements for the moment. I think I should think about 
&gt; some concepts now and hence will start with the RSD format.

Sounds reasonable.

--Roger

</body></email><email><emailId>20070427163913</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-04-27 16:39:13-0400</timestampReceived><subject>Re: architectural proposal &amp; technical problems</subject><body>


[Also answering on or-dev.]

On Wed, Apr 18, 2007 at 03:12:44PM +0200, Johannes Renner wrote:
&gt; Hello,
&gt; 
&gt; I want to show you an architectural proposal for my project
&gt; and ask you about some technical questions/problems I worry
&gt; about. Besides that I would like to ask you for your general
&gt; opinion about it. The following is only a rough description
&gt; of an architecture, please have a look at the arch.pdf and feel
&gt; free to discuss:
&gt; 
&gt; The first part is an addon for ORs, that is using the Tor
&gt; control protocol to listen for events (mainly ORCONN and/or
&gt; STREAM_BW), records bandwidth-data about single TLS-connections
&gt; the router maintains to other ORs, and simply provides this
&gt; data for requesting clients. The recordings can be done in a
&gt; configurable way and would provide e.g. max observed throughput
&gt; of some period as well as current average of last n minutes
&gt; (just a current value would be much better, but also much worse
&gt; for anonymity). We believe that the difference between max and
&gt; current avg correlates with the still available bandwidth of a link.
&gt; 
&gt; The second part is a QoS-addon for OPs, that will contain the
&gt; algorithms for route selection. It can post requests to receive
&gt; the list of bw-information from an OR-addon. In addition to this
&gt; it does active measurings of latencies/RTTs through Tor and records
&gt; that data. Using these two orthogonal informations we can then
&gt; build fast circuits from here and attach the streams to them
&gt; using the control protocol.
&gt; 
&gt; Now this all seems to be possible using Tor control protocol, but
&gt; there are two things I worry about :
&gt; 
&gt; 1. In OnionCoffee I can do measurings of RTTs in the following
&gt;    style: I take an established circuit and, as I already told
&gt;    you, send a relay connect cell to connect to localhost over
&gt;    it. I measure the time until I receive my relay end cell and
&gt;    thus get the RTT of the whole circuit. I can do this not only
&gt;    for three-hop circuits, but also for partial circuits:
&gt;    By simply using only one or two onion skins I can address the
&gt;    first or the second router in a circuit. By subtracting I can
&gt;    then compute values for the single links between the routers.
&gt;    Of course this is not the intended use for relay connect cells,
&gt;    but it is working quite well (until we introduce something like
&gt;    a ping-cell?). Unfortunately the original Tor software does not
&gt;    offer me any possibilities to do such partial measurings. The
&gt;    only possibility there is at the moment is to use Socks to try
&gt;    to connect to localhost, but this only works for whole circuits
&gt;    and is a bit of a detour. The most convenient way would be to
&gt;    extend TC so that it could be possibly used to receive this data,
&gt;    e.g. introduce a new command that lets Tor do the actual
&gt;    measurings like "measureRTT(circID, addressedRouter)".
&gt;    Tor-TODO (#8 under Research) already pinpoints that it would be
&gt;    nice to make use of the ability to let some streams exit from
&gt;    the second hop, some from the third, and so on.
&gt;    Having the possibility to choose arbitrary exits within one
&gt;    circuit would also enable us to do the measurements on
&gt;    partial circuits. What do you think about that?

This should be do-able by modifying the control protocol to adding an
extra flag to ATTACHSTREAM, right?

That is, you'd have a controller listen for circuit and stream events.
You'd tell the controller to build a circuit.  Then you'd launch a
stream to localost and say something like,

   ATTACHSTREAM (yourstream) (yourcircuit) HOP=2

to attach the stream to the second hop.  Then you'd time the delay
between the ATTACHSTREAM and receiving the END cell.

&gt; 2. The OR-addon needs to set a flag in the ORs router descriptor,
&gt;    to tell clients, that it is providing bw-data. So how can I set
&gt;    an "opt"-flag in my ORs descriptor just to tell the directory
&gt;    that I am using my addon? Is there any way to do this, preferably
&gt;    via the control protocol?

There's no way currently to tell _just_ the directory about
something.  All information goes into your descriptor, or it does
not.  The descriptor gets uploaded to the directory authorities, and
clients download it from the caches.

I guess we could have a controller feature that let you set extra
flags values in descriptor.  For safety, we'd probably want them to
start with "X-", like extension headers in email or http.

There is an accepted proposal in progress of implementation that has a
separate "extra info" document containing data that most users don't
care about.  Check out proposal 104 for more info on that.

--------------------

Now for stuff from later emails.  (I like to batch.)

WRT your idea for a separate "bandwidthinformer" port:  I don't see
the need for that.  How about this idea instead:

  For a while, we've been meaning to have _all_ routers, even routers
  that aren't directory caches, accept BEGIN_DIR commands to retrieve
  a limited amount of directory information via Tor connections.
  Caches would serve everything that they would serve normally;
  non-caches would only serve their own descriptor.

  Given this, I think you could just make any bandwidth information
  that you decide it's important to serve a separate document served
  this way.

Of course, if you want to have routers potentially send this much
info, there are bandwidth issues to consider.  You'll probably want to
write up a unified design before you push too far ahead.  Publishing
this much information is probably good for an research phase of your
project phase, but potentially not so good for long-term use.

As for the CONNECT idea: I'm not sure I see what CONNECT would get you
that an extended ATTACHSTREAM wouldn't.  Yes, ATTACHSTREAM requires
you to launch a new SOCKS connection to Tor, but ATTACHSTREAM has an
advantage over your CONNECT proposal: if the connection _doesn't_
fail, your proposal leaves no good way to actually use the newly
created connection.

yrs,
-- 
Nick Mathewson

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070501202800</emailId><senderName>Johannes Renner</senderName><senderEmail>hannesrenner@gmx.de</senderEmail><timestampReceived>2007-05-01 20:28:00-0400</timestampReceived><subject>Re: architectural proposal &amp; technical problems</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Roger Dingledine wrote:
&gt; I just added a new config option __DisablePredictedCircuits that
&gt; should do what you want ..
&gt; It simply doesn't build the preemptive "extra" circuits, so you don't
&gt; have random circuits appearing. Is this what you had in mind?

Yes, that's exactly what I had in mind, thank you for introducing
this option. Maybe other developers of controllers will also be
glad to be able to switch this off to take over the construction
of circuits for client-use.

BTW: Where can I find a list of all of the "special" config options
that start with __*? Just to find out if there are more of them that
could be useful for my purposes, but I don't know about yet?

&gt; I just implemented this:
&gt; http://archives.seul.org/or/cvs/Apr-2007/msg00137.html
&gt; 
&gt; It's not quite what Johannes wanted, because we currently still refuse to
&gt; attach to a 1-hop circuit, and now we also refuse to attach to the 1st
&gt; hop of a circuit. This is to discourage people from using Tor as a one
&gt; hop proxy, for the safety of our server operators (see paragraph 3 of
&gt; http://wiki.noreply.org/noreply/TheOnionRouter/TorFAQ#VariablePathLength).
&gt; 
&gt; Of course, it's not hard to change the code to take that check out
&gt; on the client side; and if you're doing the tests from a server
&gt; listed in the directory, the other Tor servers will likely let you
&gt; use a one-hop circuit. Is that good enough, or should we revisit the
&gt; client-disallows-single-hop-circuits-too idea?

That is also exactly what I want, thank you very much for that
modification, too. I hope all of you will also consider these two
additions useful. Unfortunately I will also need to do tests to the
first hop of a circuit, because I will be using the RTT_0-1 to compute
RTT_1-2 = RTT_0-2 - RTT_0-1. I really don't want to lessen the safety
of the server operators by this, but maybe you could revisit this idea.
Actually I don't really think that many people would be using Tor
as a one hop proxy only. And if they do, they also should consider
the risk to be traced more easily, or not? And since most of tor's
users want more security, they will be using two or more hops and
I don't think, that a lot of people will try to break into servers
to trace some lonely one-hop connections.
Otherwise I maybe would have to remove the check from the client-code
for a prototype or I would have to find another way to do the tests to
the first hop (e.g. connect to the first host directly without using
tor, which actually would be quite bad for anonymity and does not
include the time needed for crypto).

Nick Mathewson wrote:
&gt; I guess we could have a controller feature that let you set extra
&gt; flags values in descriptor.  For safety, we'd probably want them to
&gt; start with "X-", like extension headers in email or http.
&gt; There is an accepted proposal in progress of implementation that has a
&gt; separate "extra info" document containing data that most users don't
&gt; care about. Check out proposal 104 for more info on that.

That sounds good, I also think that this would be useful for everyone.
If we had such extra flags, we should eventually also be able to set
(and reset) them via a controller.

&gt; For a while, we've been meaning to have _all_ routers, even routers
&gt; that aren't directory caches, accept BEGIN_DIR commands to retrieve
&gt; a limited amount of directory information via Tor connections.
&gt; Caches would serve everything that they would serve normally;
&gt; non-caches would only serve their own descriptor.
&gt; Given this, I think you could just make any bandwidth information
&gt; that you decide it's important to serve a separate document served
&gt; this way.

I'm not sure if I understood this right. How can you serve a separate
document with this if you get either a single descriptor or the complete
network-status document? Do you mean instead of the descriptor in case
of a non-proxy?
I actually wanted to record the information within a controller that
serves this separate document to controllers of client-proxies who will
use the received information in routing. Of course it would be good to
finally include something like this into tor, which would make the
controller to record the data obsolete. But all recording and creation
of a document etc. has to be done within tor then, or am I wrong? At
the moment we are only researching which data would be useful at all and
how to design such a bandwidth document. I think in this testing phase
it would be good to use a controller that can optionally be installed
by participating server operators, since probably not everybody wants
his router to publish such information. And even later on you should
let the operators decide if they have got enough capacities to
additionally record data and serve a separate document (which could
also be done via a configuration option).

Thanks,
Johannes

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFGN6LP1TFW0/n+aNgRAji+AJ4kzmbIt4C2WAerAvEmQdL4h0OVGgCghuzJ
0LYYWuve5ernUNc8HLL9c3g=
=ykNK
-----END PGP SIGNATURE-----
</body></email><email><emailId>20070503174714</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-05-03 17:47:14-0400</timestampReceived><subject>Re: architectural proposal &amp; technical problems</subject><body>


On Tue, May 01, 2007 at 10:28:00PM +0200, Johannes Renner wrote:
&gt; -----BEGIN PGP SIGNED MESSAGE-----
&gt; Hash: SHA1
&gt; 
&gt; Roger Dingledine wrote:
&gt; &gt; I just added a new config option __DisablePredictedCircuits that
&gt; &gt; should do what you want ..
&gt; &gt; It simply doesn't build the preemptive "extra" circuits, so you don't
&gt; &gt; have random circuits appearing. Is this what you had in mind?
&gt; 
&gt; Yes, that's exactly what I had in mind, thank you for introducing
&gt; this option. Maybe other developers of controllers will also be
&gt; glad to be able to switch this off to take over the construction
&gt; of circuits for client-use.
&gt; 
&gt; BTW: Where can I find a list of all of the "special" config options
&gt; that start with __*? Just to find out if there are more of them that
&gt; could be useful for my purposes, but I don't know about yet?

I just documented them in section 5.4 of control-spec.txt.  Thanks for
the reminder!

&gt; Nick Mathewson wrote:
&gt; &gt; I guess we could have a controller feature that let you set extra
&gt; &gt; flags values in descriptor.  For safety, we'd probably want them to
&gt; &gt; start with "X-", like extension headers in email or http.
&gt; &gt; There is an accepted proposal in progress of implementation that has a
&gt; &gt; separate "extra info" document containing data that most users don't
&gt; &gt; care about. Check out proposal 104 for more info on that.
&gt; 
&gt; That sounds good, I also think that this would be useful for everyone.
&gt; If we had such extra flags, we should eventually also be able to set
&gt; (and reset) them via a controller.

I'll put this stuff in, then.  I think it's small enough not to need a
separate proposal.  I've added a note to dir-spec.txt about it, and
I'll try to get to implementing it all afternoon.

&gt; &gt; For a while, we've been meaning to have _all_ routers, even routers
&gt; &gt; that aren't directory caches, accept BEGIN_DIR commands to retrieve
&gt; &gt; a limited amount of directory information via Tor connections.
&gt; &gt; Caches would serve everything that they would serve normally;
&gt; &gt; non-caches would only serve their own descriptor.
&gt; &gt; Given this, I think you could just make any bandwidth information
&gt; &gt; that you decide it's important to serve a separate document served
&gt; &gt; this way.
&gt;
&gt; I'm not sure if I understood this right. How can you serve a separate
&gt; document with this if you get either a single descriptor or the complete
&gt; network-status document? Do you mean instead of the descriptor in case
&gt; of a non-proxy?

Err, let me rephrase:
  - It may soon be possible to have Tor servers serve descriptor-like
    documents via Tor whether they are directories or not.
  - The underlying protocol is HTTP, so it is easy to add new URLs.
  - If you want to serve a new kind of information, the easiest way
    could be to have that information served at a new URL, rather than
    at a new port.

Though actually, if (as you say) the idea is to have it be
experimental for now to figure out what works, it could be just as
easy to have a separate port for it for the moment.  I don't think I
can form much more of an opinion here until we know more about what's
in the documents, and what's in your actual design.

peace,
-- 
Nick Mathewson

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070504162051</emailId><senderName>Johannes Renner</senderName><senderEmail>hannesrenner@gmx.de</senderEmail><timestampReceived>2007-05-04 16:20:51-0400</timestampReceived><subject>Re: architectural proposal &amp; technical problems</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Nick Mathewson wrote:
&gt;   - It may soon be possible to have Tor servers serve descriptor-like
&gt;     documents via Tor whether they are directories or not.
&gt;   - The underlying protocol is HTTP, so it is easy to add new URLs.
&gt;   - If you want to serve a new kind of information, the easiest way
&gt;     could be to have that information served at a new URL, rather than
&gt;     at a new port.

Aah ok, now I know .. You are right, that is of course the most simple way
to do this. I still would be able to generate a document in a controller
and just have to put it in the right place to be served by the OR. Actually
this would be much easier than opening a separate port.

&gt; Though actually, if (as you say) the idea is to have it be
&gt; experimental for now to figure out what works, it could be just as
&gt; easy to have a separate port for it for the moment.  I don't think I
&gt; can form much more of an opinion here until we know more about what's
&gt; in the documents, and what's in your actual design.

A good format of such a document still has to be researched and specified,
but it will contain something like a list of averaged information about
the bandwidth/throughput of each TLS-link a running OR maintains as well
as about the total averaged throughput of the node. These get measured by
listening to bw and orconn-bw events for a configured short-term interval
(e.g. one minute) and examining the bytes read and written. I think that
the measuring method is quite an elegant one, because it does not produce
any extra traffic and simply counts traffic where it is already flowing.
Furthermore a max value for each TLS-connection and the total node's bw
will be delivered that was reached within a single interval in the last
long-term period (e.g. one hour). These documents shall (in a first step)
be downloaded by controllers of clients, that use the received values to
compute something like an "estimated currently available" bandwidth of
the links to support routing decisions. This is to make it simpler to
research, but as Mike already wrote this has a problem with lying, even
though you could still try to choose links for circuits in a probabilistic
way. So, later on we should maybe think about an alternate directory that
could be gathering and merging such information from all of the supporting
routers. Additionally, a client-controller does RTT-measurings for single
links, like I already explained in earlier messages, and finally chooses
routes using all of the gathered information.

Greetings,
Johannes
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFGO11j1TFW0/n+aNgRAuoiAKCE14oSJ7CuccQqj90X/YnaqaOg1wCgngJF
KJhHdQCzCKdSePbHcd8oUZA=
=Nmva
-----END PGP SIGNATURE-----
</body></email><email><emailId>20070426071917</emailId><senderName>Mike Perry</senderName><senderEmail>mikeperry@fscked.org</senderEmail><timestampReceived>2007-04-26 07:19:17-0400</timestampReceived><subject>Re: (FWD) Re: architectural proposal &amp; technical problems</subject><body>


Thus spake Johannes Renner &lt;renner@i4.informatik.rwth-aachen.de&gt;:

&gt; &gt; I doubt that bandwidths between routers
&gt; &gt; will change very much from minute to minute, and even if they do,
&gt; &gt; currently directory descriptors don't refresh fast enough for it to
&gt; &gt; matter.
&gt; 
&gt; I think that the available bandwidths between routers may actually
&gt; change from minute to minute since it depends on how many streams
&gt; a link carries and what amounts of data. I'll investigate further,
&gt; but you are right, router descriptors don't refresh fast enough and
&gt; we actually didn't plan to use them (see below).

You are most likely right that they do change, but consider what this
amount of accuracy can say about a large file transfer being done via
those nodes, for example.

Also, lying is a big problem with this. I just make sure all of my
colluding nodes claim fast connections to eachother, and slow to all
other nodes (or random arbitrary changing subsets that are hard to pin
down). For this reason I think it pretty much has to be central
authority (with alternate directory that the client addon can use), or
client-side.

&gt; &gt; So I'm a bit confused. Will the routers be publishing bandwidth
&gt; &gt; information to the directory via opt flags, or will they be publishing
&gt; &gt; it to modified clients via the addon?
&gt; 
&gt; No, they should not publish any bw-information to the directory, but
&gt; just an optional flag, so that clients can see that this router is
&gt; running such an addon and thus can request information directly from
&gt; it by connecting to an advertised port, e.g. "opt BandwidthInformer 9053".

Hrmm, this has all sorts of issues with clients connecting to nodes
that you are about to use.. But I suppose those connections could be
done over Tor.. It still makes me uneasy, especially since an
alternate directory would solve this better.

&gt; (btw: does anybody know technically how to set "opt"-flags in a comfortable way?)

It doesn't appear that you currently can. I think when you upload a
descriptor via the control port it is for client use only, but I could
be wrong.

&gt; &gt; How do you intend to do the balancing for bandwidth and latency if
&gt; &gt; every client were to be using your scheme?
&gt; 
&gt; Latencies would be measured locally from within the clients using a
&gt; probabilistic selection of nodes, just like selecting nodes for
&gt; regular circuits (maybe restricted to the fast percentile of the
&gt; routers). This information will not be made available for the others,
&gt; so every client will end up with his/her own pool of currently
&gt; considered to be fast nodes/links. That will do the load-balancing,
&gt; because if all of the clients were using the same nodes, we would
&gt; measure bad performance and simply (probabilistic) choose other nodes.

This is good. I think the local, private aspect of this is a pretty
good plus on the column of the 2C design over the OR addon design.
Though we need to think a bit about the fingerprinting issues, a way
to bias the the method towards exploration vs using the existing
weights (exploratory circuits, a-la I2P, or do we only measure during
usage?), and the anonymity and performance consequences of such a
bias. As the network grows, you will need to be more and more
exploratory to keep up with the N^2 link count.

A central authority could publish measured latencies in an alternate
directory also... Though nodes can prioritize or delay any
RELAY_BEGIN(localhost) cells in their queues.

&gt; And it will be the same with bandwidth: everyone who is interested
&gt; in, queries different (probabilistic chosen) routers in different
&gt; moments. Because the best links a router maintains in t+1 can be
&gt; different from those in t, every client in the end explores its
&gt; own random corner of the network.

One thing to consider for bandwidth is just to test if the node is
overloaded. This is easy to do globally (I have code in TorFlow to do
this now), can be placed in the directory, and doesn't leak a terrible
amount of information about the node. It also scales O(N) as opposed
to O(N^2), which also means a trusted central authority can do it
(though nodes can give them better service, so perhaps we're stuck
with client side no matter what).

&gt; &gt; So, is this whole design a prototype, or is it meant to last?
&gt; 
&gt; In the begining it will be a prototype, because we surely not know
&gt; what is the best practice. It would be good to work on a prototype,
&gt; that is designed in a way, that it could become a real-world used
&gt; implementation later on.

I think the node-addon is also weaker in this regard in that it's a
pretty ugly hack. An alternate directory can be merged into the real
directory at some point, but an addon port each tor node has to run to
provide extra info is pretty mutant to the whole design.

&gt; &gt; why not just get a fast
&gt; &gt; link and measure bandwidths AND latencies of two-hop paths
&gt; &gt; client-side, and store them yourself to run tests? Speedracer can
&gt; &gt; measure 2 hop bandwidths pretty well, and while it is a hack, you can
&gt; &gt; do latency measurements via socks and localhost as you mentioned.
&gt; 
&gt; The idea is to put as little additional load on the network as possible;
&gt; therefore we do not plan to transfer extra files in order to measure the
&gt; bandwidth (why not take that info from ORs since it is already available
&gt; there?). Otherwise we think that latency measurements will not put too much
&gt; load on the network - these are single ping cells.

Well, in the real world nodes will lie about their capacity. Either
the client or a trusted authority has to measure both. The trusted
authority can be given selective service, if nodes can tell they are
being tested though.

&gt; But we do not understand exactly what you mean with two-hop paths in here.
&gt; Why exactly 2? Do you mean to use the EXTEND command to build a two-hop
&gt; circuit and use this for measuring? This should be also possible for
&gt; one-hop circuits, right?

You can't make 1 hop circuits connect anywhere. You can test your
latency to a given node that way, but not your bandwidth to it.

The 2-hop path is to measure the bandwidth between 2 nodes. It also
works to measure the bandwidth (or more accurately, load) of a given
node, if the other node is (allegedly) as fast or faster. speedracer
does this by dividing the network into percentile tiers, averaging
stream bandwidth observed over memebers of a path, and then dividing
the nodes total bandwidth by the average observed stream, giving a
load ("average concurrent user") metric via metatroller's statistics.

&gt; Well, what we actually would like to have is the possibility to construct
&gt; only one three-hop circuit and measure partial circuits regularly (lets say
&gt; you have circ through 0-1-2-3 [where 0 is us], we are interested in doing
&gt; measurings for 0-1, 0-1-2 and 0-1-2-3).
&gt; I also like the PathlenCoinWeight proposal. This could also be useful for
&gt; measuring latencies, but the best would be just to be able to exit an existing
&gt; 3-hop-circuit at any chosen hop in between. So we could measure RTTs of partial
&gt; circuits and easily compute values for single used links.
&gt; Any of the devels can help us further?

I can't really help with this due to my limited time-budget. I say do
the SOCKS cheap hack way for now, measuring latency as circuits are
extended a hop at a time before use.

&gt; &gt; 1. Do we trust individual nodes to publish their peer latencies and
&gt; &gt; bandwidths?
&gt; 
&gt; I think, that we of course cannot trust them individual nodes.
&gt; At first we want to check whether the published information reflects the
&gt; reality and if it can be useful for clients at all. And then I think this
&gt; would be the point where we would need something like reputation?

This gets dicey. It is a lot harder for a central reputation system to
verify the N^2 links rather than just N nodes... You could try to do
some sort of frequency analysis to pair down the nodes you have to
verify to only those that claim to be fast to other peers a
"suspicious" percentage of the time, but that is even more dicey.

&gt; &gt; 2. If we do not trust individual nodes, how do we deal with the fact
&gt; &gt; that it will soon be very hard to collect these n^2 measurments from
&gt; &gt; the perspective of a central authority?
&gt; &gt; A. Can we divide them into tiers?
&gt; &gt; B. Or perhaps just truncate at some %age of the network where we just assign a \
&gt; &gt; constant value to the bandwidth of all peers (perhaps node_capacity/num_peers). \
&gt; &gt; But what about latency?
&gt; &gt; C. Or do we do all these measurements on the fly and keep long-term client
&gt; &gt; state around, so Tor gets faster the more you use it. This could
&gt; &gt; work really well for both bandwidth and latency in the 2-hop
&gt; &gt; "Censorship Resistance Only" mode I proposed in Proposal 112.
&gt; &gt; But this is particularly dangerous to anonymity, since clients
&gt; &gt; are likely to learn highly unique views of the network, and is
&gt; &gt; potentially vulnerable to gaming/selective service attacks.
&gt; 
&gt; We first want to test and try out and check what information exactly
&gt; helps best to improve the performance.
&gt; Then, if we know what will be useful we can think more about hiding
&gt; stuff for saving as much anonymity as possible.
&gt; These are all very interesting, challenging and important questions,
&gt; that have to addressed, but for the moment I think 2C sounds good:
&gt; The long-term client that makes Tor faster the more you use it.

Yeah, though please put some thought into alternate authorities as
well, and consider that N^2 factor. There are currently 1 million
(directional) links in tor.  How many probes does it take to get a
reliable avg mesurement of a link? And how do you make use of limited
information to improve speed yet not get stuck using the same nodes
all the time?

&gt; So for our purposes we would be pleased with a Tor/Tor control protocol
&gt; that is extended to the following capabilities:
&gt; 
&gt; - Two new configuration options that can be set via SETCONF:
&gt; 
&gt; 1. "opt"-entry for descriptor, example: SETCONF OptDescEntry="BandwidthInformer \
&gt; 9053" 2. option to tell Tor, that it should not construct any circuits by itself, \
&gt; similar to __LeaveStreamsUnattached, example: SETCONF __IdleCircuits=0
&gt; 
&gt; - One new command that connects over a given circuit to destIP, destPort specifying
&gt; 0, 1 or 2 to tell Tor which node of the circuit we want to address for exiting, \
&gt; e.g.: 
&gt; "CONNECT" SP circID SP ("0"|"1"|"2") SP destIP SP destPort

I think this last one is likely to be a little tricky. At least not as
simple as just adding the commands to the control port, I think the
Tor client code needs a bit of modding to be able to do this, but I'm
not sure.

&gt; This would enable us to implement my favorite method of latency-testing,
&gt; but surely needs modifications in Tor and the control protocol. So how
&gt; do you do such modifications? Do we have to implement a patch for Tor as
&gt; kind of a proposal? What other extensions do you want the control
&gt; protocol to implement for your projects? Maybe we can develop it in a way
&gt; everybody will like it?

Yeah, personally I can't really commit for doing this stuff, so you
are probably left with patching in what you need yourself.. Probably
patch the control-spec first (and post it here), then the source to
match. I don't think this stuff requires a whole proposal of its own.


-- 
Mike Perry
Mad Computer Scientist
fscked.org evil labs


[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070427154945</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-04-27 15:49:45-0400</timestampReceived><subject>Re: [or-cvs] r9993: Describe a simpler implementation for proposal 108, and note (in tor/trunk: . do</subject><body>


On Wed, Apr 25, 2007 at 03:16:28PM -0400, Roger Dingledine wrote:
&gt; On Fri, Apr 20, 2007 at 01:17:15PM -0400, nickm@seul.org wrote:
&gt; &gt;    tor/trunk/doc/spec/proposals/108-mtbf-based-stability.txt
&gt; [snip]
&gt; &gt; +Alternative:
&gt; &gt; +
&gt; &gt; +   "A router's Stability shall be defined as the sum of $alpha ^ d$ for every
&gt; &gt; +   $d$ such that the router was not observed to be unavailable $d$ days ago."
&gt; &gt; +
&gt; &gt; +   This allows a simpler implementation: every day, we multiply yesterday's
&gt; &gt; +   Stability by alpha, and if the router was running for all of today, we add
&gt; &gt; +   1.
&gt; 
&gt; I don't think you mean quite that. For a server that just appeared,
&gt; there are an infinite number of previous days where it was not observed
&gt; to be unavailable. Do you mean 'was observed to be available'?

Ah, you're right.

&gt; And by available, do we mean available for the entire day?

I think so, for arbitrary values of "day".

&gt; 
&gt; What are some ways we can choose \alpha?

We should probably decide how much we'd like to discount the distant
past.  Something between .80 and .95 is probably around right.

&gt; 
&gt; &gt; +Limitations:
&gt; &gt; +
&gt; &gt; +   Authorities can have false positives and false negatives when trying to
&gt; &gt; +   tell whether a router is up or down.  So long as these aren't terribly
&gt; &gt; +   wrong, and so long as they aren't significantly biased, we should be able
&gt; &gt; +   to use them to estimate stability pretty well.
&gt; 
&gt; I haven't seen any discussion about how the router's declared uptime fits
&gt; into this. If a router goes down and then comes up again in between
&gt; measurements, the proposed approach will treat it as being up the
&gt; whole time -- yet connections through it will be broken. One approach
&gt; to handling this would be to notice if the uptime decreases from one
&gt; descriptor to the next. This would indicate a self-declared downtime
&gt; for the router, and we can just figure that into the calculations.

This would be a good thing, but it _would_ give routers incentive to
lie about uptime.

&gt; 
&gt; I'm not sure how we should compute the length of the downtime though:
&gt; in some cases it will be just a split second as for a reboot or upgrade,
&gt; but in others maybe the computer, network, or Tor process went down
&gt; and then came back a long time later. I guess since our computations
&gt; are just rough approximations anyway, we can just assume a zero-length
&gt; downtime unless our active testing also noticed it.

Actually, I chose "up for an entire day" as a minimum quantum for a
reason.  The main problem with router instability isn't the fraction
of time it's down; if you try to connect to a router that isn't there,
that's not a big deal.  The problem with router instability is the
likelihood that it will _go_ down and drop all your circuits.
Remember, a router that goes down for 5 minutes out of a every hour
has a _higher_ fractional uptime than a router that goes down for one
day out of every week... but the latter router is far more stable, and
far more useful if your goal is long-lived circuits.

(That's why I originally chose MTBF rather than uptime percentage.
I'm _trying_ to approximate the same insight by requiring you to be up
for the entirety of a day rather than a fraction of it, but there may
be better ways to approximate it.)

&gt; 
&gt; Speaking of the active testing, here's what we do right now:
&gt; 
&gt; Every 10 seconds, we call dirserv_test_reachability(), and it tries making
&gt; connections to a different 1/128 of the router list. So a given router
&gt; gets tried every 1280 seconds, or a bit over 21 minutes. We declare a
&gt; router to be unreachable if it has not been successfully found reachable
&gt; within the past 45 minutes. So at least two testing periods not to go
&gt; by before a running router is considered to be no longer running.
&gt; 
&gt; So our measurements won't be perfect, but I think this approach is a
&gt; much better one than just blindly believing the uptime entry in the
&gt; router descriptor.
&gt; 
&gt; What is our plan for storing (and publishing?) the observed uptime
&gt; periods for each router?

I don't think publishing is necessary; there's nothing to stop us from
doing it later if we chhose.

To store the uptime, I was thinking of a flat file written
periodically; it would probably be something like 64K at the moment,
which wouldn't be a big problem for authorities to flush every 10
minutes or so.  If we wanted to be fancier, we could keep an
append-only events journal, and periodically use it to rebuild a
status file, but that doesn't seem necessary.

We could also start poking at the dark sad world of Berkeley DB and
friends, I guess.  The annoyances of that are well known, but it won't
be too bad if we only require it on authorities.

yrs,
-- 
Nick Mathewson

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070426072314</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-04-26 07:23:14-0400</timestampReceived><subject>Re: Simplifying directory authority administration</subject><body>

On Thu, Apr 26, 2007 at 03:16:33AM -0400, Roger Dingledine wrote:
&gt; But in the interest of not expanding this proposal to include all the
&gt; issues with name binding, I'm going to try to focus on the easiest and
&gt; simplest to deploy that will solve a few of the immediate problems.

Actually, let me propose a solution to put alongside the others:

"Remove the instructions in the tor-doc-server page that talk about
sending mail to tor-ops and registering your nickname."

This too would change the original notion of what Named means, but
it wouldn't change it much in practice compared to its current use.

--Roger

</body></email><email><emailId>20070427161201</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-04-27 16:12:01-0400</timestampReceived><subject>Re: Simplifying directory authority administration</subject><body>


[More discussion on proposal 113.]

On Thu, Apr 26, 2007 at 03:16:33AM -0400, Roger Dingledine wrote:
 [...]
&gt; &gt; +  Worse, name binding is a common path, but it's a pain in the neck: nobody
&gt; &gt; +  has done it for a couple of months.
&gt; 
&gt; A related problem is that people register nicknames and then vanish,
&gt; and a year or two later somebody picks the same nickname and is locked
&gt; out of the network -- in a way that isn't really intuitive to the poor
&gt; server operator.

Agreed, but separate.  Let's get them a better error, and let's
give names a safe way to time-out when unused.

(To get unused names to disappear safely, you'd probably want some
means to tell users "It's not safe to use name X any more.")

&gt; A deeper problem is really that naming isn't very useful anymore. Once
&gt; upon a time we imagined that people would refer to servers by nickname,
&gt; and an unamed server was not recommended for use. Requiring an email was
&gt; in large part a Sybil deterrent. Then we scaled past the point where
&gt; that was practical -- so we started letting unnamed servers be used in
&gt; ordinary situations, and even let multiple servers with the same nickname
&gt; join the network. We migrated to referring to servers by identity key,
&gt; because that's the unique identifier now.
&gt; 
&gt; So part of the reason that name binding isn't actively done anymore is
&gt; that it doesn't (seem to) matter enough.

Right.  It matters _a little_, though.  I still believe that people
are referring to servers by name, for example; when I see
foo.server.exit addresses and torrc configurations, people seem to use
nicknames, even when they know they shouldn't.  (The
prevent-sybil-with-naming goal and the don't-use-unnamed-servers goal
do indeed seem defunct.)

&gt; Indeed, the main reason for answering name registration mail is not to
&gt; get the name on record -- it's to make the server operator feel welcome,
&gt; and to help catch misconfigurations and confusions early.
&gt;
&gt; While we're listing problems with the Named flag, its utility is also
&gt; limited because we're missing an Unnamed flag: if only one directory
&gt; authority has a binding for a given nickname, and the named server hasn't
&gt; published a descriptor recently, then some other server can arrive in
&gt; the meantime with the same nickname and it will be listed by the other
&gt; n-1 dir authorities. (But the naive implementation of this lets a single
&gt; dir authority cut out any server(s) it chooses from the network; looks
&gt; like more research remains here.)

Agreed, and also separable.  I^WWe^WSomebody should think about this
and try to write this up as a separate proposal.  Proposal 101 gives
us a nice time to do a lot of directory-related changes; if this is
something we should do, we should do it soon.

&gt; 
&gt; We could also imagine a client-side Naming strategy, where clients bind
&gt; keys to nicknames the first time they reference them, and then store
&gt; the binding locally.

I dislike this for two reasons:
  - It keeps on the client side a record of every server the client
    has ever referred to by name.  That sounds like a security problem.
  - It keeps users from communicating usefully.  There's not much
    point in saying "I know the guy who runs Dizum; he can be trusted"
    if there's no way to tell that your friend will get the right Dizum.

&gt; 
&gt; But in the interest of not expanding this proposal to include all the
&gt; issues with name binding, I'm going to try to focus on the easiest and
&gt; simplest to deploy that will solve a few of the immediate problems.
&gt; 

 [...]

Thanks for the comments on the "possible solutions" areas.  Something
I didn't see, though, was feedback from your standpoint as an
authority operator.  Between the solutions listed, which would you
actually be willing to do the legwork for as the administrator
operator, and which would get unused the way that the current naming
system is getting unused today?

(I'd also like to hear from weasel and the other authority ops about
this.)

yrs,
-- 
Nick Mathewson

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070424060443</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-04-24 06:04:43-0400</timestampReceived><subject>Re: Proposal: Bring Back PathlenCoinWeight</subject><body>

On Wed, Apr 18, 2007 at 02:35:04PM -0700, Mike Perry wrote:
&gt;   The idea is that users should be able to choose a weight which
&gt;   probabilistically chooses their path lengths to be 2 or 3 hops. This
&gt;   weight will essentially be a biased coin that indicates an
&gt;   additional hop (beyond 2) with probability P. The user should be
&gt;   allowed to choose 0 for this weight to always get 2 hops and 1 to
&gt;   always get 3. 
&gt;
&gt;   This value should be modifiable from the controller, and should be 
&gt;   available from Vidalia.

To give some context, the PathlenCoinWeight config option was originally
there as a geometric distribution to add to some default minimum path
length. Its goal was to stop your first hop from knowing for sure that
it was your first hop. That is, if path lengths are unpredictable,
then no hop ever knows his distance from Alice for sure.

(I say 'was originally there' rather than 'was originally introduced'
because we inherited it from the previous onion routing designs.)

We dropped it for three reasons:

- Timing attacks probably give statistical confidence to a given node
  about its position in the circuit.
- Our use of entry guards, and our use of CREATE_FAST cells,
  automatically give it away in many cases, especially for non-relays.
- Given the first two points, if three hops is adequate for security,
  then more than three hops just slows you down with not much benefit.

So this proposal isn't about bringing back the old behavior. It appears
rather to be some combination of:

a) We should let people choose two hops if they want, for better
   performance and to reduce the overall load on the network.
b) We should make path length have a random component, so it's hard
   to tell if a given user prefers two-hop paths or three-hop paths.
c) We should change our policy for dropping guards based on when they
   fail.

Letting each user choose his own random weight is probably a recipe
for disaster, in that it adds complexity to the system and to analysis
and doesn't really provide any clear win. So giving people a couple of
weights to choose from (0, 1, and maybe a few more) seems a smarter move.

&gt;   Furthermore, when blocking resistance measures insert an extra relay
&gt;   hop into the equation, 4 hops will certainly be completely unusable 
&gt;   for these users, especially since it will be considerably more
&gt;   difficult to balance the load across a dark relay net than balancing
&gt;   the load on Tor itself (which today is still not without its flaws).

I believe the blocking-resistance plan is to have 3 hops also -- the
bridge acts quite like an entry guard, and then two more. But all of
that is up for more thorough analysis too.

&gt;   Therefore, the user has little benefit from the extra hop, assuming
&gt;   the adversary does timing correlation on their nodes. The real
&gt;   protection is the probability of getting both the first and last hop, 
&gt;   and this is constant whether the client chooses 2 hops, 3 hops, or 42.

My intuition agrees -- against e2e timing correlation attacks, three
hops is not (much) better than two.

&gt;   Partitioning attacks form another concern. Since Tor uses telescoping
&gt;   to build circuits, it is possible to tell a user is constructing only
&gt;   two hop paths at the entry node. It is questionable if this data is
&gt;   actually worth anything though, especially if the majority of users
&gt;   have easy access to this option, and do actually choose their path
&gt;   lengths semi-randomly.

Agreed. The possibility that an entry guard could learn that its user
is a 2-hop user doesn't bother me very much. At least not until it
turns into a deeper attack.

&gt;   Perhaps most seriously, two hop paths do allow malicious guards 
&gt;   to easily fail circuits if they do not extend to their colluding peers
&gt;   for the exit hop. Since guards can detect the number of hops in a
&gt;   path, they could always fail the 3 hop circuits and focus on
&gt;   selectively failing the two hop ones until a peer was chosen.

Yep. In fact, assuming Alice uses Tor a lot, it doesn't even need to fail
every single "safe" circuit. It can just take advantage of the circuits
where it wins, and/or maybe fail a few to help that along. Note that it's
trivial for it to recognize which circuits are the winners, so there's
no synchronization or communication needed except when it's a sure bet.

Another (passive) variant of this attack is that the entry guard could
notice the exit node Alice chooses. If she chooses one with an unusual
exit policy (e.g. it only exits to a few IP addresses, or only to a few
ports) that gives away a lot about Alice's destination. Does this mean
Alice needs to compare the exit policy of her chosen exit to all the other
exits, detect if it's giving away "too much" and add an extra hop if so?
In any case, since Alice keeps using this entry guard, it can build up a
profile via intersection attacks of what types of exit she prefers. How
bad is this? I'm not sure; but it does complicate things.

The inverse of this attack is an exit node building a profile of Alice's
entry guards, if Alice is one of a few people connecting to an unusual
destination. It would use this profile to recognize when a new connection
is "more likely" to have come from Alice.

This in turn plays into a worry that Nick raised a while ago: if a
set of entry guards is a good enough fingerprint, and Alice is on a
laptop and moves around a lot, what if she moves to a hostile network
and somebody has is looking for a fingerprint of preferred entry guards
that matches hers?

It's hard to know how to weight or rank these concerns. But they do make
it less clear that two hops provides equivalent security to three.

&gt;   I believe currently guards are rotated if circuits fail, which does 
&gt;   provide some protection,

Actually, no. Guards are marked as inactive if the initial connection
to them fails, or the create cell to them fails. If a circuit through
them fails, we don't mark anything.

Guards are only actually dropped from the guard list if they are inactive
for many weeks. Otherwise we try them again as soon as the directory
authorities tell us they're running again. Section 5 of path-spec.txt
has a few more details.

&gt; but this could be changed so that an entry 
&gt;   guard is completely abandoned after a certain number of extend or 
&gt;   general circuit failures, though perhaps this also could be gamed 
&gt;   to increase guard turnover.

Right. Remember that we're not only worried about an attacking guard
colluding with an exit node or destination website; we're also worried
about a local network colluding with an exit node or destination website.

But I guess in that second context it doesn't really help the adversary
to force Alice to rotate entry guards. Hm.

&gt; Such a game would be much more noticeable 
&gt;   than an individual guard failing circuits, though, since it would
&gt;   affect all clients, not just those who chose a particular guard.

I'm not sure I follow this. You mean if a middle hop decides to fail
connections from certain guards to encourage users to move away from them?
If the attacker has already learned that Alice is using that guard, that
would make sense; but he'd have to own an awful lot of middle hops for
that attack to be practical.

Another worry is the local network triggering repeated failures only
for Alice. But actually, Alice should be able to distinguish failures
on her local network from authenticated messages from the guards saying
that an extend failed.

Hm. What other issues are there with abandoning guards after failure? One
issue is that we could more quickly rotate away from honest guards onto
bad guards; so we would need to make sure that the bar for failure is
sufficiently high that it doesn't trigger except during one of these
attacks. This part needs more thought.

&gt; Why not fix Pathlen=2?:
&gt; 
&gt;   The main reason I am not advocating that we always use 2 hops is that 
&gt;   in some situations, timing correlation evidence by itself may not be 
&gt;   considered as solid and convincing as an actual, uninterrupted, fully 
&gt;   traced path. Are these timing attacks as effective on a real network 
&gt;   as they are in simulation? Would an extralegal adversary or authoritarian 
&gt;   government even care? In the face of these situation-dependent unknowns, 
&gt;   it should be up to the user to decide if this is a concern for them or not.

Fair enough. How do the above anonymity-breaking attacks look to you, in
this light?

Thanks!
--Roger

</body></email><email><emailId>20070423062445</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-04-23 06:24:45-0400</timestampReceived><subject>Re: A Java-based Tor simulator -- where can I share it?</subject><body>

On Mon, Apr 23, 2007 at 01:41:51AM +0200, Karsten Loesing wrote:
&gt; as a preparatory work for my GSoC project I implemented a Java-based Tor
&gt; simulator that might also be useful for others (the other GSoC
&gt; students?).

Great!

&gt; Originally, it was intended to analyze behavior of hidden
&gt; service requests in public and private Tor networks. But I think it can
&gt; be used for other services in Tor, too. At least it can be a start to
&gt; generate a first network configuration. If you want to read more, I
&gt; attached the first section of the howto to this mail. And maybe you can
&gt; read even more in the future......
&gt; 
&gt; (and this brings me to my actual question): ...... where? How can I
&gt; share this code? Can you host it at your Subversion repository? Or will
&gt; Google host it (because it's part of the project)? I could also host it
&gt; at the CVS repository at our university, but how would others learn
&gt; about it (link)?
&gt; 
&gt; The next question is about the code that we GSoCers are going to write
&gt; during our projects: do you create a branch for each GSoC project? Or
&gt; will we host our projects at Google or by ourselves?

We are happy to add projects like this to the Tor SVN repository when it
makes sense (and in this case it probably does). The usual approach is
for the author to put a tarball up somewhere first, so we can grab it and
look through it to see what it actually is, whether it's ready or wants
a lot of revision before it goes 'live', etc. If you don't have any place
to post a tarball, let me know and I can give you some web space on moria.

We'll probably want to make a new module in SVN for this, and for other
projects as they come up. We don't really have a formal process for
picking names for new modules, since we've only done it a handful of
times so far, so the current plan is to continue winging it. :)

&gt; And the last question: What about licenses? What do I have to write to
&gt; the code to include it in the license?

I'm not clear on what your question is here. Our favorite license
currently is the 3-clause BSD license, and the rest of the projects in Tor
SVN use that license too. If you want to use 3-clause BSD too, feel free
to grab the text of it from a Tor tarball, change the names, years, etc,
and now you have your own shiny new license. Is this what you were asking?

Thanks!
--Roger

</body></email><email><emailId>20070423114903</emailId><senderName>Benedikt Boss</senderName><senderEmail>benedikt.boss@googlemail.com</senderEmail><timestampReceived>2007-04-23 11:49:03-0400</timestampReceived><subject>Re: A Java-based Tor simulator -- where can I share it?</subject><body>

very nice! im very looking forward to this one .. 
how is traffic generated in the simulation? do you have sort of a rule
based generator or do i still need manual interaction?

greetings
benedikt


On Mon, Apr 23, 2007 at 02:24:45AM -0400, Roger Dingledine wrote:
&gt; On Mon, Apr 23, 2007 at 01:41:51AM +0200, Karsten Loesing wrote:
&gt; &gt; as a preparatory work for my GSoC project I implemented a Java-based Tor
&gt; &gt; simulator that might also be useful for others (the other GSoC
&gt; &gt; students?).
&gt; 
&gt; Great!
&gt; 
&gt; &gt; Originally, it was intended to analyze behavior of hidden
&gt; &gt; service requests in public and private Tor networks. But I think it can
&gt; &gt; be used for other services in Tor, too. At least it can be a start to
&gt; &gt; generate a first network configuration. If you want to read more, I
&gt; &gt; attached the first section of the howto to this mail. And maybe you can
&gt; &gt; read even more in the future......
&gt; &gt; 
&gt; &gt; (and this brings me to my actual question): ...... where? How can I
&gt; &gt; share this code? Can you host it at your Subversion repository? Or will
&gt; &gt; Google host it (because it's part of the project)? I could also host it
&gt; &gt; at the CVS repository at our university, but how would others learn
&gt; &gt; about it (link)?
&gt; &gt; 
&gt; &gt; The next question is about the code that we GSoCers are going to write
&gt; &gt; during our projects: do you create a branch for each GSoC project? Or
&gt; &gt; will we host our projects at Google or by ourselves?
&gt; 
&gt; We are happy to add projects like this to the Tor SVN repository when it
&gt; makes sense (and in this case it probably does). The usual approach is
&gt; for the author to put a tarball up somewhere first, so we can grab it and
&gt; look through it to see what it actually is, whether it's ready or wants
&gt; a lot of revision before it goes 'live', etc. If you don't have any place
&gt; to post a tarball, let me know and I can give you some web space on moria.
&gt; 
&gt; We'll probably want to make a new module in SVN for this, and for other
&gt; projects as they come up. We don't really have a formal process for
&gt; picking names for new modules, since we've only done it a handful of
&gt; times so far, so the current plan is to continue winging it. :)
&gt; 
&gt; &gt; And the last question: What about licenses? What do I have to write to
&gt; &gt; the code to include it in the license?
&gt; 
&gt; I'm not clear on what your question is here. Our favorite license
&gt; currently is the 3-clause BSD license, and the rest of the projects in Tor
&gt; SVN use that license too. If you want to use 3-clause BSD too, feel free
&gt; to grab the text of it from a Tor tarball, change the names, years, etc,
&gt; and now you have your own shiny new license. Is this what you were asking?
&gt; 
&gt; Thanks!
&gt; --Roger
</body></email><email><emailId>20070604185800</emailId><senderName>Peter Palfrader</senderName><senderEmail>peter@palfrader.org</senderEmail><timestampReceived>2007-06-04 18:58:00-0400</timestampReceived><subject>control interface via unix domain socket</subject><body>

Hi,

this is a first cut at a patch to also offer the control interface over
a unix domain socket, not just a TCP port.

Things that remain to be done:
 - make relative filenames relative to datadir?
 - document in manpage

Please let me know if this is something that should go in, and if yes
how to change it so that it can.




To test you can use socat, e.g. socat - UNIX-CONNECT:./foo
Make sure you don't forget the CRLF line endings, i.e. do ^V^M&lt;enter&gt; at
the end of a line.

here a diff -w, a normal diff is attached:

Index: configure.in
===================================================================
--- configure.in	(revision 10485)
+++ configure.in	(working copy)
@@ -240,7 +240,7 @@
 
 AC_CHECK_HEADERS(unistd.h string.h signal.h ctype.h sys/stat.h sys/types.h fcntl.h \
sys/fcntl.h sys/time.h errno.h assert.h time.h, , AC_MSG_WARN(Some headers were not \
found, compilation may fail.  If compilation succeeds, please send your orconfig.h to \
the developers so we can fix this warning.))  
-AC_CHECK_HEADERS(netdb.h sys/ioctl.h sys/socket.h arpa/inet.h netinet/in.h pwd.h \
grp.h) +AC_CHECK_HEADERS(netdb.h sys/ioctl.h sys/socket.h arpa/inet.h netinet/in.h \
pwd.h grp.h sys/un.h)  
 dnl These headers are not essential
 
Index: src/or/config.c
===================================================================
--- src/or/config.c	(revision 10487)
+++ src/or/config.c	(working copy)
@@ -149,6 +149,9 @@
   VAR("ContactInfo",         STRING,   ContactInfo,          NULL),
   VAR("ControlListenAddress",LINELIST, ControlListenAddress, NULL),
   VAR("ControlPort",         UINT,     ControlPort,          "0"),
+#ifdef HAVE_SYS_UN_H
+  VAR("ControlSocket",       LINELIST, ControlSocket,        NULL),
+#endif
   VAR("CookieAuthentication",BOOL,     CookieAuthentication, "0"),
   VAR("DataDirectory",       STRING,   DataDirectory,        NULL),
   OBSOLETE("DebugLogFile"),
Index: src/or/or.h
===================================================================
--- src/or/or.h	(revision 10487)
+++ src/or/or.h	(working copy)
@@ -56,6 +56,9 @@
 #ifdef HAVE_SYS_SOCKET_H
 #include &lt;sys/socket.h&gt;
 #endif
+#ifdef HAVE_SYS_UN_H
+#include &lt;sys/un.h&gt;
+#endif
 #ifdef HAVE_SYS_TIME_H
 #include &lt;sys/time.h&gt;
 #endif
@@ -239,7 +242,9 @@
 #define CONN_TYPE_AP_NATD_LISTENER 14
 /** Type for sockets listening for DNS requests. */
 #define CONN_TYPE_AP_DNS_LISTENER 15
-#define _CONN_TYPE_MAX 15
+/** Type for unix domain sockets for control interface */
+#define CONN_TYPE_CONTROL_UDS_LISTENER 16
+#define _CONN_TYPE_MAX 16
 
 #define CONN_IS_EDGE(x) \
   ((x)-&gt;type == CONN_TYPE_EXIT || (x)-&gt;type == CONN_TYPE_AP)
@@ -1803,6 +1808,7 @@
   int TransPort;
   int NatdPort; /**&lt; Port to listen on for transparent natd connections. */
   int ControlPort; /**&lt; Port to listen on for control connections. */
+  config_line_t * ControlSocket; /**&lt; Unix Domain Socket to listen on for control \
connections. */  int DirPort; /**&lt; Port to listen on for directory connections. */
   int DNSPort; /**&lt; Port to listen on for DNS requests. */
   int AssumeReachable; /**&lt; Whether to publish our descriptor regardless. */
Index: src/or/connection.c
===================================================================
--- src/or/connection.c	(revision 10487)
+++ src/or/connection.c	(working copy)
@@ -54,6 +54,7 @@
     case CONN_TYPE_DIR: return "Directory";
     case CONN_TYPE_CPUWORKER: return "CPU worker";
     case CONN_TYPE_CONTROL_LISTENER: return "Control listener";
+    case CONN_TYPE_CONTROL_UDS_LISTENER: return "Control unix-socket listener";
     case CONN_TYPE_CONTROL: return "Control";
     default:
       log_warn(LD_BUG, "unknown connection type %d", type);
@@ -78,6 +79,7 @@
     case CONN_TYPE_AP_DNS_LISTENER:
     case CONN_TYPE_DIR_LISTENER:
     case CONN_TYPE_CONTROL_LISTENER:
+    case CONN_TYPE_CONTROL_UDS_LISTENER:
       if (state == LISTENER_STATE_READY)
         return "ready";
       break;
@@ -295,6 +297,13 @@
     buf_free(conn-&gt;outbuf);
   }
 
+  if (conn-&gt;type == CONN_TYPE_CONTROL_UDS_LISTENER) {
+    if (unlink(conn-&gt;address) &lt; 0 &amp;&amp; errno != ENOENT) {
+      log_warn(LD_NET, "Could not unlink %s: %s", conn-&gt;address,
+                       strerror(errno));
+    }
+  }
+
   tor_free(conn-&gt;address);
 
   if (connection_speaks_cells(conn)) {
@@ -343,6 +352,7 @@
     connection_or_remove_from_identity_map(TO_OR_CONN(conn));
   }
 
+
   memset(conn, 0xAA, sizeof(connection_t)); /* poison memory */
   tor_free(mem);
 }
@@ -632,16 +642,30 @@
 connection_create_listener(const char *listenaddress, uint16_t listenport,
                            int type)
 {
-  struct sockaddr_in listenaddr; /* where to bind */
   char *address = NULL;
   connection_t *conn;
   uint16_t usePort;
+  int s; /* the socket we're going to make */
+  int is_inet = (type != CONN_TYPE_CONTROL_UDS_LISTENER);
+  int is_tcp = (is_inet &amp;&amp; type != CONN_TYPE_AP_DNS_LISTENER);
+
+  if (get_n_open_sockets() &gt;= get_options()-&gt;_ConnLimit-1) {
+    int n_conns = get_n_open_sockets();
+    log_warn(LD_NET,"Failing because we have %d connections already. Please "
+             "raise your ulimit -n.", n_conns);
+    control_event_general_status(LOG_WARN, "TOO_MANY_CONNECTIONS CURRENT=%d",
+                                 n_conns);
+    return NULL;
+  }
+
+
+
+  if (is_inet) {
+    struct sockaddr_in listenaddr; /* where to bind */
   uint32_t addr;
-  int s; /* the socket we're going to make */
 #ifndef MS_WINDOWS
   int one=1;
 #endif
-  int is_tcp = (type != CONN_TYPE_AP_DNS_LISTENER);
 
   memset(&amp;listenaddr,0,sizeof(struct sockaddr_in));
   if (parse_addr_port(LOG_WARN, listenaddress, &amp;address, &amp;addr, &amp;usePort)&lt;0) {
@@ -659,15 +683,6 @@
   log_notice(LD_NET, "Opening %s on %s:%d",
              conn_type_to_string(type), address, usePort);
 
-  if (get_n_open_sockets() &gt;= get_options()-&gt;_ConnLimit-1) {
-    int n_conns = get_n_open_sockets();
-    log_warn(LD_NET,"Failing because we have %d connections already. Please "
-             "raise your ulimit -n.", n_conns);
-    control_event_general_status(LOG_WARN, "TOO_MANY_CONNECTIONS CURRENT=%d",
-                                 n_conns);
-    return NULL;
-  }
-
   s = tor_open_socket(PF_INET,
                       is_tcp ? SOCK_STREAM : SOCK_DGRAM,
                       is_tcp ? IPPROTO_TCP: IPPROTO_UDP);
@@ -703,7 +718,46 @@
       goto err;
     }
   }
+  } else {
+#ifdef HAVE_SYS_UN_H
+    struct sockaddr_un sockaddr;
+    sockaddr.sun_family = AF_UNIX;
+    int len;
+    address = tor_strdup(listenaddress);
 
+    log_notice(LD_NET, "Opening %s on %s",
+	       conn_type_to_string(type), address);
+
+    strncpy(sockaddr.sun_path, address, sizeof(sockaddr.sun_path));
+    if (unlink(sockaddr.sun_path) &lt; 0 &amp;&amp; errno != ENOENT) {
+      log_warn(LD_NET, "Could not unlink %s: %s", address,
+                       strerror(errno));
+      goto err;
+    }
+    s = tor_open_socket(AF_UNIX, SOCK_STREAM, 0);
+    if (s &lt; 0) {
+      log_warn(LD_NET,"Socket creation failed: %s.", strerror(errno));
+      goto err;
+    }
+
+    len = strlen(sockaddr.sun_path) + sizeof(sockaddr.sun_family);
+    if (bind(s, (struct sockaddr *)&amp;sockaddr, len) == -1) {
+      log_warn(LD_NET,"Bind to %s failed: %s.", address,
+               tor_socket_strerror(tor_socket_errno(s)));
+      goto err;
+    }
+
+    if (listen(s,SOMAXCONN) &lt; 0) {
+      log_warn(LD_NET, "Could not listen on %s: %s", address,
+	       tor_socket_strerror(tor_socket_errno(s)));
+      tor_close_socket(s);
+      goto err;
+    }
+#else
+    assert(0);
+#endif /* HAVE_SYS_UN_H */
+  }
+
   set_socket_nonblocking(s);
 
   conn = connection_new(type);
@@ -722,7 +776,7 @@
             conn_type_to_string(type), usePort);
 
   conn-&gt;state = LISTENER_STATE_READY;
-  if (is_tcp) {
+  if (is_tcp || !is_inet) {
     connection_start_reading(conn);
   } else {
     tor_assert(type == CONN_TYPE_AP_DNS_LISTENER);
@@ -801,6 +855,9 @@
 
   set_socket_nonblocking(news);
 
+  if (((struct sockaddr*)addrbuf)-&gt;sa_family == AF_INET) {
+    assert(conn-&gt;type != CONN_TYPE_CONTROL_UDS_LISTENER);
+
   if (check_sockaddr_in((struct sockaddr*)addrbuf, remotelen, LOG_INFO)&lt;0) {
     log_info(LD_NET,
              "accept() returned a strange address; trying getsockname().");
@@ -851,6 +908,20 @@
   newconn-&gt;port = ntohs(remote.sin_port);
   newconn-&gt;address = tor_dup_addr(newconn-&gt;addr);
 
+  } else if (((struct sockaddr*)addrbuf)-&gt;sa_family == AF_UNIX) {
+    assert(conn-&gt;type == CONN_TYPE_CONTROL_UDS_LISTENER);
+
+    newconn = connection_new(new_type);
+    newconn-&gt;s = news;
+
+    /* remember the remote address  --  do we have anything sane to put here? */
+    newconn-&gt;addr = 0;
+    newconn-&gt;port = 1;
+    newconn-&gt;address = tor_strdup(conn-&gt;address);
+  } else {
+    assert(0);
+  };
+
   if (connection_add(newconn) &lt; 0) { /* no space, forget it */
     connection_free(newconn);
     return 0; /* no need to tear down the parent */
@@ -1042,6 +1113,12 @@
     line = NULL;
     SMARTLIST_FOREACH(launch, config_line_t *, wanted,
       {
+	if (type == CONN_TYPE_CONTROL_UDS_LISTENER) {
+	  if (!strcasecmp(wanted-&gt;value, conn-&gt;address)) {
+	    line = wanted;
+	    break;
+	  }
+	} else {
         char *address=NULL;
         uint16_t port;
         if (!parse_addr_port(LOG_WARN, wanted-&gt;value, &amp;address, NULL, &amp;port)) {
@@ -1054,6 +1131,7 @@
             break;
           }
         }
+	}
       });
     if (! line) {
       /* This one isn't configured. Close it. */
@@ -1142,6 +1220,11 @@
                       options-&gt;ControlPort, "127.0.0.1",
                       replaced_conns, new_conns, 0)&lt;0)
     return -1;
+  if (retry_listeners(CONN_TYPE_CONTROL_UDS_LISTENER,
+                      options-&gt;ControlSocket,
+                      options-&gt;ControlSocket ? 1 : 0, NULL,
+                      replaced_conns, new_conns, 0)&lt;0)
+    return -1;
 
   return 0;
 }
@@ -1546,6 +1629,7 @@
     case CONN_TYPE_DIR_LISTENER:
       return connection_handle_listener_read(conn, CONN_TYPE_DIR);
     case CONN_TYPE_CONTROL_LISTENER:
+    case CONN_TYPE_CONTROL_UDS_LISTENER:
       return connection_handle_listener_read(conn, CONN_TYPE_CONTROL);
     case CONN_TYPE_AP_DNS_LISTENER:
       /* This should never happen; eventdns.c handles the reads here. */
@@ -2631,6 +2715,7 @@
     case CONN_TYPE_AP_NATD_LISTENER:
     case CONN_TYPE_DIR_LISTENER:
     case CONN_TYPE_CONTROL_LISTENER:
+    case CONN_TYPE_CONTROL_UDS_LISTENER:
     case CONN_TYPE_AP_DNS_LISTENER:
       tor_assert(conn-&gt;state == LISTENER_STATE_READY);
       break;
-- 
                           |  .''`.  ** Debian GNU/Linux **
      Peter Palfrader      | : :' :      The  universal
 http://www.palfrader.org/ | `. `'      Operating System
                           |   `-    http://www.debian.org/



Index: configure.in
===================================================================
--- configure.in	(revision 10485)
+++ configure.in	(working copy)
@@ -240,7 +240,7 @@
 
 AC_CHECK_HEADERS(unistd.h string.h signal.h ctype.h sys/stat.h sys/types.h fcntl.h \
sys/fcntl.h sys/time.h errno.h assert.h time.h, , AC_MSG_WARN(Some headers were not \
found, compilation may fail.  If compilation succeeds, please send your orconfig.h to \
the developers so we can fix this warning.))  
-AC_CHECK_HEADERS(netdb.h sys/ioctl.h sys/socket.h arpa/inet.h netinet/in.h pwd.h \
grp.h) +AC_CHECK_HEADERS(netdb.h sys/ioctl.h sys/socket.h arpa/inet.h netinet/in.h \
pwd.h grp.h sys/un.h)  
 dnl These headers are not essential
 
Index: src/or/config.c
===================================================================
--- src/or/config.c	(revision 10487)
+++ src/or/config.c	(working copy)
@@ -149,6 +149,9 @@
   VAR("ContactInfo",         STRING,   ContactInfo,          NULL),
   VAR("ControlListenAddress",LINELIST, ControlListenAddress, NULL),
   VAR("ControlPort",         UINT,     ControlPort,          "0"),
+#ifdef HAVE_SYS_UN_H
+  VAR("ControlSocket",       LINELIST, ControlSocket,        NULL),
+#endif
   VAR("CookieAuthentication",BOOL,     CookieAuthentication, "0"),
   VAR("DataDirectory",       STRING,   DataDirectory,        NULL),
   OBSOLETE("DebugLogFile"),
Index: src/or/or.h
===================================================================
--- src/or/or.h	(revision 10487)
+++ src/or/or.h	(working copy)
@@ -56,6 +56,9 @@
 #ifdef HAVE_SYS_SOCKET_H
 #include &lt;sys/socket.h&gt;
 #endif
+#ifdef HAVE_SYS_UN_H
+#include &lt;sys/un.h&gt;
+#endif
 #ifdef HAVE_SYS_TIME_H
 #include &lt;sys/time.h&gt;
 #endif
@@ -239,7 +242,9 @@
 #define CONN_TYPE_AP_NATD_LISTENER 14
 /** Type for sockets listening for DNS requests. */
 #define CONN_TYPE_AP_DNS_LISTENER 15
-#define _CONN_TYPE_MAX 15
+/** Type for unix domain sockets for control interface */
+#define CONN_TYPE_CONTROL_UDS_LISTENER 16
+#define _CONN_TYPE_MAX 16
 
 #define CONN_IS_EDGE(x) \
   ((x)-&gt;type == CONN_TYPE_EXIT || (x)-&gt;type == CONN_TYPE_AP)
@@ -1803,6 +1808,7 @@
   int TransPort;
   int NatdPort; /**&lt; Port to listen on for transparent natd connections. */
   int ControlPort; /**&lt; Port to listen on for control connections. */
+  config_line_t * ControlSocket; /**&lt; Unix Domain Socket to listen on for control \
connections. */  int DirPort; /**&lt; Port to listen on for directory connections. */
   int DNSPort; /**&lt; Port to listen on for DNS requests. */
   int AssumeReachable; /**&lt; Whether to publish our descriptor regardless. */
Index: src/or/connection.c
===================================================================
--- src/or/connection.c	(revision 10487)
+++ src/or/connection.c	(working copy)
@@ -54,6 +54,7 @@
     case CONN_TYPE_DIR: return "Directory";
     case CONN_TYPE_CPUWORKER: return "CPU worker";
     case CONN_TYPE_CONTROL_LISTENER: return "Control listener";
+    case CONN_TYPE_CONTROL_UDS_LISTENER: return "Control unix-socket listener";
     case CONN_TYPE_CONTROL: return "Control";
     default:
       log_warn(LD_BUG, "unknown connection type %d", type);
@@ -78,6 +79,7 @@
     case CONN_TYPE_AP_DNS_LISTENER:
     case CONN_TYPE_DIR_LISTENER:
     case CONN_TYPE_CONTROL_LISTENER:
+    case CONN_TYPE_CONTROL_UDS_LISTENER:
       if (state == LISTENER_STATE_READY)
         return "ready";
       break;
@@ -295,6 +297,13 @@
     buf_free(conn-&gt;outbuf);
   }
 
+  if (conn-&gt;type == CONN_TYPE_CONTROL_UDS_LISTENER) {
+    if (unlink(conn-&gt;address) &lt; 0 &amp;&amp; errno != ENOENT) {
+      log_warn(LD_NET, "Could not unlink %s: %s", conn-&gt;address,
+                       strerror(errno));
+    }
+  }
+
   tor_free(conn-&gt;address);
 
   if (connection_speaks_cells(conn)) {
@@ -343,6 +352,7 @@
     connection_or_remove_from_identity_map(TO_OR_CONN(conn));
   }
 
+
   memset(conn, 0xAA, sizeof(connection_t)); /* poison memory */
   tor_free(mem);
 }
@@ -632,33 +642,13 @@
 connection_create_listener(const char *listenaddress, uint16_t listenport,
                            int type)
 {
-  struct sockaddr_in listenaddr; /* where to bind */
   char *address = NULL;
   connection_t *conn;
   uint16_t usePort;
-  uint32_t addr;
   int s; /* the socket we're going to make */
-#ifndef MS_WINDOWS
-  int one=1;
-#endif
-  int is_tcp = (type != CONN_TYPE_AP_DNS_LISTENER);
+  int is_inet = (type != CONN_TYPE_CONTROL_UDS_LISTENER);
+  int is_tcp = (is_inet &amp;&amp; type != CONN_TYPE_AP_DNS_LISTENER);
 
-  memset(&amp;listenaddr,0,sizeof(struct sockaddr_in));
-  if (parse_addr_port(LOG_WARN, listenaddress, &amp;address, &amp;addr, &amp;usePort)&lt;0) {
-    log_warn(LD_CONFIG,
-             "Error parsing/resolving ListenAddress %s", listenaddress);
-    return NULL;
-  }
-
-  if (usePort==0)
-    usePort = listenport;
-  listenaddr.sin_addr.s_addr = htonl(addr);
-  listenaddr.sin_family = AF_INET;
-  listenaddr.sin_port = htons((uint16_t) usePort);
-
-  log_notice(LD_NET, "Opening %s on %s:%d",
-             conn_type_to_string(type), address, usePort);
-
   if (get_n_open_sockets() &gt;= get_options()-&gt;_ConnLimit-1) {
     int n_conns = get_n_open_sockets();
     log_warn(LD_NET,"Failing because we have %d connections already. Please "
@@ -668,40 +658,104 @@
     return NULL;
   }
 
-  s = tor_open_socket(PF_INET,
-                      is_tcp ? SOCK_STREAM : SOCK_DGRAM,
-                      is_tcp ? IPPROTO_TCP: IPPROTO_UDP);
-  if (s &lt; 0) {
-    log_warn(LD_NET,"Socket creation failed.");
-    goto err;
-  }
 
+
+  if (is_inet) {
+    struct sockaddr_in listenaddr; /* where to bind */
+    uint32_t addr;
 #ifndef MS_WINDOWS
-  /* REUSEADDR on normal places means you can rebind to the port
-   * right after somebody else has let it go. But REUSEADDR on win32
-   * means you can bind to the port _even when somebody else
-   * already has it bound_. So, don't do that on Win32. */
-  setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (void*) &amp;one, sizeof(one));
+    int one=1;
 #endif
 
-  if (bind(s,(struct sockaddr *)&amp;listenaddr,sizeof(listenaddr)) &lt; 0) {
-    const char *helpfulhint = "";
-    int e = tor_socket_errno(s);
-    if (ERRNO_IS_EADDRINUSE(e))
-      helpfulhint = ". Is Tor already running?";
-    log_warn(LD_NET, "Could not bind to %s:%u: %s%s", address, usePort,
-             tor_socket_strerror(e), helpfulhint);
-    tor_close_socket(s);
-    goto err;
-  }
+    memset(&amp;listenaddr,0,sizeof(struct sockaddr_in));
+    if (parse_addr_port(LOG_WARN, listenaddress, &amp;address, &amp;addr, &amp;usePort)&lt;0) {
+      log_warn(LD_CONFIG,
+	       "Error parsing/resolving ListenAddress %s", listenaddress);
+      return NULL;
+    }
 
-  if (is_tcp) {
+    if (usePort==0)
+      usePort = listenport;
+    listenaddr.sin_addr.s_addr = htonl(addr);
+    listenaddr.sin_family = AF_INET;
+    listenaddr.sin_port = htons((uint16_t) usePort);
+
+    log_notice(LD_NET, "Opening %s on %s:%d",
+	       conn_type_to_string(type), address, usePort);
+
+    s = tor_open_socket(PF_INET,
+			is_tcp ? SOCK_STREAM : SOCK_DGRAM,
+			is_tcp ? IPPROTO_TCP: IPPROTO_UDP);
+    if (s &lt; 0) {
+      log_warn(LD_NET,"Socket creation failed.");
+      goto err;
+    }
+
+#ifndef MS_WINDOWS
+    /* REUSEADDR on normal places means you can rebind to the port
+     * right after somebody else has let it go. But REUSEADDR on win32
+     * means you can bind to the port _even when somebody else
+     * already has it bound_. So, don't do that on Win32. */
+    setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (void*) &amp;one, sizeof(one));
+#endif
+
+    if (bind(s,(struct sockaddr *)&amp;listenaddr,sizeof(listenaddr)) &lt; 0) {
+      const char *helpfulhint = "";
+      int e = tor_socket_errno(s);
+      if (ERRNO_IS_EADDRINUSE(e))
+	helpfulhint = ". Is Tor already running?";
+      log_warn(LD_NET, "Could not bind to %s:%u: %s%s", address, usePort,
+	       tor_socket_strerror(e), helpfulhint);
+      tor_close_socket(s);
+      goto err;
+    }
+
+    if (is_tcp) {
+      if (listen(s,SOMAXCONN) &lt; 0) {
+	log_warn(LD_NET, "Could not listen on %s:%u: %s", address, usePort,
+		 tor_socket_strerror(tor_socket_errno(s)));
+	tor_close_socket(s);
+	goto err;
+      }
+    }
+  } else {
+#ifdef HAVE_SYS_UN_H
+    struct sockaddr_un sockaddr;
+    sockaddr.sun_family = AF_UNIX;
+    int len;
+    address = tor_strdup(listenaddress);
+
+    log_notice(LD_NET, "Opening %s on %s",
+	       conn_type_to_string(type), address);
+
+    strncpy(sockaddr.sun_path, address, sizeof(sockaddr.sun_path));
+    if (unlink(sockaddr.sun_path) &lt; 0 &amp;&amp; errno != ENOENT) {
+      log_warn(LD_NET, "Could not unlink %s: %s", address,
+                       strerror(errno));
+      goto err;
+    }
+    s = tor_open_socket(AF_UNIX, SOCK_STREAM, 0);
+    if (s &lt; 0) {
+      log_warn(LD_NET,"Socket creation failed: %s.", strerror(errno));
+      goto err;
+    }
+
+    len = strlen(sockaddr.sun_path) + sizeof(sockaddr.sun_family);
+    if (bind(s, (struct sockaddr *)&amp;sockaddr, len) == -1) {
+      log_warn(LD_NET,"Bind to %s failed: %s.", address,
+               tor_socket_strerror(tor_socket_errno(s)));
+      goto err;
+    }
+
     if (listen(s,SOMAXCONN) &lt; 0) {
-      log_warn(LD_NET, "Could not listen on %s:%u: %s", address, usePort,
-               tor_socket_strerror(tor_socket_errno(s)));
+      log_warn(LD_NET, "Could not listen on %s: %s", address,
+	       tor_socket_strerror(tor_socket_errno(s)));
       tor_close_socket(s);
       goto err;
     }
+#else
+    assert(0);
+#endif /* HAVE_SYS_UN_H */
   }
 
   set_socket_nonblocking(s);
@@ -722,7 +776,7 @@
             conn_type_to_string(type), usePort);
 
   conn-&gt;state = LISTENER_STATE_READY;
-  if (is_tcp) {
+  if (is_tcp || !is_inet) {
     connection_start_reading(conn);
   } else {
     tor_assert(type == CONN_TYPE_AP_DNS_LISTENER);
@@ -801,56 +855,73 @@
 
   set_socket_nonblocking(news);
 
-  if (check_sockaddr_in((struct sockaddr*)addrbuf, remotelen, LOG_INFO)&lt;0) {
-    log_info(LD_NET,
-             "accept() returned a strange address; trying getsockname().");
-    remotelen=256;
-    memset(addrbuf, 0, sizeof(addrbuf));
-    if (getsockname(news, (struct sockaddr*)addrbuf, &amp;remotelen)&lt;0) {
-      int e = tor_socket_errno(news);
-      log_warn(LD_NET, "getsockname() for new connection failed: %s",
-               tor_socket_strerror(e));
-    } else {
-      if (check_sockaddr_in((struct sockaddr*)addrbuf, remotelen,
-                            LOG_WARN) &lt; 0) {
-        log_warn(LD_NET,"Something's wrong with this conn. Closing it.");
-        tor_close_socket(news);
-        return 0;
+  if (((struct sockaddr*)addrbuf)-&gt;sa_family == AF_INET) {
+    assert(conn-&gt;type != CONN_TYPE_CONTROL_UDS_LISTENER);
+
+    if (check_sockaddr_in((struct sockaddr*)addrbuf, remotelen, LOG_INFO)&lt;0) {
+      log_info(LD_NET,
+	       "accept() returned a strange address; trying getsockname().");
+      remotelen=256;
+      memset(addrbuf, 0, sizeof(addrbuf));
+      if (getsockname(news, (struct sockaddr*)addrbuf, &amp;remotelen)&lt;0) {
+	int e = tor_socket_errno(news);
+	log_warn(LD_NET, "getsockname() for new connection failed: %s",
+		 tor_socket_strerror(e));
+      } else {
+	if (check_sockaddr_in((struct sockaddr*)addrbuf, remotelen,
+			      LOG_WARN) &lt; 0) {
+	  log_warn(LD_NET,"Something's wrong with this conn. Closing it.");
+	  tor_close_socket(news);
+	  return 0;
+	}
       }
     }
-  }
-  memcpy(&amp;remote, addrbuf, sizeof(struct sockaddr_in));
+    memcpy(&amp;remote, addrbuf, sizeof(struct sockaddr_in));
 
-  /* process entrance policies here, before we even create the connection */
-  if (new_type == CONN_TYPE_AP) {
-    /* check sockspolicy to see if we should accept it */
-    if (socks_policy_permits_address(ntohl(remote.sin_addr.s_addr)) == 0) {
-      tor_inet_ntoa(&amp;remote.sin_addr, tmpbuf, sizeof(tmpbuf));
-      log_notice(LD_APP,"Denying socks connection from untrusted address %s.",
-                 tmpbuf);
-      tor_close_socket(news);
-      return 0;
+    /* process entrance policies here, before we even create the connection */
+    if (new_type == CONN_TYPE_AP) {
+      /* check sockspolicy to see if we should accept it */
+      if (socks_policy_permits_address(ntohl(remote.sin_addr.s_addr)) == 0) {
+	tor_inet_ntoa(&amp;remote.sin_addr, tmpbuf, sizeof(tmpbuf));
+	log_notice(LD_APP,"Denying socks connection from untrusted address %s.",
+		   tmpbuf);
+	tor_close_socket(news);
+	return 0;
+      }
     }
-  }
-  if (new_type == CONN_TYPE_DIR) {
-    /* check dirpolicy to see if we should accept it */
-    if (dir_policy_permits_address(ntohl(remote.sin_addr.s_addr)) == 0) {
-      tor_inet_ntoa(&amp;remote.sin_addr, tmpbuf, sizeof(tmpbuf));
-      log_notice(LD_DIRSERV,"Denying dir connection from address %s.",
-                 tmpbuf);
-      tor_close_socket(news);
-      return 0;
+    if (new_type == CONN_TYPE_DIR) {
+      /* check dirpolicy to see if we should accept it */
+      if (dir_policy_permits_address(ntohl(remote.sin_addr.s_addr)) == 0) {
+	tor_inet_ntoa(&amp;remote.sin_addr, tmpbuf, sizeof(tmpbuf));
+	log_notice(LD_DIRSERV,"Denying dir connection from address %s.",
+		   tmpbuf);
+	tor_close_socket(news);
+	return 0;
+      }
     }
-  }
 
-  newconn = connection_new(new_type);
-  newconn-&gt;s = news;
+    newconn = connection_new(new_type);
+    newconn-&gt;s = news;
 
-  /* remember the remote address */
-  newconn-&gt;addr = ntohl(remote.sin_addr.s_addr);
-  newconn-&gt;port = ntohs(remote.sin_port);
-  newconn-&gt;address = tor_dup_addr(newconn-&gt;addr);
+    /* remember the remote address */
+    newconn-&gt;addr = ntohl(remote.sin_addr.s_addr);
+    newconn-&gt;port = ntohs(remote.sin_port);
+    newconn-&gt;address = tor_dup_addr(newconn-&gt;addr);
 
+  } else if (((struct sockaddr*)addrbuf)-&gt;sa_family == AF_UNIX) {
+    assert(conn-&gt;type == CONN_TYPE_CONTROL_UDS_LISTENER);
+
+    newconn = connection_new(new_type);
+    newconn-&gt;s = news;
+
+    /* remember the remote address  --  do we have anything sane to put here? */
+    newconn-&gt;addr = 0;
+    newconn-&gt;port = 1;
+    newconn-&gt;address = tor_strdup(conn-&gt;address);
+  } else {
+    assert(0);
+  };
+
   if (connection_add(newconn) &lt; 0) { /* no space, forget it */
     connection_free(newconn);
     return 0; /* no need to tear down the parent */
@@ -1042,18 +1113,25 @@
     line = NULL;
     SMARTLIST_FOREACH(launch, config_line_t *, wanted,
       {
-        char *address=NULL;
-        uint16_t port;
-        if (!parse_addr_port(LOG_WARN, wanted-&gt;value, &amp;address, NULL, &amp;port)) {
-          int addr_matches = !strcasecmp(address, conn-&gt;address);
-          tor_free(address);
-          if (! port)
-            port = port_option;
-          if (port == conn-&gt;port &amp;&amp; addr_matches) {
-            line = wanted;
-            break;
-          }
-        }
+	if (type == CONN_TYPE_CONTROL_UDS_LISTENER) {
+	  if (!strcasecmp(wanted-&gt;value, conn-&gt;address)) {
+	    line = wanted;
+	    break;
+	  }
+	} else {
+	  char *address=NULL;
+	  uint16_t port;
+	  if (!parse_addr_port(LOG_WARN, wanted-&gt;value, &amp;address, NULL, &amp;port)) {
+	    int addr_matches = !strcasecmp(address, conn-&gt;address);
+	    tor_free(address);
+	    if (! port)
+	      port = port_option;
+	    if (port == conn-&gt;port &amp;&amp; addr_matches) {
+	      line = wanted;
+	      break;
+	    }
+	  }
+	}
       });
     if (! line) {
       /* This one isn't configured. Close it. */
@@ -1142,6 +1220,11 @@
                       options-&gt;ControlPort, "127.0.0.1",
                       replaced_conns, new_conns, 0)&lt;0)
     return -1;
+  if (retry_listeners(CONN_TYPE_CONTROL_UDS_LISTENER,
+                      options-&gt;ControlSocket,
+                      options-&gt;ControlSocket ? 1 : 0, NULL,
+                      replaced_conns, new_conns, 0)&lt;0)
+    return -1;
 
   return 0;
 }
@@ -1546,6 +1629,7 @@
     case CONN_TYPE_DIR_LISTENER:
       return connection_handle_listener_read(conn, CONN_TYPE_DIR);
     case CONN_TYPE_CONTROL_LISTENER:
+    case CONN_TYPE_CONTROL_UDS_LISTENER:
       return connection_handle_listener_read(conn, CONN_TYPE_CONTROL);
     case CONN_TYPE_AP_DNS_LISTENER:
       /* This should never happen; eventdns.c handles the reads here. */
@@ -2631,6 +2715,7 @@
     case CONN_TYPE_AP_NATD_LISTENER:
     case CONN_TYPE_DIR_LISTENER:
     case CONN_TYPE_CONTROL_LISTENER:
+    case CONN_TYPE_CONTROL_UDS_LISTENER:
     case CONN_TYPE_AP_DNS_LISTENER:
       tor_assert(conn-&gt;state == LISTENER_STATE_READY);
       break;



</body></email><email><emailId>20070703143521</emailId><senderName>Carsten_Krger</senderName><senderEmail>c.krueger@gmx.org</senderEmail><timestampReceived>2007-07-03 14:35:21-0400</timestampReceived><subject>Choose exitnodes in country x</subject><body>

Hello,

it would be nice to have the ability to choose only exitnodes in
country X.
Additional to "ExitNodes nickname, ..." something like this "ExitCountry country, ..."
would be nice.
country should be the official TLD code I think
http://www.iana.org/root-whois/index.html

There is more and more censorship at websites that only allows
visitors from specific countries or show different content.

greetings
Carsten


</body></email><email><emailId>20070809204331</emailId><senderName>"vikingserver () gmail ! com"</senderName><senderEmail>vikingserver@gmail.com</senderEmail><timestampReceived>2007-08-09 20:43:31-0400</timestampReceived><subject>bug in uninstaller</subject><body>

Dear programmers,

I recently uninstalled the tor bundle, in order to install the new tor0204.
Normally i just install the bundle on top of the previous installation,
but this time I did like you normally should when you have upgraded a
program for more than 30 times and the default folder has changed...
I uninstalled, and whoops suddenly my torrc, fingerprint, secret key and
all disappeared!

Please urgently change the uninstaller so that it leaves the settings!!!

This must be a pain in the ass for people running hidden services and/or
running servers. (Sorry for the language.)

If you want the option to remove all settings, you could leave the user
a choice. Please fix this. Maybe you also should announce it on the
or-talk or announce list. As you have changed the default folder, others
might uninstall first and then get their keys, fingerprint and torrc
wiped out, the same way I did.

/Viking server admin
</body></email><email><emailId>20070905165837</emailId><senderName>"Michael_google gmail_Gersten"</senderName><senderEmail>keybounce@gmail.com</senderEmail><timestampReceived>2007-09-05 16:58:37-0400</timestampReceived><subject>Question on router to router communication</subject><body>

I've noticed that my tor configured as a client will only have one
outgoing TCP connection to an entry node, no matter how many circuits
Vidalia shows as going to that entry guard.

I'm assuming that this continues on other router to router channels --
if there are three circuits that go from (for example) desync to
Tonga, there will only be one TCP connection.

Is this necessary from a security standpoint? Tor can be sped up if
that "one channel per pair" restriction can be broken.

(Just like IP itself. A layer two connection between two nodes has (I
forget exactly) 8 channels, each of which can only have one
outstanding packet. Allowing Tor to have multiple channels between two
nodes will prevent a single stopped TCP from stopping all traffic
going that way.)
</body></email><email><emailId>20071001201830</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-10-01 20:18:30-0400</timestampReceived><subject>Re: Turning off a server</subject><body>


On Sat, Sep 29, 2007 at 02:02:09PM +0100, Robert Hogan wrote:
&gt; AFAICS there's no way of turning off a server immediately, without actually 
&gt; killing the tor process.
&gt; 
&gt; What I mean by this is some controller command(s) that:
&gt; 
&gt; - Closes all the server's ORCONNs immediately
&gt; - Sends a suicide descriptor to the authdirs.
&gt; 
&gt; The use-case is the general user who runs a relay most of the time but 
&gt; occasionally wants to toggle it off without disripting general use.

I'd rather that users who want to stop being a server _not_ kill all
ORCONNs immediately: doing so kills all the active connections for
every user who's touching that server.

Instead, I'd prefer that all circuits through that server die
naturally as clients time them out over the next 10-30 minutes, and
that the server stop accepting new circuits.  Does not that work in
practice?  If it doesn't work (because circuits stay open
indefinitely), I think the answer is to give existing circuits 5-10
minutes or so finish up.

yrs,
-- 
Nick Mathewson

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20071106224113</emailId><senderName>Steven Murdoch</senderName><senderEmail>tor+steven.murdoch@cl.cam.ac.uk</senderEmail><timestampReceived>2007-11-06 22:41:13-0400</timestampReceived><subject>Proposal for revised TLS handshake</subject><body>


As some of you may know, there is a plan to make Tor clients more
resistant to being blocked [1]. The first parts of this are already
implemented, and the next step is to make the Tor traffic look more
like HTTPS, so it is hard to block one without blocking the other.

I've been working on a proposal for a new TLS handshake, which is
closer to a HTTP connection than before. Unfortunately we have had to
throw away some nice features of TLS, which Tor needs but HTTPS
doesn't use. So part of the handshake, in particular the client
authentication, has been converted to a custom protcol, inside the
encrypted tunnel.

The draft proposal of the protocol and other issues can be found at:

 http://www.cl.cam.ac.uk/~sjm217/volatile/xxx-tls-certificates.txt

This is in the process of being implemented, so if you have any
comments or suggestions, please do let me know.

Thanks,
Steven.

[1] http://www.torproject.org/svn/trunk/doc/design-paper/blocking.pdf

--=20
w: http://www.cl.cam.ac.uk/users/sjm217/

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20071203225129</emailId><senderName>Marcus Wolschon</senderName><senderEmail>marcus@wolschon.biz</senderEmail><timestampReceived>2007-12-03 22:51:29-0400</timestampReceived><subject>Tor Ipv6-Patch</subject><body>

This is a MIME-formatted message.  If you see this text it means that your
E-mail software does not support MIME-formatted messages.

[Attachment #2 (multipart/mixed)]


Dear list,

I wrote an extensive patch to make tor support
* hidden services on ipv6-addresses
* binding for socks on an ipv6-address
* convert a lot of the internal data-structures for the comming full
ipv6-support.

I wrote it to tor-volunteers@torproject.org on friday but got no
answer thus I am posting them here.

The code may not use the prefered naming-conventions or the
tor_address_t -data-structure (because that one uses socket_addr
and we only need the actual address-part) but I guess a refactoring
for it to meet the coding-guidelines is far less work then writing it
and getting it to work in the first place.

Marcus Wolschon

["2007-12-03-V3_marcus_ipv6_hidden_services_diff_to_tor.diff" (text/x-patch)]

Index: or/circuitlist.c
===================================================================
--- or/circuitlist.c	(Revision 12621)
+++ or/circuitlist.c	(Arbeitskopie)
@@ -216,6 +216,11 @@
     global_circuitlist = circ;
   }
 }
+/** compare the 2 given ipv6-addresses
+ *
+ *  * returns 0 if they are equal.
+ *   */
+int compare_in6_addr(struct in6_addr a, struct in6_addr b);
 
 /** Append to &lt;b&gt;out&lt;/b&gt; all circuits in state OR_WAIT waiting for
  * the given connection. */
@@ -235,7 +240,9 @@
     tor_assert(circ-&gt;state == CIRCUIT_STATE_OR_WAIT);
     if (tor_digest_is_zero(circ-&gt;n_conn_id_digest)) {
       /* Look at addr/port. This is an unkeyed connection. */
-      if (circ-&gt;n_addr != or_conn-&gt;_base.addr ||
+      if (circ-&gt;n_family != or_conn-&gt;_base.socket_family ||
+          (circ-&gt;n_family == AF_INET &amp;&amp; circ-&gt;n_addr4 != or_conn-&gt;_base.addr4) ||
+          (circ-&gt;n_family == AF_INET6 &amp;&amp; compare_in6_addr(circ-&gt;n_addr6, \
or_conn-&gt;_base.addr6) != 0) ||  circ-&gt;n_port != or_conn-&gt;_base.port)
         continue;
     } else {
@@ -558,8 +565,10 @@
         }
       }
     }
-    if (!circ-&gt;n_conn &amp;&amp; circ-&gt;n_addr &amp;&amp; circ-&gt;n_port &amp;&amp;
-        circ-&gt;n_addr == conn-&gt;addr &amp;&amp;
+    if (!circ-&gt;n_conn &amp;&amp; (circ-&gt;n_family != AF_INET || circ-&gt;n_addr4) &amp;&amp; \
circ-&gt;n_port &amp;&amp; +        circ-&gt;n_family == conn-&gt;socket_family &amp;&amp;
+        (circ-&gt;n_family != AF_INET || circ-&gt;n_addr4 == conn-&gt;addr4)&amp;&amp;
+        (circ-&gt;n_family != AF_INET6 || compare_in6_addr(circ-&gt;n_addr6, conn-&gt;addr6) \
== 0)&amp;&amp;  circ-&gt;n_port == conn-&gt;port &amp;&amp;
         conn-&gt;type == CONN_TYPE_OR &amp;&amp;
         !memcmp(TO_OR_CONN(conn)-&gt;identity_digest, circ-&gt;n_conn_id_digest,
Index: or/connection_or.c
===================================================================
--- or/connection_or.c	(Revision 12621)
+++ or/connection_or.c	(Arbeitskopie)
@@ -336,14 +336,20 @@
 
   if (get_options()-&gt;HttpsProxy) {
     char buf[1024];
-    char addrbuf[INET_NTOA_BUF_LEN];
-    struct in_addr in;
+    char addrbuf[64];
     char *base64_authenticator=NULL;
     const char *authenticator = get_options()-&gt;HttpsProxyAuthenticator;
+    
+    if (conn-&gt;socket_family == AF_INET6) {
+      struct in6_addr addr;
+      addr = conn-&gt;addr6;
+      tor_inet_ntop(AF_INET6, &amp;addr, addrbuf, sizeof(addrbuf));
+    } else {
+      struct in_addr in;
+      in.s_addr = htonl(conn-&gt;addr4);
+      tor_inet_ntoa(&amp;in, addrbuf, sizeof(addrbuf));
+    }
 
-    in.s_addr = htonl(conn-&gt;addr);
-    tor_inet_ntoa(&amp;in, addrbuf, sizeof(addrbuf));
-
     if (authenticator) {
       base64_authenticator = alloc_http_authenticator(authenticator);
       if (!base64_authenticator)
@@ -375,6 +381,58 @@
  * have an addr/port/id_digest, then fill in as much as we can. Start
  * by checking to see if this describes a router we know. */
 static void
+connection_or_init_conn_from_address6(or_connection_t *conn,
+                                     struct in6_addr addr6, uint16_t port,
+                                     const char *id_digest,
+                                     int started_here)
+{
+  or_options_t *options = get_options();
+  routerinfo_t *r = router_get_by_digest(id_digest);
+  conn-&gt;bandwidthrate = (int)options-&gt;BandwidthRate;
+  conn-&gt;read_bucket = conn-&gt;bandwidthburst = (int)options-&gt;BandwidthBurst;
+  connection_or_set_identity_digest(conn, id_digest);
+  conn-&gt;_base.socket_family = AF_INET6;
+  conn-&gt;_base.addr6 = addr6;
+  conn-&gt;_base.port = port;
+  conn-&gt;real_socket_family = AF_INET6;
+  conn-&gt;real_addr6 = addr6;
+  if (r) {
+    if (conn-&gt;_base.addr4 == r-&gt;addr)
+      conn-&gt;is_canonical = 1;
+    if (!started_here) {
+      /* Override the addr/port, so our log messages will make sense.
+       * This is dangerous, since if we ever try looking up a conn by
+       * its actual addr/port, we won't remember. Careful! */
+      /* XXXX020 this is stupid, and it's the reason we need real_addr to
+       * track is_canonical properly. */
+      conn-&gt;_base.socket_family = AF_INET;
+      conn-&gt;_base.addr4 = r-&gt;addr;
+      conn-&gt;_base.port = r-&gt;or_port;
+    }
+    conn-&gt;nickname = tor_strdup(r-&gt;nickname);
+    tor_free(conn-&gt;_base.address);
+    conn-&gt;_base.address = tor_strdup(r-&gt;address);
+  } else {
+    const char *n;
+    /* If we're an authoritative directory server, we may know a
+     * nickname for this router. */
+    n = dirserv_get_nickname_by_digest(id_digest);
+    if (n) {
+      conn-&gt;nickname = tor_strdup(n);
+    } else {
+      conn-&gt;nickname = tor_malloc(HEX_DIGEST_LEN+2);
+      conn-&gt;nickname[0] = '$';
+      base16_encode(conn-&gt;nickname+1, HEX_DIGEST_LEN+1,
+                    conn-&gt;identity_digest, DIGEST_LEN);
+    }
+    tor_free(conn-&gt;_base.address);
+    conn-&gt;_base.address = tor_dup_addr6(addr6);
+  }
+}
+/** If we don't necessarily know the router we're connecting to, but we
+ * have an addr/port/id_digest, then fill in as much as we can. Start
+ * by checking to see if this describes a router we know. */
+static void
 connection_or_init_conn_from_address(or_connection_t *conn,
                                      uint32_t addr, uint16_t port,
                                      const char *id_digest,
@@ -385,11 +443,13 @@
   conn-&gt;bandwidthrate = (int)options-&gt;BandwidthRate;
   conn-&gt;read_bucket = conn-&gt;bandwidthburst = (int)options-&gt;BandwidthBurst;
   connection_or_set_identity_digest(conn, id_digest);
-  conn-&gt;_base.addr = addr;
+  conn-&gt;_base.socket_family = AF_INET;
+  conn-&gt;_base.addr4 = addr;
   conn-&gt;_base.port = port;
-  conn-&gt;real_addr = addr;
+  conn-&gt;real_socket_family = AF_INET;
+  conn-&gt;real_addr4 = addr;
   if (r) {
-    if (conn-&gt;_base.addr == r-&gt;addr)
+    if (conn-&gt;_base.addr4 == r-&gt;addr)
       conn-&gt;is_canonical = 1;
     if (!started_here) {
       /* Override the addr/port, so our log messages will make sense.
@@ -397,7 +457,8 @@
        * its actual addr/port, we won't remember. Careful! */
       /* XXXX020 this is stupid, and it's the reason we need real_addr to
        * track is_canonical properly. */
-      conn-&gt;_base.addr = r-&gt;addr;
+      conn-&gt;_base.socket_family = AF_INET;
+      conn-&gt;_base.addr4 = r-&gt;addr;
       conn-&gt;_base.port = r-&gt;or_port;
     }
     conn-&gt;nickname = tor_strdup(r-&gt;nickname);
@@ -775,8 +836,13 @@
                                   conn-&gt;handshake_state-&gt;started_here,
                                               id_digest) &lt; 0)
     return -1;
-  connection_or_init_conn_from_address(conn, conn-&gt;_base.addr,
-                                       conn-&gt;_base.port, id_digest, 0);
+  if (conn-&gt;_base.socket_family == AF_INET6) {
+    connection_or_init_conn_from_address6(conn, conn-&gt;_base.addr6,
+                                         conn-&gt;_base.port, id_digest, 0);
+  } else {
+    connection_or_init_conn_from_address(conn, conn-&gt;_base.addr4,
+                                         conn-&gt;_base.port, id_digest, 0);
+  }
   if (connection_or_act_on_netinfo(conn)&lt;0)
     return -1;
   return connection_or_set_state_open(conn);
@@ -809,8 +875,13 @@
                                                 digest_rcvd) &lt; 0)
       return -1;
     if (!started_here) {
-      connection_or_init_conn_from_address(conn,conn-&gt;_base.addr,
-                                           conn-&gt;_base.port, digest_rcvd, 0);
+      if (!conn-&gt;_base.socket_family == AF_INET6) {
+        connection_or_init_conn_from_address6(conn,conn-&gt;_base.addr6,
+                                             conn-&gt;_base.port, digest_rcvd, 0);
+      } else {
+        connection_or_init_conn_from_address(conn,conn-&gt;_base.addr4,
+                                             conn-&gt;_base.port, digest_rcvd, 0);
+      }
     }
     return connection_or_set_state_open(conn);
   } else {
@@ -1040,7 +1111,11 @@
   set_uint32(cell.payload, htonl(now));
   cell.payload[4] = RESOLVED_TYPE_IPV4;
   cell.payload[5] = 4;
-  set_uint32(cell.payload+6, htonl(conn-&gt;_base.addr));
+  if (conn-&gt;_base.socket_family == AF_INET6) {
+    log_warn(LD_BUG, "we do not support ipv6 in connection_or_send_netinfo() ");
+    return -1;
+  }
+  set_uint32(cell.payload+6, htonl(conn-&gt;_base.addr4));
 
   /* My address. */
   if ((me = router_get_my_routerinfo())) {
Index: or/rendservice.c
===================================================================
--- or/rendservice.c	(Revision 12621)
+++ or/rendservice.c	(Arbeitskopie)
@@ -20,7 +20,9 @@
 typedef struct rend_service_port_config_t {
   uint16_t virtual_port;
   uint16_t real_port;
-  uint32_t real_addr;
+  u_int16_t real_family;      // AF_INET or AF_INET6
+  uint32_t real_addr4;        // ipv4-address of hidden service depending on \
real_family +  struct in6_addr real_addr6; // ipv6-address of hidden service \
depending on real_family  } rend_service_port_config_t;
 
 /** Try to maintain this many intro points per service if possible. */
@@ -129,7 +131,6 @@
 {
   int i;
   rend_service_port_config_t *p;
-  struct in_addr addr;
 
   if (!service-&gt;intro_prefer_nodes)
     service-&gt;intro_prefer_nodes = tor_strdup("");
@@ -166,15 +167,25 @@
   } else {
     smartlist_set_capacity(service-&gt;ports, -1);
     smartlist_add(rend_service_list, service);
-    log_debug(LD_REND,"Configuring service with directory \"%s\"",
+    log_debug(LD_REND,"Configuring hidden service with directory \"%s\"",
               service-&gt;directory);
     for (i = 0; i &lt; smartlist_len(service-&gt;ports); ++i) {
-      char addrbuf[INET_NTOA_BUF_LEN];
       p = smartlist_get(service-&gt;ports, i);
-      addr.s_addr = htonl(p-&gt;real_addr);
-      tor_inet_ntoa(&amp;addr, addrbuf, sizeof(addrbuf));
-      log_debug(LD_REND,"Service maps port %d to %s:%d",
-                p-&gt;virtual_port, addrbuf, p-&gt;real_port);
+      if (p-&gt;real_family == AF_INET6) {
+         char addrbuf[42];
+         struct in6_addr addr;
+         addr = p-&gt;real_addr6;
+	 tor_inet_ntop(AF_INET6, &amp;addr, addrbuf, sizeof(addrbuf));
+         log_debug(LD_REND,"Hidden service maps ipv6 port %d to [%s]:%d",
+                   p-&gt;virtual_port, addrbuf, p-&gt;real_port);
+      } else {
+         char addrbuf[INET_NTOA_BUF_LEN];
+         struct in_addr addr;
+         addr.s_addr = htonl(p-&gt;real_addr4);
+         tor_inet_ntoa(&amp;addr, addrbuf, sizeof(addrbuf));
+         log_debug(LD_REND,"Hidden service maps ipv4 port %d to %s:%d",
+                   p-&gt;virtual_port, addrbuf, p-&gt;real_port);
+      }
     }
   }
 }
@@ -193,7 +204,6 @@
   int virtport;
   int realport;
   uint16_t p;
-  uint32_t addr;
   const char *addrport;
   rend_service_port_config_t *result = NULL;
 
@@ -212,32 +222,60 @@
     goto err;
   }
 
+  result = tor_malloc(sizeof(rend_service_port_config_t));
+  result-&gt;virtual_port = virtport;
+
   if (smartlist_len(sl) == 1) {
     /* No addr:port part; use default. */
-    realport = virtport;
-    addr = 0x7F000001u; /* 127.0.0.1 */
+    result-&gt;real_family = AF_INET;
+    result-&gt;real_port = virtport;
+    result-&gt;real_addr4 = 0x7F000001u; /* 127.0.0.1 */
+    log_warn(LD_CONFIG,"no address nor port in hidden service port "
+                 "configuration-&gt;localhost.");
   } else {
     addrport = smartlist_get(sl,1);
     if (strchr(addrport, ':') || strchr(addrport, '.')) {
-      if (parse_addr_port(LOG_WARN, addrport, NULL, &amp;addr, &amp;p)&lt;0) {
-        log_warn(LD_CONFIG,"Unparseable address in hidden service port "
+      uint32_t addr4;
+      if (parse_addr_port(LOG_WARN, addrport, NULL, &amp;addr4, &amp;p)&lt;0) {
+        struct in6_addr addr6;
+        if (parse_addr6_port(LOG_WARN, addrport, NULL, &amp;addr6, &amp;p)&lt;0) {
+           log_warn(LD_CONFIG,"Unparseable address in hidden service port "
                  "configuration.");
-        goto err;
+           goto err;
+	} else {
+         // ipv6-address could be parsed
+         result-&gt;real_family = AF_INET6;
+         result-&gt;real_addr6 = addr6;
+
+         char addrbuf[42];
+         struct in6_addr addr;
+         addr = result-&gt;real_addr6;
+         tor_inet_ntop(AF_INET6, &amp;addr, addrbuf, sizeof(addrbuf));
+           log_warn(LD_CONFIG,"parse_port_config() parseable ipv6-address %s in \
hidden service port " +                 "configuration.", addrbuf);
+	}
+      } else {
+         // ipv4-address could be parsed
+         result-&gt;real_family = AF_INET;
+         result-&gt;real_addr4 = addr4;
+           log_warn(LD_CONFIG,"parse_port_config() parseable ipv4-address in hidden \
service port " +                 "configuration.");
       }
       realport = p?p:virtport;
+      result-&gt;real_port = realport;
     } else {
       /* No addr:port, no addr -- must be port. */
       realport = atoi(addrport);
       if (realport &lt; 1 || realport &gt; 65535)
         goto err;
-      addr = 0x7F000001u; /* Default to 127.0.0.1 */
+      result-&gt;real_family = AF_INET;
+      result-&gt;real_port = realport;
+      result-&gt;real_addr4 = 0x7F000001u; /* 127.0.0.1 */
+           log_warn(LD_CONFIG,"no address in hidden service port "
+                 "configuration-&gt;localhost.");
     }
   }
 
-  result = tor_malloc(sizeof(rend_service_port_config_t));
-  result-&gt;virtual_port = virtport;
-  result-&gt;real_port = realport;
-  result-&gt;real_addr = addr;
  err:
   SMARTLIST_FOREACH(sl, char *, c, tor_free(c));
   smartlist_free(sl);
@@ -286,6 +324,7 @@
     if (!strcasecmp(line-&gt;key, "HiddenServicePort")) {
       portcfg = parse_port_config(line-&gt;value);
       if (!portcfg) {
+        log_warn(LD_CONFIG, "unparsable HiddenServicePort %s", line-&gt;value);
         rend_service_free(service);
         return -1;
       }
@@ -387,7 +426,7 @@
     const char *name = smartlist_get(service-&gt;intro_nodes, i);
     router = router_get_by_nickname(name, 1);
     if (!router) {
-      log_info(LD_REND,"Router '%s' not found for intro point %d. Skipping.",
+      log_info(LD_REND,"Router '%s' not found for hidden service intro point %d. \
Skipping.",  safe_str(name), i);
       continue;
     }
@@ -428,7 +467,7 @@
     if (strlcpy(fname,s-&gt;directory,sizeof(fname)) &gt;= sizeof(fname) ||
         strlcat(fname,PATH_SEPARATOR"private_key",sizeof(fname))
                                                   &gt;= sizeof(fname)) {
-      log_warn(LD_CONFIG, "Directory name too long to store key file: \"%s\".",
+      log_warn(LD_CONFIG, "Directory name too long to store key file: \"%s\" for \
hidden service.",  s-&gt;directory);
       return -1;
     }
@@ -438,17 +477,17 @@
 
     /* Create service file */
     if (rend_get_service_id(s-&gt;private_key, s-&gt;service_id)&lt;0) {
-      log_warn(LD_BUG, "Internal error: couldn't encode service ID.");
+      log_warn(LD_BUG, "Internal error: couldn't encode hidden service ID.");
       return -1;
     }
     if (crypto_pk_get_digest(s-&gt;private_key, s-&gt;pk_digest)&lt;0) {
-      log_warn(LD_BUG, "Couldn't compute hash of public key.");
+      log_warn(LD_BUG, "Couldn't compute hash of public key for hidden service.");
       return -1;
     }
     if (strlcpy(fname,s-&gt;directory,sizeof(fname)) &gt;= sizeof(fname) ||
         strlcat(fname,PATH_SEPARATOR"hostname",sizeof(fname))
                                                   &gt;= sizeof(fname)) {
-      log_warn(LD_CONFIG, "Directory name too long to store hostname file:"
+      log_warn(LD_CONFIG, "Directory name too long to store hostname file for hidden \
service:"  " \"%s\".", s-&gt;directory);
       return -1;
     }
@@ -467,9 +506,11 @@
 rend_service_get_by_pk_digest_and_version(const char* digest,
                                           uint8_t version)
 {
+  log_warn(LD_BUG, "Looking up hidden service for digest %s with version %i.", \
digest, version);  SMARTLIST_FOREACH(rend_service_list, rend_service_t*, s,
                     if (!memcmp(s-&gt;pk_digest,digest,DIGEST_LEN) &amp;&amp;
                         s-&gt;descriptor_version == version) return s);
+  log_warn(LD_BUG, "Couldn't find hidden service for digest %s with version %i.", \
digest, version);  return NULL;
 }
 
@@ -521,12 +562,12 @@
 
   base32_encode(serviceid, REND_SERVICE_ID_LEN_BASE32+1,
                 circuit-&gt;rend_pk_digest, REND_SERVICE_ID_LEN);
-  log_info(LD_REND, "Received INTRODUCE2 cell for service %s on circ %d.",
+  log_info(LD_REND, "Received INTRODUCE2 cell for hidden service %s on circ %d.",
            escaped(serviceid), circuit-&gt;_base.n_circ_id);
 
   if (circuit-&gt;_base.purpose != CIRCUIT_PURPOSE_S_INTRO) {
     log_warn(LD_PROTOCOL,
-             "Got an INTRODUCE2 over a non-introduction circuit %d.",
+             "Got an INTRODUCE2 over a non-introduction to hidden service circuit \
%d.",  circuit-&gt;_base.n_circ_id);
     return -1;
   }
@@ -534,7 +575,7 @@
   /* min key length plus digest length plus nickname length */
   if (request_len &lt; DIGEST_LEN+REND_COOKIE_LEN+(MAX_NICKNAME_LEN+1)+
       DH_KEY_LEN+42) {
-    log_warn(LD_PROTOCOL, "Got a truncated INTRODUCE2 cell on circ %d.",
+    log_warn(LD_PROTOCOL, "Got a truncated INTRODUCE2 cell on hidden service circ \
%d.",  circuit-&gt;_base.n_circ_id);
     return -1;
   }
@@ -543,7 +584,7 @@
   service = rend_service_get_by_pk_digest_and_version(
               circuit-&gt;rend_pk_digest, circuit-&gt;rend_desc_version);
   if (!service) {
-    log_warn(LD_REND, "Got an INTRODUCE2 cell for an unrecognized service %s.",
+    log_warn(LD_REND, "Got an INTRODUCE2 cell for an unrecognized hidden service \
%s.",  escaped(serviceid));
     return -1;
   }
@@ -560,7 +601,7 @@
   if (memcmp(intro_key_digest, request, DIGEST_LEN)) {
     base32_encode(serviceid, REND_SERVICE_ID_LEN_BASE32+1,
                   request, REND_SERVICE_ID_LEN);
-    log_warn(LD_REND, "Got an INTRODUCE2 cell for the wrong service (%s).",
+    log_warn(LD_REND, "Got an INTRODUCE2 cell for the wrong hidden service (%s).",
              escaped(serviceid));
     return -1;
   }
@@ -568,7 +609,7 @@
   keylen = crypto_pk_keysize(intro_key);
   if (request_len &lt; keylen+DIGEST_LEN) {
     log_warn(LD_PROTOCOL,
-             "PK-encrypted portion of INTRODUCE2 cell was truncated.");
+             "PK-encrypted portion of INTRODUCE2 hidden service cell was \
truncated.");  return -1;
   }
   /* Next N bytes is encrypted with service key */
@@ -577,7 +618,7 @@
        intro_key,buf,request+DIGEST_LEN,request_len-DIGEST_LEN,
        PK_PKCS1_OAEP_PADDING,1);
   if (r&lt;0) {
-    log_warn(LD_PROTOCOL, "Couldn't decrypt INTRODUCE2 cell.");
+    log_warn(LD_PROTOCOL, "Couldn't decrypt INTRODUCE2 hidden service cell.");
     return -1;
   }
   len = r;
@@ -585,7 +626,8 @@
     /* Version 2 INTRODUCE2 cell. */
     int klen;
     extend_info = tor_malloc_zero(sizeof(extend_info_t));
-    extend_info-&gt;addr = ntohl(get_uint32(buf+1));
+    extend_info-&gt;family = AF_INET;
+    extend_info-&gt;addr4 = ntohl(get_uint32(buf+1));
     extend_info-&gt;port = ntohs(get_uint16(buf+5));
     memcpy(extend_info-&gt;identity_digest, buf+7, DIGEST_LEN);
     extend_info-&gt;nickname[0] = '$';
@@ -594,7 +636,7 @@
 
     klen = ntohs(get_uint16(buf+7+DIGEST_LEN));
     if ((int)len != 7+DIGEST_LEN+2+klen+20+128) {
-      log_warn(LD_PROTOCOL, "Bad length %u for version 2 INTRODUCE2 cell.",
+      log_warn(LD_PROTOCOL, "Bad length %u for version 2 INTRODUCE2 hidden service \
cell.",  (int)len);
       reason = END_CIRC_REASON_TORPROTOCOL;
       goto err;
@@ -602,7 +644,7 @@
     extend_info-&gt;onion_key = crypto_pk_asn1_decode(buf+7+DIGEST_LEN+2, klen);
     if (!extend_info-&gt;onion_key) {
       log_warn(LD_PROTOCOL,
-               "Error decoding onion key in version 2 INTRODUCE2 cell.");
+               "Error decoding onion key in version 2 INTRODUCE2 hidden service \
cell.");  reason = END_CIRC_REASON_TORPROTOCOL;
       goto err;
     }
@@ -625,12 +667,12 @@
     ptr=memchr(rp_nickname,0,nickname_field_len);
     if (!ptr || ptr == rp_nickname) {
       log_warn(LD_PROTOCOL,
-               "Couldn't find a nul-padded nickname in INTRODUCE2 cell.");
+               "Couldn't find a nul-padded nickname in INTRODUCE2 hidden service \
cell.");  return -1;
     }
     if ((version == 0 &amp;&amp; !is_legal_nickname(rp_nickname)) ||
         (version == 1 &amp;&amp; !is_legal_nickname_or_hexdigest(rp_nickname))) {
-      log_warn(LD_PROTOCOL, "Bad nickname in INTRODUCE2 cell.");
+      log_warn(LD_PROTOCOL, "Bad nickname in INTRODUCE2 hidden service cell.");
       return -1;
     }
     /* Okay, now we know that a nickname is at the start of the buffer. */
@@ -640,7 +682,7 @@
                                * any */
     router = router_get_by_nickname(rp_nickname, 0);
     if (!router) {
-      log_info(LD_REND, "Couldn't find router %s named in introduce2 cell.",
+      log_info(LD_REND, "Couldn't find router %s named in introduce2 hidden service \
cell.",  escaped_safe_str(rp_nickname));
       /* XXXX Add a no-such-router reason? */
       reason = END_CIRC_REASON_TORPROTOCOL;
@@ -651,7 +693,7 @@
   }
 
   if (len != REND_COOKIE_LEN+DH_KEY_LEN) {
-    log_warn(LD_PROTOCOL, "Bad length %u for INTRODUCE2 cell.", (int)len);
+    log_warn(LD_PROTOCOL, "Bad length %u for INTRODUCE2 hidden service cell.", \
(int)len);  reason = END_CIRC_REASON_TORPROTOCOL;
     return -1;
   }
@@ -663,13 +705,13 @@
   dh = crypto_dh_new();
   if (!dh || crypto_dh_generate_public(dh)&lt;0) {
     log_warn(LD_BUG,"Internal error: couldn't build DH state "
-             "or generate public key.");
+             "or generate public key for hidden service.");
     reason = END_CIRC_REASON_INTERNAL;
     goto err;
   }
   if (crypto_dh_compute_secret(dh, ptr+REND_COOKIE_LEN, DH_KEY_LEN, keys,
                                DIGEST_LEN+CPATH_KEY_MATERIAL_LEN)&lt;0) {
-    log_warn(LD_BUG, "Internal error: couldn't complete DH handshake");
+    log_warn(LD_BUG, "Internal error: couldn't complete DH handshake for hidden \
service");  reason = END_CIRC_REASON_INTERNAL;
     goto err;
   }
@@ -691,14 +733,14 @@
   }
   if (!launched) { /* give up */
     log_warn(LD_REND, "Giving up launching first hop of circuit to rendezvous "
-             "point %s for service %s.",
+             "point %s for hidden service %s.",
              escaped_safe_str(extend_info-&gt;nickname), serviceid);
     reason = END_CIRC_REASON_CONNECTFAILED;
     goto err;
   }
   log_info(LD_REND,
            "Accepted intro; launching circuit to %s "
-           "(cookie %s) for service %s.",
+           "(cookie %s) for hidden service %s.",
            escaped_safe_str(extend_info-&gt;nickname), hexcookie, serviceid);
   tor_assert(launched-&gt;build_state);
   /* Fill in the circuit's state. */
@@ -744,7 +786,7 @@
       oldcirc-&gt;build_state-&gt;failure_count &gt; MAX_REND_FAILURES ||
       oldcirc-&gt;build_state-&gt;expiry_time &lt; time(NULL)) {
     log_info(LD_REND,
-             "Attempt to build circuit to %s for rendezvous has failed "
+             "Attempt to build circuit to hidden service %s for rendezvous has \
failed "  "too many times or expired; giving up.",
              oldcirc-&gt;build_state ?
                oldcirc-&gt;build_state-&gt;chosen_exit-&gt;nickname : "*unknown*");
@@ -755,18 +797,18 @@
   tor_assert(oldstate);
 
   if (oldstate-&gt;pending_final_cpath == NULL) {
-    log_info(LD_REND,"Skipping relaunch of circ that failed on its first hop. "
+    log_info(LD_REND,"Skipping relaunch of circ that failed on its first hop for \
hidden service. "  "Initiator will retry.");
     return;
   }
 
-  log_info(LD_REND,"Reattempting rendezvous circuit to '%s'",
+  log_info(LD_REND,"Reattempting rendezvous hidden service circuit to '%s'",
            oldstate-&gt;chosen_exit-&gt;nickname);
 
   newcirc = circuit_launch_by_extend_info(CIRCUIT_PURPOSE_S_CONNECT_REND, 0,
                                oldstate-&gt;chosen_exit, 0, 1, 1);
   if (!newcirc) {
-    log_warn(LD_REND,"Couldn't relaunch rendezvous circuit to '%s'.",
+    log_warn(LD_REND,"Couldn't relaunch rendezvous hidden service circuit to '%s'.",
              oldstate-&gt;chosen_exit-&gt;nickname);
     return;
   }
@@ -796,7 +838,7 @@
   origin_circuit_t *launched;
 
   log_info(LD_REND,
-           "Launching circuit to introduction point %s for service %s",
+           "Launching circuit to introduction point %s for hidden service %s",
            escaped_safe_str(nickname), service-&gt;service_id);
 
   rep_hist_note_used_internal(time(NULL), 1, 0);
@@ -806,7 +848,7 @@
                                         nickname, 1, 0, 1);
   if (!launched) {
     log_info(LD_REND,
-             "Can't launch circuit to establish introduction at %s.",
+             "Can't launch circuit to establish introduction for hidden service at \
%s.",  escaped_safe_str(nickname));
     return -1;
   }
@@ -849,14 +891,14 @@
   service = rend_service_get_by_pk_digest_and_version(
               circuit-&gt;rend_pk_digest, circuit-&gt;rend_desc_version);
   if (!service) {
-    log_warn(LD_REND, "Unrecognized service ID %s on introduction circuit %d.",
+    log_warn(LD_REND, "Unrecognized hidden service ID %s on introduction circuit \
%d.",  serviceid, circuit-&gt;_base.n_circ_id);
     reason = END_CIRC_REASON_NOSUCHSERVICE;
     goto err;
   }
 
   log_info(LD_REND,
-           "Established circuit %d as introduction point for service %s",
+           "Established circuit %d as introduction point for hidden service %s",
            circuit-&gt;_base.n_circ_id, serviceid);
 
   /* If the introduction point will not be used in an unversioned
@@ -879,7 +921,7 @@
   note_crypto_pk_op(REND_SERVER);
   r = crypto_pk_private_sign_digest(intro_key, buf+len, buf, len);
   if (r&lt;0) {
-    log_warn(LD_BUG, "Internal error: couldn't sign introduction request.");
+    log_warn(LD_BUG, "Internal error: couldn't sign introduction hidden service \
request.");  reason = END_CIRC_REASON_INTERNAL;
     goto err;
   }
@@ -889,7 +931,7 @@
                                    RELAY_COMMAND_ESTABLISH_INTRO,
                                    buf, len, circuit-&gt;cpath-&gt;prev)&lt;0) {
     log_info(LD_GENERAL,
-             "Couldn't send introduction request for service %s on circuit %d",
+             "Couldn't send introduction request for hidden service %s on circuit \
%d",  serviceid, circuit-&gt;_base.n_circ_id);
     reason = END_CIRC_REASON_INTERNAL;
     goto err;
@@ -914,13 +956,13 @@
 
   if (circuit-&gt;_base.purpose != CIRCUIT_PURPOSE_S_ESTABLISH_INTRO) {
     log_warn(LD_PROTOCOL,
-             "received INTRO_ESTABLISHED cell on non-intro circuit.");
+             "received INTRO_ESTABLISHED cell on non-intro hidden service \
circuit.");  goto err;
   }
   service = rend_service_get_by_pk_digest_and_version(
               circuit-&gt;rend_pk_digest, circuit-&gt;rend_desc_version);
   if (!service) {
-    log_warn(LD_REND, "Unknown service on introduction circuit %d.",
+    log_warn(LD_REND, "Unknown hidden service on introduction circuit %d.",
              circuit-&gt;_base.n_circ_id);
     goto err;
   }
@@ -930,7 +972,7 @@
   base32_encode(serviceid, REND_SERVICE_ID_LEN_BASE32 + 1,
                 circuit-&gt;rend_pk_digest, REND_SERVICE_ID_LEN);
   log_info(LD_REND,
-           "Received INTRO_ESTABLISHED cell on circuit %d for service %s",
+           "Received INTRO_ESTABLISHED cell on circuit %d for hidden service %s",
            circuit-&gt;_base.n_circ_id, serviceid);
 
   return 0;
@@ -964,13 +1006,13 @@
 
   log_info(LD_REND,
            "Done building circuit %d to rendezvous with "
-           "cookie %s for service %s",
+           "cookie %s for hidden service %s",
            circuit-&gt;_base.n_circ_id, hexcookie, serviceid);
 
   service = rend_service_get_by_pk_digest_and_version(
               circuit-&gt;rend_pk_digest, circuit-&gt;rend_desc_version);
   if (!service) {
-    log_warn(LD_GENERAL, "Internal error: unrecognized service ID on "
+    log_warn(LD_GENERAL, "Internal error: unrecognized hidden service ID on "
              "introduction circuit.");
     reason = END_CIRC_REASON_INTERNAL;
     goto err;
@@ -980,7 +1022,7 @@
   memcpy(buf, circuit-&gt;rend_cookie, REND_COOKIE_LEN);
   if (crypto_dh_get_public(hop-&gt;dh_handshake_state,
                            buf+REND_COOKIE_LEN, DH_KEY_LEN)&lt;0) {
-    log_warn(LD_GENERAL,"Couldn't get DH public key.");
+    log_warn(LD_GENERAL,"Couldn't get DH public key for hidden service.");
     reason = END_CIRC_REASON_INTERNAL;
     goto err;
   }
@@ -992,7 +1034,7 @@
                                    RELAY_COMMAND_RENDEZVOUS1,
                                    buf, REND_COOKIE_LEN+DH_KEY_LEN+DIGEST_LEN,
                                    circuit-&gt;cpath-&gt;prev)&lt;0) {
-    log_warn(LD_GENERAL, "Couldn't send RENDEZVOUS1 cell.");
+    log_warn(LD_GENERAL, "Couldn't send RENDEZVOUS1 cell for hidden service.");
     reason = END_CIRC_REASON_INTERNAL;
     goto err;
   }
@@ -1078,7 +1120,7 @@
     if (rend_encode_service_descriptor(service-&gt;desc,
                                        service-&gt;private_key,
                                        &amp;desc, &amp;desc_len)&lt;0) {
-      log_warn(LD_BUG, "Internal error: couldn't encode service descriptor; "
+      log_warn(LD_BUG, "Internal error: couldn't encode hidden service descriptor; "
                "not uploading.");
       return;
     }
@@ -1107,7 +1149,7 @@
       seconds_valid = rend_encode_v2_descriptors(desc_strs, desc_ids,
                       service-&gt;desc, now, NULL, 0);
       if (seconds_valid &lt; 0) {
-        log_warn(LD_BUG, "Internal error: couldn't encode service descriptor; "
+        log_warn(LD_BUG, "Internal error: couldn't encode hidden service descriptor; \
"  "not uploading.");
         return;
       }
@@ -1138,8 +1180,8 @@
                                                    service-&gt;desc, now,
                                                    NULL, 1);
         if (seconds_valid &lt; 0) {
-          log_warn(LD_BUG, "Internal error: couldn't encode service "
-                   "descriptor; not uploading.");
+          log_warn(LD_BUG, "Internal error: couldn't encode hidden service "
+                   "descriptor for service %s; not uploading.", serviceid);
           return;
         }
         directory_post_to_hs_dir(desc_ids, desc_strs, serviceid,
@@ -1153,7 +1195,7 @@
         smartlist_free(desc_ids);
       }
       uploaded = 1;
-      log_info(LD_REND, "Successfully uploaded v2 rend descriptors!");
+      log_info(LD_REND, "Successfully uploaded v2 rend hidden service descriptors \
for service %s!", serviceid);  }
   }
 
@@ -1242,7 +1284,7 @@
                0, 0);
       if (!router) {
         log_warn(LD_REND,
-                 "Could only establish %d introduction points for %s.",
+                 "Could only establish %d introduction points for hidden service \
                %s.",
                  smartlist_len(service-&gt;intro_nodes), service-&gt;service_id);
         break;
       }
@@ -1255,7 +1297,7 @@
       smartlist_add(intro_routers, router);
       smartlist_add(exclude_routers, router);
       smartlist_add(service-&gt;intro_nodes, hex_digest);
-      log_info(LD_REND, "Picked router %s as an intro point for %s.",
+      log_info(LD_REND, "Picked router %s as an intro point for hidden service %s.",
                router-&gt;nickname, service-&gt;service_id);
     }
 
@@ -1271,7 +1313,7 @@
       intro = smartlist_get(service-&gt;intro_nodes, j);
       r = rend_service_launch_establish_intro(service, intro);
       if (r&lt;0) {
-        log_warn(LD_REND, "Error launching circuit to node %s for service %s.",
+        log_warn(LD_REND, "Error launching circuit to node %s for hidden service \
%s.",  intro, service-&gt;service_id);
       }
     }
@@ -1330,7 +1372,7 @@
 
   for (i=0; i &lt; smartlist_len(rend_service_list); ++i) {
     service = smartlist_get(rend_service_list, i);
-    log(severity, LD_GENERAL, "Service configured in \"%s\":",
+    log(severity, LD_GENERAL, "Hidden service configured in \"%s\":",
         service-&gt;directory);
     for (j=0; j &lt; smartlist_len(service-&gt;intro_nodes); ++j) {
       nickname = smartlist_get(service-&gt;intro_nodes, j);
@@ -1373,7 +1415,7 @@
   rend_service_port_config_t *chosen_port;
 
   tor_assert(circ-&gt;_base.purpose == CIRCUIT_PURPOSE_S_REND_JOINED);
-  log_debug(LD_REND,"beginning to hunt for addr/port");
+  log_debug(LD_REND,"beginning to hunt for addr/port for hidden ipv4 or ipv6 \
-service");  base32_encode(serviceid, REND_SERVICE_ID_LEN_BASE32+1,
                 circ-&gt;rend_pk_digest, REND_SERVICE_ID_LEN);
   service = rend_service_get_by_pk_digest_and_version(circ-&gt;rend_pk_digest,
@@ -1394,11 +1436,25 @@
   chosen_port = smartlist_choose(matching_ports);
   smartlist_free(matching_ports);
   if (chosen_port) {
-    conn-&gt;_base.addr = chosen_port-&gt;real_addr;
+    if (chosen_port-&gt;real_family == AF_INET6) {
+      conn-&gt;_base.addr6 = chosen_port-&gt;real_addr6;
+
+      char addrbuf[42];
+      struct in6_addr addr;
+      addr = conn-&gt;_base.addr6;
+      tor_inet_ntop(AF_INET6, &amp;addr, addrbuf, sizeof(addrbuf));
+      log_info(LD_REND, "rend_service_set_connection_addr_port() found virtual \
ipv6-port mapping exist for port %d on service %s on local ipv6 %s", +           \
conn-&gt;_base.port, serviceid, addrbuf); +    } else {
+      conn-&gt;_base.addr4 = chosen_port-&gt;real_addr4;
+      log_info(LD_REND, "rend_service_set_connection_addr_port() found virtual \
ipv4-port mapping exist for port %d on (ipv4) service %s", +           \
conn-&gt;_base.port, serviceid); +    }
+    conn-&gt;_base.socket_family = chosen_port-&gt;real_family;
     conn-&gt;_base.port = chosen_port-&gt;real_port;
     return 0;
   }
-  log_info(LD_REND, "No virtual port mapping exists for port %d on service %s",
+  log_info(LD_REND, "No virtual port mapping exists for port %d on hidden ipv4 or \
ipv6 - service %s",  conn-&gt;_base.port,serviceid);
   return -1;
 }
Index: or/routerlist.c
===================================================================
--- or/routerlist.c	(Revision 12621)
+++ or/routerlist.c	(Arbeitskopie)
@@ -4496,7 +4496,7 @@
 
   /* XXX020 make this louder once we have some v2hidservs */
   log_info(LD_REND, "We don't have enough hidden service directories to "
-           "perform v2 rendezvous operations!");
+           "perform v2 rendezvous operations! id=%s", id);
   return -1;
 }
 
Index: or/connection_edge.c
===================================================================
--- or/connection_edge.c	(Revision 12621)
+++ or/connection_edge.c	(Arbeitskopie)
@@ -204,7 +204,12 @@
   payload[0] = reason;
   if (reason == END_STREAM_REASON_EXITPOLICY &amp;&amp;
       !connection_edge_is_rendezvous_stream(conn)) {
-    set_uint32(payload+1, htonl(conn-&gt;_base.addr));
+     if (conn-&gt;_base.socket_family == AF_INET6) {
+       log_warn(LD_BUG,
+                "ipv6 not supported in connection_edge_end for \
non-rendezvous-streams"); +       return 0;
+     }
+    set_uint32(payload+1, htonl(conn-&gt;_base.addr4));
     set_uint32(payload+5, htonl(dns_clip_ttl(conn-&gt;address_ttl)));
     payload_len += 8;
   }
@@ -280,19 +285,28 @@
 int
 connection_edge_finished_connecting(edge_connection_t *edge_conn)
 {
-  char valbuf[INET_NTOA_BUF_LEN];
   connection_t *conn;
-  struct in_addr in;
 
   tor_assert(edge_conn);
   tor_assert(edge_conn-&gt;_base.type == CONN_TYPE_EXIT);
   conn = TO_CONN(edge_conn);
   tor_assert(conn-&gt;state == EXIT_CONN_STATE_CONNECTING);
 
-  in.s_addr = htonl(conn-&gt;addr);
-  tor_inet_ntoa(&amp;in,valbuf,sizeof(valbuf));
-  log_info(LD_EXIT,"Exit connection to %s:%u (%s) established.",
-           escaped_safe_str(conn-&gt;address),conn-&gt;port,safe_str(valbuf));
+  if (conn-&gt;socket_family == AF_INET6) {
+    char addrbuf[42];
+    struct in6_addr addr;
+    addr = conn-&gt;addr6;
+    tor_inet_ntop(AF_INET6, &amp;addr, addrbuf, sizeof(addrbuf));
+    log_info(LD_EXIT,"Exit connection to %s:%u (%s) established.",
+             escaped_safe_str(conn-&gt;address),conn-&gt;port,safe_str(addrbuf));
+  } else {
+    char valbuf[INET_NTOA_BUF_LEN];
+    struct in_addr in;
+    in.s_addr = htonl(conn-&gt;addr4);
+    tor_inet_ntoa(&amp;in,valbuf,sizeof(valbuf));
+    log_info(LD_EXIT,"Exit connection to %s:%u (%s) established.",
+             escaped_safe_str(conn-&gt;address),conn-&gt;port,safe_str(valbuf));
+  }
 
   conn-&gt;state = EXIT_CONN_STATE_OPEN;
   connection_watch_events(conn, EV_READ); /* stop writing, continue reading */
@@ -305,8 +319,17 @@
                                      RELAY_COMMAND_CONNECTED, NULL, 0) &lt; 0)
       return 0; /* circuit is closed, don't continue */
   } else {
+    if (conn-&gt;socket_family == AF_INET6) {
+      char addrbuf[42];
+      struct in6_addr addr;
+      addr = conn-&gt;addr6;
+      tor_inet_ntop(AF_INET6, &amp;addr, addrbuf, sizeof(addrbuf));
+      log_info(LD_EXIT,"ipv6 not supported for exit connection to %s:%u (%s) that is \
not a rendezvous_stream.", +             \
escaped_safe_str(conn-&gt;address),conn-&gt;port,safe_str(addrbuf)); +      return -1;
+    }
     char connected_payload[8];
-    set_uint32(connected_payload, htonl(conn-&gt;addr));
+    set_uint32(connected_payload, htonl(conn-&gt;addr4));
     set_uint32(connected_payload+4,
                htonl(dns_clip_ttl(edge_conn-&gt;address_ttl)));
     if (connection_edge_send_command(edge_conn,
@@ -359,7 +382,7 @@
       continue;
     conn = TO_EDGE_CONN(c);
     /* if it's an internal linked connection, don't yell its status. */
-    severity = (!conn-&gt;_base.addr &amp;&amp; !conn-&gt;_base.port)
+    severity = ((conn-&gt;_base.socket_family == AF_INET &amp;&amp; !conn-&gt;_base.addr4) &amp;&amp; \
!conn-&gt;_base.port)  ? LOG_INFO : LOG_NOTICE;
     seconds_idle = now - conn-&gt;_base.timestamp_lastread;
 
@@ -1991,7 +2014,7 @@
   }
 
   conn-&gt;_base.address = tor_strdup("(Tor_internal)");
-  conn-&gt;_base.addr = 0;
+  conn-&gt;_base.addr4 = 0;
   conn-&gt;_base.port = 0;
 
   if (connection_add(TO_CONN(conn)) &lt; 0) { /* no space, forget it */
@@ -2371,8 +2394,11 @@
 
   if (rh.command == RELAY_COMMAND_BEGIN_DIR) {
     tor_assert(or_circ);
-    if (or_circ-&gt;p_conn &amp;&amp; or_circ-&gt;p_conn-&gt;_base.addr)
-      n_stream-&gt;_base.addr = or_circ-&gt;p_conn-&gt;_base.addr;
+    if (or_circ-&gt;p_conn &amp;&amp; (or_circ-&gt;p_conn-&gt;_base.socket_family != AF_INET || \
or_circ-&gt;p_conn-&gt;_base.addr4)) { +       n_stream-&gt;_base.socket_family = \
or_circ-&gt;p_conn-&gt;_base.socket_family; +       n_stream-&gt;_base.addr4 = \
or_circ-&gt;p_conn-&gt;_base.addr4; +       n_stream-&gt;_base.addr6 = \
or_circ-&gt;p_conn-&gt;_base.addr6; +      }
     return connection_exit_connect_dir(n_stream);
   }
 
@@ -2444,6 +2470,12 @@
   return 0;
 }
 
+/** compare the 2 given ipv6-addresses
+ *  *
+ *   * returns 0 if they are equal.
+ *    */
+int compare_in6_addr(struct in6_addr a, struct in6_addr b);
+
 /** Connect to conn's specified addr and port. If it worked, conn
  * has now been added to the connection_array.
  *
@@ -2454,7 +2486,9 @@
 void
 connection_exit_connect(edge_connection_t *edge_conn)
 {
-  uint32_t addr;
+  uint32_t addr4;
+  struct in6_addr addr6;
+  int addr_family = AF_INET;
   uint16_t port;
   connection_t *conn = TO_CONN(edge_conn);
 
@@ -2468,19 +2502,33 @@
     return;
   }
 
-  addr = conn-&gt;addr;
   port = conn-&gt;port;
+  if (conn-&gt;socket_family == AF_INET6) {
+    addr6 = conn-&gt;addr6;
+    addr_family = AF_INET6;
+  } else {
+    addr4 = conn-&gt;addr4;
+  }
   if (redirect_exit_list) {
     SMARTLIST_FOREACH(redirect_exit_list, exit_redirect_t *, r,
-    {
-      if (!addr_mask_cmp_bits(addr, r-&gt;addr, r-&gt;maskbits) &amp;&amp;
+    {/*
+          if (!addr_mask_cmp_bits(addr, r-&gt;addr, r-&gt;maskbits) &amp;&amp;
+	            (r-&gt;port_min &lt;= port) &amp;&amp; (port &lt;= r-&gt;port_max)) {
+      */
+      if (
+          (conn-&gt;socket_family == AF_INET/*r-&gt;family*/ &amp;&amp;
+           ((conn-&gt;socket_family == AF_INET &amp;&amp; !addr_mask_cmp_bits(addr4, r-&gt;addr, \
r-&gt;maskbits)) /*&amp;&amp; +            (conn-&gt;socket_family == AF_INET6 &amp;&amp; \
!compare_in6_addr(addr6, r-&gt;addr6))*/) +	  ) &amp;&amp;
           (r-&gt;port_min &lt;= port) &amp;&amp; (port &lt;= r-&gt;port_max)) {
-        struct in_addr in;
+
         if (r-&gt;is_redirect) {
           char tmpbuf[INET_NTOA_BUF_LEN];
-          addr = r-&gt;addr_dest;
+          addr_family = AF_INET;
+          addr4 = r-&gt;addr_dest;
           port = r-&gt;port_dest;
-          in.s_addr = htonl(addr);
+          struct in_addr in;
+          in.s_addr = htonl(addr4);
           tor_inet_ntoa(&amp;in, tmpbuf, sizeof(tmpbuf));
           log_debug(LD_EXIT, "Redirecting connection from %s:%d to %s:%d",
                     escaped_safe_str(conn-&gt;address), conn-&gt;port,
@@ -2492,7 +2540,13 @@
   }
 
   log_debug(LD_EXIT,"about to try connecting");
-  switch (connection_connect(conn, conn-&gt;address, addr, port)) {
+  int s = -1;
+  if (addr_family == AF_INET) {
+     s = connection_connect(conn, conn-&gt;address, addr4, port);
+  } else {
+     s = connection_connect6(conn, conn-&gt;address, addr6, port);
+  }
+  switch (s) {
     case -1:
       connection_edge_end_errno(edge_conn);
       circuit_detach_stream(circuit_get_by_edge_conn(edge_conn), edge_conn);
@@ -2525,8 +2579,11 @@
                                  NULL, 0);
   } else { /* normal stream */
     /* This must be the original address, not the redirected address. */
+    if (conn-&gt;socket_family == AF_INET6) {
+      log_warn(LD_BUG,"we do not support ipv6 in connection_exit_connect!");
+    }
     char connected_payload[8];
-    set_uint32(connected_payload, htonl(conn-&gt;addr));
+    set_uint32(connected_payload, htonl(conn-&gt;addr4));
     set_uint32(connected_payload+4,
                htonl(dns_clip_ttl(edge_conn-&gt;address_ttl)));
     connection_edge_send_command(edge_conn,
@@ -2554,7 +2611,8 @@
 
   dirconn = TO_DIR_CONN(connection_new(CONN_TYPE_DIR, AF_INET));
 
-  dirconn-&gt;_base.addr = 0x7f000001;
+  dirconn-&gt;_base.socket_family = AF_INET;
+  dirconn-&gt;_base.addr4 = 0x7f000001;
   dirconn-&gt;_base.port = 0;
   dirconn-&gt;_base.address = tor_strdup("Tor network");
   dirconn-&gt;_base.type = CONN_TYPE_DIR;
Index: or/dns.c
===================================================================
--- or/dns.c	(Revision 12621)
+++ or/dns.c	(Arbeitskopie)
@@ -413,7 +413,7 @@
     {
     case RESOLVED_TYPE_IPV4:
       buf[1] = 4;
-      set_uint32(buf+2, htonl(conn-&gt;_base.addr));
+      set_uint32(buf+2, htonl(conn-&gt;_base.addr4));
       set_uint32(buf+6, htonl(ttl));
       buflen = 10;
       break;
@@ -627,7 +627,8 @@
   /* first check if exitconn-&gt;_base.address is an IP. If so, we already
    * know the answer. */
   if (tor_inet_aton(exitconn-&gt;_base.address, &amp;in) != 0) {
-    exitconn-&gt;_base.addr = ntohl(in.s_addr);
+    exitconn-&gt;_base.socket_family = AF_INET;
+    exitconn-&gt;_base.addr4 = ntohl(in.s_addr);
     exitconn-&gt;address_ttl = DEFAULT_DNS_TTL;
     return 1;
   }
@@ -694,7 +695,8 @@
           tor_assert(is_resolve);
           *hostname_out = tor_strdup(resolve-&gt;result.hostname);
         } else {
-          exitconn-&gt;_base.addr = resolve-&gt;result.addr;
+	  exitconn-&gt;_base.socket_family = AF_INET;
+          exitconn-&gt;_base.addr4 = resolve-&gt;result.addr;
         }
         return 1;
       case CACHE_STATE_CACHED_FAILED:
@@ -1000,7 +1002,8 @@
     pendconn = pend-&gt;conn; /* don't pass complex things to the
                               connection_mark_for_close macro */
     assert_connection_ok(TO_CONN(pendconn),time(NULL));
-    pendconn-&gt;_base.addr = addr;
+    pendconn-&gt;_base.socket_family = AF_INET;
+    pendconn-&gt;_base.addr4 = addr;
     pendconn-&gt;address_ttl = ttl;
 
     if (outcome != DNS_RESOLVE_SUCCEEDED) {
Index: or/or.h
===================================================================
--- or/or.h	(Revision 12621)
+++ or/or.h	(Arbeitskopie)
@@ -851,8 +851,9 @@
   int socket_family; /**&lt; Address family of this connection's socket.  Usually
                       * AF_INET, but it can also be AF_UNIX, or in the future
                       * AF_INET6 */
-  uint32_t addr; /**&lt; IP of the other side of the connection; used to identify
+  uint32_t addr4; /**&lt; IP of the other side of the connection; used to identify
                   * routers, along with port. */
+  struct in6_addr addr6;
   uint16_t port; /**&lt; If non-zero, port  on the other end
                   * of the connection. */
   uint16_t marked_for_close; /**&lt; Should we close this conn on the next
@@ -913,7 +914,9 @@
    * recent, we can rate limit it further. */
   time_t client_used;
 
-  uint32_t real_addr; /**DOCDOC */
+  int real_socket_family; /**&lt; AF_INET or AF_INET6 */
+  uint32_t real_addr4; /**&lt; DOCDOC*/
+  struct in6_addr real_addr6;
 
   circ_id_type_t circ_id_type:2; /**&lt; When we send CREATE cells along this
                                   * connection, which half of the space should
@@ -1576,8 +1579,10 @@
   char nickname[MAX_HEX_NICKNAME_LEN+1]; /**&lt; This router's nickname for
                                           * display. */
   char identity_digest[DIGEST_LEN]; /**&lt; Hash of this router's identity key. */
-  uint16_t port; /**&lt; OR port. */
-  uint32_t addr; /**&lt; IP address in host order. */
+  uint16_t port;         /**&lt; OR port. */
+  uint32_t addr4;        /**&lt; IPv4 address in host order. */
+  struct in6_addr addr6; /**&lt; IPv6 address. */
+  u_int16_t family;      /**&lt; AF_INET6 or AF_INET */
   crypto_pk_env_t *onion_key; /**&lt; Current onionskin key. */
 } extend_info_t;
 
@@ -1737,7 +1742,11 @@
   /** The port for the OR that is next in this circuit. */
   uint16_t n_port;
   /** The IPv4 address of the OR that is next in this circuit. */
-  uint32_t n_addr;
+  uint32_t n_addr4;
+  /** The IPv6 address of the OR that is next in this circuit. */
+  struct in6_addr n_addr6;
+  /**  AF_INET6 or AF_INET */
+  u_int16_t n_family;
 
   /** True iff we are waiting for n_conn_cells to become less full before
    * allowing p_streams to add any more cells. (Origin circuit only.) */
@@ -2623,6 +2632,8 @@
 
 int connection_connect(connection_t *conn, const char *address, uint32_t addr,
                        uint16_t port);
+int connection_connect6(connection_t *conn, const char *address, struct in6_addr \
addr, +                       uint16_t port);
 int retry_all_listeners(smartlist_t *replaced_conns,
                         smartlist_t *new_conns);
 
Index: or/connection.c
===================================================================
--- or/connection.c	(Revision 12621)
+++ or/connection.c	(Arbeitskopie)
@@ -645,6 +645,44 @@
   });
 }
 
+/** Create an AF_INET6 listenaddr struct.
+ * &lt;b&gt;listenaddress&lt;/b&gt; provides the host and optionally the port information
+ * for the new structure.  If no port is provided in &lt;b&gt;listenaddress&lt;/b&gt; then
+ * &lt;b&gt;listenport&lt;/b&gt; is used.
+ *
+ * If not NULL &lt;b&gt;readable_addrress&lt;/b&gt; will contain a copy of the host part of
+ * &lt;b&gt;listenaddress&lt;/b&gt;.
+ *
+ * The listenaddr struct has to be freed by the caller.
+ */
+static struct sockaddr_in6 *
+create_inet6_sockaddr(const char *listenaddress, uint16_t listenport,
+                     char **readable_address) {
+  struct sockaddr_in6 *listenaddr = NULL;
+  struct in6_addr addr6;
+  uint16_t usePort = 0;
+
+  if (parse_addr6_port(LOG_WARN,
+                      listenaddress, readable_address, &amp;addr6, &amp;usePort)&lt;0) {
+    log_warn(LD_CONFIG,
+             "Error parsing/resolving ipv6 ListenAddress %s", listenaddress);
+    goto err;
+  }
+  if (usePort==0)
+    usePort = listenport;
+
+  listenaddr = tor_malloc_zero(sizeof(struct sockaddr_in6));
+  listenaddr-&gt;sin6_addr = addr6;
+  listenaddr-&gt;sin6_family = AF_INET;
+  listenaddr-&gt;sin6_port = htons((uint16_t) usePort);
+
+  return listenaddr;
+
+ err:
+  tor_free(listenaddr);
+  return NULL;
+}
+
 /** Create an AF_INET listenaddr struct.
  * &lt;b&gt;listenaddress&lt;/b&gt; provides the host and optionally the port information
  * for the new structure.  If no port is provided in &lt;b&gt;listenaddress&lt;/b&gt; then
@@ -747,7 +785,7 @@
     return NULL;
   }
 
-  if (listensockaddr-&gt;sa_family == AF_INET) {
+  if (listensockaddr-&gt;sa_family == AF_INET6) {
     int is_tcp = (type != CONN_TYPE_AP_DNS_LISTENER);
 #ifndef MS_WINDOWS
     int one=1;
@@ -756,6 +794,55 @@
       start_reading = 1;
 
     usePort = ntohs( (uint16_t)
+                     ((struct sockaddr_in6 *)listensockaddr)-&gt;sin6_port);
+
+    log_notice(LD_NET, "Opening %s on ipv6 %s:%d",
+               conn_type_to_string(type), address, usePort);
+
+    s = tor_open_socket(PF_INET6,
+                        is_tcp ? SOCK_STREAM : SOCK_DGRAM,
+                        is_tcp ? IPPROTO_TCP: IPPROTO_UDP);
+    if (s &lt; 0) {
+      log_warn(LD_NET,"ipv6 socket creation failed.");
+      goto err;
+    }
+
+#ifndef MS_WINDOWS
+    /* REUSEADDR on normal places means you can rebind to the port
+     * right after somebody else has let it go. But REUSEADDR on win32
+     * means you can bind to the port _even when somebody else
+     * already has it bound_. So, don't do that on Win32. */
+    setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (void*) &amp;one, sizeof(one));
+#endif
+
+    if (bind(s, listensockaddr, sizeof(struct sockaddr_in6)) &lt; 0) {
+      const char *helpfulhint = "";
+      int e = tor_socket_errno(s);
+      if (ERRNO_IS_EADDRINUSE(e))
+        helpfulhint = ". Is Tor already running?";
+      log_warn(LD_NET, "Could not bind to ipv6 %s:%u: %s%s", address, usePort,
+               tor_socket_strerror(e), helpfulhint);
+      tor_close_socket(s);
+      goto err;
+    }
+
+    if (is_tcp) {
+      if (listen(s,SOMAXCONN) &lt; 0) {
+        log_warn(LD_NET, "Could not listen on ipv6 %s:%u: %s", address, usePort,
+                 tor_socket_strerror(tor_socket_errno(s)));
+        tor_close_socket(s);
+        goto err;
+      }
+    }
+  } else if (listensockaddr-&gt;sa_family == AF_INET) {
+    int is_tcp = (type != CONN_TYPE_AP_DNS_LISTENER);
+#ifndef MS_WINDOWS
+    int one=1;
+#endif
+    if (is_tcp)
+      start_reading = 1;
+
+    usePort = ntohs( (uint16_t)
                      ((struct sockaddr_in *)listensockaddr)-&gt;sin_port);
 
     log_notice(LD_NET, "Opening %s on %s:%d",
@@ -877,23 +964,41 @@
 check_sockaddr_in(struct sockaddr *sa, int len, int level)
 {
   int ok = 1;
-  struct sockaddr_in *sin=(struct sockaddr_in*)sa;
 
-  if (len != sizeof(struct sockaddr_in)) {
-    log_fn(level, LD_NET, "Length of address not as expected: %d vs %d",
-           len,(int)sizeof(struct sockaddr_in));
-    ok = 0;
-  }
-  if (sa-&gt;sa_family != AF_INET) {
+  if (sa-&gt;sa_family == AF_INET6) {
+     struct sockaddr_in6 *sin=(struct sockaddr_in6*)sa;
+
+     if (len != sizeof(struct sockaddr_in6)) {
+       log_fn(level, LD_NET, "Length of ipv6 address not as expected: %d vs %d",
+              len,(int)sizeof(struct sockaddr_in));
+       ok = 0;
+     }
+
+     if (sin-&gt;sin6_port == 0) {
+       log_fn(level, LD_NET,
+              "Address for new connection has port equal to zero.");
+       ok = 0;
+     }
+  } else if (sa-&gt;sa_family == AF_INET) {
+     struct sockaddr_in *sin=(struct sockaddr_in*)sa;
+
+     if (len != sizeof(struct sockaddr_in)) {
+       log_fn(level, LD_NET, "Length of ipv4 address not as expected: %d vs %d",
+              len,(int)sizeof(struct sockaddr_in));
+       ok = 0;
+     }
+
+     if (sin-&gt;sin_addr.s_addr == 0 || sin-&gt;sin_port == 0) {
+       log_fn(level, LD_NET,
+              "Address for new connection has address/port equal to zero.");
+       ok = 0;
+     }
+  } else {
     log_fn(level, LD_NET, "Family of address not as expected: %d vs %d",
            sa-&gt;sa_family, AF_INET);
     ok = 0;
   }
-  if (sin-&gt;sin_addr.s_addr == 0 || sin-&gt;sin_port == 0) {
-    log_fn(level, LD_NET,
-           "Address for new connection has address/port equal to zero.");
-    ok = 0;
-  }
+
   return ok ? 0 : -1;
 }
 
@@ -906,7 +1011,8 @@
   int news; /* the new socket */
   connection_t *newconn;
   /* information about the remote peer when connecting to other routers */
-  struct sockaddr_in remote;
+  struct sockaddr_in remote4;
+  struct sockaddr_in6 remote6;
   char addrbuf[256];
   /* length of the remote address. Must be whatever accept() needs. */
   socklen_t remotelen = sizeof(addrbuf);
@@ -916,7 +1022,7 @@
   tor_assert((size_t)remotelen &gt;= sizeof(struct sockaddr_in));
   memset(addrbuf, 0, sizeof(addrbuf));
 
-  news = accept(conn-&gt;s,(struct sockaddr *)&amp;addrbuf,&amp;remotelen);
+  news = accept(conn-&gt;s ,(struct sockaddr *)&amp;addrbuf, &amp;remotelen);
   if (news &lt; 0) { /* accept() error */
     int e = tor_socket_errno(conn-&gt;s);
     if (ERRNO_IS_ACCEPT_EAGAIN(e)) {
@@ -953,7 +1059,7 @@
     return 0;
   }
 
-  if (conn-&gt;socket_family == AF_INET) {
+  if (conn-&gt;socket_family == AF_INET || conn-&gt;socket_family == AF_INET6) {
     if (check_sockaddr_in((struct sockaddr*)addrbuf, remotelen, LOG_INFO)&lt;0) {
       log_info(LD_NET,
                "accept() returned a strange address; trying getsockname().");
@@ -972,13 +1078,18 @@
         }
       }
     }
-    memcpy(&amp;remote, addrbuf, sizeof(struct sockaddr_in));
+    if (conn-&gt;socket_family == AF_INET6) {
+      memcpy(&amp;remote6, addrbuf, sizeof(struct sockaddr_in6));
+    } else {
+      memcpy(&amp;remote4, addrbuf, sizeof(struct sockaddr_in));
+    }
 
     /* process entrance policies here, before we even create the connection */
     if (new_type == CONN_TYPE_AP) {
       /* check sockspolicy to see if we should accept it */
-      if (socks_policy_permits_address(ntohl(remote.sin_addr.s_addr)) == 0) {
-        tor_inet_ntoa(&amp;remote.sin_addr, tmpbuf, sizeof(tmpbuf));
+      //TODO: support ipv6
+      if (conn-&gt;socket_family == AF_INET &amp;&amp; \
socks_policy_permits_address(ntohl(remote4.sin_addr.s_addr)) == 0) { +        \
tor_inet_ntoa(&amp;remote4.sin_addr, tmpbuf, sizeof(tmpbuf));  log_notice(LD_APP,
                    "Denying socks connection from untrusted address %s.",
                    tmpbuf);
@@ -988,8 +1099,9 @@
     }
     if (new_type == CONN_TYPE_DIR) {
       /* check dirpolicy to see if we should accept it */
-      if (dir_policy_permits_address(ntohl(remote.sin_addr.s_addr)) == 0) {
-        tor_inet_ntoa(&amp;remote.sin_addr, tmpbuf, sizeof(tmpbuf));
+      //TODO: support ipv6
+      if (conn-&gt;socket_family == AF_INET &amp;&amp; \
dir_policy_permits_address(ntohl(remote4.sin_addr.s_addr)) == 0) { +        \
tor_inet_ntoa(&amp;remote4.sin_addr, tmpbuf, sizeof(tmpbuf));  \
log_notice(LD_DIRSERV,"Denying dir connection from address %s.",  tmpbuf);
         tor_close_socket(news);
@@ -1001,9 +1113,16 @@
     newconn-&gt;s = news;
 
     /* remember the remote address */
-    newconn-&gt;addr = ntohl(remote.sin_addr.s_addr);
-    newconn-&gt;port = ntohs(remote.sin_port);
-    newconn-&gt;address = tor_dup_addr(newconn-&gt;addr);
+    if (conn-&gt;socket_family == AF_INET6) {
+      newconn-&gt;addr6 = remote6.sin6_addr;
+      newconn-&gt;port = ntohs(remote6.sin6_port);
+      newconn-&gt;address = tor_dup_addr6(newconn-&gt;addr6);
+    } else {
+      newconn-&gt;addr4 = remote4.sin_addr.s_addr;
+      newconn-&gt;port = ntohs(remote4.sin_port);
+      newconn-&gt;address = tor_dup_addr(newconn-&gt;addr4);
+    }
+    newconn-&gt;socket_family = conn-&gt;socket_family;
 
   } else if (conn-&gt;socket_family == AF_UNIX) {
     /* For now only control ports can be unix domain sockets
@@ -1014,12 +1133,12 @@
     newconn-&gt;s = news;
 
     /* remember the remote address -- do we have anything sane to put here? */
-    newconn-&gt;addr = 0;
+    newconn-&gt;addr4 = 0;
     newconn-&gt;port = 1;
     newconn-&gt;address = tor_strdup(conn-&gt;address);
   } else {
     tor_assert(0);
-  };
+  }
 
   if (connection_add(newconn) &lt; 0) { /* no space, forget it */
     connection_free(newconn);
@@ -1161,6 +1280,96 @@
   return inprogress ? 0 : 1;
 }
 
+/** Take conn, make a nonblocking socket; try to connect to
+ * addr:port (they arrive in *host order*). If fail, return -1. Else
+ * assign s to conn-\&gt;s: if connected return 1, if EAGAIN return 0.
+ *
+ * address is used to make the logs useful.
+ *
+ * On success, add conn to the list of polled connections.
+ */
+int
+connection_connect6(connection_t *conn, const char *address,
+                   struct in6_addr addr6, uint16_t port)
+{
+  int s, inprogress = 0;
+  struct sockaddr_in6 dest_addr6;
+  or_options_t *options = get_options();
+
+  if (get_n_open_sockets() &gt;= get_options()-&gt;_ConnLimit-1) {
+    int n_conns = get_n_open_sockets();
+    log_warn(LD_NET,"Failing because we have %d connections already. Please "
+             "raise your ulimit -n.", n_conns);
+    control_event_general_status(LOG_WARN, "TOO_MANY_CONNECTIONS CURRENT=%d",
+                                 n_conns);
+    return -1;
+  }
+
+  s = tor_open_socket(PF_INET6, SOCK_STREAM, IPPROTO_TCP);
+  if (s &lt; 0) {
+    log_warn(LD_NET,"Error creating network socket: %s",
+             tor_socket_strerror(tor_socket_errno(-1)));
+    return -1;
+  }
+
+  if (options-&gt;OutboundBindAddress) {
+    struct sockaddr_in6 ext_addr6;
+
+    memset(&amp;ext_addr6, 0, sizeof(ext_addr6));
+    ext_addr6.sin6_family = AF_INET6;
+    ext_addr6.sin6_port = 0;
+    if (!tor_inet_aton6(options-&gt;OutboundBindAddress, &amp;ext_addr6.sin6_addr)) {
+      log_warn(LD_CONFIG,"Outbound ipv6 bind address '%s' didn't parse. Ignoring.",
+               options-&gt;OutboundBindAddress);
+    } else {
+      if (bind(s, (struct sockaddr*)&amp;ext_addr6, sizeof(ext_addr6)) &lt; 0) {
+        log_warn(LD_NET,"Error binding network ipv6 socket: %s",
+                 tor_socket_strerror(tor_socket_errno(s)));
+        tor_close_socket(s);
+        return -1;
+      }
+    }
+  }
+
+  set_socket_nonblocking(s);
+
+  if (options-&gt;ConstrainedSockets)
+    set_constrained_socket_buffers(s, (int)options-&gt;ConstrainedSockSize);
+
+  memset(&amp;dest_addr6, 0, sizeof(dest_addr6));
+  dest_addr6.sin6_family = AF_INET6;
+  dest_addr6.sin6_port = htons(port);
+  dest_addr6.sin6_addr = addr6;
+
+  log_debug(LD_NET, "Connecting to ipv6 %s:%u.", escaped_safe_str(address), port);
+
+  if (connect(s, (struct sockaddr *)&amp;dest_addr6, sizeof(dest_addr6)) &lt; 0) {
+    int e = tor_socket_errno(s);
+    if (!ERRNO_IS_CONN_EINPROGRESS(e)) {
+      /* yuck. kill it. */
+      log_info(LD_NET,
+               "connect() to ipv6 %s:%u failed: %s", escaped_safe_str(address),
+               port, tor_socket_strerror(e));
+      tor_close_socket(s);
+      return -1;
+    } else {
+      inprogress = 1;
+    }
+  }
+
+  if (!server_mode(options))
+    client_check_address_changed(s);
+
+  /* it succeeded. we're connected. */
+  log_fn(inprogress?LOG_DEBUG:LOG_INFO, LD_NET,
+         "Connection to ipv6 %s:%u %s (sock %d).", escaped_safe_str(address),
+         port, inprogress?"in progress":"established", s);
+  conn-&gt;s = s;
+  if (connection_add(conn) &lt; 0) /* no space, forget it */
+    return -1;
+  return inprogress ? 0 : 1;
+}
+
 /**
  * Launch any configured listener connections of type &lt;b&gt;type&lt;/b&gt;.  (A
  * listener is configured if &lt;b&gt;port_option&lt;/b&gt; is non-zero.  If any
@@ -1190,7 +1399,7 @@
   connection_t *conn;
   config_line_t *line;
 
-  tor_assert(socket_family == AF_INET || socket_family == AF_UNIX);
+  tor_assert(socket_family == AF_INET || socket_family == AF_INET6 || socket_family \
== AF_UNIX);  
   if (cfg &amp;&amp; port_option) {
     for (c = cfg; c; c = c-&gt;next) {
@@ -1223,6 +1432,19 @@
         char *address=NULL;
         uint16_t port;
         switch (socket_family) {
+          case AF_INET6:
+            if (!parse_addr6_port(LOG_WARN,
+                                 wanted-&gt;value, &amp;address, NULL, &amp;port)) {
+              int addr_matches = !strcasecmp(address, conn-&gt;address);
+              tor_free(address);
+              if (! port)
+                port = port_option;
+              if (port == conn-&gt;port &amp;&amp; addr_matches) {
+                line = wanted;
+                break;
+              }
+            }
+            break;
           case AF_INET:
             if (!parse_addr_port(LOG_WARN,
                                  wanted-&gt;value, &amp;address, NULL, &amp;port)) {
@@ -1275,6 +1497,12 @@
         struct sockaddr *listensockaddr;
 
         switch (socket_family) {
+          case AF_INET6:
+            listensockaddr = (struct sockaddr *)
+                             create_inet6_sockaddr(cfg_line-&gt;value,
+                                                  (uint16_t) port_option,
+                                                  &amp;address);
+            break;
           case AF_INET:
             listensockaddr = (struct sockaddr *)
                              create_inet_sockaddr(cfg_line-&gt;value,
@@ -1342,7 +1570,12 @@
                       options-&gt;SocksPort, "127.0.0.1",
                       replaced_conns, new_conns, 0,
                       AF_INET)&lt;0)
-    return -1;
+    // maybe the user deliberately configured an ipv6-address to listen on
+    if (retry_listeners(CONN_TYPE_AP_LISTENER, options-&gt;SocksListenAddress, 
+                        options-&gt;SocksPort, "::1",
+                        replaced_conns, new_conns, 0,
+                        AF_INET6)&lt;0)
+      return -1;
   if (retry_listeners(CONN_TYPE_AP_TRANS_LISTENER, options-&gt;TransListenAddress,
                       options-&gt;TransPort, "127.0.0.1",
                       replaced_conns, new_conns, 0,
@@ -1380,7 +1613,7 @@
 static int
 connection_is_rate_limited(connection_t *conn)
 {
-  if (conn-&gt;linked || is_internal_IP(conn-&gt;addr, 0))
+  if (conn-&gt;linked || (conn-&gt;socket_family == AF_INET &amp;&amp; is_internal_IP(conn-&gt;addr4, \
0)))  return 0;
   else
     return 1;
@@ -2328,7 +2561,8 @@
   SMARTLIST_FOREACH(conns, connection_t *, conn,
   {
     if (conn-&gt;type == CONN_TYPE_OR &amp;&amp;
-        conn-&gt;addr == addr &amp;&amp;
+        conn-&gt;socket_family == AF_INET &amp;&amp;
+        conn-&gt;addr4 == addr &amp;&amp;
         conn-&gt;port == port &amp;&amp;
         !conn-&gt;marked_for_close &amp;&amp;
         (!best || best-&gt;_base.timestamp_created &lt; conn-&gt;timestamp_created))
@@ -2348,7 +2582,8 @@
   SMARTLIST_FOREACH(conns, connection_t *, conn,
   {
     if (conn-&gt;type == type &amp;&amp;
-        conn-&gt;addr == addr &amp;&amp;
+        conn-&gt;socket_family == AF_INET &amp;&amp;
+        conn-&gt;addr4 == addr &amp;&amp;
         conn-&gt;port == port &amp;&amp;
         conn-&gt;purpose == purpose &amp;&amp;
         !conn-&gt;marked_for_close)
Index: or/rendcommon.c
===================================================================
--- or/rendcommon.c	(Revision 12621)
+++ or/rendcommon.c	(Arbeitskopie)
@@ -227,7 +227,11 @@
       goto done;
     }
     /* Assemble everything for this introduction point. */
-    address = tor_dup_addr(info-&gt;addr);
+    if (info-&gt;family == AF_INET6) {
+      address = tor_dup_addr6(info-&gt;addr6);
+    } else {
+      address = tor_dup_addr(info-&gt;addr4);
+    }
     res = tor_snprintf(unenc + unenc_written, unenc_len - unenc_written,
                          "introduction-point %s\n"
                          "ip-address %s\n"
@@ -760,8 +764,11 @@
 {
   char key[REND_SERVICE_ID_LEN_BASE32+2]; /* &lt;version&gt;&lt;query&gt;\0 */
   tor_assert(rend_cache);
-  if (!rend_valid_service_id(query))
+  if (!rend_valid_service_id(query)) {
+    log_warn(LD_REND, "hidden service descriptor '%s.onion' ID is not legal.",
+             query);
     return -1;
+  }
   *e = NULL;
   if (version != 0) {
     tor_snprintf(key, sizeof(key), "2%s", query);
@@ -771,8 +778,13 @@
     tor_snprintf(key, sizeof(key), "0%s", query);
     *e = strmap_get_lc(rend_cache, key);
   }
-  if (!*e)
+  if (!*e) {
+    log_warn(LD_REND, "no cached rend_cache_entry_t for hidden service  '%s.onion' \
with version %i.", +             query,version);
     return 0;
+  }
+  log_warn(LD_REND, "we have a cached rend_cache_entry_t for hidden service  \
'%s.onion' with version %i.", +             query, version);
   return 1;
 }
 
Index: or/directory.c
===================================================================
--- or/directory.c	(Revision 12621)
+++ or/directory.c	(Arbeitskopie)
@@ -478,7 +478,7 @@
     routerinfo_t *me = router_get_my_routerinfo();
     if (me &amp;&amp;
         router_digest_is_me(conn-&gt;identity_digest) &amp;&amp;
-        me-&gt;addr == conn-&gt;_base.addr &amp;&amp;
+        me-&gt;addr == conn-&gt;_base.addr4 &amp;&amp; //TODO: support directories on IPv6
         me-&gt;dir_port == conn-&gt;_base.port)
       return 1;
   }
@@ -644,7 +644,8 @@
   conn = TO_DIR_CONN(connection_new(CONN_TYPE_DIR, AF_INET));
 
   /* set up conn so it's got all the data we need to remember */
-  conn-&gt;_base.addr = addr;
+  conn-&gt;_base.socket_family = AF_INET;
+  conn-&gt;_base.addr4 = addr;
   conn-&gt;_base.port = use_begindir ? or_port : dir_port;
   conn-&gt;_base.address = tor_strdup(address);
   memcpy(conn-&gt;identity_digest, digest, DIGEST_LEN);
@@ -1940,7 +1941,7 @@
     tor_snprintf(cp, sizeof(tmp)-(cp-tmp), "Content-Type: %s\r\n", type);
     cp += strlen(cp);
   }
-  if (!is_internal_IP(conn-&gt;_base.addr, 0)) {
+  if (conn-&gt;_base.socket_family == AF_INET &amp;&amp; !is_internal_IP(conn-&gt;_base.addr4, 0)) \
                { //TODO: support ipv6
     /* Don't report the source address for a localhost/private connection. */
     tor_snprintf(cp, sizeof(tmp)-(cp-tmp),
                  X_ADDRESS_HEADER "%s\r\n", conn-&gt;_base.address);
@@ -3121,7 +3122,7 @@
     /* Determine responsible dirs. */
     if (hid_serv_get_responsible_directories(responsible_dirs, desc_id) &lt; 0) {
       log_warn(LD_REND, "Could not determine the responsible hidden service "
-                        "directories to post descriptors to.");
+                        "directories to post descriptors to. desc_id=%s", desc_id);
       smartlist_free(responsible_dirs);
       return;
     }
@@ -3169,7 +3170,7 @@
   if (hid_serv_get_responsible_directories(responsible_dirs, desc_id) &lt; 0) {
     /* XXX020 make this louder once we have some v2hidservs */
     log_info(LD_REND, "Could not determine the responsible hidden service "
-                      "directories to fetch descriptors.");
+                      "directories to fetch descriptors. desc_id=%s", desc_id);
     smartlist_free(responsible_dirs);
     return;
   }
Index: or/routerparse.c
===================================================================
--- or/routerparse.c	(Revision 12621)
+++ or/routerparse.c	(Arbeitskopie)
@@ -3454,7 +3454,8 @@
       tor_free(info);
       goto err;
     }
-    info-&gt;addr = ntohl(ip.s_addr);
+    info-&gt;family = AF_INET;
+    info-&gt;addr4 = ntohl(ip.s_addr);
     /* Parse onion port. */
     tok = find_first_by_keyword(tokens, R_IPO_ONION_PORT);
     info-&gt;port = (uint16_t) atoi(tok-&gt;args[0]);
Index: or/command.c
===================================================================
--- or/command.c	(Revision 12621)
+++ or/command.c	(Arbeitskopie)
@@ -560,7 +560,7 @@
     }
     if (other_addr_type == RESOLVED_TYPE_IPV4 &amp;&amp; other_addr_len == 4) {
       uint32_t addr = ntohl(get_uint32(cp));
-      if (addr == conn-&gt;real_addr) {
+      if (conn-&gt;real_socket_family == AF_INET &amp;&amp; addr == conn-&gt;real_addr4) {
         conn-&gt;handshake_state-&gt;apparently_canonical = 1;
         break;
       }
Index: or/circuituse.c
===================================================================
--- or/circuituse.c	(Revision 12621)
+++ or/circuituse.c	(Arbeitskopie)
@@ -1261,7 +1261,7 @@
   conn_age = time(NULL) - conn-&gt;_base.timestamp_created;
 
   if (conn_age &gt;= get_options()-&gt;SocksTimeout) {
-    int severity = (!conn-&gt;_base.addr &amp;&amp; !conn-&gt;_base.port) ?
+    int severity = ((conn-&gt;_base.socket_family == AF_INET &amp;&amp; !conn-&gt;_base.addr4) &amp;&amp; \
!conn-&gt;_base.port) ?  LOG_INFO : LOG_NOTICE;
     log_fn(severity, LD_APP,
            "Tried for %d seconds to get a connection to %s:%d. Giving up.",
Index: or/test.c
===================================================================
--- or/test.c	(Revision 12621)
+++ or/test.c	(Arbeitskopie)
@@ -3311,7 +3311,8 @@
     info-&gt;nickname[0] = '$';
     base16_encode(info-&gt;nickname + 1, sizeof(info-&gt;nickname) - 1,
                   info-&gt;identity_digest, DIGEST_LEN);
-    info-&gt;addr = crypto_rand_int(65536); /* Does not cover all IP addresses. */
+    info-&gt;family = AF_INET;
+    info-&gt;addr4 = crypto_rand_int(65536); /* Does not cover all IP addresses. */
     info-&gt;port = crypto_rand_int(65536);
     generated-&gt;intro_points[i] = tor_strdup(info-&gt;nickname);
     generated-&gt;intro_point_extend_info[i] = info;
@@ -3346,7 +3347,7 @@
                DIGEST_LEN);
     test_streq(gen_info-&gt;nickname, par_info-&gt;nickname);
     test_streq(generated-&gt;intro_points[i], parsed-&gt;intro_points[i]);
-    test_eq(gen_info-&gt;addr, par_info-&gt;addr);
+    test_eq(gen_info-&gt;addr4, par_info-&gt;addr4);
     test_eq(gen_info-&gt;port, par_info-&gt;port);
   }
   tor_free(intro_points_encrypted);
Index: or/router.c
===================================================================
--- or/router.c	(Revision 12621)
+++ or/router.c	(Arbeitskopie)
@@ -1049,11 +1049,13 @@
 
   /* make sure it's resolved to something. this way we can't get a
      'maybe' below. */
-  if (!conn-&gt;_base.addr)
+  if (conn-&gt;_base.socket_family == AF_INET &amp;&amp; !conn-&gt;_base.addr4)
     return -1;
 
-  return compare_addr_to_addr_policy(conn-&gt;_base.addr, conn-&gt;_base.port,
-                   desc_routerinfo-&gt;exit_policy) != ADDR_POLICY_ACCEPTED;
+  if (conn-&gt;_base.socket_family == AF_INET)
+    return compare_addr_to_addr_policy(conn-&gt;_base.addr4, conn-&gt;_base.port,
+                     desc_routerinfo-&gt;exit_policy) != ADDR_POLICY_ACCEPTED;
+  return 0; //TODO: support an ipv6 exit-policy
 }
 
 /** Return true iff I'm a server and &lt;b&gt;digest&lt;/b&gt; is equal to
Index: or/cpuworker.c
===================================================================
--- or/cpuworker.c	(Revision 12621)
+++ or/cpuworker.c	(Arbeitskopie)
@@ -468,7 +468,11 @@
       log_info(LD_OR,"circ-&gt;p_conn gone. Failing circ.");
       return -1;
     }
-    tag_pack(tag, circ-&gt;p_conn-&gt;_base.addr, circ-&gt;p_conn-&gt;_base.port,
+    if (circ-&gt;p_conn-&gt;_base.socket_family == AF_INET6) {
+      log_info(LD_OR,"we do not support ipv6 in assign_to_cpuworker().");
+      return -1;
+    }
+    tag_pack(tag, circ-&gt;p_conn-&gt;_base.addr4, circ-&gt;p_conn-&gt;_base.port,
              circ-&gt;p_circ_id);
 
     cpuworker-&gt;state = CPUWORKER_STATE_BUSY_ONION;
Index: or/circuitbuild.c
===================================================================
--- or/circuitbuild.c	(Revision 12621)
+++ or/circuitbuild.c	(Arbeitskopie)
@@ -350,7 +350,11 @@
   tor_assert(firsthop-&gt;extend_info);
 
   /* now see if we're already connected to the first OR in 'route' */
-  in.s_addr = htonl(firsthop-&gt;extend_info-&gt;addr);
+  if (firsthop-&gt;extend_info-&gt;family == AF_INET6) {
+     log_info(LD_CIRC,"we do not support Ipv6 for firsthop yet. Closing.");
+     return -END_CIRC_REASON_CONNECTFAILED;
+  }
+  in.s_addr = htonl(firsthop-&gt;extend_info-&gt;addr4);
   tor_inet_ntoa(&amp;in, tmpbuf, sizeof(tmpbuf));
   log_debug(LD_CIRC,"Looking for firsthop '%s:%u'",tmpbuf,
             firsthop-&gt;extend_info-&gt;port);
@@ -367,11 +371,13 @@
        router_digest_version_as_new_as(firsthop-&gt;extend_info-&gt;identity_digest,
                                        "0.1.1.9-alpha-cvs"))) {
     /* not currently connected */
-    circ-&gt;_base.n_addr = firsthop-&gt;extend_info-&gt;addr;
-    circ-&gt;_base.n_port = firsthop-&gt;extend_info-&gt;port;
+    circ-&gt;_base.n_family = firsthop-&gt;extend_info-&gt;family;
+    circ-&gt;_base.n_addr4  = firsthop-&gt;extend_info-&gt;addr4;
+    circ-&gt;_base.n_addr6  = firsthop-&gt;extend_info-&gt;addr6;
+    circ-&gt;_base.n_port   = firsthop-&gt;extend_info-&gt;port;
 
     if (!n_conn || n_conn-&gt;_base.or_is_obsolete) { /* launch the connection */
-      n_conn = connection_or_connect(firsthop-&gt;extend_info-&gt;addr,
+      n_conn = connection_or_connect(firsthop-&gt;extend_info-&gt;addr4,
                                      firsthop-&gt;extend_info-&gt;port,
                                      firsthop-&gt;extend_info-&gt;identity_digest);
       if (!n_conn) { /* connect failed, forget the whole thing */
@@ -387,7 +393,9 @@
      */
     return 0;
   } else { /* it's already open. use it. */
-    circ-&gt;_base.n_addr = n_conn-&gt;_base.addr;
+    circ-&gt;_base.n_addr6 = n_conn-&gt;_base.addr6;
+    circ-&gt;_base.n_addr4 = n_conn-&gt;_base.addr4;
+    circ-&gt;_base.n_family = n_conn-&gt;_base.socket_family;
     circ-&gt;_base.n_port = n_conn-&gt;_base.port;
     circ-&gt;_base.n_conn = n_conn;
     log_debug(LD_CIRC,"Conn open. Delivering first onion skin.");
@@ -399,6 +407,19 @@
   return 0;
 }
 
+/** compare the 2 given ipv6-addresses
+ *
+ * returns 0 if they are equal.
+ */
+int compare_in6_addr(struct in6_addr a, struct in6_addr b) {
+  int i;
+  for (i=0; i&lt;16; i++) {
+    if (a.s6_addr[i] != b.s6_addr[i])
+       return 1;
+  }
+  return 0;
+}
+
 /** Find any circuits that are waiting on &lt;b&gt;or_conn&lt;/b&gt; to become
  * open and get them to send their create cells forward.
  *
@@ -426,7 +447,9 @@
         continue;
       if (tor_digest_is_zero(circ-&gt;n_conn_id_digest)) {
         /* Look at addr/port. This is an unkeyed connection. */
-        if (circ-&gt;n_addr != or_conn-&gt;_base.addr ||
+        if (circ-&gt;n_family != or_conn-&gt;_base.socket_family ||
+	    (circ-&gt;n_family == AF_INET  &amp;&amp; circ-&gt;n_addr4 != or_conn-&gt;_base.addr4) ||
+	    (circ-&gt;n_family == AF_INET6 &amp;&amp; compare_in6_addr(circ-&gt;n_addr6, \
or_conn-&gt;_base.addr6) != 0) ||  circ-&gt;n_port != or_conn-&gt;_base.port)
           continue;
         /* now teach circ the right identity_digest */
@@ -652,7 +675,12 @@
       return 0;
     }
 
-    set_uint32(payload, htonl(hop-&gt;extend_info-&gt;addr));
+    if (hop-&gt;extend_info-&gt;family == AF_INET6) {
+        log(LOG_NOTICE, LD_GENERAL,
+            "circuit_send_next_onion_skin() - we do not support ipv6 for next hops \
yet. Ignoring."); +        return 0;
+    }
+    set_uint32(payload, htonl(hop-&gt;extend_info-&gt;addr4));
     set_uint16(payload+4, htons(hop-&gt;extend_info-&gt;port));
 
     onionskin = payload+2+4;
@@ -733,7 +761,8 @@
     return -1;
   }
 
-  circ-&gt;n_addr = ntohl(get_uint32(cell-&gt;payload+RELAY_HEADER_SIZE));
+  circ-&gt;n_family = AF_INET;
+  circ-&gt;n_addr4 = ntohl(get_uint32(cell-&gt;payload+RELAY_HEADER_SIZE));
   circ-&gt;n_port = ntohs(get_uint16(cell-&gt;payload+RELAY_HEADER_SIZE+4));
 
   onionskin = cell-&gt;payload+RELAY_HEADER_SIZE+4+2;
@@ -748,7 +777,11 @@
      router_digest_version_as_new_as(id_digest,"0.1.1.9-alpha-cvs"))) {
     struct in_addr in;
     char tmpbuf[INET_NTOA_BUF_LEN];
-    in.s_addr = htonl(circ-&gt;n_addr);
+    if (circ-&gt;n_family == AF_INET6) {
+      log_info(LD_CIRC|LD_OR, "Next router is on an ipv6-address. we do not support \
this yet."); +      return 0;
+    }
+    in.s_addr = htonl(circ-&gt;n_addr4);
     tor_inet_ntoa(&amp;in,tmpbuf,sizeof(tmpbuf));
     log_info(LD_CIRC|LD_OR,"Next router (%s:%d) not connected. Connecting.",
              tmpbuf, circ-&gt;n_port);
@@ -761,11 +794,18 @@
     memcpy(circ-&gt;n_conn_id_digest, id_digest, DIGEST_LEN);
 
     if (n_conn &amp;&amp; !n_conn-&gt;_base.or_is_obsolete) {
-      circ-&gt;n_addr = n_conn-&gt;_base.addr;
+      circ-&gt;n_family = n_conn-&gt;_base.socket_family;
+      circ-&gt;n_addr4 = n_conn-&gt;_base.addr4;
+      circ-&gt;n_addr6 = n_conn-&gt;_base.addr6;
       circ-&gt;n_port = n_conn-&gt;_base.port;
     } else {
      /* we should try to open a connection */
-      n_conn = connection_or_connect(circ-&gt;n_addr, circ-&gt;n_port, id_digest);
+      if (circ-&gt;n_family == AF_INET6) {
+        log_info(LD_CIRC,"Cannot launch n_conn because we do not support ipv6 \
between nodes yet. Closing circuit."); +        circuit_mark_for_close(circ, \
END_CIRC_REASON_CONNECTFAILED); +        return 0;
+      }
+      n_conn = connection_or_connect(circ-&gt;n_addr4, circ-&gt;n_port, id_digest);
       if (!n_conn) {
         log_info(LD_CIRC,"Launching n_conn failed. Closing circuit.");
         circuit_mark_for_close(circ, END_CIRC_REASON_CONNECTFAILED);
@@ -781,7 +821,9 @@
   }
 
   /* these may be different if the router connected to us from elsewhere */
-  circ-&gt;n_addr = n_conn-&gt;_base.addr;
+  circ-&gt;n_family = n_conn-&gt;_base.socket_family;
+  circ-&gt;n_addr4 = n_conn-&gt;_base.addr4;
+  circ-&gt;n_addr6 = n_conn-&gt;_base.addr6;
   circ-&gt;n_port = n_conn-&gt;_base.port;
 
   circ-&gt;n_conn = n_conn;
@@ -1008,7 +1050,16 @@
                                circ-&gt;p_conn, &amp;cell, CELL_DIRECTION_IN);
   log_debug(LD_CIRC,"Finished sending 'created' cell.");
 
-  if (!is_local_IP(circ-&gt;p_conn-&gt;_base.addr) &amp;&amp;
+  if (circ-&gt;p_conn-&gt;_base.socket_family == AF_INET6) {
+     log_debug(LD_CIRC,"not checking is_local_IP because we do not support ipv6 \
yet."); +     if(connection_or_nonopen_was_started_here(circ-&gt;p_conn)) {
+       /* record that we could process create cells from a non-local conn
+        * that we didn't initiate; presumably this means that create cells
+        * can reach us too. */
+       router_orport_found_reachable();
+      }
+  } else
+  if (!is_local_IP(circ-&gt;p_conn-&gt;_base.addr4) &amp;&amp;
       !connection_or_nonopen_was_started_here(circ-&gt;p_conn)) {
     /* record that we could process create cells from a non-local conn
      * that we didn't initiate; presumably this means that create cells
@@ -1749,7 +1800,8 @@
     strlcpy(info-&gt;nickname, nickname, sizeof(info-&gt;nickname));
   if (onion_key)
     info-&gt;onion_key = crypto_pk_dup_key(onion_key);
-  info-&gt;addr = addr;
+  info-&gt;family = AF_INET;
+  info-&gt;addr4 = addr;
   info-&gt;port = port;
   return info;
 }
Index: or/dnsserv.c
===================================================================
--- or/dnsserv.c	(Revision 12621)
+++ or/dnsserv.c	(Arbeitskopie)
@@ -116,9 +116,10 @@
   conn-&gt;_base.state = AP_CONN_STATE_RESOLVE_WAIT;
   conn-&gt;is_dns_request = 1;
 
-  TO_CONN(conn)-&gt;addr = ntohl(sin-&gt;sin_addr.s_addr);
+  TO_CONN(conn)-&gt;socket_family = AF_INET;
+  TO_CONN(conn)-&gt;addr4 = ntohl(sin-&gt;sin_addr.s_addr);
   TO_CONN(conn)-&gt;port = ntohs(sin-&gt;sin_port);
-  TO_CONN(conn)-&gt;address = tor_dup_addr(TO_CONN(conn)-&gt;addr);
+  TO_CONN(conn)-&gt;address = tor_dup_addr(TO_CONN(conn)-&gt;addr4);
 
   if (q-&gt;type == EVDNS_TYPE_A)
     conn-&gt;socks_request-&gt;command = SOCKS_COMMAND_RESOLVE;
Index: or/rendclient.c
===================================================================
--- or/rendclient.c	(Revision 12621)
+++ or/rendclient.c	(Arbeitskopie)
@@ -117,10 +117,14 @@
   if (entry-&gt;parsed-&gt;protocols &amp; (1&lt;&lt;2)) {
     /* version 2 format */
     extend_info_t *extend_info = rendcirc-&gt;build_state-&gt;chosen_exit;
+    if (extend_info-&gt;family == AF_INET6) {
+      log_warn(LD_BUG, "we do not support ipv6 in rend_client_send_introduction");
+      goto err;
+      }
     int klen;
     tmp[0] = 2; /* version 2 of the cell format */
     /* nul pads */
-    set_uint32(tmp+1, htonl(extend_info-&gt;addr));
+    set_uint32(tmp+1, htonl(extend_info-&gt;addr4));
     set_uint16(tmp+5, htons(extend_info-&gt;port));
     memcpy(tmp+7, extend_info-&gt;identity_digest, DIGEST_LEN);
     klen = crypto_pk_asn1_encode(extend_info-&gt;onion_key, tmp+7+DIGEST_LEN+2,
@@ -505,7 +509,7 @@
         entry-&gt;parsed-&gt;n_intro_points &gt; 0) {
       /* either this fetch worked, or it failed but there was a
        * valid entry from before which we should reuse */
-      log_info(LD_REND,"Rend desc is usable. Launching circuits.");
+      log_info(LD_REND,"Rend desc for hidden service '%s.onion' is usable. Launching \
circuits.", safe_str(query));  conn-&gt;_base.state = AP_CONN_STATE_CIRCUIT_WAIT;
 
       /* restart their timeout values, so they get a fair shake at
@@ -516,12 +520,12 @@
 
       if (connection_ap_handshake_attach_circuit(conn) &lt; 0) {
         /* it will never work */
-        log_warn(LD_REND,"Rendezvous attempt failed. Closing.");
+        log_warn(LD_REND,"Rendezvous attempt for hidden service '%s.onion' failed. \
                Closing.", safe_str(query));
         connection_mark_unattached_ap(conn, END_STREAM_REASON_CANT_ATTACH);
       }
     } else { /* 404, or fetch didn't get that far */
       log_notice(LD_REND,"Closing stream for '%s.onion': hidden service is "
-                 "unavailable (try again later).", safe_str(query));
+                 "unavailable (try again later). entry-&gt;parsed-&gt;n_intro_points=%i", \
                safe_str(query), entry-&gt;parsed-&gt;n_intro_points);
       connection_mark_unattached_ap(conn, END_STREAM_REASON_RESOLVEFAILED);
     }
   });
Index: common/util.c
===================================================================
--- common/util.c	(Revision 12621)
+++ common/util.c	(Arbeitskopie)
@@ -2223,13 +2223,13 @@
     _address = tor_strndup(addrport, colon-addrport);
     _port = (int) tor_parse_long(colon+1,10,1,65535,NULL,NULL);
     if (!_port) {
-      log_fn(severity, LD_GENERAL, "Port %s out of range", escaped(colon+1));
+      log_fn(severity, LD_GENERAL, "ipv4-Port %s out of range", escaped(colon+1));
       ok = 0;
     }
     if (!port_out) {
       char *esc_addrport = esc_for_log(addrport);
       log_fn(severity, LD_GENERAL,
-             "Port %s given on %s when not required",
+             "ipv4-Port %s given on %s when not required",
              escaped(colon+1), esc_addrport);
       tor_free(esc_addrport);
       ok = 0;
@@ -2241,8 +2241,8 @@
 
   if (addr) {
     /* There's an addr pointer, so we need to resolve the hostname. */
-    if (tor_lookup_hostname(_address,addr)) {
-      log_fn(severity, LD_NET, "Couldn't look up %s", escaped(_address));
+    if (tor_lookup_hostname(_address, addr)) {
+      log_fn(severity, LD_NET, "Couldn't look up ipv4 %s", escaped(_address));
       ok = 0;
       *addr = 0;
     }
@@ -2260,7 +2260,81 @@
 
   return ok ? 0 : -1;
 }
+/** Parse a string of the form "[host]" and "[host]:port" from &lt;b&gt;addrport&lt;/b&gt;.  If
+ * &lt;b&gt;address&lt;/b&gt; is provided, set *&lt;b&gt;address&lt;/b&gt; to a copy of the
+ * host portion of the string.  If &lt;b&gt;addr&lt;/b&gt; is provided, try to
+ * resolve the host portion of the string and store it into
+ * *&lt;b&gt;addr&lt;/b&gt;.  If &lt;b&gt;port_out&lt;/b&gt; is provided,
+ * store the port number into *&lt;b&gt;port_out&lt;/b&gt;, or 0 if no port is given.
+ * If &lt;b&gt;port_out&lt;/b&gt; is NULL, then there must be no port number in
+ * &lt;b&gt;addrport&lt;/b&gt;.
+ * Return 0 on success, -1 on failure.
+ */
+int
+parse_addr6_port(int severity, const char *addrport, char **address,
+                struct in6_addr *addr, uint16_t *port_out)
+{
+  const char *colon;
+  char *_address = NULL;
+  int _port;
+  int ok = 1;
 
+  tor_assert(addrport);
+
+  colon = strstr(addrport, "]:");
+  if (colon) {
+    _address = tor_strndup(addrport, colon - addrport);
+    _port = (int) tor_parse_long(colon + 2, 10, 1, 65535, NULL, NULL);
+    log_fn(severity, LD_NET, "DEBUG ipv6 incl [ and ] is: %s port is %i", \
escaped(_address), _port); +    if (!_port) {
+      log_fn(severity, LD_GENERAL, "ipv6-Port %s out of range", escaped(colon+1));
+      ok = 0;
+    }
+    if (!port_out) {
+      char *esc_addrport = esc_for_log(addrport);
+      log_fn(severity, LD_GENERAL,
+             "ipv6-Port %s given on %s when not required",
+             escaped(colon+1), esc_addrport);
+      tor_free(esc_addrport);
+      ok = 0;
+    }
+  } else {
+    _address = tor_strdup(addrport);
+    _port = 0;
+    log_fn(severity, LD_NET, "DEBUG ipv6 incl [ and ] is: %s port is default", \
escaped(_address)); +  }
+  log_fn(severity, LD_NET, "DEBUG ipv6 incl [ and ] is: %s", escaped(_address));
+  const char *end = strstr(_address, "]");
+  if (end)
+    _address = tor_strndup(_address, end - _address);
+  log_fn(severity, LD_NET, "DEBUG ipv6 incl [ is: %s", escaped(_address));
+  const char *start = strstr(_address, "[");
+  if (start)
+    _address = (char *) start + 1;
+  log_fn(severity, LD_NET, "DEBUG ipv6 without [ is: %s", escaped(_address));
+
+  if (addr) {
+    /* There's an addr pointer, so we need to resolve the hostname. */
+    if (tor_lookup_hostname6(_address, addr)) {
+      log_fn(severity, LD_NET, "Couldn't look up ipv6 %s", escaped(_address));
+      ok = 0;
+      //*addr = 0;
+    }
+  }
+
+  if (address &amp;&amp; ok) {
+    *address = _address;
+  } else {
+    if (address)
+      *address = NULL;
+//TODO    tor_free(_address);
+  }
+  if (port_out)
+    *port_out = ok ? ((uint16_t) _port) : 0;
+
+  return ok ? 0 : -1;
+}
+
 /** If &lt;b&gt;mask&lt;/b&gt; is an address mask for a bit-prefix, return the number of
  * bits.  Otherwise, return -1. */
 int
@@ -2827,6 +2901,18 @@
  *  and return a strdup of the resulting address.
  */
 char *
+tor_dup_addr6(struct in6_addr addr)
+{
+  char buf[42];
+
+  tor_inet_ntop(AF_INET6, &amp;addr, buf, sizeof(buf));
+  return tor_strdup(buf);
+}
+
+/** Given a host-order &lt;b&gt;addr&lt;/b&gt;, call tor_inet_ntop() on it
+ *  and return a strdup of the resulting address.
+ */
+char *
 tor_dup_addr(uint32_t addr)
 {
   char buf[TOR_ADDR_BUF_LEN];
Index: common/util.h
===================================================================
--- common/util.h	(Revision 12621)
+++ common/util.h	(Arbeitskopie)
@@ -271,6 +271,8 @@
 int is_internal_IP(uint32_t ip, int for_listening) ATTR_PURE;
 int parse_addr_port(int severity, const char *addrport, char **address,
                     uint32_t *addr, uint16_t *port_out);
+int parse_addr6_port(int severity, const char *addrport, char **address,
+                    struct in6_addr *addr, uint16_t *port_out);
 int parse_port_range(const char *port, uint16_t *port_min_out,
                      uint16_t *port_max_out);
 int parse_addr_and_port_range(const char *s, uint32_t *addr_out,
@@ -280,6 +282,7 @@
 int addr_mask_cmp_bits(uint32_t a1, uint32_t a2, maskbits_t bits);
 int tor_inet_ntoa(const struct in_addr *in, char *buf, size_t buf_len);
 char *tor_dup_addr(uint32_t addr) ATTR_MALLOC;
+char *tor_dup_addr6(struct in6_addr addr) ATTR_MALLOC;
 int get_interface_address(int severity, uint32_t *addr);
 
 int get_interface_address6(int severity, sa_family_t family, tor_addr_t *addr);
Index: common/compat.c
===================================================================
--- common/compat.c	(Revision 12621)
+++ common/compat.c	(Arbeitskopie)
@@ -834,6 +834,16 @@
  * but works on Windows and Solaris.)
  */
 int
+tor_inet_aton6(const char *c, struct in6_addr* addr)
+{
+ return tor_inet_pton(AF_INET6, c, addr);
+}
+
+/** Set *addr to the IP address (in dotted-quad notation) stored in c.
+ * Return 1 on success, 0 if c is badly formatted.  (Like inet_aton(c,addr),
+ * but works on Windows and Solaris.)
+ */
+int
 tor_inet_aton(const char *c, struct in_addr* addr)
 {
 #ifdef HAVE_INET_ATON
@@ -1052,6 +1062,30 @@
  * doesn't treat raw IP addresses properly.)
  */
 int
+tor_lookup_hostname6(const char *name, struct in6_addr *addr)
+{
+  tor_addr_t myaddr;
+  int ret;
+
+  if ((ret = tor_addr_lookup(name, AF_INET6, &amp;myaddr)))
+    return ret;
+
+  if (IN_FAMILY(&amp;myaddr) == AF_INET6) {
+    *addr = myaddr.sa6.sin6_addr;
+    return ret;
+  }
+
+  return -1;
+}
+
+/** Similar behavior to Unix gethostbyname: resolve &lt;b&gt;name&lt;/b&gt;, and set
+ * *&lt;b&gt;addr&lt;/b&gt; to the proper IP address, in host byte order.  Returns 0
+ * on success, -1 on failure; 1 on transient failure.
+ *
+ * (This function exists because standard windows gethostbyname
+ * doesn't treat raw IP addresses properly.)
+ */
+int
 tor_lookup_hostname(const char *name, uint32_t *addr)
 {
   tor_addr_t myaddr;
@@ -1086,7 +1120,7 @@
   struct in6_addr iaddr6;
   tor_assert(name);
   tor_assert(addr);
-  tor_assert(family == AF_INET || family == AF_UNSPEC);
+  tor_assert(family == AF_INET || family == AF_INET6 || family == AF_UNSPEC);
   memset(addr, 0, sizeof(addr)); /* Clear the extraneous fields. */
   if (!*name) {
     /* Empty address is an error. */
Index: common/compat.h
===================================================================
--- common/compat.h	(Revision 12621)
+++ common/compat.h	(Arbeitskopie)
@@ -389,9 +389,11 @@
 #define TOR_ADDR_BUF_LEN 46 /* ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255 */
 
 int tor_inet_aton(const char *cp, struct in_addr *addr) ATTR_NONNULL((1,2));
+int tor_inet_aton6(const char *cp, struct in6_addr *addr) ATTR_NONNULL((1,2));
 const char *tor_inet_ntop(int af, const void *src, char *dst, size_t len);
 int tor_inet_pton(int af, const char *src, void *dst);
 int tor_lookup_hostname(const char *name, uint32_t *addr) ATTR_NONNULL((1,2));
+int tor_lookup_hostname6(const char *name, struct in6_addr *addr) \
ATTR_NONNULL((1,2));  void set_socket_nonblocking(int socket);
 int tor_socketpair(int family, int type, int protocol, int fd[2]);
 int network_init(void);


["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20071204051122</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-12-04 05:11:22-0400</timestampReceived><subject>Re: Tor Ipv6-Patch</subject><body>


On Mon, Dec 03, 2007 at 11:51:29PM +0100, Marcus Wolschon wrote:
&gt; 
&gt; Dear list,
&gt; 
&gt; I wrote an extensive patch to make tor support
&gt; * hidden services on ipv6-addresses
&gt; * binding for socks on an ipv6-address
&gt; * convert a lot of the internal data-structures for the comming full
&gt; ipv6-support.
&gt; 
&gt; I wrote it to tor-volunteers@torproject.org on friday but got no
&gt; answer thus I am posting them here.
&gt; 
&gt; The code may not use the prefered naming-conventions or the
&gt; tor_address_t -data-structure (because that one uses socket_addr
&gt; and we only need the actual address-part) but I guess a refactoring
&gt; for it to meet the coding-guidelines is far less work then writing it
&gt; and getting it to work in the first place.

Hi, Marcus!  Thanks, and good job!  The 0.2.0.x series is in
feature-freeze now, but I'll save this patch to be sure to merge it once
0.2.1.x is branched.

A few general points below in case you (or somebody else) wants to work
on this patch some more.  None of these are show-stoppers, but fixing
them will make the patch better.

 - You're right that the preferred way to store addresses that could be
   either IPv4 or IPv6 is indeed with tor_addr_t.  (Thanks for the
   reminder, BTW: I fixed tor_addr_t to be a tagged union of in_addr and
   in6_addr, not of sockaddr_in and sockaddr_in6.)

 - Generally speaking, we try to avoid duplicated "cut and paste" code;
   it makes it hard to be sure that we can update all instances of the
   original code path.  (connection_or_init_conn_from_address6, for
   example, is almost exactly the same as the existing
   connection_init_conn_from_address.)

 - It's good to break up patches into functional parts, since shorter
   patches are way easier to review.  For example, this patch includes
   lots of log cleanups that make the logs say "hidden service" instead
   of "service".  That's a cleanup, and that can go into 0.2.0.x on its
   own, but it doesn't seem to be dependent much on the rest of the
   patch.  Also, the different functional changes could probably be
   separated.

Thanks again for your patch!  I've wanted IPv6 support for a long time;
it will be great to finally get it in.

peace,
-- 
Nick




[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20071204082325</emailId><senderName>Marcus Wolschon - Wolschon Softwaredesign</senderName><senderEmail>marcus@wolschon.biz</senderEmail><timestampReceived>2007-12-04 08:23:25-0400</timestampReceived><subject>Re: Tor Ipv6-Patch</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Hello Nick,

Nick Mathewson schrieb:
&gt;  - You're right that the preferred way to store addresses that could be
&gt;    either IPv4 or IPv6 is indeed with tor_addr_t.  (Thanks for the
&gt;    reminder, BTW: I fixed tor_addr_t to be a tagged union of in_addr and
&gt;    in6_addr, not of sockaddr_in and sockaddr_in6.)

do you want to do the refactoring to use tor_address_t or shall I?
So we need a pair of tor_address_t and int socket_family. Wouldn't it
be better to have the socket_family in a struct with the tor_address_t
- -union? That way it would probably be a drop-in -replacement for the
32bit-addresses.

&gt;  - Generally speaking, we try to avoid duplicated "cut and paste" code;
&gt;    it makes it hard to be sure that we can update all instances of the
&gt;    original code path.  (connection_or_init_conn_from_address6, for
&gt;    example, is almost exactly the same as the existing
&gt;    connection_init_conn_from_address.)

I tried to do if-then where it would not double the size of
the method. With tor_address_t this will probably be needed in
far less places.

&gt; 
&gt;  - For example, this patch includes
&gt;    lots of log cleanups that make the logs say "hidden service" instead
&gt;    of "service".  That's a cleanup, and that can go into 0.2.0.x on its
&gt;    own, but it doesn't seem to be dependent much on the rest of the
&gt;    patch.

Yes, I changed that log-lined during debugging, so I could easily grep
in the debug-log while it scrolls by.

&gt;  Also, the different functional changes could probably be
&gt;    separated.

The ipv6-socks-listen is just a few lines (since it already does
ipv4+AF_UNIX) and depends on the infrastructure the ipv6-hidden-
services need.

PS:
Is there already a spec for the changes to the protocoll needed to
fully support ipv6?
* determining if a node has ipv6-connectivity (not just ipv6-support
  in the ip-stack)
* asking directory-servers with a bitmask or similar of the
  socket-families you support
* adressing nodes that have multiple (types of) addresses. (probably
  can be ignored and theated as 2 nodes for quite a while)
* changing the protocoll to have a socket-family and space for larger
  addresses.

Marcus


- --
 Marcus Wolschon
 Wolschon Softwaredesign und Beratung
 UStID: DE238951181
 Marcus@Wolschon.biz
 +49 177/6272871 (m-a-r-c-u-s-1)
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFHVQ59f1hPnk3Z0cQRAuhbAJ9YZXDVC9v7n5pdgpDlUfF5E8TKKQCgwwIT
/OaM8hbJyGyFe2SQgX/5tt8=
=Fii9
-----END PGP SIGNATURE-----
</body></email><email><emailId>20071204083646</emailId><senderName>"anon ymous"</senderName><senderEmail>a.y.main.contact@googlemail.com</senderEmail><timestampReceived>2007-12-04 08:36:46-0400</timestampReceived><subject>Re: Tor Ipv6-Patch</subject><body>

Hello Marcus,

good to see that you did implement it after our chat-session.
Sorry I could not be of much help with my rusty C/C++.

I notices a very small memory-leak in
parse_addr6_port()
in the line
//TODO    tor_free(_address);

I guess we should remember the original _address
without the "start +1" and simila in another variable
so we can free it later.


A.Y.
</body></email><email><emailId>20071204125804</emailId><senderName>"Michael G. Reed"</senderName><senderEmail>reed@inet.org</senderEmail><timestampReceived>2007-12-04 12:58:04-0400</timestampReceived><subject>Re: Tor Ipv6-Patch</subject><body>

On Tue, 4 Dec 2007, Nick Mathewson wrote:
|&gt;  - You're right that the preferred way to store addresses that could be
|&gt;    either IPv4 or IPv6 is indeed with tor_addr_t.  (Thanks for the
|&gt;    reminder, BTW: I fixed tor_addr_t to be a tagged union of in_addr and
|&gt;    in6_addr, not of sockaddr_in and sockaddr_in6.)

Not sure if it applies in this case or not (I'm looking at this
comment from 50,000 feet, not having looked at the actual usage/code),
but an in6_addr is insufficient to fully specify all IPv6 addresses
(it is fine for global-scope addresses, but cannot handle
link/site-scoped addresses -- if there is any chance of a scoped
address, you must use either a sockaddr_in6, or a in6_addr with
another field to specify the next hop interface either textually (if
external), or numerically (if in-system)).  Since routers (in the
OSPFv3/RIPng sense that is) are encouraged to use link-local next
hops, you will see sockaddr_in6's prevalent in that sort of
development...  Again, may not apply here, but thought I would throw
that out (I've done just a wee-bit of IPv6 router coding in the
not-so-distant past :).

-Michael

</body></email><email><emailId>20071204130350</emailId><senderName>"Michael G. Reed"</senderName><senderEmail>reed@inet.org</senderEmail><timestampReceived>2007-12-04 13:03:50-0400</timestampReceived><subject>Re: Tor Ipv6-Patch</subject><body>

On Tue, 4 Dec 2007, Marcus Wolschon - Wolschon Softwaredesign wrote:
|&gt; &gt;  - You're right that the preferred way to store addresses that could be
|&gt; &gt;    either IPv4 or IPv6 is indeed with tor_addr_t.  (Thanks for the
|&gt; &gt;    reminder, BTW: I fixed tor_addr_t to be a tagged union of in_addr and
|&gt; &gt;    in6_addr, not of sockaddr_in and sockaddr_in6.)
|&gt; 
|&gt; do you want to do the refactoring to use tor_address_t or shall I?
|&gt; So we need a pair of tor_address_t and int socket_family. Wouldn't it
|&gt; be better to have the socket_family in a struct with the tor_address_t
|&gt; - -union? That way it would probably be a drop-in -replacement for the
|&gt; 32bit-addresses.

This is exactly why multi-protocol developers normally use
sockaddr_storage to define the space for an address they do not know
the type of in advance and then rely on the sa_family field to
differentiate.  sockaddr_storage is guaranteed to be large enough to
hold the largest supported address type in the system (not
efficient/desirable/usable for on-the-wire, but is best used in
application processing).

-Michael

</body></email><email><emailId>20071204131802</emailId><senderName>Marcus Wolschon</senderName><senderEmail>marcus@wolschon.biz</senderEmail><timestampReceived>2007-12-04 13:18:02-0400</timestampReceived><subject>Re: Tor Ipv6-Patch</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Michael G. Reed schrieb:
&gt; On Tue, 4 Dec 2007, Nick Mathewson wrote:
&gt; |&gt;  - You're right that the preferred way to store addresses that could be
&gt; |&gt;    either IPv4 or IPv6 is indeed with tor_addr_t.  (Thanks for the
&gt; |&gt;    reminder, BTW: I fixed tor_addr_t to be a tagged union of in_addr and
&gt; |&gt;    in6_addr, not of sockaddr_in and sockaddr_in6.)
&gt; 
&gt; Not sure if it applies in this case or not (I'm looking at this
&gt; comment from 50,000 feet, not having looked at the actual usage/code),
&gt; but an in6_addr is insufficient to fully specify all IPv6 addresses
&gt; (it is fine for global-scope addresses, but cannot handle
&gt; link/site-scoped addresses -

Hello Michael,

inside tor we only deal with addresses we are listening on and
the addresses of target-hosts and tor-servers.
I am aware of the scope-field but do not think there is need for
this in tor. Routing is done by the underlying operating-system
and as far as I could see we never deal with nexthops or the
local default-router but instead only with global scoped addresses
and ::1 .
Is anyone aware of a place in tor where this may be an issue?

The only place I could imaging is some user manually binding
tor to a fe80:... but this will fail as soon as privacy-enhancements
are enabled as the link-local-address changes and does not reveal
the mac-address. (As far as I understood that feature.)
If that host has no global ipv6-address at all, it cannot have a route
to the outside world (no NAT in ipv6 on purpose) thus a tor-node with
no global-scoped address would be useless.

Marcus
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFHVVOKf1hPnk3Z0cQRAstrAKCoZkINfMLOcgZfcRWRtb5oK77BFACgtlJ3
AlygQCWujPEPlW28jZS+Va4=
=GF4S
-----END PGP SIGNATURE-----
</body></email><email><emailId>20071204134240</emailId><senderName>Karsten Loesing</senderName><senderEmail>karsten.loesing@gmx.net</senderEmail><timestampReceived>2007-12-04 13:42:40-0400</timestampReceived><subject>Re: Tor Ipv6-Patch</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Hi Marcus,

&gt; I wrote an extensive patch to make tor support
&gt; * hidden services on ipv6-addresses

I've had a quick look on your changes and would like to point out some
issues related to hidden services:

- - You changed encoding of v2 hidden service descriptors, so that
introduction points can be addressed via IPv6 in
rend_encode_v2_intro_points(), but I think you did not change parsing of
those descriptors, so that descriptors containing introduction points
with IPv6 addresses would be rejected; see
rend_decrypt_introduction_points().

- - Even without your changes, the 0.2.0.x code should be more tolerant
with hidden service descriptors containing IPv6 addresses for
introduction points. Currently, the whole descriptor would be rejected.
But if newer Tor versions could encode both introduction points with
IPv4 and IPv6 addresses, current versions could at least keep the IPv4
introduction points and discard only the IPv6 ones. Otherwise we might
need a new descriptor version only for understanding IPv6 addresses,
which does not really make sense.

- - When supporting IPv6 for introduction points and the actual service,
rendezvous points should also be addressable using IPv6. This requires
using v3 INTRODUCE2 cells or something similar (see rend-spec.txt
section 1.8.1). Maybe that cell format should be implemented in this
context, too. However, it still requires some thinking about proposal
121 on hidden service authentication in order to incorporate all
necessary changes in one step. For 0.2.1.x?

&gt; The code may not use the prefered naming-conventions [...]

Hmm, maybe you also want to run "make check-spaces". At least that's
what I was told when starting to write code for Tor. :)

- --Karsten
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFHVVlQ0M+WPffBEmURAj5CAKCgtQRVWDQ7+p4gkR6pmssckdTtwACgw560
+YLSMocSRO5V+oiCmsc+2jw=
=0Xjs
-----END PGP SIGNATURE-----
</body></email><email><emailId>20071204134926</emailId><senderName>"Michael G. Reed"</senderName><senderEmail>reed@inet.org</senderEmail><timestampReceived>2007-12-04 13:49:26-0400</timestampReceived><subject>Re: Tor Ipv6-Patch</subject><body>

On Tue, 4 Dec 2007, Marcus Wolschon wrote:
|&gt; &gt; |&gt;  - You're right that the preferred way to store addresses that could be
|&gt; &gt; |&gt;    either IPv4 or IPv6 is indeed with tor_addr_t.  (Thanks for the
|&gt; &gt; |&gt;    reminder, BTW: I fixed tor_addr_t to be a tagged union of in_addr and
|&gt; &gt; |&gt;    in6_addr, not of sockaddr_in and sockaddr_in6.)
|&gt; &gt; 
|&gt; &gt; Not sure if it applies in this case or not (I'm looking at this
|&gt; &gt; comment from 50,000 feet, not having looked at the actual usage/code),
|&gt; &gt; but an in6_addr is insufficient to fully specify all IPv6 addresses
|&gt; &gt; (it is fine for global-scope addresses, but cannot handle
|&gt; &gt; link/site-scoped addresses -
|&gt; 
|&gt; Hello Michael,
|&gt; 
|&gt; inside tor we only deal with addresses we are listening on and
|&gt; the addresses of target-hosts and tor-servers.
|&gt; I am aware of the scope-field but do not think there is need for
|&gt; this in tor. Routing is done by the underlying operating-system
|&gt; and as far as I could see we never deal with nexthops or the
|&gt; local default-router but instead only with global scoped addresses
|&gt; and ::1 .
|&gt; Is anyone aware of a place in tor where this may be an issue?

As I said, I haven't looked at the usage/code, so it may be a complete
non-issue.  I'm going off past history having done IPv6 work where
people made bad short-term decisions and then later had to refactor
because they forgot about the possibility of scoped addresses.

|&gt; The only place I could imaging is some user manually binding
|&gt; tor to a fe80:... but this will fail as soon as privacy-enhancements
|&gt; are enabled as the link-local-address changes and does not reveal
|&gt; the mac-address. (As far as I understood that feature.)
|&gt; If that host has no global ipv6-address at all, it cannot have a route
|&gt; to the outside world (no NAT in ipv6 on purpose) thus a tor-node with
|&gt; no global-scoped address would be useless.

No real routers use privacy-enhancements (they break OSPFv3), only
IPv6 hosts should use that if at all (the whole privacy-enhancements
are stupid in the first place IMHO - they really buy you nothing in
terms of privacy and make life a LOT uglier for intelligent L3/L4
switches/routers, but that's a separate issue not to mention dealing
with rogue nodes and blacklists).

Normally, a scoped address is used purely for forcing traffic out a
particular interface (IE, giving a restriction on the routing engine
on which way the traffic must go).  They make sense in a
point-to-point system/network where you are not relying on the normal
L3 global routing to get your traffic from point A to B -- in that
sense it is very TOR-like (IE, TOR picks the route thru the network
and tells the L3 network on a hop by hop basis how to get the traffic
to the destination)...of course, this breaks down because it relies on
the L3 network to actually route the traffic between nodes (because
nodes are rarely, if ever, directly connected to each other meaning we
need the L3 routing to move traffic inter-node).

-Michael

</body></email><email><emailId>20071001233120</emailId><senderName>"Michael_google gmail_Gersten"</senderName><senderEmail>keybounce@gmail.com</senderEmail><timestampReceived>2007-10-01 23:31:20-0400</timestampReceived><subject>Re: Turning off a server</subject><body>

&gt; &gt; AFAICS there's no way of turning off a server immediately, without actually
&gt; &gt; killing the tor process.
&gt; &gt;
&gt; &gt; What I mean by this is some controller command(s) that:
&gt; &gt;
&gt; &gt; - Closes all the server's ORCONNs immediately
&gt; &gt; - Sends a suicide descriptor to the authdirs.
&gt; &gt;
&gt; &gt; The use-case is the general user who runs a relay most of the time but
&gt; &gt; occasionally wants to toggle it off without disripting general use.
&gt;
&gt; I'd rather that users who want to stop being a server _not_ kill all
&gt; ORCONNs immediately: doing so kills all the active connections for
&gt; every user who's touching that server.
&gt;
&gt; Instead, I'd prefer that all circuits through that server die
&gt; naturally as clients time them out over the next 10-30 minutes, and
&gt; that the server stop accepting new circuits.  Does not that work in
&gt; practice?  If it doesn't work (because circuits stay open
&gt; indefinitely), I think the answer is to give existing circuits 5-10
&gt; minutes or so finish up.

It doesn't work. I have more than once closed my OrPort, and seen
heavy traffic (&gt;95% of bandwidth) for an hour. I can see &gt;40% traffic
for an hour and a half.

My thought:
If I want to die, I will send a "Circuit wants to be terminated"
message back upstream to the originating node. That node knows if the
circuit is in use or not, and can close it if it is not. * If it is in
use, at least that tor client knows not to open any new TCP
connections over that circuit.

I think that's the "missing" element. There is no way that I know of
for a circuit to refuse any new TCP connection while still staying
open for existing ones. And even better is being able to notify that
originating client that new TCP connections will be rejected before
hand, so that a new circuit can be prepared ahead of time.
</body></email><email><emailId>20071009225433</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-10-09 22:54:33-0400</timestampReceived><subject>Re: Turning off a server</subject><body>

On Mon, Oct 01, 2007 at 04:31:20PM -0700, Michael_google gmail_Gersten wrote:
&gt;  If it is in
&gt; use, at least that tor client knows not to open any new TCP
&gt; connections over that circuit.
&gt; 
&gt; I think that's the "missing" element. There is no way that I know of
&gt; for a circuit to refuse any new TCP connection while still staying
&gt; open for existing ones.

Actually, that feature exists right now. Look for calls to
we_are_hibernating() in various places in the code (command.c and
connection_edge.c in particular).

&gt; And even better is being able to notify that
&gt; originating client that new TCP connections will be rejected before
&gt; hand, so that a new circuit can be prepared ahead of time.

As soon as the first stream is refused with reason
END_STREAM_REASON_HIBERNATING, the client will give up on that circuit
for new streams, and try a new circuit -- see edge_reason_is_retriable().

Hope that helps,
--Roger

</body></email><email><emailId>20071009225947</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-10-09 22:59:47-0400</timestampReceived><subject>Re: Turning off a server</subject><body>

On Tue, Oct 09, 2007 at 06:54:33PM -0400, Roger Dingledine wrote:
&gt; &gt; I think that's the "missing" element. There is no way that I know of
&gt; &gt; for a circuit to refuse any new TCP connection while still staying
&gt; &gt; open for existing ones.
&gt; 
&gt; Actually, that feature exists right now. Look for calls to
&gt; we_are_hibernating() in various places in the code (command.c and
&gt; connection_edge.c in particular).

I think it might be smart to instead check "are we hibernating, or are
we not a server anymore" in these various places. I'd be happy to apply
a patch for that if one appeared. :)

It's not quite what Robert asked for originally though, since it won't
affect a very active stream that stays very active.

Perhaps a combination of refusing new requests plus throttling via
RelayBandwidthRate would be sufficient?

--Roger

</body></email><email><emailId>20070906161839</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-09-06 16:18:39-0400</timestampReceived><subject>Re: Question on router to router communication</subject><body>


On Wed, Sep 05, 2007 at 09:58:37AM -0700, Michael_google gmail_Gersten wrote:
&gt; I've noticed that my tor configured as a client will only have one
&gt; outgoing TCP connection to an entry node, no matter how many circuits
&gt; Vidalia shows as going to that entry guard.
&gt; 
&gt; I'm assuming that this continues on other router to router channels --
&gt; if there are three circuits that go from (for example) desync to
&gt; Tonga, there will only be one TCP connection.
&gt; 
&gt; Is this necessary from a security standpoint? Tor can be sped up if
&gt; that "one channel per pair" restriction can be broken.

Probably, yes?  Otherwise, it is trivial for an external attacker to
separate individual circuits and trace them more easily.  (It may be
possible to do this anyway with traffic analysis techniques, but also
maybe not.)

For more information on the Tor design, you might want to check out
the design paper at http://tor.eff.org/doc/design-paper/tor-design.pdf .

&gt; (Just like IP itself. A layer two connection between two nodes has (I
&gt; forget exactly) 8 channels, each of which can only have one
&gt; outstanding packet. Allowing Tor to have multiple channels between two
&gt; nodes will prevent a single stopped TCP from stopping all traffic
&gt; going that way.)

Another long-term solution is possibly to switch to a UDP transport
between Tor servers (using DTLS in place of TLS) and then provide
reliability and ordering at a higher layer of the protocol.
Unfortunately, this is pretty hard, and we don't have a really solid
idea of how to do it best.

yrs,
-- 
Nick Mathewson

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070703144519</emailId><senderName>"Jonathan Yu"</senderName><senderEmail>jonathan.i.yu@gmail.com</senderEmail><timestampReceived>2007-07-03 14:45:19-0400</timestampReceived><subject>Re: Choose exitnodes in country x</subject><body>

Hi there,

How are you proposing to detect country?

By the last part of the reverse hostname? Some ISPs do not have
reverse hostnames or their reverse hostnames don't necessarily reflect
the country of origin.

Through GeoIP systems like HostIP et al? This isn't all too reliable
either because IP spaces change all the time.

Best Regards,

Jonathan Yu

On 7/3/07, Carsten Krger &lt;C.Krueger@gmx.org&gt; wrote:
&gt; Hello,
&gt;
&gt; it would be nice to have the ability to choose only exitnodes in
&gt; country X.
&gt; Additional to "ExitNodes nickname, ..." something like this "ExitCountry country, ..."
&gt; would be nice.
&gt; country should be the official TLD code I think
&gt; http://www.iana.org/root-whois/index.html
&gt;
&gt; There is more and more censorship at websites that only allows
&gt; visitors from specific countries or show different content.
&gt;
&gt; greetings
&gt; Carsten
&gt;
&gt;
&gt;

</body></email><email><emailId>20070703195822</emailId><senderName>Robert Hogan</senderName><senderEmail>robert@roberthogan.net</senderEmail><timestampReceived>2007-07-03 19:58:22-0400</timestampReceived><subject>Re: Choose exitnodes in country x</subject><body>

On Tuesday 03 July 2007 15:35:21 you wrote:
&gt; Hello,
&gt;
&gt; it would be nice to have the ability to choose only exitnodes in
&gt; country X.
&gt; Additional to "ExitNodes nickname, ..." something like this "ExitCountry
&gt; country, ..." would be nice.
&gt; country should be the official TLD code I think
&gt; http://www.iana.org/root-whois/index.html
&gt;
&gt; There is more and more censorship at websites that only allows
&gt; visitors from specific countries or show different content.
&gt;

As Jonathan Yu pointed out there is no particularly reliable method for 
choosing by country, geoip is the closest match out there.

TorK uses geoip to offer a 'Citizen Of' feature, where you choose the country 
you want to 'browse the internet from', i.e. use exitnodes from only that 
country. 

-- 

Browse Anonymously Anywhere	- http://anonymityanywhere.com
TorK	- KDE Anonymity Manager	- http://tork.sf.net
KlamAV	- KDE Anti-Virus 	- http://www.klamav.net

</body></email><email><emailId>20070703211140</emailId><senderName>Carsten_Krger</senderName><senderEmail>c.krueger@gmx.org</senderEmail><timestampReceived>2007-07-03 21:11:40-0400</timestampReceived><subject>Re: Choose exitnodes in country x</subject><body>

Hi,

&gt; How are you proposing to detect country?

no automatic, add an additional entry to the tor directory.
For a human there is no problem to get the country out of traceroute.
For new tornodes it can be asked direct within the registration
process.

greetings
Carsten

</body></email><email><emailId>20070704204207</emailId><senderName>Wesley Kenzie</senderName><senderEmail>wkenzie@shaw.ca</senderEmail><timestampReceived>2007-07-04 20:42:07-0400</timestampReceived><subject>RE: Choose exitnodes in country x</subject><body>

pickaproxy.com and geospoofing.com will be offering this functionality as a
server-side service - you will be able to choose an exit node in
country/state/city/ISP/Org so that the server can then setup a long-lived
Tor circuit for you - you will then be advised on how to configure your
workstation proxy settings, with regard to port number and domain/host name.
This does not require you to install Tor on your machine, or to upgrade it
when new versions come around.  Nor will Vidalia or Privoxy be required on
the workstation.

We will offer options to use stunnel or OpenVPN connections to our server
(your proxy).  And we're looking at using polipo (on the server) to speed
things up.

We have multiple sources of geolocation data so they will be more accurate
than the open source GeoIP library - we pay for them where the license
requires us to.

. . .
Wesley Kenzie
WebMaster, showmyip.com, etc.



-----Original Message-----
From: owner-or-dev@freehaven.net [mailto:owner-or-dev@freehaven.net] On
Behalf Of Robert Hogan
Sent: July 3, 2007 12:58 PM
To: or-dev@freehaven.net
Subject: Re: Choose exitnodes in country x


On Tuesday 03 July 2007 15:35:21 you wrote:
&gt; Hello,
&gt;
&gt; it would be nice to have the ability to choose only exitnodes in 
&gt; country X. Additional to "ExitNodes nickname, ..." something like this 
&gt; "ExitCountry country, ..." would be nice.
&gt; country should be the official TLD code I think
&gt; http://www.iana.org/root-whois/index.html
&gt;
&gt; There is more and more censorship at websites that only allows 
&gt; visitors from specific countries or show different content.
&gt;

As Jonathan Yu pointed out there is no particularly reliable method for 
choosing by country, geoip is the closest match out there.

TorK uses geoip to offer a 'Citizen Of' feature, where you choose the
country 
you want to 'browse the internet from', i.e. use exitnodes from only that 
country. 

-- 

Browse Anonymously Anywhere	- http://anonymityanywhere.com
TorK	- KDE Anonymity Manager	- http://tork.sf.net
KlamAV	- KDE Anti-Virus 	- http://www.klamav.net




</body></email><email><emailId>20070704232139</emailId><senderName>Cat Okita</senderName><senderEmail>cat@reptiles.org</senderEmail><timestampReceived>2007-07-04 23:21:39-0400</timestampReceived><subject>RE: Choose exitnodes in country x</subject><body>


Hi Wesley -

I'm going to presume that your email isn't advertising a commercial service,
which I'd certainly find to be in dubious taste, both from the standpoint
of inappropriate advertising, and from the moral standpoint of profiting
from the goodwill of others.

However - could you say a word-or-five about the privacy and anonymity
implications of connecting directly to your well known site, and then
asking for a specific exit node?

It seems to me that you're not only encouraging people to make highly
identifiable connections to a single location (stunnel or OpenVPN to your
servers), which would then be an excellent target for compromising
anonymity - but you're also then encouraging people to reduce their
anonymity by selecting extremely specific exit nodes, making it again,
easier to identify and target them.

I note that you're saying that Vidalia and Privoxy won't be required - is
your plan to run all of the user traffic through your server, and then
through the Tor network?

A comment on the implications of using a caching web proxy for Tor
users on your server would be interesting as well.

cheers!

On Wed, 4 Jul 2007, Wesley Kenzie wrote:
&gt; pickaproxy.com and geospoofing.com will be offering this functionality as a
&gt; server-side service - you will be able to choose an exit node in
&gt; country/state/city/ISP/Org so that the server can then setup a long-lived
&gt; Tor circuit for you - you will then be advised on how to configure your
&gt; workstation proxy settings, with regard to port number and domain/host name.
&gt; This does not require you to install Tor on your machine, or to upgrade it
&gt; when new versions come around.  Nor will Vidalia or Privoxy be required on
&gt; the workstation.
&gt;
&gt; We will offer options to use stunnel or OpenVPN connections to our server
&gt; (your proxy).  And we're looking at using polipo (on the server) to speed
&gt; things up.
&gt;
&gt; We have multiple sources of geolocation data so they will be more accurate
&gt; than the open source GeoIP library - we pay for them where the license
&gt; requires us to.
&gt;
&gt; . . .
&gt; Wesley Kenzie
&gt; WebMaster, showmyip.com, etc.
&gt;
&gt;
&gt;
&gt; -----Original Message-----
&gt; From: owner-or-dev@freehaven.net [mailto:owner-or-dev@freehaven.net] On
&gt; Behalf Of Robert Hogan
&gt; Sent: July 3, 2007 12:58 PM
&gt; To: or-dev@freehaven.net
&gt; Subject: Re: Choose exitnodes in country x
&gt;
&gt;
&gt; On Tuesday 03 July 2007 15:35:21 you wrote:
&gt;&gt; Hello,
&gt;&gt;
&gt;&gt; it would be nice to have the ability to choose only exitnodes in
&gt;&gt; country X. Additional to "ExitNodes nickname, ..." something like this
&gt;&gt; "ExitCountry country, ..." would be nice.
&gt;&gt; country should be the official TLD code I think
&gt;&gt; http://www.iana.org/root-whois/index.html
&gt;&gt;
&gt;&gt; There is more and more censorship at websites that only allows
&gt;&gt; visitors from specific countries or show different content.
&gt;&gt;
&gt;
&gt; As Jonathan Yu pointed out there is no particularly reliable method for
&gt; choosing by country, geoip is the closest match out there.
&gt;
&gt; TorK uses geoip to offer a 'Citizen Of' feature, where you choose the
&gt; country
&gt; you want to 'browse the internet from', i.e. use exitnodes from only that
&gt; country.
&gt;
&gt; -- 
&gt;
&gt; Browse Anonymously Anywhere	- http://anonymityanywhere.com
&gt; TorK	- KDE Anonymity Manager	- http://tork.sf.net
&gt; KlamAV	- KDE Anti-Virus 	- http://www.klamav.net
&gt;
&gt;
&gt;

==========================================================================
"A cat spends her life conflicted between a deep, passionate and profound
desire for fish and an equally deep, passionate and profound desire to
avoid getting wet.  This is the defining metaphor of my life right now."
</body></email><email><emailId>20070705000712</emailId><senderName>Wesley Kenzie</senderName><senderEmail>wkenzie@shaw.ca</senderEmail><timestampReceived>2007-07-05 00:07:12-0400</timestampReceived><subject>RE: Choose exitnodes in country x</subject><body>

You are correct - this is not just to be a commercial service.

We do not intend to offer a completely anonymous service, but rather to
extend the existing usefulness of Tor to more users and to provide
functionality which we are always being asked about - namely how to spoof
being in a particular geographic location.

We will make it as clear as we can where anonymity can be compromised or
exposed, much as Tor already does on it's download page.

Our server(s) will function as an entry point to the Tor network, but if we
can find a way to afford to scale it then we will distribute these to
various locations so there will be multiple and (relatively) randomly
selected servers and port numbers.

The use of polipo will be optional - again we will make everyone aware of
it's implications.  I have seen how it improves the speed and responsiveness
of using Tor, so would like to make that available to people who want it.

Basically we see that not everyone needs or wants 100% anonymity, and we do
not intend to only target that market.  In fact, is it even possible
anywhere with anything right now?

We're also listening to what our users want, so welcome comments and cat
calls :)

. . .
Wesley  


-----Original Message-----
From: owner-or-talk@freehaven.net [mailto:owner-or-talk@freehaven.net] On
Behalf Of Cat Okita
Sent: July 4, 2007 4:22 PM
To: or-dev@freehaven.net
Cc: or-talk@freehaven.net
Subject: RE: Choose exitnodes in country x



Hi Wesley -

I'm going to presume that your email isn't advertising a commercial service,
which I'd certainly find to be in dubious taste, both from the standpoint of
inappropriate advertising, and from the moral standpoint of profiting from
the goodwill of others.

However - could you say a word-or-five about the privacy and anonymity
implications of connecting directly to your well known site, and then asking
for a specific exit node?

It seems to me that you're not only encouraging people to make highly
identifiable connections to a single location (stunnel or OpenVPN to your
servers), which would then be an excellent target for compromising anonymity
- but you're also then encouraging people to reduce their anonymity by
selecting extremely specific exit nodes, making it again, easier to identify
and target them.

I note that you're saying that Vidalia and Privoxy won't be required - is
your plan to run all of the user traffic through your server, and then
through the Tor network?

A comment on the implications of using a caching web proxy for Tor users on
your server would be interesting as well.

cheers!

On Wed, 4 Jul 2007, Wesley Kenzie wrote:
&gt; pickaproxy.com and geospoofing.com will be offering this functionality 
&gt; as a server-side service - you will be able to choose an exit node in 
&gt; country/state/city/ISP/Org so that the server can then setup a 
&gt; long-lived Tor circuit for you - you will then be advised on how to 
&gt; configure your workstation proxy settings, with regard to port number 
&gt; and domain/host name. This does not require you to install Tor on your 
&gt; machine, or to upgrade it when new versions come around.  Nor will 
&gt; Vidalia or Privoxy be required on the workstation.
&gt;
&gt; We will offer options to use stunnel or OpenVPN connections to our 
&gt; server (your proxy).  And we're looking at using polipo (on the 
&gt; server) to speed things up.
&gt;
&gt; We have multiple sources of geolocation data so they will be more 
&gt; accurate than the open source GeoIP library - we pay for them where 
&gt; the license requires us to.
&gt;
&gt; . . .
&gt; Wesley Kenzie
&gt; WebMaster, showmyip.com, etc.
&gt;
&gt;
&gt;
&gt; -----Original Message-----
&gt; From: owner-or-dev@freehaven.net [mailto:owner-or-dev@freehaven.net] 
&gt; On Behalf Of Robert Hogan
&gt; Sent: July 3, 2007 12:58 PM
&gt; To: or-dev@freehaven.net
&gt; Subject: Re: Choose exitnodes in country x
&gt;
&gt;
&gt; On Tuesday 03 July 2007 15:35:21 you wrote:
&gt;&gt; Hello,
&gt;&gt;
&gt;&gt; it would be nice to have the ability to choose only exitnodes in 
&gt;&gt; country X. Additional to "ExitNodes nickname, ..." something like 
&gt;&gt; this "ExitCountry country, ..." would be nice. country should be the 
&gt;&gt; official TLD code I think http://www.iana.org/root-whois/index.html
&gt;&gt;
&gt;&gt; There is more and more censorship at websites that only allows 
&gt;&gt; visitors from specific countries or show different content.
&gt;&gt;
&gt;
&gt; As Jonathan Yu pointed out there is no particularly reliable method 
&gt; for choosing by country, geoip is the closest match out there.
&gt;
&gt; TorK uses geoip to offer a 'Citizen Of' feature, where you choose the 
&gt; country you want to 'browse the internet from', i.e. use exitnodes 
&gt; from only that country.
&gt;
&gt; --
&gt;
&gt; Browse Anonymously Anywhere	- http://anonymityanywhere.com
&gt; TorK	- KDE Anonymity Manager	- http://tork.sf.net
&gt; KlamAV	- KDE Anti-Virus 	- http://www.klamav.net
&gt;
&gt;
&gt;

==========================================================================
"A cat spends her life conflicted between a deep, passionate and profound
desire for fish and an equally deep, passionate and profound desire to avoid
getting wet.  This is the defining metaphor of my life right now."



</body></email><email><emailId>20070605003647</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-06-05 00:36:47-0400</timestampReceived><subject>Re: control interface via unix domain socket</subject><body>


On Mon, Jun 04, 2007 at 08:58:00PM +0200, Peter Palfrader wrote:
&gt; Hi,
&gt; 
&gt; this is a first cut at a patch to also offer the control interface over
&gt; a unix domain socket, not just a TCP port.
&gt; 
&gt; Things that remain to be done:
&gt;  - make relative filenames relative to datadir?
&gt;  - document in manpage
&gt; 
&gt; Please let me know if this is something that should go in, and if yes
&gt; how to change it so that it can.

This should go in.  Here are a few comments about what should/could
get changed.

  - Right now, your code rejects the ControlSocket option as
    unrecognized.  if the code can't support it.  That's not how we
    handle unsupported options right now; instead, we try to give a
    message that says, "this Tor can't support that (otherwise valid)
    option."  (In some cases, we just ignore the option.  That's bad
    too.)

  - Make sure your code passes "make check-spaces".

  - I'm not sure we need to have a new listener type for this.
    I think, instead, that connection_create_listener should
    take a "struct sockaddr" as its argument, and that its callers
    should pass it a sockaddr of the right kind.  This will avoid
    bloating connection_create_listener, and will make the eventual
    IPv6 listeners easier too.

    To handle the special-cases on AF_UNIX later on, we could add a
    one-bit is_unix_socket flag to connection_t.

  - I think you missed the code to make connection_is_listener() work,
    in case you don't go with the above.

With that in mind, this looks pretty close to complete.  Would you
like to do the cleanup, or should I?

yrs,
-- 
Nick Mathewson

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070605191436</emailId><senderName>Peter Palfrader</senderName><senderEmail>peter@palfrader.org</senderEmail><timestampReceived>2007-06-05 19:14:36-0400</timestampReceived><subject>Re: control interface via unix domain socket</subject><body>

On Mon, 04 Jun 2007, Nick Mathewson wrote:

&gt; &gt; Things that remain to be done:
&gt; &gt;  - make relative filenames relative to datadir?
&gt; &gt;  - document in manpage

&gt;   - Right now, your code rejects the ControlSocket option as
&gt;     unrecognized.  if the code can't support it.  That's not how we
&gt;     handle unsupported options right now; instead, we try to give a
&gt;     message that says, "this Tor can't support that (otherwise valid)
&gt;     option."  (In some cases, we just ignore the option.  That's bad
&gt;     too.)

Fixed.

&gt;   - Make sure your code passes "make check-spaces".

It should now.

&gt;   - I'm not sure we need to have a new listener type for this.
&gt;     I think, instead, that connection_create_listener should
&gt;     take a "struct sockaddr" as its argument, and that its callers
&gt;     should pass it a sockaddr of the right kind.  This will avoid
&gt;     bloating connection_create_listener, and will make the eventual
&gt;     IPv6 listeners easier too.
&gt; 
&gt;     To handle the special-cases on AF_UNIX later on, we could add a
&gt;     one-bit is_unix_socket flag to connection_t.

I added a new field to connection_t, sa_family.  Right now it will
always be AF_INET or AF_UNIX, but it may be AF_INET6 in the future.
Also, the additional connection type is gone.  relaunch_listener()
now takes an extra argument specifying if you want unix or inet sockets.

&gt;   - I think you missed the code to make connection_is_listener() work,
&gt;     in case you don't go with the above.

N/A anymore :)

&gt; With that in mind, this looks pretty close to complete.  Would you
&gt; like to do the cleanup, or should I?

How does this look?
-- 
                           |  .''`.  ** Debian GNU/Linux **
      Peter Palfrader      | : :' :      The  universal
 http://www.palfrader.org/ | `. `'      Operating System
                           |   `-    http://www.debian.org/


Index: configure.in
===================================================================
--- configure.in	(revision 10502)
+++ configure.in	(working copy)
@@ -240,7 +240,7 @@
 
 AC_CHECK_HEADERS(unistd.h string.h signal.h ctype.h sys/stat.h sys/types.h fcntl.h \
sys/fcntl.h sys/time.h errno.h assert.h time.h, , AC_MSG_WARN(Some headers were not \
found, compilation may fail.  If compilation succeeds, please send your orconfig.h to \
the developers so we can fix this warning.))  
-AC_CHECK_HEADERS(netdb.h sys/ioctl.h sys/socket.h arpa/inet.h netinet/in.h pwd.h \
grp.h) +AC_CHECK_HEADERS(netdb.h sys/ioctl.h sys/socket.h arpa/inet.h netinet/in.h \
pwd.h grp.h sys/un.h)  
 dnl These headers are not essential
 
Index: src/or/connection_or.c
===================================================================
--- src/or/connection_or.c	(revision 10502)
+++ src/or/connection_or.c	(working copy)
@@ -465,7 +465,7 @@
     return NULL;
   }
 
-  conn = TO_OR_CONN(connection_new(CONN_TYPE_OR));
+  conn = TO_OR_CONN(connection_new(CONN_TYPE_OR, AF_INET));
 
   /* set up conn so it's got all the data we need to remember */
   connection_or_init_conn_from_address(conn, addr, port, id_digest, 1);
Index: src/or/config.c
===================================================================
--- src/or/config.c	(revision 10502)
+++ src/or/config.c	(working copy)
@@ -149,6 +149,7 @@
   VAR("ContactInfo",         STRING,   ContactInfo,          NULL),
   VAR("ControlListenAddress",LINELIST, ControlListenAddress, NULL),
   VAR("ControlPort",         UINT,     ControlPort,          "0"),
+  VAR("ControlSocket",       LINELIST, ControlSocket,        NULL),
   VAR("CookieAuthentication",BOOL,     CookieAuthentication, "0"),
   VAR("DataDirectory",       STRING,   DataDirectory,        NULL),
   OBSOLETE("DebugLogFile"),
@@ -811,6 +812,14 @@
     start_daemon();
   }
 
+#ifndef HAVE_SYS_UN_H
+  if (options-&gt;ControlSocket) {
+    *msg = tor_strdup("Unix domain sockets (ControlSocket) not supported"
+                      " on this OS/with this build.");
+    goto rollback;
+  }
+#endif
+
   if (running_tor) {
     /* We need to set the connection limit before we can open the listeners. */
     options-&gt;_ConnLimit =
Index: src/or/connection_edge.c
===================================================================
--- src/or/connection_edge.c	(revision 10502)
+++ src/or/connection_edge.c	(working copy)
@@ -1916,7 +1916,7 @@
   log_notice(LD_APP,"Making internal anonymized tunnel to %s:%d ...",
              safe_str(address),port); /* XXXX020 Downgrade back to info. */
 
-  conn = TO_EDGE_CONN(connection_new(CONN_TYPE_AP));
+  conn = TO_EDGE_CONN(connection_new(CONN_TYPE_AP, AF_INET));
   conn-&gt;_base.linked = 1; /* so that we can add it safely below. */
 
   /* populate conn-&gt;socks_request */
@@ -2210,7 +2210,7 @@
   }
 
   log_debug(LD_EXIT,"Creating new exit connection.");
-  n_stream = TO_EDGE_CONN(connection_new(CONN_TYPE_EXIT));
+  n_stream = TO_EDGE_CONN(connection_new(CONN_TYPE_EXIT, AF_INET));
   n_stream-&gt;_base.purpose = EXIT_PURPOSE_CONNECT;
 
   n_stream-&gt;stream_id = rh.stream_id;
@@ -2316,7 +2316,7 @@
    * resolved; but if we didn't store them in a connection like this,
    * the housekeeping in dns.c would get way more complicated.)
    */
-  dummy_conn = TO_EDGE_CONN(connection_new(CONN_TYPE_EXIT));
+  dummy_conn = TO_EDGE_CONN(connection_new(CONN_TYPE_EXIT, AF_INET));
   dummy_conn-&gt;stream_id = rh.stream_id;
   dummy_conn-&gt;_base.address = tor_strndup(cell-&gt;payload+RELAY_HEADER_SIZE,
                                           rh.length);
@@ -2450,7 +2450,7 @@
 
   exitconn-&gt;_base.state = EXIT_CONN_STATE_OPEN;
 
-  dirconn = TO_DIR_CONN(connection_new(CONN_TYPE_DIR));
+  dirconn = TO_DIR_CONN(connection_new(CONN_TYPE_DIR, AF_INET));
 
   dirconn-&gt;_base.addr = 0x7f000001;
   dirconn-&gt;_base.port = 0;
Index: src/or/or.h
===================================================================
--- src/or/or.h	(revision 10502)
+++ src/or/or.h	(working copy)
@@ -56,6 +56,9 @@
 #ifdef HAVE_SYS_SOCKET_H
 #include &lt;sys/socket.h&gt;
 #endif
+#ifdef HAVE_SYS_UN_H
+#include &lt;sys/un.h&gt;
+#endif
 #ifdef HAVE_SYS_TIME_H
 #include &lt;sys/time.h&gt;
 #endif
@@ -790,6 +793,9 @@
                                  * could write? */
   time_t timestamp_created; /**&lt; When was this connection_t created? */
 
+  int sa_family; /**&lt; Address family of this connection's socket.  Usually
+                  * AF_INET, but it can also be AF_UNIX, or in the future
+                  * AF_INET6 */
   uint32_t addr; /**&lt; IP of the other side of the connection; used to identify
                   * routers, along with port. */
   uint16_t port; /**&lt; If non-zero, port  on the other end
@@ -1819,6 +1825,8 @@
   int TransPort;
   int NatdPort; /**&lt; Port to listen on for transparent natd connections. */
   int ControlPort; /**&lt; Port to listen on for control connections. */
+  config_line_t * ControlSocket; /**&lt; Unix Domain Socket to listen on
+                                  * for control connections. */
   int DirPort; /**&lt; Port to listen on for directory connections. */
   int DNSPort; /**&lt; Port to listen on for DNS requests. */
   int AssumeReachable; /**&lt; Whether to publish our descriptor regardless. */
@@ -2341,7 +2349,7 @@
 const char *conn_type_to_string(int type);
 const char *conn_state_to_string(int type, int state);
 
-connection_t *connection_new(int type);
+connection_t *connection_new(int type, int sa_family);
 void connection_link_connections(connection_t *conn_a, connection_t *conn_b);
 void connection_unregister_events(connection_t *conn);
 void connection_free(connection_t *conn);
Index: src/or/connection.c
===================================================================
--- src/or/connection.c	(revision 10502)
+++ src/or/connection.c	(working copy)
@@ -14,8 +14,9 @@
 
 #include "or.h"
 
-static connection_t *connection_create_listener(const char *listenaddress,
-                                                uint16_t listenport, int type);
+static connection_t *connection_create_listener(
+                               struct sockaddr *listensockaddr, int type,
+                               char* address);
 static int connection_init_accepted_conn(connection_t *conn,
                                          uint8_t listener_type);
 static int connection_handle_listener_read(connection_t *conn, int new_type);
@@ -156,7 +157,7 @@
  * Initialize conn's timestamps to now.
  */
 connection_t *
-connection_new(int type)
+connection_new(int type, int sa_family)
 {
   static uint32_t n_connections_allocated = 1;
   connection_t *conn;
@@ -194,6 +195,7 @@
   conn-&gt;conn_array_index = -1; /* also default to 'not used' */
 
   conn-&gt;type = type;
+  conn-&gt;sa_family = sa_family;
   if (!connection_is_listener(conn)) { /* listeners never use their buf */
     conn-&gt;inbuf = buf_new();
     conn-&gt;outbuf = buf_new();
@@ -293,7 +295,18 @@
   if (!connection_is_listener(conn)) {
     buf_free(conn-&gt;inbuf);
     buf_free(conn-&gt;outbuf);
+  } else {
+    if (conn-&gt;sa_family == AF_UNIX) {
+      /* For now only control ports can be unix domain sockets
+       * and listeners at the same time */
+      tor_assert(conn-&gt;type == CONN_TYPE_CONTROL_LISTENER);
+
+      if (unlink(conn-&gt;address) &lt; 0 &amp;&amp; errno != ENOENT) {
+        log_warn(LD_NET, "Could not unlink %s: %s", conn-&gt;address,
+                         strerror(errno));
   }
+    }
+  }
 
   tor_free(conn-&gt;address);
 
@@ -621,44 +634,97 @@
   });
 }
 
-/** Bind a new non-blocking socket listening to
- * &lt;b&gt;listenaddress&lt;/b&gt;:&lt;b&gt;listenport&lt;/b&gt;, and add this new connection
- * (of type &lt;b&gt;type&lt;/b&gt;) to the connection array.
+/** Create an AF_INET listenaddr struct.
+ * &lt;b&gt;listenaddress&lt;/b&gt; provides the host and optionally the port information
+ * for the new structure.  If no port is provided in &lt;b&gt;listenaddress&lt;/b&gt; then
+ * &lt;b&gt;listenport&lt;/b&gt; is used.
  *
- * If &lt;b&gt;listenaddress&lt;/b&gt; includes a port, we bind on that port;
- * otherwise, we use listenport.
+ * If not NULL &lt;b&gt;readable_addrress&lt;/b&gt; will contain a copy of the host part of
+ * &lt;b&gt;listenaddress&lt;/b&gt;.
+ *
+ * The listenaddr struct has to be freed by the caller.
  */
-static connection_t *
-connection_create_listener(const char *listenaddress, uint16_t listenport,
-                           int type)
-{
-  struct sockaddr_in listenaddr; /* where to bind */
-  char *address = NULL;
-  connection_t *conn;
-  uint16_t usePort;
+struct sockaddr_in *
+create_inet_sockaddr(const char *listenaddress, uint16_t listenport,
+                     char **readable_address) {
+  struct sockaddr_in *listenaddr = NULL;
   uint32_t addr;
-  int s; /* the socket we're going to make */
-#ifndef MS_WINDOWS
-  int one=1;
-#endif
-  int is_tcp = (type != CONN_TYPE_AP_DNS_LISTENER);
+  uint16_t usePort = 0;
 
-  memset(&amp;listenaddr,0,sizeof(struct sockaddr_in));
-  if (parse_addr_port(LOG_WARN, listenaddress, &amp;address, &amp;addr, &amp;usePort)&lt;0) {
+  if (parse_addr_port(LOG_WARN,
+                      listenaddress, readable_address, &amp;addr, &amp;usePort)&lt;0) {
     log_warn(LD_CONFIG,
              "Error parsing/resolving ListenAddress %s", listenaddress);
-    return NULL;
+    goto err;
   }
-
   if (usePort==0)
     usePort = listenport;
-  listenaddr.sin_addr.s_addr = htonl(addr);
-  listenaddr.sin_family = AF_INET;
-  listenaddr.sin_port = htons((uint16_t) usePort);
 
-  log_notice(LD_NET, "Opening %s on %s:%d",
-             conn_type_to_string(type), address, usePort);
+  listenaddr = tor_malloc_zero(sizeof(struct sockaddr_in));
+  listenaddr-&gt;sin_addr.s_addr = htonl(addr);
+  listenaddr-&gt;sin_family = AF_INET;
+  listenaddr-&gt;sin_port = htons((uint16_t) usePort);
 
+  return listenaddr;
+
+ err:
+  tor_free(listenaddr);
+  return NULL;
+}
+
+#ifdef HAVE_SYS_UN_H
+/** Create an AF_UNIX listenaddr struct.
+ * &lt;b&gt;listenaddress&lt;/b&gt; provides the path to the unix socket.
+ *
+ * Eventually &lt;b&gt;listenaddress&lt;/b&gt; will also optionally contain user, group,
+ * and file permissions for the new socket.  But not yet. XXX
+ * Also, since we do not create the socket here the information doesn't help
+ * here.
+ *
+ * If not NULL &lt;b&gt;readable_addrress&lt;/b&gt; will contain a copy of the path part of
+ * &lt;b&gt;listenaddress&lt;/b&gt;.
+ *
+ * The listenaddr struct has to be freed by the caller.
+ */
+struct sockaddr_un *
+create_unix_sockaddr(const char *listenaddress, char **readable_address)
+{
+  struct sockaddr_un *sockaddr = NULL;
+
+  sockaddr = tor_malloc_zero(sizeof(struct sockaddr_un));
+  sockaddr-&gt;sun_family = AF_UNIX;
+  strncpy(sockaddr-&gt;sun_path, listenaddress, sizeof(sockaddr-&gt;sun_path));
+
+  if (readable_address)
+    *readable_address = tor_strdup(listenaddress);
+
+  return sockaddr;
+}
+#else
+struct sockaddr *
+create_unix_sockaddr(const char *listenaddress, char **readable_address)
+{
+  log_fn(LOG_ERR, LD_BUG,
+         "Unix domain sockets not supported, yet we tried to create one.");
+  assert(0);
+};
+#endif /* HAVE_SYS_UN_H */
+
+/** Bind a new non-blocking socket listening to the socket described
+ * by &lt;b&gt;listensockaddr&lt;/b&gt;.
+ *
+ * &lt;b&gt;address&lt;/b&gt; is only used for logging purposes and to add the information
+ * to the conn.
+ */
+static connection_t *
+connection_create_listener(struct sockaddr *listensockaddr, int type,
+  char* address)
+{
+  connection_t *conn;
+  int s; /* the socket we're going to make */
+  uint16_t usePort = 0;
+  int start_reading = 0;
+
   if (get_n_open_sockets() &gt;= get_options()-&gt;_ConnLimit-1) {
     int n_conns = get_n_open_sockets();
     log_warn(LD_NET,"Failing because we have %d connections already. Please "
@@ -668,6 +734,20 @@
     return NULL;
   }
 
+  if (listensockaddr-&gt;sa_family == AF_INET) {
+    int is_tcp = (type != CONN_TYPE_AP_DNS_LISTENER);
+#ifndef MS_WINDOWS
+    int one=1;
+#endif
+    if (is_tcp)
+      start_reading = 1;
+
+    usePort = ntohs( (uint16_t)
+                     ((struct sockaddr_in *)listensockaddr)-&gt;sin_port);
+
+    log_notice(LD_NET, "Opening %s on %s:%d",
+               conn_type_to_string(type), address, usePort);
+
   s = tor_open_socket(PF_INET,
                       is_tcp ? SOCK_STREAM : SOCK_DGRAM,
                       is_tcp ? IPPROTO_TCP: IPPROTO_UDP);
@@ -684,7 +764,7 @@
   setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (void*) &amp;one, sizeof(one));
 #endif
 
-  if (bind(s,(struct sockaddr *)&amp;listenaddr,sizeof(listenaddr)) &lt; 0) {
+    if (bind(s,listensockaddr,sizeof(struct sockaddr_in)) &lt; 0) {
     const char *helpfulhint = "";
     int e = tor_socket_errno(s);
     if (ERRNO_IS_EADDRINUSE(e))
@@ -703,13 +783,56 @@
       goto err;
     }
   }
+#ifdef HAVE_SYS_UN_H
+  } else if (listensockaddr-&gt;sa_family == AF_UNIX) {
+    int len;
+    start_reading = 1;
 
+    /* For now only control ports can be unix domain sockets
+     * and listeners at the same time */
+    tor_assert(type == CONN_TYPE_CONTROL_LISTENER);
+
+    log_notice(LD_NET, "Opening %s on %s",
+               conn_type_to_string(type), address);
+
+    if (unlink(address) &lt; 0 &amp;&amp; errno != ENOENT) {
+      log_warn(LD_NET, "Could not unlink %s: %s", address,
+                       strerror(errno));
+      goto err;
+    }
+    s = tor_open_socket(AF_UNIX, SOCK_STREAM, 0);
+    if (s &lt; 0) {
+      log_warn(LD_NET,"Socket creation failed: %s.", strerror(errno));
+      goto err;
+    }
+
+    len = strlen(((struct sockaddr_un *)listensockaddr)-&gt;sun_path) +
+          sizeof(((struct sockaddr_un *)listensockaddr)-&gt;sun_family);
+    if (bind(s, listensockaddr, len) == -1) {
+      log_warn(LD_NET,"Bind to %s failed: %s.", address,
+               tor_socket_strerror(tor_socket_errno(s)));
+      goto err;
+    }
+
+    if (listen(s,SOMAXCONN) &lt; 0) {
+      log_warn(LD_NET, "Could not listen on %s: %s", address,
+               tor_socket_strerror(tor_socket_errno(s)));
+      tor_close_socket(s);
+      goto err;
+    }
+#endif /* HAVE_SYS_UN_H */
+  } else {
+      log_err(LD_BUG,"Got unexpected address family %d.",
+              listensockaddr-&gt;sa_family);
+      tor_assert(0);
+  }
+
   set_socket_nonblocking(s);
 
-  conn = connection_new(type);
+  conn = connection_new(type, listensockaddr-&gt;sa_family);
+  conn-&gt;sa_family = listensockaddr-&gt;sa_family;
   conn-&gt;s = s;
-  conn-&gt;address = address;
-  address = NULL;
+  conn-&gt;address = tor_strdup(address);
   conn-&gt;port = usePort;
 
   if (connection_add(conn) &lt; 0) { /* no space, forget it */
@@ -722,7 +845,7 @@
             conn_type_to_string(type), usePort);
 
   conn-&gt;state = LISTENER_STATE_READY;
-  if (is_tcp) {
+  if (start_reading) {
     connection_start_reading(conn);
   } else {
     tor_assert(type == CONN_TYPE_AP_DNS_LISTENER);
@@ -732,7 +855,6 @@
   return conn;
 
  err:
-  tor_free(address);
   return NULL;
 }
 
@@ -801,6 +923,9 @@
 
   set_socket_nonblocking(news);
 
+  tor_assert(((struct sockaddr*)addrbuf)-&gt;sa_family == conn-&gt;sa_family);
+
+  if (conn-&gt;sa_family == AF_INET) {
   if (check_sockaddr_in((struct sockaddr*)addrbuf, remotelen, LOG_INFO)&lt;0) {
     log_info(LD_NET,
              "accept() returned a strange address; trying getsockname().");
@@ -826,7 +951,8 @@
     /* check sockspolicy to see if we should accept it */
     if (socks_policy_permits_address(ntohl(remote.sin_addr.s_addr)) == 0) {
       tor_inet_ntoa(&amp;remote.sin_addr, tmpbuf, sizeof(tmpbuf));
-      log_notice(LD_APP,"Denying socks connection from untrusted address %s.",
+        log_notice(LD_APP,
+                   "Denying socks connection from untrusted address %s.",
                  tmpbuf);
       tor_close_socket(news);
       return 0;
@@ -843,7 +969,7 @@
     }
   }
 
-  newconn = connection_new(new_type);
+    newconn = connection_new(new_type, conn-&gt;sa_family);
   newconn-&gt;s = news;
 
   /* remember the remote address */
@@ -851,6 +977,22 @@
   newconn-&gt;port = ntohs(remote.sin_port);
   newconn-&gt;address = tor_dup_addr(newconn-&gt;addr);
 
+  } else if (conn-&gt;sa_family == AF_UNIX) {
+    /* For now only control ports can be unix domain sockets
+     * and listeners at the same time */
+    tor_assert(conn-&gt;type == CONN_TYPE_CONTROL_LISTENER);
+
+    newconn = connection_new(new_type, conn-&gt;sa_family);
+    newconn-&gt;s = news;
+
+    /* remember the remote address -- do we have anything sane to put here? */
+    newconn-&gt;addr = 0;
+    newconn-&gt;port = 1;
+    newconn-&gt;address = tor_strdup(conn-&gt;address);
+  } else {
+    tor_assert(0);
+  };
+
   if (connection_add(newconn) &lt; 0) { /* no space, forget it */
     connection_free(newconn);
     return 0; /* no need to tear down the parent */
@@ -1007,7 +1149,8 @@
                 int port_option, const char *default_addr,
                 smartlist_t *replaced_conns,
                 smartlist_t *new_conns,
-                int never_open_conns)
+                int never_open_conns,
+                int sa_family)
 {
   smartlist_t *launch = smartlist_create(), *conns;
   int free_launch_elts = 1;
@@ -1016,6 +1159,8 @@
   connection_t *conn;
   config_line_t *line;
 
+  tor_assert(sa_family == AF_INET || sa_family == AF_UNIX);
+
   if (cfg &amp;&amp; port_option) {
     for (c = cfg; c; c = c-&gt;next) {
       smartlist_add(launch, c);
@@ -1036,7 +1181,9 @@
   conns = get_connection_array();
   SMARTLIST_FOREACH(conns, connection_t *, conn,
   {
-    if (conn-&gt;type != type || conn-&gt;marked_for_close)
+    if (conn-&gt;type != type ||
+        conn-&gt;sa_family != sa_family ||
+        conn-&gt;marked_for_close)
       continue;
     /* Okay, so this is a listener.  Is it configured? */
     line = NULL;
@@ -1044,7 +1191,10 @@
       {
         char *address=NULL;
         uint16_t port;
-        if (!parse_addr_port(LOG_WARN, wanted-&gt;value, &amp;address, NULL, &amp;port)) {
+        switch (sa_family) {
+          case AF_INET:
+            if (!parse_addr_port(LOG_WARN,
+                                 wanted-&gt;value, &amp;address, NULL, &amp;port)) {
           int addr_matches = !strcasecmp(address, conn-&gt;address);
           tor_free(address);
           if (! port)
@@ -1054,6 +1204,16 @@
             break;
           }
         }
+            break;
+          case AF_UNIX:
+            if (!strcasecmp(wanted-&gt;value, conn-&gt;address)) {
+              line = wanted;
+              break;
+            }
+            break;
+          default:
+            tor_assert(0);
+        }
       });
     if (! line) {
       /* This one isn't configured. Close it. */
@@ -1080,8 +1240,31 @@
   if (!never_open_conns) {
     SMARTLIST_FOREACH(launch, config_line_t *, cfg_line,
       {
-        conn = connection_create_listener(cfg_line-&gt;value,
-                                          (uint16_t) port_option, type);
+        char *address = NULL;
+        struct sockaddr *listensockaddr;
+
+        switch (sa_family) {
+          case AF_INET:
+            listensockaddr = (struct sockaddr *)
+                             create_inet_sockaddr(cfg_line-&gt;value,
+                                                  (uint16_t) port_option,
+                                                  &amp;address);
+            break;
+          case AF_UNIX:
+            listensockaddr = (struct sockaddr *)
+                             create_unix_sockaddr(cfg_line-&gt;value,
+                                                  &amp;address);
+            break;
+          default:
+            tor_assert(0);
+        }
+
+        if (listensockaddr) {
+          conn = connection_create_listener(listensockaddr, type, address);
+          tor_free(address);
+        } else
+          conn = NULL;
+
         if (!conn) {
           r = -1;
         } else {
@@ -1115,33 +1298,46 @@
 
   if (retry_listeners(CONN_TYPE_OR_LISTENER, options-&gt;ORListenAddress,
                       options-&gt;ORPort, "0.0.0.0",
-                      replaced_conns, new_conns, options-&gt;ClientOnly)&lt;0)
+                      replaced_conns, new_conns, options-&gt;ClientOnly,
+                      AF_INET)&lt;0)
     return -1;
   if (retry_listeners(CONN_TYPE_DIR_LISTENER, options-&gt;DirListenAddress,
                       options-&gt;DirPort, "0.0.0.0",
-                      replaced_conns, new_conns, 0)&lt;0)
+                      replaced_conns, new_conns, 0,
+                      AF_INET)&lt;0)
     return -1;
   if (retry_listeners(CONN_TYPE_AP_LISTENER, options-&gt;SocksListenAddress,
                       options-&gt;SocksPort, "127.0.0.1",
-                      replaced_conns, new_conns, 0)&lt;0)
+                      replaced_conns, new_conns, 0,
+                      AF_INET)&lt;0)
     return -1;
   if (retry_listeners(CONN_TYPE_AP_TRANS_LISTENER, options-&gt;TransListenAddress,
                       options-&gt;TransPort, "127.0.0.1",
-                      replaced_conns, new_conns, 0)&lt;0)
+                      replaced_conns, new_conns, 0,
+                      AF_INET)&lt;0)
     return -1;
   if (retry_listeners(CONN_TYPE_AP_NATD_LISTENER, options-&gt;NatdListenAddress,
                       options-&gt;NatdPort, "127.0.0.1",
-                      replaced_conns, new_conns, 0)&lt;0)
+                      replaced_conns, new_conns, 0,
+                      AF_INET)&lt;0)
     return -1;
   if (retry_listeners(CONN_TYPE_AP_DNS_LISTENER, options-&gt;DNSListenAddress,
                       options-&gt;DNSPort, "127.0.0.1",
-                      replaced_conns, new_conns, 0)&lt;0)
+                      replaced_conns, new_conns, 0,
+                      AF_INET)&lt;0)
     return -1;
   if (retry_listeners(CONN_TYPE_CONTROL_LISTENER,
                       options-&gt;ControlListenAddress,
                       options-&gt;ControlPort, "127.0.0.1",
-                      replaced_conns, new_conns, 0)&lt;0)
+                      replaced_conns, new_conns, 0,
+                      AF_INET)&lt;0)
     return -1;
+  if (retry_listeners(CONN_TYPE_CONTROL_LISTENER,
+                      options-&gt;ControlSocket,
+                      options-&gt;ControlSocket ? 1 : 0, NULL,
+                      replaced_conns, new_conns, 0,
+                      AF_UNIX)&lt;0)
+    return -1;
 
   return 0;
 }
Index: src/or/directory.c
===================================================================
--- src/or/directory.c	(revision 10502)
+++ src/or/directory.c	(working copy)
@@ -490,7 +490,7 @@
       tor_assert(0);
   }
 
-  conn = TO_DIR_CONN(connection_new(CONN_TYPE_DIR));
+  conn = TO_DIR_CONN(connection_new(CONN_TYPE_DIR, AF_INET));
 
   /* set up conn so it's got all the data we need to remember */
   conn-&gt;_base.addr = addr;
Index: src/or/cpuworker.c
===================================================================
--- src/or/cpuworker.c	(revision 10502)
+++ src/or/cpuworker.c	(working copy)
@@ -339,7 +339,7 @@
   tor_free(fdarray);
 #endif
 
-  conn = connection_new(CONN_TYPE_CPUWORKER);
+  conn = connection_new(CONN_TYPE_CPUWORKER, AF_UNIX);
 
   set_socket_nonblocking(fd);
 
Index: src/or/dnsserv.c
===================================================================
--- src/or/dnsserv.c	(revision 10502)
+++ src/or/dnsserv.c	(working copy)
@@ -110,7 +110,7 @@
   /* XXXX020 Send a stream event to the controller. */
 
   /* Make a new dummy AP connection, and attach the request to it. */
-  conn = TO_EDGE_CONN(connection_new(CONN_TYPE_AP));
+  conn = TO_EDGE_CONN(connection_new(CONN_TYPE_AP, AF_INET));
   conn-&gt;_base.state = AP_CONN_STATE_RESOLVE_WAIT;
   if (q-&gt;type == EVDNS_TYPE_A)
     conn-&gt;socks_request-&gt;command = SOCKS_COMMAND_RESOLVE;



Index: configure.in
===================================================================
--- configure.in	(revision 10502)
+++ configure.in	(working copy)
@@ -240,7 +240,7 @@
 
 AC_CHECK_HEADERS(unistd.h string.h signal.h ctype.h sys/stat.h sys/types.h fcntl.h \
sys/fcntl.h sys/time.h errno.h assert.h time.h, , AC_MSG_WARN(Some headers were not \
found, compilation may fail.  If compilation succeeds, please send your orconfig.h to \
the developers so we can fix this warning.))  
-AC_CHECK_HEADERS(netdb.h sys/ioctl.h sys/socket.h arpa/inet.h netinet/in.h pwd.h \
grp.h) +AC_CHECK_HEADERS(netdb.h sys/ioctl.h sys/socket.h arpa/inet.h netinet/in.h \
pwd.h grp.h sys/un.h)  
 dnl These headers are not essential
 
Index: src/or/connection_or.c
===================================================================
--- src/or/connection_or.c	(revision 10502)
+++ src/or/connection_or.c	(working copy)
@@ -465,7 +465,7 @@
     return NULL;
   }
 
-  conn = TO_OR_CONN(connection_new(CONN_TYPE_OR));
+  conn = TO_OR_CONN(connection_new(CONN_TYPE_OR, AF_INET));
 
   /* set up conn so it's got all the data we need to remember */
   connection_or_init_conn_from_address(conn, addr, port, id_digest, 1);
Index: src/or/config.c
===================================================================
--- src/or/config.c	(revision 10502)
+++ src/or/config.c	(working copy)
@@ -149,6 +149,7 @@
   VAR("ContactInfo",         STRING,   ContactInfo,          NULL),
   VAR("ControlListenAddress",LINELIST, ControlListenAddress, NULL),
   VAR("ControlPort",         UINT,     ControlPort,          "0"),
+  VAR("ControlSocket",       LINELIST, ControlSocket,        NULL),
   VAR("CookieAuthentication",BOOL,     CookieAuthentication, "0"),
   VAR("DataDirectory",       STRING,   DataDirectory,        NULL),
   OBSOLETE("DebugLogFile"),
@@ -811,6 +812,14 @@
     start_daemon();
   }
 
+#ifndef HAVE_SYS_UN_H
+  if (options-&gt;ControlSocket) {
+    *msg = tor_strdup("Unix domain sockets (ControlSocket) not supported"
+                      " on this OS/with this build.");
+    goto rollback;
+  }
+#endif
+
   if (running_tor) {
     /* We need to set the connection limit before we can open the listeners. */
     options-&gt;_ConnLimit =
Index: src/or/connection_edge.c
===================================================================
--- src/or/connection_edge.c	(revision 10502)
+++ src/or/connection_edge.c	(working copy)
@@ -1916,7 +1916,7 @@
   log_notice(LD_APP,"Making internal anonymized tunnel to %s:%d ...",
              safe_str(address),port); /* XXXX020 Downgrade back to info. */
 
-  conn = TO_EDGE_CONN(connection_new(CONN_TYPE_AP));
+  conn = TO_EDGE_CONN(connection_new(CONN_TYPE_AP, AF_INET));
   conn-&gt;_base.linked = 1; /* so that we can add it safely below. */
 
   /* populate conn-&gt;socks_request */
@@ -2210,7 +2210,7 @@
   }
 
   log_debug(LD_EXIT,"Creating new exit connection.");
-  n_stream = TO_EDGE_CONN(connection_new(CONN_TYPE_EXIT));
+  n_stream = TO_EDGE_CONN(connection_new(CONN_TYPE_EXIT, AF_INET));
   n_stream-&gt;_base.purpose = EXIT_PURPOSE_CONNECT;
 
   n_stream-&gt;stream_id = rh.stream_id;
@@ -2316,7 +2316,7 @@
    * resolved; but if we didn't store them in a connection like this,
    * the housekeeping in dns.c would get way more complicated.)
    */
-  dummy_conn = TO_EDGE_CONN(connection_new(CONN_TYPE_EXIT));
+  dummy_conn = TO_EDGE_CONN(connection_new(CONN_TYPE_EXIT, AF_INET));
   dummy_conn-&gt;stream_id = rh.stream_id;
   dummy_conn-&gt;_base.address = tor_strndup(cell-&gt;payload+RELAY_HEADER_SIZE,
                                           rh.length);
@@ -2450,7 +2450,7 @@
 
   exitconn-&gt;_base.state = EXIT_CONN_STATE_OPEN;
 
-  dirconn = TO_DIR_CONN(connection_new(CONN_TYPE_DIR));
+  dirconn = TO_DIR_CONN(connection_new(CONN_TYPE_DIR, AF_INET));
 
   dirconn-&gt;_base.addr = 0x7f000001;
   dirconn-&gt;_base.port = 0;
Index: src/or/or.h
===================================================================
--- src/or/or.h	(revision 10502)
+++ src/or/or.h	(working copy)
@@ -56,6 +56,9 @@
 #ifdef HAVE_SYS_SOCKET_H
 #include &lt;sys/socket.h&gt;
 #endif
+#ifdef HAVE_SYS_UN_H
+#include &lt;sys/un.h&gt;
+#endif
 #ifdef HAVE_SYS_TIME_H
 #include &lt;sys/time.h&gt;
 #endif
@@ -790,6 +793,9 @@
                                  * could write? */
   time_t timestamp_created; /**&lt; When was this connection_t created? */
 
+  int sa_family; /**&lt; Address family of this connection's socket.  Usually
+                  * AF_INET, but it can also be AF_UNIX, or in the future
+                  * AF_INET6 */
   uint32_t addr; /**&lt; IP of the other side of the connection; used to identify
                   * routers, along with port. */
   uint16_t port; /**&lt; If non-zero, port  on the other end
@@ -1819,6 +1825,8 @@
   int TransPort;
   int NatdPort; /**&lt; Port to listen on for transparent natd connections. */
   int ControlPort; /**&lt; Port to listen on for control connections. */
+  config_line_t * ControlSocket; /**&lt; Unix Domain Socket to listen on
+                                  * for control connections. */
   int DirPort; /**&lt; Port to listen on for directory connections. */
   int DNSPort; /**&lt; Port to listen on for DNS requests. */
   int AssumeReachable; /**&lt; Whether to publish our descriptor regardless. */
@@ -2341,7 +2349,7 @@
 const char *conn_type_to_string(int type);
 const char *conn_state_to_string(int type, int state);
 
-connection_t *connection_new(int type);
+connection_t *connection_new(int type, int sa_family);
 void connection_link_connections(connection_t *conn_a, connection_t *conn_b);
 void connection_unregister_events(connection_t *conn);
 void connection_free(connection_t *conn);
Index: src/or/connection.c
===================================================================
--- src/or/connection.c	(revision 10502)
+++ src/or/connection.c	(working copy)
@@ -14,8 +14,9 @@
 
 #include "or.h"
 
-static connection_t *connection_create_listener(const char *listenaddress,
-                                                uint16_t listenport, int type);
+static connection_t *connection_create_listener(
+                               struct sockaddr *listensockaddr, int type,
+                               char* address);
 static int connection_init_accepted_conn(connection_t *conn,
                                          uint8_t listener_type);
 static int connection_handle_listener_read(connection_t *conn, int new_type);
@@ -156,7 +157,7 @@
  * Initialize conn's timestamps to now.
  */
 connection_t *
-connection_new(int type)
+connection_new(int type, int sa_family)
 {
   static uint32_t n_connections_allocated = 1;
   connection_t *conn;
@@ -194,6 +195,7 @@
   conn-&gt;conn_array_index = -1; /* also default to 'not used' */
 
   conn-&gt;type = type;
+  conn-&gt;sa_family = sa_family;
   if (!connection_is_listener(conn)) { /* listeners never use their buf */
     conn-&gt;inbuf = buf_new();
     conn-&gt;outbuf = buf_new();
@@ -293,6 +295,17 @@
   if (!connection_is_listener(conn)) {
     buf_free(conn-&gt;inbuf);
     buf_free(conn-&gt;outbuf);
+  } else {
+    if (conn-&gt;sa_family == AF_UNIX) {
+      /* For now only control ports can be unix domain sockets
+       * and listeners at the same time */
+      tor_assert(conn-&gt;type == CONN_TYPE_CONTROL_LISTENER);
+
+      if (unlink(conn-&gt;address) &lt; 0 &amp;&amp; errno != ENOENT) {
+        log_warn(LD_NET, "Could not unlink %s: %s", conn-&gt;address,
+                         strerror(errno));
+      }
+    }
   }
 
   tor_free(conn-&gt;address);
@@ -621,44 +634,97 @@
   });
 }
 
-/** Bind a new non-blocking socket listening to
- * &lt;b&gt;listenaddress&lt;/b&gt;:&lt;b&gt;listenport&lt;/b&gt;, and add this new connection
- * (of type &lt;b&gt;type&lt;/b&gt;) to the connection array.
+/** Create an AF_INET listenaddr struct.
+ * &lt;b&gt;listenaddress&lt;/b&gt; provides the host and optionally the port information
+ * for the new structure.  If no port is provided in &lt;b&gt;listenaddress&lt;/b&gt; then
+ * &lt;b&gt;listenport&lt;/b&gt; is used.
  *
- * If &lt;b&gt;listenaddress&lt;/b&gt; includes a port, we bind on that port;
- * otherwise, we use listenport.
+ * If not NULL &lt;b&gt;readable_addrress&lt;/b&gt; will contain a copy of the host part of
+ * &lt;b&gt;listenaddress&lt;/b&gt;.
+ *
+ * The listenaddr struct has to be freed by the caller.
  */
-static connection_t *
-connection_create_listener(const char *listenaddress, uint16_t listenport,
-                           int type)
-{
-  struct sockaddr_in listenaddr; /* where to bind */
-  char *address = NULL;
-  connection_t *conn;
-  uint16_t usePort;
+struct sockaddr_in *
+create_inet_sockaddr(const char *listenaddress, uint16_t listenport,
+                     char **readable_address) {
+  struct sockaddr_in *listenaddr = NULL;
   uint32_t addr;
-  int s; /* the socket we're going to make */
-#ifndef MS_WINDOWS
-  int one=1;
-#endif
-  int is_tcp = (type != CONN_TYPE_AP_DNS_LISTENER);
+  uint16_t usePort = 0;
 
-  memset(&amp;listenaddr,0,sizeof(struct sockaddr_in));
-  if (parse_addr_port(LOG_WARN, listenaddress, &amp;address, &amp;addr, &amp;usePort)&lt;0) {
+  if (parse_addr_port(LOG_WARN,
+                      listenaddress, readable_address, &amp;addr, &amp;usePort)&lt;0) {
     log_warn(LD_CONFIG,
              "Error parsing/resolving ListenAddress %s", listenaddress);
-    return NULL;
+    goto err;
   }
-
   if (usePort==0)
     usePort = listenport;
-  listenaddr.sin_addr.s_addr = htonl(addr);
-  listenaddr.sin_family = AF_INET;
-  listenaddr.sin_port = htons((uint16_t) usePort);
 
-  log_notice(LD_NET, "Opening %s on %s:%d",
-             conn_type_to_string(type), address, usePort);
+  listenaddr = tor_malloc_zero(sizeof(struct sockaddr_in));
+  listenaddr-&gt;sin_addr.s_addr = htonl(addr);
+  listenaddr-&gt;sin_family = AF_INET;
+  listenaddr-&gt;sin_port = htons((uint16_t) usePort);
 
+  return listenaddr;
+
+ err:
+  tor_free(listenaddr);
+  return NULL;
+}
+
+#ifdef HAVE_SYS_UN_H
+/** Create an AF_UNIX listenaddr struct.
+ * &lt;b&gt;listenaddress&lt;/b&gt; provides the path to the unix socket.
+ *
+ * Eventually &lt;b&gt;listenaddress&lt;/b&gt; will also optionally contain user, group,
+ * and file permissions for the new socket.  But not yet. XXX
+ * Also, since we do not create the socket here the information doesn't help
+ * here.
+ *
+ * If not NULL &lt;b&gt;readable_addrress&lt;/b&gt; will contain a copy of the path part of
+ * &lt;b&gt;listenaddress&lt;/b&gt;.
+ *
+ * The listenaddr struct has to be freed by the caller.
+ */
+struct sockaddr_un *
+create_unix_sockaddr(const char *listenaddress, char **readable_address)
+{
+  struct sockaddr_un *sockaddr = NULL;
+
+  sockaddr = tor_malloc_zero(sizeof(struct sockaddr_un));
+  sockaddr-&gt;sun_family = AF_UNIX;
+  strncpy(sockaddr-&gt;sun_path, listenaddress, sizeof(sockaddr-&gt;sun_path));
+
+  if (readable_address)
+    *readable_address = tor_strdup(listenaddress);
+
+  return sockaddr;
+}
+#else
+struct sockaddr *
+create_unix_sockaddr(const char *listenaddress, char **readable_address)
+{
+  log_fn(LOG_ERR, LD_BUG,
+         "Unix domain sockets not supported, yet we tried to create one.");
+  assert(0);
+};
+#endif /* HAVE_SYS_UN_H */
+
+/** Bind a new non-blocking socket listening to the socket described
+ * by &lt;b&gt;listensockaddr&lt;/b&gt;.
+ *
+ * &lt;b&gt;address&lt;/b&gt; is only used for logging purposes and to add the information
+ * to the conn.
+ */
+static connection_t *
+connection_create_listener(struct sockaddr *listensockaddr, int type,
+  char* address)
+{
+  connection_t *conn;
+  int s; /* the socket we're going to make */
+  uint16_t usePort = 0;
+  int start_reading = 0;
+
   if (get_n_open_sockets() &gt;= get_options()-&gt;_ConnLimit-1) {
     int n_conns = get_n_open_sockets();
     log_warn(LD_NET,"Failing because we have %d connections already. Please "
@@ -668,48 +734,105 @@
     return NULL;
   }
 
-  s = tor_open_socket(PF_INET,
-                      is_tcp ? SOCK_STREAM : SOCK_DGRAM,
-                      is_tcp ? IPPROTO_TCP: IPPROTO_UDP);
-  if (s &lt; 0) {
-    log_warn(LD_NET,"Socket creation failed.");
-    goto err;
-  }
+  if (listensockaddr-&gt;sa_family == AF_INET) {
+    int is_tcp = (type != CONN_TYPE_AP_DNS_LISTENER);
+#ifndef MS_WINDOWS
+    int one=1;
+#endif
+    if (is_tcp)
+      start_reading = 1;
 
+    usePort = ntohs( (uint16_t)
+                     ((struct sockaddr_in *)listensockaddr)-&gt;sin_port);
+
+    log_notice(LD_NET, "Opening %s on %s:%d",
+               conn_type_to_string(type), address, usePort);
+
+    s = tor_open_socket(PF_INET,
+                        is_tcp ? SOCK_STREAM : SOCK_DGRAM,
+                        is_tcp ? IPPROTO_TCP: IPPROTO_UDP);
+    if (s &lt; 0) {
+      log_warn(LD_NET,"Socket creation failed.");
+      goto err;
+    }
+
 #ifndef MS_WINDOWS
-  /* REUSEADDR on normal places means you can rebind to the port
-   * right after somebody else has let it go. But REUSEADDR on win32
-   * means you can bind to the port _even when somebody else
-   * already has it bound_. So, don't do that on Win32. */
-  setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (void*) &amp;one, sizeof(one));
+    /* REUSEADDR on normal places means you can rebind to the port
+     * right after somebody else has let it go. But REUSEADDR on win32
+     * means you can bind to the port _even when somebody else
+     * already has it bound_. So, don't do that on Win32. */
+    setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (void*) &amp;one, sizeof(one));
 #endif
 
-  if (bind(s,(struct sockaddr *)&amp;listenaddr,sizeof(listenaddr)) &lt; 0) {
-    const char *helpfulhint = "";
-    int e = tor_socket_errno(s);
-    if (ERRNO_IS_EADDRINUSE(e))
-      helpfulhint = ". Is Tor already running?";
-    log_warn(LD_NET, "Could not bind to %s:%u: %s%s", address, usePort,
-             tor_socket_strerror(e), helpfulhint);
-    tor_close_socket(s);
-    goto err;
-  }
+    if (bind(s,listensockaddr,sizeof(struct sockaddr_in)) &lt; 0) {
+      const char *helpfulhint = "";
+      int e = tor_socket_errno(s);
+      if (ERRNO_IS_EADDRINUSE(e))
+        helpfulhint = ". Is Tor already running?";
+      log_warn(LD_NET, "Could not bind to %s:%u: %s%s", address, usePort,
+               tor_socket_strerror(e), helpfulhint);
+      tor_close_socket(s);
+      goto err;
+    }
 
-  if (is_tcp) {
+    if (is_tcp) {
+      if (listen(s,SOMAXCONN) &lt; 0) {
+        log_warn(LD_NET, "Could not listen on %s:%u: %s", address, usePort,
+                 tor_socket_strerror(tor_socket_errno(s)));
+        tor_close_socket(s);
+        goto err;
+      }
+    }
+#ifdef HAVE_SYS_UN_H
+  } else if (listensockaddr-&gt;sa_family == AF_UNIX) {
+    int len;
+    start_reading = 1;
+
+    /* For now only control ports can be unix domain sockets
+     * and listeners at the same time */
+    tor_assert(type == CONN_TYPE_CONTROL_LISTENER);
+
+    log_notice(LD_NET, "Opening %s on %s",
+               conn_type_to_string(type), address);
+
+    if (unlink(address) &lt; 0 &amp;&amp; errno != ENOENT) {
+      log_warn(LD_NET, "Could not unlink %s: %s", address,
+                       strerror(errno));
+      goto err;
+    }
+    s = tor_open_socket(AF_UNIX, SOCK_STREAM, 0);
+    if (s &lt; 0) {
+      log_warn(LD_NET,"Socket creation failed: %s.", strerror(errno));
+      goto err;
+    }
+
+    len = strlen(((struct sockaddr_un *)listensockaddr)-&gt;sun_path) +
+          sizeof(((struct sockaddr_un *)listensockaddr)-&gt;sun_family);
+    if (bind(s, listensockaddr, len) == -1) {
+      log_warn(LD_NET,"Bind to %s failed: %s.", address,
+               tor_socket_strerror(tor_socket_errno(s)));
+      goto err;
+    }
+
     if (listen(s,SOMAXCONN) &lt; 0) {
-      log_warn(LD_NET, "Could not listen on %s:%u: %s", address, usePort,
+      log_warn(LD_NET, "Could not listen on %s: %s", address,
                tor_socket_strerror(tor_socket_errno(s)));
       tor_close_socket(s);
       goto err;
     }
+#endif /* HAVE_SYS_UN_H */
+  } else {
+      log_err(LD_BUG,"Got unexpected address family %d.",
+              listensockaddr-&gt;sa_family);
+      tor_assert(0);
   }
 
   set_socket_nonblocking(s);
 
-  conn = connection_new(type);
+  conn = connection_new(type, listensockaddr-&gt;sa_family);
+  conn-&gt;sa_family = listensockaddr-&gt;sa_family;
   conn-&gt;s = s;
-  conn-&gt;address = address;
-  address = NULL;
+  conn-&gt;address = tor_strdup(address);
   conn-&gt;port = usePort;
 
   if (connection_add(conn) &lt; 0) { /* no space, forget it */
@@ -722,7 +845,7 @@
             conn_type_to_string(type), usePort);
 
   conn-&gt;state = LISTENER_STATE_READY;
-  if (is_tcp) {
+  if (start_reading) {
     connection_start_reading(conn);
   } else {
     tor_assert(type == CONN_TYPE_AP_DNS_LISTENER);
@@ -732,7 +855,6 @@
   return conn;
 
  err:
-  tor_free(address);
   return NULL;
 }
 
@@ -801,56 +923,76 @@
 
   set_socket_nonblocking(news);
 
-  if (check_sockaddr_in((struct sockaddr*)addrbuf, remotelen, LOG_INFO)&lt;0) {
-    log_info(LD_NET,
-             "accept() returned a strange address; trying getsockname().");
-    remotelen=256;
-    memset(addrbuf, 0, sizeof(addrbuf));
-    if (getsockname(news, (struct sockaddr*)addrbuf, &amp;remotelen)&lt;0) {
-      int e = tor_socket_errno(news);
-      log_warn(LD_NET, "getsockname() for new connection failed: %s",
-               tor_socket_strerror(e));
-    } else {
-      if (check_sockaddr_in((struct sockaddr*)addrbuf, remotelen,
-                            LOG_WARN) &lt; 0) {
-        log_warn(LD_NET,"Something's wrong with this conn. Closing it.");
+  tor_assert(((struct sockaddr*)addrbuf)-&gt;sa_family == conn-&gt;sa_family);
+
+  if (conn-&gt;sa_family == AF_INET) {
+    if (check_sockaddr_in((struct sockaddr*)addrbuf, remotelen, LOG_INFO)&lt;0) {
+      log_info(LD_NET,
+               "accept() returned a strange address; trying getsockname().");
+      remotelen=256;
+      memset(addrbuf, 0, sizeof(addrbuf));
+      if (getsockname(news, (struct sockaddr*)addrbuf, &amp;remotelen)&lt;0) {
+        int e = tor_socket_errno(news);
+        log_warn(LD_NET, "getsockname() for new connection failed: %s",
+                 tor_socket_strerror(e));
+      } else {
+        if (check_sockaddr_in((struct sockaddr*)addrbuf, remotelen,
+                              LOG_WARN) &lt; 0) {
+          log_warn(LD_NET,"Something's wrong with this conn. Closing it.");
+          tor_close_socket(news);
+          return 0;
+        }
+      }
+    }
+    memcpy(&amp;remote, addrbuf, sizeof(struct sockaddr_in));
+
+    /* process entrance policies here, before we even create the connection */
+    if (new_type == CONN_TYPE_AP) {
+      /* check sockspolicy to see if we should accept it */
+      if (socks_policy_permits_address(ntohl(remote.sin_addr.s_addr)) == 0) {
+        tor_inet_ntoa(&amp;remote.sin_addr, tmpbuf, sizeof(tmpbuf));
+        log_notice(LD_APP,
+                   "Denying socks connection from untrusted address %s.",
+                   tmpbuf);
         tor_close_socket(news);
         return 0;
       }
     }
-  }
-  memcpy(&amp;remote, addrbuf, sizeof(struct sockaddr_in));
-
-  /* process entrance policies here, before we even create the connection */
-  if (new_type == CONN_TYPE_AP) {
-    /* check sockspolicy to see if we should accept it */
-    if (socks_policy_permits_address(ntohl(remote.sin_addr.s_addr)) == 0) {
-      tor_inet_ntoa(&amp;remote.sin_addr, tmpbuf, sizeof(tmpbuf));
-      log_notice(LD_APP,"Denying socks connection from untrusted address %s.",
-                 tmpbuf);
-      tor_close_socket(news);
-      return 0;
+    if (new_type == CONN_TYPE_DIR) {
+      /* check dirpolicy to see if we should accept it */
+      if (dir_policy_permits_address(ntohl(remote.sin_addr.s_addr)) == 0) {
+        tor_inet_ntoa(&amp;remote.sin_addr, tmpbuf, sizeof(tmpbuf));
+        log_notice(LD_DIRSERV,"Denying dir connection from address %s.",
+                   tmpbuf);
+        tor_close_socket(news);
+        return 0;
+      }
     }
-  }
-  if (new_type == CONN_TYPE_DIR) {
-    /* check dirpolicy to see if we should accept it */
-    if (dir_policy_permits_address(ntohl(remote.sin_addr.s_addr)) == 0) {
-      tor_inet_ntoa(&amp;remote.sin_addr, tmpbuf, sizeof(tmpbuf));
-      log_notice(LD_DIRSERV,"Denying dir connection from address %s.",
-                 tmpbuf);
-      tor_close_socket(news);
-      return 0;
-    }
-  }
 
-  newconn = connection_new(new_type);
-  newconn-&gt;s = news;
+    newconn = connection_new(new_type, conn-&gt;sa_family);
+    newconn-&gt;s = news;
 
-  /* remember the remote address */
-  newconn-&gt;addr = ntohl(remote.sin_addr.s_addr);
-  newconn-&gt;port = ntohs(remote.sin_port);
-  newconn-&gt;address = tor_dup_addr(newconn-&gt;addr);
+    /* remember the remote address */
+    newconn-&gt;addr = ntohl(remote.sin_addr.s_addr);
+    newconn-&gt;port = ntohs(remote.sin_port);
+    newconn-&gt;address = tor_dup_addr(newconn-&gt;addr);
 
+  } else if (conn-&gt;sa_family == AF_UNIX) {
+    /* For now only control ports can be unix domain sockets
+     * and listeners at the same time */
+    tor_assert(conn-&gt;type == CONN_TYPE_CONTROL_LISTENER);
+
+    newconn = connection_new(new_type, conn-&gt;sa_family);
+    newconn-&gt;s = news;
+
+    /* remember the remote address -- do we have anything sane to put here? */
+    newconn-&gt;addr = 0;
+    newconn-&gt;port = 1;
+    newconn-&gt;address = tor_strdup(conn-&gt;address);
+  } else {
+    tor_assert(0);
+  };
+
   if (connection_add(newconn) &lt; 0) { /* no space, forget it */
     connection_free(newconn);
     return 0; /* no need to tear down the parent */
@@ -1007,7 +1149,8 @@
                 int port_option, const char *default_addr,
                 smartlist_t *replaced_conns,
                 smartlist_t *new_conns,
-                int never_open_conns)
+                int never_open_conns,
+                int sa_family)
 {
   smartlist_t *launch = smartlist_create(), *conns;
   int free_launch_elts = 1;
@@ -1016,6 +1159,8 @@
   connection_t *conn;
   config_line_t *line;
 
+  tor_assert(sa_family == AF_INET || sa_family == AF_UNIX);
+
   if (cfg &amp;&amp; port_option) {
     for (c = cfg; c; c = c-&gt;next) {
       smartlist_add(launch, c);
@@ -1036,7 +1181,9 @@
   conns = get_connection_array();
   SMARTLIST_FOREACH(conns, connection_t *, conn,
   {
-    if (conn-&gt;type != type || conn-&gt;marked_for_close)
+    if (conn-&gt;type != type ||
+        conn-&gt;sa_family != sa_family ||
+        conn-&gt;marked_for_close)
       continue;
     /* Okay, so this is a listener.  Is it configured? */
     line = NULL;
@@ -1044,15 +1191,28 @@
       {
         char *address=NULL;
         uint16_t port;
-        if (!parse_addr_port(LOG_WARN, wanted-&gt;value, &amp;address, NULL, &amp;port)) {
-          int addr_matches = !strcasecmp(address, conn-&gt;address);
-          tor_free(address);
-          if (! port)
-            port = port_option;
-          if (port == conn-&gt;port &amp;&amp; addr_matches) {
-            line = wanted;
+        switch (sa_family) {
+          case AF_INET:
+            if (!parse_addr_port(LOG_WARN,
+                                 wanted-&gt;value, &amp;address, NULL, &amp;port)) {
+              int addr_matches = !strcasecmp(address, conn-&gt;address);
+              tor_free(address);
+              if (! port)
+                port = port_option;
+              if (port == conn-&gt;port &amp;&amp; addr_matches) {
+                line = wanted;
+                break;
+              }
+            }
             break;
-          }
+          case AF_UNIX:
+            if (!strcasecmp(wanted-&gt;value, conn-&gt;address)) {
+              line = wanted;
+              break;
+            }
+            break;
+          default:
+            tor_assert(0);
         }
       });
     if (! line) {
@@ -1080,8 +1240,31 @@
   if (!never_open_conns) {
     SMARTLIST_FOREACH(launch, config_line_t *, cfg_line,
       {
-        conn = connection_create_listener(cfg_line-&gt;value,
-                                          (uint16_t) port_option, type);
+        char *address = NULL;
+        struct sockaddr *listensockaddr;
+
+        switch (sa_family) {
+          case AF_INET:
+            listensockaddr = (struct sockaddr *)
+                             create_inet_sockaddr(cfg_line-&gt;value,
+                                                  (uint16_t) port_option,
+                                                  &amp;address);
+            break;
+          case AF_UNIX:
+            listensockaddr = (struct sockaddr *)
+                             create_unix_sockaddr(cfg_line-&gt;value,
+                                                  &amp;address);
+            break;
+          default:
+            tor_assert(0);
+        }
+
+        if (listensockaddr) {
+          conn = connection_create_listener(listensockaddr, type, address);
+          tor_free(address);
+        } else
+          conn = NULL;
+
         if (!conn) {
           r = -1;
         } else {
@@ -1115,33 +1298,46 @@
 
   if (retry_listeners(CONN_TYPE_OR_LISTENER, options-&gt;ORListenAddress,
                       options-&gt;ORPort, "0.0.0.0",
-                      replaced_conns, new_conns, options-&gt;ClientOnly)&lt;0)
+                      replaced_conns, new_conns, options-&gt;ClientOnly,
+                      AF_INET)&lt;0)
     return -1;
   if (retry_listeners(CONN_TYPE_DIR_LISTENER, options-&gt;DirListenAddress,
                       options-&gt;DirPort, "0.0.0.0",
-                      replaced_conns, new_conns, 0)&lt;0)
+                      replaced_conns, new_conns, 0,
+                      AF_INET)&lt;0)
     return -1;
   if (retry_listeners(CONN_TYPE_AP_LISTENER, options-&gt;SocksListenAddress,
                       options-&gt;SocksPort, "127.0.0.1",
-                      replaced_conns, new_conns, 0)&lt;0)
+                      replaced_conns, new_conns, 0,
+                      AF_INET)&lt;0)
     return -1;
   if (retry_listeners(CONN_TYPE_AP_TRANS_LISTENER, options-&gt;TransListenAddress,
                       options-&gt;TransPort, "127.0.0.1",
-                      replaced_conns, new_conns, 0)&lt;0)
+                      replaced_conns, new_conns, 0,
+                      AF_INET)&lt;0)
     return -1;
   if (retry_listeners(CONN_TYPE_AP_NATD_LISTENER, options-&gt;NatdListenAddress,
                       options-&gt;NatdPort, "127.0.0.1",
-                      replaced_conns, new_conns, 0)&lt;0)
+                      replaced_conns, new_conns, 0,
+                      AF_INET)&lt;0)
     return -1;
   if (retry_listeners(CONN_TYPE_AP_DNS_LISTENER, options-&gt;DNSListenAddress,
                       options-&gt;DNSPort, "127.0.0.1",
-                      replaced_conns, new_conns, 0)&lt;0)
+                      replaced_conns, new_conns, 0,
+                      AF_INET)&lt;0)
     return -1;
   if (retry_listeners(CONN_TYPE_CONTROL_LISTENER,
                       options-&gt;ControlListenAddress,
                       options-&gt;ControlPort, "127.0.0.1",
-                      replaced_conns, new_conns, 0)&lt;0)
+                      replaced_conns, new_conns, 0,
+                      AF_INET)&lt;0)
     return -1;
+  if (retry_listeners(CONN_TYPE_CONTROL_LISTENER,
+                      options-&gt;ControlSocket,
+                      options-&gt;ControlSocket ? 1 : 0, NULL,
+                      replaced_conns, new_conns, 0,
+                      AF_UNIX)&lt;0)
+    return -1;
 
   return 0;
 }
Index: src/or/directory.c
===================================================================
--- src/or/directory.c	(revision 10502)
+++ src/or/directory.c	(working copy)
@@ -490,7 +490,7 @@
       tor_assert(0);
   }
 
-  conn = TO_DIR_CONN(connection_new(CONN_TYPE_DIR));
+  conn = TO_DIR_CONN(connection_new(CONN_TYPE_DIR, AF_INET));
 
   /* set up conn so it's got all the data we need to remember */
   conn-&gt;_base.addr = addr;
Index: src/or/cpuworker.c
===================================================================
--- src/or/cpuworker.c	(revision 10502)
+++ src/or/cpuworker.c	(working copy)
@@ -339,7 +339,7 @@
   tor_free(fdarray);
 #endif
 
-  conn = connection_new(CONN_TYPE_CPUWORKER);
+  conn = connection_new(CONN_TYPE_CPUWORKER, AF_UNIX);
 
   set_socket_nonblocking(fd);
 
Index: src/or/dnsserv.c
===================================================================
--- src/or/dnsserv.c	(revision 10502)
+++ src/or/dnsserv.c	(working copy)
@@ -110,7 +110,7 @@
   /* XXXX020 Send a stream event to the controller. */
 
   /* Make a new dummy AP connection, and attach the request to it. */
-  conn = TO_EDGE_CONN(connection_new(CONN_TYPE_AP));
+  conn = TO_EDGE_CONN(connection_new(CONN_TYPE_AP, AF_INET));
   conn-&gt;_base.state = AP_CONN_STATE_RESOLVE_WAIT;
   if (q-&gt;type == EVDNS_TYPE_A)
     conn-&gt;socks_request-&gt;command = SOCKS_COMMAND_RESOLVE;



</body></email><email><emailId>20071203113918</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-12-03 11:39:18-0400</timestampReceived><subject>Proposal: Getting GeoIP data and publishing usage summaries</subject><body>

Filename: 126-geoip-fetching.txt
Title: Getting GeoIP data and publishing usage summaries
Version: $Revision: 12644 $
Last-Modified: $Date: 2007-12-03 06:18:44 -0500 (Mon, 03 Dec 2007) $
Author: Roger Dingledine
Created: 2007-11-24
Status: Open

1. Background and motivation

  Right now we can keep a rough count of Tor users, both total and by
  country, by watching connections to a single directory mirror. Being
  able to get usage estimates is useful both for our funders (to
  demonstrate progress) and for our own development (so we know how
  quickly we're scaling and can design accordingly, and so we know which
  countries and communities to focus on more). This need for information
  is the only reason we haven't deployed "directory guards" (think of
  them like entry guards but for directory information; in practice,
  it would seem that Tor clients should simply use their entry guards
  as their directory guards; see also proposal 125).

  With the move toward bridges, we will no longer be able to track Tor
  clients that use bridges, since they use their bridges as directory
  guards. Further, we need to be able to learn which bridges stop seeing
  use from certain countries (and are thus likely blocked), so we can
  avoid giving them out to other users in those countries.

  Right now we already do GeoIP lookups in Vidalia: Vidalia draws relays
  and circuits on its 'network map', and it performs anonymized GeoIP
  lookups to its central servers to know where to put the dots. Vidalia
  caches answers it gets -- to reduce delay, to reduce overhead on
  the network, and to reduce anonymity issues where users reveal their
  knowledge about the network through which IP addresses they ask about.

  But with the advent of bridges, Tor clients are asking about IP
  addresses that aren't in the main directory. In particular, bridge
  users inform the central Vidalia servers about each bridge as they
  discover it and their Vidalia tries to map it.

  Also, we wouldn't mind letting Vidalia do a GeoIP lookup on the client's
  own IP address, so it can provide a more useful map.

  Finally, Vidalia's central servers leave users open to partitioning
  attacks, even if they can't target specific users. Further, as we
  start using GeoIP results for more operational or security-relevant
  goals, such as avoiding or including particular countries in circuits,
  it becomes more important that users can't be singled out in terms of
  their IP-to-country mapping beliefs.

2. The available GeoIP databases

  There are at least two classes of GeoIP database out there: "IP to
  country", which tells us the country code for the IP address but
  no more details, and "IP to city", which tells us the country code,
  the name of the city, and some basic latitude/longitude guesses.

  A recent ip-to-country.csv is 3421362 bytes. Compressed, it is 564252
  bytes. A typical line is:
    "205500992","208605279","US","USA","UNITED STATES"
  http://ip-to-country.webhosting.info/node/view/5

  Similarly, the maxmind GeoLite Country database is also about 500KB
  compressed.
  http://www.maxmind.com/app/geolitecountry

  The maxmind GeoLite City database gives more finegrained detail like
  geo coordinates and city name. Vidalia currently makes use of this
  information. On the other hand it's 16MB compressed. A typical line is:
    206.124.149.146,Bellevue,WA,US,47.6051,-122.1134
  http://www.maxmind.com/app/geolitecity

  There are other databases out there, like
  http://www.hostip.info/faq.html
  http://www.webconfs.com/ip-to-city.php
  that want more attention, but for now let's assume that all the db's
  are around this size.

3. What we'd like to solve

  Goal #1a: Tor relays collect IP-to-country user stats and publish
  sanitized versions.
  Goal #1b: Tor bridges collect IP-to-country user stats and publish
  sanitized versions.

  Goal #2a: Vidalia learns IP-to-city stats for Tor relays, for better
  mapping.
  Goal #2b: Vidalia learns IP-to-country stats for Tor relays, so the user
  can pick countries for her paths.

  Goal #3: Vidalia doesn't do external lookups on bridge relay addresses.

  Goal #4: Vidalia resolves the Tor client's IP-to-country or IP-to-city
  for better mapping.

  Goal #5: Reduce partitioning opportunities where Vidalia central
  servers can give different (distinguishing) responses.

4. Solution overview

  Our goal is to allow Tor relays, bridges, and clients to learn enough
  GeoIP information so they can do local private queries.

4.1. The IP-to-country db

  Directory authorities should publish a "geoip" file that contains
  IP-to-country mappings. Directory caches will mirror it, and Tor clients
  and relays (including bridge relays) will fetch it. Thus we can solve
  goals 1a and 1b (publish sanitized usage info). Controllers could also
  use this to solve goal 2b (choosing path by country attributes). It
  also solves goal 4 (learning the Tor client's country), though for
  huge countries like the US we'd still need to decide where the "middle"
  should be when we're mapping that address.

  The IP-to-country details are described further in Sections 5 and
  6 below.

4.2. The IP-to-city db

  In an ideal world, the IP-to-city db would be small enough that we
  could distribute it in the above manner too. But for now, it is too
  large. Here's where the design choice forks.

  Option A: Vidalia should continue doing its anonymized IP-to-city
  queries. Thus we can achieve goals 2a and 2b. We would solve goal
  3 by only doing lookups on descriptors that are purpose "general"
  (see Section 4.2.1 for how). We would leave goal 5 unsolved.

  Option B: Each directory authority should keep an IP-to-city db,
  lookup the value for each router it lists, and include that line in
  the router's network-status entry. The network-status consensus would
  then use the line that appears in the majority of votes. This approach
  also solves goals 2a and 2b, goal 3 (Vidalia doesn't do any lookups
  at all now), and goal 5 (reduced partitioning risks).

  Option B has the advantage that Vidalia can simplify its operation,
  and the advantage that this consensus IP-to-city data is available to
  other controllers besides just Vidalia. But it has the disadvantage
  that the networkstatus consensus becomes larger, even though most of
  the GeoIP information won't change from one consensus to the next. Is
  there another reasonable location for it that can provide similar
  consensus security properties?

4.2.1. Controllers can query for router annotations

  Vidalia needs to stop doing queries on bridge relay IP addresses.
  It could do that by only doing lookups on descriptors that are in
  the networkstatus consensus, but that precludes designs like Blossom
  that might want to map its relay locations. The best answer is that it
  should learn the router annotations, with a new controller 'getinfo'
  command:
    "GETINFO router-annotations/id/&lt;OR identity&gt;" or
    "GETINFO router-annotations/name/&lt;OR nickname&gt;"
  which would respond with something like
    @downloaded-at 2007-11-29 08:06:38
    @source "128.31.0.34"
    @purpose bridge

  [We could also make the answer include the digest for the router in
  question, which would enable us to ask GETINFO router-annotations/all.
  Is this worth it? -RD]

  Then Vidalia can avoid doing lookups on descriptors with purpose
  "bridge". Even better would be to add a new annotation "@private true"
  so Vidalia can know how to handle new purposes that we haven't created
  yet. Vidalia could special-case "bridge" for now, for compatibility
  with the current 0.2.0.x-alphas.

4.3. Recommendation

  My overall recommendation is that we should implement 4.1 soon
  (e.g. early in 0.2.1.x), and we can go with 4.2 option A for now,
  with the hope that later we discover a better way to distribute the
  IP-to-city info and can switch to 4.2 option B.

  Below we discuss more how to go about achieving 4.1.

5. Publishing and caching the GeoIP (IP-to-country) database

  Each v3 directory authority should put a copy of the "geoip" file in
  its datadirectory. Then its network-status votes should include a hash
  of this file (Recommended-geoip-hash: %s), and the resulting consensus
  directory should specify the consensus hash.

  There should be a new URL for fetching this geoip db (by "current.z"
  for testing purposes, and by hash.z for typical downloads). Authorities
  should fetch and serve the one listed in the consensus, even when they
  vote for their own. This would argue for storing the cached version
  in a better filename than "geoip".

  Directory mirrors should keep a copy of this file available via the
  same URLs.

  We assume that the file would change at most a few times a month. Should
  Tor ship with a bootstrap geoip file? An out-of-date geoip file may
  open you up to partitioning attacks, but for the most part it won't
  be that different.

  There should be a config option to disable updating the geoip file,
  in case users want to use their own file (e.g. they have a proprietary
  GeoIP file they prefer to use). In that case we leave it up to the
  user to update his geoip file out-of-band.

  [XXX Should consider forward/backward compatibility, e.g. if we want
  to move to a new geoip file format. -RD]

6. Controllers use the IP-to-country db for mapping and for path building

  Down the road, Vidalia could use the IP-to-country mappings for placing
  on its map:
  - The location of the client
  - The location of the bridges, or other relays not in the
    networkstatus, on the map.
  - Any relays that it doesn't yet have an IP-to-city answer for.

  Other controllers can also use it to set EntryNodes, ExitNodes, etc
  in a per-country way.

  To support these features, we need to export the IP-to-country data
  via the Tor controller protocol.

  Is it sufficient just to add a new GETINFO command?
    GETINFO ip-to-country/128.31.0.34
    250+ip-to-country/128.31.0.34="US","USA","UNITED STATES"

6.1. Other interfaces

  Robert Hogan has also suggested a

    GETINFO relays-by-country/cn

  as well as torrc options for ExitCountryCodes, EntryCountryCodes,
  ExcludeCountryCodes, etc.

7. Relays and bridges use the IP-to-country db for usage summaries

  Once bridges have a GeoIP database locally, they can start to publish
  sanitized summaries of client usage -- how many users they see and from
  what countries. This might also be a more useful way for ordinary Tor
  relays to convey the level of usage they see, which would allow us to
  switch to using directory guards for all users by default.

  But how to safely summarize this information without opening too many
  anonymity leaks?

7.1 Attacks to think about

  First, note that we need to have a large enough time window that we're
  not aiding correlation attacks much. I hope 24 hours is enough. So
  that means no publishing stats until you've been up at least 24 hours.
  And you can't publish follow-up stats more often than every 24 hours,
  or people could look at the differential.

  Second, note that we need to be sufficiently vague about the IP
  addresses we're reporting. We are hoping that just specifying the
  country will be vague enough. But a) what about active attacks where
  we convince a bridge to use a GeoIP db that labels each suspect IP
  address as a unique country? We have to assume that the consensus GeoIP
  db won't be malicious in this way. And b) could such singling-out
  attacks occur naturally, for example because of countries that have
  a very small IP space? We should investigate that.

7.2. Granularity of users

  Do we only want to report countries that have a sufficient anonymity set
  (that is, number of users) for the day? For example, we might avoid
  listing any countries that have seen less than five addresses over
  the 24 hour period. This approach would be helpful in reducing the
  singling-out opportunities -- in the extreme case, we could imagine a
  situation where one blogger from the Sudan used Tor on a given day, and
  we can discover which entry guard she used.

  But I fear that especially for bridges, seeing only one hit from a
  given country in a given day may be quite common.

  As a compromise, we should start out with an "Other" category in
  the reported stats, which is the sum of unlisted countries; if that
  category is consistently interesting, we can think harder about how
  to get the right data from it safely.

  But note that bridge summaries will not be made public individually,
  since doing so would help people enumerate bridges. Whereas summaries
  from normal relays will be public. So perhaps that means we can afford
  to be more specific in bridge summaries? In particular, I'm thinking the
  "other" category should be used by public relays but not for bridges
  (or if it is, used with a lower threshold).

  Even for countries that have many Tor users, we might not want to be
  too specific about how many users we've seen. For example, we might
  round down the number of users we report to the nearest multiple of 5.
  My instinct for now is that this won't be that useful.

7.3 Other issues

  Another note: we'll likely be overreporting in the case of users with
  dynamic IP addresses: if they rotate to a new address over the course
  of the day, we'll count them twice. So be it.

7.4. Where to publish the summaries?

  We designed extrainfo documents for information like this. So they
  should just be more entries in the extrainfo doc.

  But if we want to publish summaries every 24 hours (no more often,
  no less often), aren't we tried to the router descriptor publishing
  schedule? That is, if we publish a new router descriptor at the 18
  hour mark, and nothing much has changed at the 24 hour mark, won't
  the new descriptor get dropped as being "cosmetically similar", and
  then nobody will know to ask about the new extrainfo document?

  One solution would be to make and remember the 24 hour summary at the
  24 hour mark, but not actually publish it anywhere until we happen to
  publish a new descriptor for other reasons. If we happen to go down
  before publishing a new descriptor, then so be it, at least we tried.

7.5. What if the relay is unreachable or goes to sleep?

  Even if you've been up for 24 hours, if you were hibernating for 18
  of them, then we're not getting as much fuzziness as we'd like. So
  I guess that means that we need a 24-hour period of being "awake"
  before we'll willing to publish a summary. A similar attack works if
  you've been awake but unreachable for the first 18 of the 24 hours. As
  another example, a bridge that's on a laptop might be suspended for
  some of each day.

  This implies that some relays and bridges will never publish summary
  stats, because they're not ever reliably working for 24 hours in
  a row. If a significant percentage of our reporters end up being in
  this boat, we should investigate whether we can accumulate 24 hours of
  "usefulness", even if there are holes in the middle, and publish based
  on that.

  What other issues are like this? It seems that just moving to a new
  IP address shouldn't be a reason to cancel stats publishing, assuming
  we were usable at each address.

7.6. IP addresses that aren't in the geoip db

  Some IP addresses aren't in the public geoip databases. In particular,
  I've found that a lot of African countries are missing, but there
  are also some common ones in the US that are missing, like parts of
  Comcast. We could just lump unknown IP addresses into the "other"
  category, but it might be useful to gather a general sense of how many
  lookups are failing entirely, by adding a separate "Unknown" category.

  We could also contribute back to the geoip db, by letting bridges set
  a config option to report the actual IP addresses that failed their
  lookup. Then the bridge authority operators can manually make sure
  the correct answer will be in later geoip files. This config option
  should be disabled by default.

7.7 Bringing it all together

  So here's the plan:

  24 hours after starting up (modulo Section 7.5 above), bridges and
  relays should construct a daily summary of client countries they've
  seen, including the above "Unknown" category (Section 7.6) as well.

  Non-bridge relays lump all countries with less than K (e.g. K=5) users
  into the "Other" category (see Sec 7.2 above), whereas bridge relays are
  willing to list a country even when it has only one user for the day.

  Whenever we have a daily summary on record, we include it in our
  extrainfo document whenever we publish one. The daily summary we
  remember locally gets replaced with a newer one when another 24
  hours pass.

7.8. Some forward secrecy

  How should we remember addresses locally? If we convert them into
  country-codes immediately, we will count them again if we see them
  again. On the other hand, we don't really want to keep a list hanging
  around of all IP addresses we've seen in the past 24 hours.

  Step one is that we should never write this stuff to disk. Keeping it
  only in ram will make things somewhat better. Step two is to avoid
  keeping any timestamps associated with it: rather than a rolling
  24-hour window, which would require us to remember the various times
  we've seen that address, we can instead just throw out the whole list
  every 24 hours and start over.

  We could hash the addresses, and then compare hashes when deciding if
  we've seen a given address before. We could even do keyed hashes. Or
  Bloom filters. But if our goal is to defend against an adversary
  who steals a copy of our ram while we're running and then does
  guess-and-check on whatever blob we're keeping, we're in bad shape.

  We could drop the last octet of the IP address as soon as we see
  it. That would cause us to undercount some users from cablemodem and
  DSL networks that have a high density of Tor users. And it wouldn't
  really help that much -- indeed, the extent to which it does help is
  exactly the extent to which it makes our stats less useful.

  Other ideas?

</body></email><email><emailId>20071206044842</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-12-06 04:48:42-0400</timestampReceived><subject>Re: Tor Ipv6-Patch</subject><body>


On Tue, Dec 04, 2007 at 08:03:50AM -0500, Michael G. Reed wrote:
&gt; On Tue, 4 Dec 2007, Marcus Wolschon - Wolschon Softwaredesign wrote:
&gt; |&gt; &gt;  - You're right that the preferred way to store addresses that could be
&gt; |&gt; &gt;    either IPv4 or IPv6 is indeed with tor_addr_t.  (Thanks for the
&gt; |&gt; &gt;    reminder, BTW: I fixed tor_addr_t to be a tagged union of in_addr and
&gt; |&gt; &gt;    in6_addr, not of sockaddr_in and sockaddr_in6.)
&gt; |&gt; 
&gt; |&gt; do you want to do the refactoring to use tor_address_t or shall I?
&gt; |&gt; So we need a pair of tor_address_t and int socket_family. Wouldn't it
&gt; |&gt; be better to have the socket_family in a struct with the tor_address_t
&gt; |&gt; - -union? That way it would probably be a drop-in -replacement for the
&gt; |&gt; 32bit-addresses.

Check out how the code for tor_addr_t is now; it's about what you say:
It's a struct with a family and a union of in_addr and in6_addr.
("Tagged union" in this case means "union with a field that tells you
which case of the union a particular item is.)

(Also, you keep saying "tor_address_t" instead of "tor_addr_t".  Are you
looking at another struct somewhere with a different name?)

&gt; This is exactly why multi-protocol developers normally use
&gt; sockaddr_storage to define the space for an address they do not know
&gt; the type of in advance and then rely on the sa_family field to
&gt; differentiate.  sockaddr_storage is guaranteed to be large enough to
&gt; hold the largest supported address type in the system (not
&gt; efficient/desirable/usable for on-the-wire, but is best used in
&gt; application processing).

Alas, we need lots of these: a rough estimage is at least 40K [*] on a
busy server.  Sockaddr_storage is about 128 bytes on most platforms
I've encountered, whereas we only need ~16 bytes for an in6_addr.
(sockaddr_in6 is only ~~28 bytes).  I know Tor is already a bit of a
memory hog, but adding another 4MB to the process size for the unused
portion of all the sockaddr_storages rubs me the wrong way.

Yrs,
-- 
Nick

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20071206152422</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-12-06 15:24:22-0400</timestampReceived><subject>Re: [or-cvs] r12599: more progress on the geoip proposal  (tor/trunk/doc/spec/proposals)</subject><body>

On Mon, Dec 03, 2007 at 09:46:13PM +0000, Robert Hogan wrote:
&gt; That said, tt would be just an extra three bytes per status (including the 
&gt; space) if you were  to provide country code, roughly 4-5K at current volumes. 
&gt; If country code is enough for the near future then this might be the way to 
&gt; go. The x-y co-ordinates could then be an opt field in the network-status 
&gt; document, if a client needs them.

Right, but that doesn't solve one of the main goals here: being able to
do private lookups on addresses that aren't in the main directory.

(I don't actually care much about being able to do path selection by
country. But I do want to make sure that whatever design I pick here
doesn't preclude doing that later.)

&gt; Given that bw is something to conserve, perhaps a few wasteful bytes from the 
&gt; network-status could be removed for 0.2, e.g.. the '-'  and ':' in the date 
&gt; and time stamps. Maybe the status flags could be abbreviated? These two alone 
&gt; would make enough room for country code and co-ordinates! ;-) I know what a 
&gt; hack that would be to code around, but...

Compression (nearly) does this for free. Certainly enough that I don't
want to get messy with it. :)

--Roger

</body></email><email><emailId>20071208124854</emailId><senderName>Marcus Wolschon - Wolschon Softwaredesign</senderName><senderEmail>marcus@wolschon.biz</senderEmail><timestampReceived>2007-12-08 12:48:54-0400</timestampReceived><subject>Re: Tor Ipv6-Patch (V4)</subject><body>

This is a MIME-formatted message.  If you see this text it means that your
E-mail software does not support MIME-formatted messages.

[Attachment #2 (multipart/mixed)]


Karsten Loesing schrieb:
&gt; Hi Marcus,
&gt; - You changed encoding of v2 hidden service descriptors, so that
&gt; introduction points can be addressed via IPv6 in
&gt; rend_encode_v2_intro_points(), but I think you did not change parsing of
&gt; those descriptors, so that descriptors containing introduction points
&gt; with IPv6 addresses would be rejected; see
&gt; rend_decrypt_introduction_points().

Hello Karsten,
I think I fixed that.

Hello Nick,
&gt;  - You're right that the preferred way to store addresses that could be
&gt;    either IPv4 or IPv6 is indeed with tor_addr_t.  (Thanks for the
&gt;    reminder, BTW: I fixed tor_addr_t to be a tagged union of in_addr and
&gt;    in6_addr, not of sockaddr_in and sockaddr_in6.)

I changed much of it to tor_addr_t. It looks much better.

&gt;  - Generally speaking, we try to avoid duplicated "cut and paste" code;
&gt;    it makes it hard to be sure that we can update all instances of the
&gt;    original code path.  (connection_or_init_conn_from_address6, for
&gt;    example, is almost exactly the same as the existing
&gt;    connection_init_conn_from_address.)

that one is gone now. Thanks for the info.

As for the changed log-strings. I removed them manually
from the diff. I hope patch can still work with it.

I did test the code and it can connect normally to the
ipv4-internet and to the ipv6-hidden-service.

Marcus

-- 
 Marcus Wolschon
 Wolschon Softwaredesign und Beratung
 UStID: DE238951181
 Marcus@Wolschon.biz
 +49 177/6272871 (m-a-r-c-u-s-1)

["2007-12-08-V4_marcus_ipv6_hidden_services_diff_to_tor.diff" (text/x-patch)]

Index: or/circuitlist.c
===================================================================
--- or/circuitlist.c
+++ or/circuitlist.c
@@ -235,7 +235,7 @@
     tor_assert(circ-&gt;state == CIRCUIT_STATE_OR_WAIT);
     if (tor_digest_is_zero(circ-&gt;n_conn_id_digest)) {
       /* Look at addr/port. This is an unkeyed connection. */
-      if (circ-&gt;n_addr != or_conn-&gt;_base.addr ||
+      if ( (compare_addr(circ-&gt;n_addr, or_conn-&gt;_base.addr) != 0) ||
           circ-&gt;n_port != or_conn-&gt;_base.port)
         continue;
     } else {
@@ -558,8 +558,8 @@
         }
       }
     }
-    if (!circ-&gt;n_conn &amp;&amp; circ-&gt;n_addr &amp;&amp; circ-&gt;n_port &amp;&amp;
-        circ-&gt;n_addr == conn-&gt;addr &amp;&amp;
+    if (!circ-&gt;n_conn &amp;&amp; (circ-&gt;n_addr.family != AF_INET || \
circ-&gt;n_addr.addr.in_addr.s_addr) &amp;&amp; circ-&gt;n_port &amp;&amp; +        \
(compare_addr(circ-&gt;n_addr, conn-&gt;addr) == 0)&amp;&amp;  circ-&gt;n_port == conn-&gt;port &amp;&amp;
         conn-&gt;type == CONN_TYPE_OR &amp;&amp;
         !memcmp(TO_OR_CONN(conn)-&gt;identity_digest, circ-&gt;n_conn_id_digest,
Index: or/connection_or.c
===================================================================
--- or/connection_or.c
+++ or/connection_or.c
@@ -339,14 +339,20 @@
 
   if (get_options()-&gt;HttpsProxy) {
     char buf[1024];
-    char addrbuf[INET_NTOA_BUF_LEN];
-    struct in_addr in;
+    char addrbuf[64];
     char *base64_authenticator=NULL;
     const char *authenticator = get_options()-&gt;HttpsProxyAuthenticator;
+    
+    if (conn-&gt;addr.family == AF_INET6) {
+      struct in6_addr addr;
+      addr = conn-&gt;addr.addr.in6_addr;
+      tor_inet_ntop(AF_INET6, &amp;addr, addrbuf, sizeof(addrbuf));
+    } else {
+      struct in_addr in;
+      in.s_addr = htonl(conn-&gt;addr.addr.in_addr.s_addr);
+      tor_inet_ntoa(&amp;in, addrbuf, sizeof(addrbuf));
+    }
 
-    in.s_addr = htonl(conn-&gt;addr);
-    tor_inet_ntoa(&amp;in, addrbuf, sizeof(addrbuf));
-
     if (authenticator) {
       base64_authenticator = alloc_http_authenticator(authenticator);
       if (!base64_authenticator)
@@ -379,7 +385,7 @@
  * by checking to see if this describes a router we know. */
 static void
 connection_or_init_conn_from_address(or_connection_t *conn,
-                                     uint32_t addr, uint16_t port,
+                                     struct tor_addr_t addr, uint16_t port,
                                      const char *id_digest,
                                      int started_here)
 {
@@ -392,15 +398,17 @@
   conn-&gt;_base.port = port;
   conn-&gt;real_addr = addr;
   if (r) {
-    if (conn-&gt;_base.addr == r-&gt;addr)
+    if (conn-&gt;_base.addr.family == AF_INET &amp;&amp; conn-&gt;_base.addr.addr.in_addr.s_addr \
== r-&gt;addr)  conn-&gt;is_canonical = 1;
+
     if (!started_here) {
       /* Override the addr/port, so our log messages will make sense.
        * This is dangerous, since if we ever try looking up a conn by
        * its actual addr/port, we won't remember. Careful! */
       /* XXXX020 this is stupid, and it's the reason we need real_addr to
        * track is_canonical properly. */
-      conn-&gt;_base.addr = r-&gt;addr;
+      conn-&gt;_base.addr.family = AF_INET;
+      conn-&gt;_base.addr.addr.in_addr.s_addr = r-&gt;addr;
       conn-&gt;_base.port = r-&gt;or_port;
     }
     conn-&gt;nickname = tor_strdup(r-&gt;nickname);
@@ -420,7 +428,11 @@
                     conn-&gt;identity_digest, DIGEST_LEN);
     }
     tor_free(conn-&gt;_base.address);
-    conn-&gt;_base.address = tor_dup_addr(addr);
+    if (addr.family == AF_INET6) {
+      conn-&gt;_base.address = tor_dup_addr6(addr.addr.in6_addr);
+    } else {
+      conn-&gt;_base.address = tor_dup_addr(addr.addr.in_addr.s_addr);
+    }
   }
 }
 
@@ -495,7 +507,7 @@
  * Return the launched conn, or NULL if it failed.
  */
 or_connection_t *
-connection_or_connect(uint32_t addr, uint16_t port, const char *id_digest)
+connection_or_connect(tor_addr_t addr, uint16_t port, const char *id_digest)
 {
   or_connection_t *conn;
   or_options_t *options = get_options();
@@ -507,7 +519,7 @@
     return NULL;
   }
 
-  conn = TO_OR_CONN(connection_new(CONN_TYPE_OR, AF_INET));
+  conn = TO_OR_CONN(connection_new(CONN_TYPE_OR, addr.family));
 
   /* set up conn so it's got all the data we need to remember */
   connection_or_init_conn_from_address(conn, addr, port, id_digest, 1);
@@ -516,7 +528,8 @@
 
   if (options-&gt;HttpsProxy) {
     /* we shouldn't connect directly. use the https proxy instead. */
-    addr = options-&gt;HttpsProxyAddr;
+    addr.family = AF_INET;
+    addr.addr.in_addr.s_addr = options-&gt;HttpsProxyAddr;
     port = options-&gt;HttpsProxyPort;
   }
 
@@ -797,8 +810,13 @@
                                   conn-&gt;handshake_state-&gt;started_here,
                                               id_digest) &lt; 0)
     return -1;
-  connection_or_init_conn_from_address(conn, conn-&gt;_base.addr,
-                                       conn-&gt;_base.port, id_digest, 0);
+  if (conn-&gt;_base.socket_family == AF_INET6) {
+    connection_or_init_conn_from_address6(conn, conn-&gt;_base.addr6,
+                                         conn-&gt;_base.port, id_digest, 0);
+  } else {
+    connection_or_init_conn_from_address(conn, conn-&gt;_base.addr4,
+                                         conn-&gt;_base.port, id_digest, 0);
+  }
   if (connection_or_act_on_netinfo(conn)&lt;0)
     return -1;
   return connection_or_set_state_open(conn);
@@ -1068,7 +1086,11 @@
   set_uint32(cell.payload, htonl(now));
   cell.payload[4] = RESOLVED_TYPE_IPV4;
   cell.payload[5] = 4;
-  set_uint32(cell.payload+6, htonl(conn-&gt;_base.addr));
+  if (conn-&gt;_base.addr.family == AF_INET6) {
+    log_warn(LD_BUG, "we do not support ipv6 in connection_or_send_netinfo() ");
+    return -1;
+  }
+  set_uint32(cell.payload+6, htonl(conn-&gt;_base.addr.addr.in_addr.s_addr));
 
   /* My address. */
   if ((me = router_get_my_routerinfo())) {
Index: or/config.c
===================================================================
--- or/config.c
+++ or/config.c
@@ -1940,9 +1940,9 @@
  */
 int
 resolve_my_address(int warn_severity, or_options_t *options,
-                   uint32_t *addr_out, char **hostname_out)
+                   tor_addr_t *addr_out, char **hostname_out)
 {
-  struct in_addr in;
+  struct in_addr in; //TODO: support ipv4
   struct hostent *rent;
   char hostname[256];
   int explicit_ip=1;
@@ -2056,8 +2056,9 @@
   }
 
   log_debug(LD_CONFIG, "Resolved Address to '%s'.", tmpbuf);
-  *addr_out = ntohl(in.s_addr);
-  if (last_resolved_addr &amp;&amp; last_resolved_addr != *addr_out) {
+  addr_out-&gt;family = AF_INET;
+  addr_out-&gt;addr.in_addr.s_addr = ntohl(in.s_addr);
+  if (last_resolved_addr &amp;&amp; last_resolved_addr != addr_out-&gt;addr.in_addr.s_addr) {
     /* Leave this as a notice, regardless of the requested severity,
      * at least until dynamic IP address support becomes bulletproof. */
     log_notice(LD_NET,
@@ -2065,7 +2066,7 @@
                tmpbuf);
     ip_address_changed(0);
   }
-  if (last_resolved_addr != *addr_out) {
+  if (last_resolved_addr != addr_out-&gt;addr.in_addr.s_addr) {
     const char *method;
     const char *h = hostname;
     if (explicit_ip) {
@@ -2083,7 +2084,7 @@
                                 "EXTERNAL_ADDRESS ADDRESS=%s METHOD=%s %s%s",
                                 tmpbuf, method, h?"HOSTNAME=":"", h);
   }
-  last_resolved_addr = *addr_out;
+  last_resolved_addr = addr_out-&gt;addr.in_addr.s_addr;
   if (hostname_out)
     *hostname_out = tor_strdup(hostname);
   return 0;
@@ -2604,7 +2605,7 @@
 
   if (authdir_mode(options)) {
     /* confirm that our address isn't broken, so we can complain now */
-    uint32_t tmp;
+    struct tor_addr_t tmp;
     if (resolve_my_address(LOG_WARN, options, &amp;tmp, NULL) &lt; 0)
       REJECT("Failed to resolve/guess local address. See logs for details.");
   }
Index: or/rendservice.c
===================================================================
--- or/rendservice.c
+++ or/rendservice.c
@@ -20,7 +20,9 @@
 typedef struct rend_service_port_config_t {
   uint16_t virtual_port;
   uint16_t real_port;
-  uint32_t real_addr;
+  u_int16_t real_family;      // AF_INET or AF_INET6
+  uint32_t real_addr4;        // ipv4-address of hidden service depending on \
real_family +  struct in6_addr real_addr6; // ipv6-address of hidden service \
depending on real_family  } rend_service_port_config_t;
 
 /** Try to maintain this many intro points per service if possible. */
@@ -129,7 +131,6 @@
 {
   int i;
   rend_service_port_config_t *p;
-  struct in_addr addr;
 
   if (!service-&gt;intro_prefer_nodes)
     service-&gt;intro_prefer_nodes = tor_strdup("");
@@ -166,15 +167,25 @@
   } else {
     smartlist_set_capacity(service-&gt;ports, -1);
     smartlist_add(rend_service_list, service);
-    log_debug(LD_REND,"Configuring service with directory \"%s\"",
+    log_debug(LD_REND,"Configuring hidden service with directory \"%s\"",
               service-&gt;directory);
     for (i = 0; i &lt; smartlist_len(service-&gt;ports); ++i) {
-      char addrbuf[INET_NTOA_BUF_LEN];
       p = smartlist_get(service-&gt;ports, i);
-      addr.s_addr = htonl(p-&gt;real_addr);
-      tor_inet_ntoa(&amp;addr, addrbuf, sizeof(addrbuf));
-      log_debug(LD_REND,"Service maps port %d to %s:%d",
-                p-&gt;virtual_port, addrbuf, p-&gt;real_port);
+      if (p-&gt;real_family == AF_INET6) {
+         char addrbuf[42];
+         struct in6_addr addr;
+         addr = p-&gt;real_addr6;
+	 tor_inet_ntop(AF_INET6, &amp;addr, addrbuf, sizeof(addrbuf));
+         log_debug(LD_REND,"Hidden service maps ipv6 port %d to [%s]:%d",
+                   p-&gt;virtual_port, addrbuf, p-&gt;real_port);
+      } else {
+         char addrbuf[INET_NTOA_BUF_LEN];
+         struct in_addr addr;
+         addr.s_addr = htonl(p-&gt;real_addr4);
+         tor_inet_ntoa(&amp;addr, addrbuf, sizeof(addrbuf));
+         log_debug(LD_REND,"Hidden service maps ipv4 port %d to %s:%d",
+                   p-&gt;virtual_port, addrbuf, p-&gt;real_port);
+      }
     }
   }
 }
@@ -193,7 +204,6 @@
   int virtport;
   int realport;
   uint16_t p;
-  uint32_t addr;
   const char *addrport;
   rend_service_port_config_t *result = NULL;
 
@@ -212,32 +222,60 @@
     goto err;
   }
 
+  result = tor_malloc(sizeof(rend_service_port_config_t));
+  result-&gt;virtual_port = virtport;
+
   if (smartlist_len(sl) == 1) {
     /* No addr:port part; use default. */
-    realport = virtport;
-    addr = 0x7F000001u; /* 127.0.0.1 */
+    result-&gt;real_family = AF_INET;
+    result-&gt;real_port = virtport;
+    result-&gt;real_addr4 = 0x7F000001u; /* 127.0.0.1 */
+    log_warn(LD_CONFIG,"no address nor port in hidden service port "
+                 "configuration-&gt;localhost.");
   } else {
     addrport = smartlist_get(sl,1);
     if (strchr(addrport, ':') || strchr(addrport, '.')) {
-      if (parse_addr_port(LOG_WARN, addrport, NULL, &amp;addr, &amp;p)&lt;0) {
-        log_warn(LD_CONFIG,"Unparseable address in hidden service port "
+      uint32_t addr4;
+      if (parse_addr_port(LOG_WARN, addrport, NULL, &amp;addr4, &amp;p)&lt;0) {
+        struct in6_addr addr6;
+        if (parse_addr6_port(LOG_WARN, addrport, NULL, &amp;addr6, &amp;p)&lt;0) {
+           log_warn(LD_CONFIG,"Unparseable address in hidden service port "
                  "configuration.");
-        goto err;
+           goto err;
+	} else {
+         // ipv6-address could be parsed
+         result-&gt;real_family = AF_INET6;
+         result-&gt;real_addr6 = addr6;
+
+         char addrbuf[42];
+         struct in6_addr addr;
+         addr = result-&gt;real_addr6;
+         tor_inet_ntop(AF_INET6, &amp;addr, addrbuf, sizeof(addrbuf));
+           log_warn(LD_CONFIG,"parse_port_config() parseable ipv6-address %s in \
hidden service port " +                 "configuration.", addrbuf);
+	}
+      } else {
+         // ipv4-address could be parsed
+         result-&gt;real_family = AF_INET;
+         result-&gt;real_addr4 = addr4;
+           log_warn(LD_CONFIG,"parse_port_config() parseable ipv4-address in hidden \
service port " +                 "configuration.");
       }
       realport = p?p:virtport;
+      result-&gt;real_port = realport;
     } else {
       /* No addr:port, no addr -- must be port. */
       realport = atoi(addrport);
       if (realport &lt; 1 || realport &gt; 65535)
         goto err;
-      addr = 0x7F000001u; /* Default to 127.0.0.1 */
+      result-&gt;real_family = AF_INET;
+      result-&gt;real_port = realport;
+      result-&gt;real_addr4 = 0x7F000001u; /* 127.0.0.1 */
+           log_warn(LD_CONFIG,"no address in hidden service port "
+                 "configuration-&gt;localhost.");
     }
   }
 
-  result = tor_malloc(sizeof(rend_service_port_config_t));
-  result-&gt;virtual_port = virtport;
-  result-&gt;real_port = realport;
-  result-&gt;real_addr = addr;
  err:
   SMARTLIST_FOREACH(sl, char *, c, tor_free(c));
   smartlist_free(sl);
@@ -286,6 +324,7 @@
     if (!strcasecmp(line-&gt;key, "HiddenServicePort")) {
       portcfg = parse_port_config(line-&gt;value);
       if (!portcfg) {
+        log_warn(LD_CONFIG, "unparsable HiddenServicePort %s", line-&gt;value);
         rend_service_free(service);
         return -1;
       }
@@ -387,7 +426,7 @@
     const char *name = smartlist_get(service-&gt;intro_nodes, i);
     router = router_get_by_nickname(name, 1);
     if (!router) {
-      log_info(LD_REND,"Router '%s' not found for intro point %d. Skipping.",
+      log_info(LD_REND,"Router '%s' not found for hidden service intro point %d. \
Skipping.",  safe_str(name), i);
       continue;
     }
@@ -428,7 +467,7 @@
     if (strlcpy(fname,s-&gt;directory,sizeof(fname)) &gt;= sizeof(fname) ||
         strlcat(fname,PATH_SEPARATOR"private_key",sizeof(fname))
                                                   &gt;= sizeof(fname)) {
-      log_warn(LD_CONFIG, "Directory name too long to store key file: \"%s\".",
+      log_warn(LD_CONFIG, "Directory name too long to store key file: \"%s\" for \
hidden service.",  s-&gt;directory);
       return -1;
     }
@@ -438,17 +477,17 @@
 
     /* Create service file */
     if (rend_get_service_id(s-&gt;private_key, s-&gt;service_id)&lt;0) {
-      log_warn(LD_BUG, "Internal error: couldn't encode service ID.");
+      log_warn(LD_BUG, "Internal error: couldn't encode hidden service ID.");
       return -1;
     }
     if (crypto_pk_get_digest(s-&gt;private_key, s-&gt;pk_digest)&lt;0) {
-      log_warn(LD_BUG, "Couldn't compute hash of public key.");
+      log_warn(LD_BUG, "Couldn't compute hash of public key for hidden service.");
       return -1;
     }
     if (strlcpy(fname,s-&gt;directory,sizeof(fname)) &gt;= sizeof(fname) ||
         strlcat(fname,PATH_SEPARATOR"hostname",sizeof(fname))
                                                   &gt;= sizeof(fname)) {
-      log_warn(LD_CONFIG, "Directory name too long to store hostname file:"
+      log_warn(LD_CONFIG, "Directory name too long to store hostname file for hidden \
service:"  " \"%s\".", s-&gt;directory);
       return -1;
     }
@@ -585,7 +626,8 @@
     /* Version 2 INTRODUCE2 cell. */
     int klen;
     extend_info = tor_malloc_zero(sizeof(extend_info_t));
-    extend_info-&gt;addr = ntohl(get_uint32(buf+1));
+    extend_info-&gt;addr.family = AF_INET;
+    extend_info-&gt;addr.addr.in_addr.s_addr = ntohl(get_uint32(buf+1));
     extend_info-&gt;port = ntohs(get_uint16(buf+5));
     memcpy(extend_info-&gt;identity_digest, buf+7, DIGEST_LEN);
     extend_info-&gt;nickname[0] = '$';
@@ -1153,7 +1195,7 @@
         smartlist_free(desc_ids);
       }
       uploaded = 1;
-      log_info(LD_REND, "Successfully uploaded v2 rend descriptors!");
+      log_info(LD_REND, "Successfully uploaded v2 rend hidden service descriptors \
for service %s!", serviceid);  }
   }
 
@@ -1394,11 +1436,25 @@
   chosen_port = smartlist_choose(matching_ports);
   smartlist_free(matching_ports);
   if (chosen_port) {
-    conn-&gt;_base.addr = chosen_port-&gt;real_addr;
+    if (chosen_port-&gt;real_family == AF_INET6) {
+      conn-&gt;_base.addr.addr.in6_addr = chosen_port-&gt;real_addr6;
+
+      char addrbuf[42];
+      struct in6_addr addr;
+      addr = conn-&gt;_base.addr.addr.in6_addr;
+      tor_inet_ntop(AF_INET6, &amp;addr, addrbuf, sizeof(addrbuf));
+      log_info(LD_REND, "rend_service_set_connection_addr_port() found virtual \
ipv6-port mapping exist for port %d on service %s on local ipv6 %s", +           \
conn-&gt;_base.port, serviceid, addrbuf); +    } else {
+      conn-&gt;_base.addr.addr.in_addr.s_addr = chosen_port-&gt;real_addr4;
+      log_info(LD_REND, "rend_service_set_connection_addr_port() found virtual \
ipv4-port mapping exist for port %d on (ipv4) service %s", +           \
conn-&gt;_base.port, serviceid); +    }
+    conn-&gt;_base.addr.family = chosen_port-&gt;real_family;
     conn-&gt;_base.port = chosen_port-&gt;real_port;
     return 0;
   }
-  log_info(LD_REND, "No virtual port mapping exists for port %d on service %s",
+  log_info(LD_REND, "No virtual port mapping exists for port %d on hidden ipv4 or \
ipv6 - service %s",  conn-&gt;_base.port,serviceid);
   return -1;
 }
Index: or/routerlist.c
===================================================================
--- or/routerlist.c
+++ or/routerlist.c
@@ -3306,7 +3306,7 @@
                        authority_type_t type)
 {
   trusted_dir_server_t *ent;
-  uint32_t a;
+  struct tor_addr_t a;
   char *hostname = NULL;
   size_t dlen;
   if (!trusted_dir_servers)
@@ -3320,7 +3320,7 @@
       return;
     }
   } else {
-    if (tor_lookup_hostname(address, &amp;a)) {
+    if (tor_addr_lookup(address, AF_INET, &amp;a) || a.family != AF_INET) {
       log_warn(LD_CONFIG,
                "Unable to lookup address for directory server at '%s'",
                address);
@@ -3332,7 +3332,7 @@
   ent = tor_malloc_zero(sizeof(trusted_dir_server_t));
   ent-&gt;nickname = nickname ? tor_strdup(nickname) : NULL;
   ent-&gt;address = hostname;
-  ent-&gt;addr = a;
+  ent-&gt;addr = a.addr.in_addr.s_addr;
   ent-&gt;dir_port = dir_port;
   ent-&gt;or_port = or_port;
   ent-&gt;is_running = 1;
@@ -4507,7 +4507,7 @@
 
   /* XXX020 make this louder once we have some v2hidservs */
   log_info(LD_REND, "We don't have enough hidden service directories to "
-           "perform v2 rendezvous operations!");
+           "perform v2 rendezvous operations! id=%s", id);
   return -1;
 }
 
Index: or/dirserv.c
===================================================================
--- or/dirserv.c
+++ or/dirserv.c
@@ -2053,7 +2053,7 @@
 {
   or_options_t *options = get_options();
   networkstatus_vote_t *v3_out = NULL;
-  uint32_t addr;
+  tor_addr_t addr;
   char *hostname = NULL, *client_versions = NULL, *server_versions = NULL;
   const char *contact;
   smartlist_t *routers, *routerstatuses;
@@ -2082,7 +2082,7 @@
   }
   if (!strchr(hostname, '.')) {
     tor_free(hostname);
-    hostname = tor_dup_addr(addr);
+    hostname = tor_dup_addr(addr.addr.in_addr.s_addr);
   }
   if (crypto_pk_get_digest(private_key, signing_key_digest)&lt;0) {
     log_err(LD_BUG, "Error computing signing key digest");
@@ -2201,7 +2201,7 @@
   voter-&gt;nickname = tor_strdup(options-&gt;Nickname);
   memcpy(voter-&gt;identity_digest, identity_digest, DIGEST_LEN);
   voter-&gt;address = hostname;
-  voter-&gt;addr = addr;
+  voter-&gt;addr = addr.addr.in_addr.s_addr;
   voter-&gt;dir_port = options-&gt;DirPort;
   voter-&gt;or_port = options-&gt;ORPort;
   voter-&gt;contact = tor_strdup(contact);
@@ -2245,7 +2245,7 @@
   char published[ISO_TIME_LEN+1];
   char digest[DIGEST_LEN];
   struct in_addr in;
-  uint32_t addr;
+  tor_addr_t addr;
   crypto_pk_env_t *private_key;
   routerlist_t *rl = router_get_routerlist();
   time_t now = time(NULL);
@@ -2265,7 +2265,7 @@
     log_warn(LD_NET, "Couldn't resolve my hostname");
     goto done;
   }
-  in.s_addr = htonl(addr);
+  in.s_addr = htonl(addr.addr.in_addr.s_addr);
   tor_inet_ntoa(&amp;in, ipaddr, sizeof(ipaddr));
 
   format_iso_time(published, now);
@@ -2686,7 +2686,10 @@
       /* Remember when we started trying to determine reachability */
       if (!router-&gt;testing_since)
         router-&gt;testing_since = now;
-      connection_or_connect(router-&gt;addr, router-&gt;or_port,
+      struct tor_addr_t connectaddr;
+      connectaddr.family = AF_INET;
+      connectaddr.addr.in_addr.s_addr = router-&gt;addr;
+      connection_or_connect(connectaddr, router-&gt;or_port,
                             id_digest);
     }
   });
Index: or/control.c
===================================================================
--- or/control.c
+++ or/control.c
@@ -1233,10 +1233,10 @@
   } else if (!strcmp(question, "features/names")) {
     *answer = tor_strdup("VERBOSE_NAMES EXTENDED_EVENTS");
   } else if (!strcmp(question, "address")) {
-    uint32_t addr;
+    tor_addr_t addr;
     if (router_pick_published_address(get_options(), &amp;addr) &lt; 0)
       return -1;
-    *answer = tor_dup_addr(addr);
+    *answer = tor_dup_addr(addr.addr.in_addr.s_addr);
   } else if (!strcmp(question, "dir-usage")) {
     *answer = directory_dump_request_log();
   } else if (!strcmp(question, "fingerprint")) {
Index: or/connection_edge.c
===================================================================
--- or/connection_edge.c
+++ or/connection_edge.c
@@ -204,7 +204,12 @@
   payload[0] = reason;
   if (reason == END_STREAM_REASON_EXITPOLICY &amp;&amp;
       !connection_edge_is_rendezvous_stream(conn)) {
-    set_uint32(payload+1, htonl(conn-&gt;_base.addr));
+     if (conn-&gt;_base.addr.family == AF_INET6) {
+       log_warn(LD_BUG,
+                "ipv6 not supported in connection_edge_end for \
non-rendezvous-streams"); +       return 0;
+     }
+    set_uint32(payload+1, htonl(conn-&gt;_base.addr.addr.in_addr.s_addr));
     set_uint32(payload+5, htonl(dns_clip_ttl(conn-&gt;address_ttl)));
     payload_len += 8;
   }
@@ -280,19 +285,27 @@
 int
 connection_edge_finished_connecting(edge_connection_t *edge_conn)
 {
-  char valbuf[INET_NTOA_BUF_LEN];
   connection_t *conn;
-  struct in_addr in;
 
   tor_assert(edge_conn);
   tor_assert(edge_conn-&gt;_base.type == CONN_TYPE_EXIT);
   conn = TO_CONN(edge_conn);
   tor_assert(conn-&gt;state == EXIT_CONN_STATE_CONNECTING);
 
-  in.s_addr = htonl(conn-&gt;addr);
-  tor_inet_ntoa(&amp;in,valbuf,sizeof(valbuf));
-  log_info(LD_EXIT,"Exit connection to %s:%u (%s) established.",
-           escaped_safe_str(conn-&gt;address),conn-&gt;port,safe_str(valbuf));
+  if (conn-&gt;addr.family == AF_INET6) {
+    char addrbuf[42];
+    struct in6_addr addr = conn-&gt;addr.addr.in6_addr;
+    tor_inet_ntop(AF_INET6, &amp;addr, addrbuf, sizeof(addrbuf));
+    log_info(LD_EXIT,"Exit connection to %s:%u (%s) established.",
+             escaped_safe_str(conn-&gt;address),conn-&gt;port,safe_str(addrbuf));
+  } else {
+    char valbuf[INET_NTOA_BUF_LEN];
+    struct in_addr in;
+    in.s_addr = htonl(conn-&gt;addr.addr.in_addr.s_addr);
+    tor_inet_ntoa(&amp;in,valbuf,sizeof(valbuf));
+    log_info(LD_EXIT,"Exit connection to %s:%u (%s) established.",
+             escaped_safe_str(conn-&gt;address),conn-&gt;port,safe_str(valbuf));
+  }
 
   conn-&gt;state = EXIT_CONN_STATE_OPEN;
   connection_watch_events(conn, EV_READ); /* stop writing, continue reading */
@@ -305,8 +318,16 @@
                                      RELAY_COMMAND_CONNECTED, NULL, 0) &lt; 0)
       return 0; /* circuit is closed, don't continue */
   } else {
+    if (conn-&gt;addr.family == AF_INET6) {
+      char addrbuf[42];
+      struct in6_addr addr = conn-&gt;addr.addr.in6_addr;
+      tor_inet_ntop(AF_INET6, &amp;addr, addrbuf, sizeof(addrbuf));
+      log_info(LD_EXIT,"ipv6 not supported for exit connection to %s:%u (%s) that is \
not a rendezvous_stream.", +             \
escaped_safe_str(conn-&gt;address),conn-&gt;port,safe_str(addrbuf)); +      return -1;
+    }
     char connected_payload[8];
-    set_uint32(connected_payload, htonl(conn-&gt;addr));
+    set_uint32(connected_payload, htonl(conn-&gt;addr.addr.in_addr.s_addr));
     set_uint32(connected_payload+4,
                htonl(dns_clip_ttl(edge_conn-&gt;address_ttl)));
     if (connection_edge_send_command(edge_conn,
@@ -359,7 +380,7 @@
       continue;
     conn = TO_EDGE_CONN(c);
     /* if it's an internal linked connection, don't yell its status. */
-    severity = (!conn-&gt;_base.addr &amp;&amp; !conn-&gt;_base.port)
+    severity = ((conn-&gt;_base.addr.family == AF_INET &amp;&amp; \
!conn-&gt;_base.addr.addr.in_addr.s_addr) &amp;&amp; !conn-&gt;_base.port)  ? LOG_INFO : \
LOG_NOTICE;  seconds_idle = now - conn-&gt;_base.timestamp_lastread;
 
@@ -1992,7 +2013,7 @@
   }
 
   conn-&gt;_base.address = tor_strdup("(Tor_internal)");
-  conn-&gt;_base.addr = 0;
+  conn-&gt;_base.addr.addr.in_addr.s_addr = 0;
   conn-&gt;_base.port = 0;
 
   if (connection_add(TO_CONN(conn)) &lt; 0) { /* no space, forget it */
@@ -2371,8 +2392,9 @@
 
   if (rh.command == RELAY_COMMAND_BEGIN_DIR) {
     tor_assert(or_circ);
-    if (or_circ-&gt;p_conn &amp;&amp; or_circ-&gt;p_conn-&gt;_base.addr)
-      n_stream-&gt;_base.addr = or_circ-&gt;p_conn-&gt;_base.addr;
+    if (or_circ-&gt;p_conn &amp;&amp; (or_circ-&gt;p_conn-&gt;_base.addr.family != AF_INET || \
or_circ-&gt;p_conn-&gt;_base.addr.addr.in_addr.s_addr)) { +       n_stream-&gt;_base.addr = \
or_circ-&gt;p_conn-&gt;_base.addr; +      }
     return connection_exit_connect_dir(n_stream);
   }
 
@@ -2444,6 +2466,12 @@
   return 0;
 }
 
+/** compare the 2 given ipv6-addresses
+ *  *
+ *   * returns 0 if they are equal.
+ *    */
+int compare_in6_addr(struct in6_addr a, struct in6_addr b);
+
 /** Connect to conn's specified addr and port. If it worked, conn
  * has now been added to the connection_array.
  *
@@ -2454,10 +2482,11 @@
 void
 connection_exit_connect(edge_connection_t *edge_conn)
 {
-  uint32_t addr;
-  uint16_t port;
   connection_t *conn = TO_CONN(edge_conn);
+  struct tor_addr_t addr = conn-&gt;addr;
+  uint16_t port = conn-&gt;port;
 
+
   if (!connection_edge_is_rendezvous_stream(edge_conn) &amp;&amp;
       router_compare_to_my_exit_policy(edge_conn)) {
     log_info(LD_EXIT,"%s:%d failed exit policy. Closing.",
@@ -2468,19 +2497,26 @@
     return;
   }
 
-  addr = conn-&gt;addr;
-  port = conn-&gt;port;
   if (redirect_exit_list) {
     SMARTLIST_FOREACH(redirect_exit_list, exit_redirect_t *, r,
-    {
-      if (!addr_mask_cmp_bits(addr, r-&gt;addr, r-&gt;maskbits) &amp;&amp;
+    {/*
+          if (!addr_mask_cmp_bits(addr, r-&gt;addr, r-&gt;maskbits) &amp;&amp;
+	            (r-&gt;port_min &lt;= port) &amp;&amp; (port &lt;= r-&gt;port_max)) {
+      */
+      if (
+          (conn-&gt;addr.family == AF_INET/*r-&gt;family*/ &amp;&amp;
+           ((conn-&gt;addr.family == AF_INET &amp;&amp; \
!addr_mask_cmp_bits(addr.addr.in_addr.s_addr, r-&gt;addr, r-&gt;maskbits)) /*&amp;&amp; +           \
(conn-&gt;socket_family == AF_INET6 &amp;&amp; !compare_addr(addr, r-&gt;addr))*/) +	  ) &amp;&amp;
           (r-&gt;port_min &lt;= port) &amp;&amp; (port &lt;= r-&gt;port_max)) {
-        struct in_addr in;
+
         if (r-&gt;is_redirect) {
           char tmpbuf[INET_NTOA_BUF_LEN];
-          addr = r-&gt;addr_dest;
+          addr.family = AF_INET;
+          addr.addr.in_addr.s_addr = r-&gt;addr_dest;
           port = r-&gt;port_dest;
-          in.s_addr = htonl(addr);
+          struct in_addr in;
+          in.s_addr = htonl(addr.addr.in_addr.s_addr);
           tor_inet_ntoa(&amp;in, tmpbuf, sizeof(tmpbuf));
           log_debug(LD_EXIT, "Redirecting connection from %s:%d to %s:%d",
                     escaped_safe_str(conn-&gt;address), conn-&gt;port,
@@ -2492,7 +2528,8 @@
   }
 
   log_debug(LD_EXIT,"about to try connecting");
-  switch (connection_connect(conn, conn-&gt;address, addr, port)) {
+  int s = connection_connect(conn, conn-&gt;address, addr, port);
+  switch (s) {
     case -1:
       connection_edge_end_errno(edge_conn);
       circuit_detach_stream(circuit_get_by_edge_conn(edge_conn), edge_conn);
@@ -2525,8 +2562,11 @@
                                  NULL, 0);
   } else { /* normal stream */
     /* This must be the original address, not the redirected address. */
+    if (conn-&gt;addr.family == AF_INET6) {
+      log_warn(LD_BUG,"we do not support ipv6 in connection_exit_connect!");
+    }
     char connected_payload[8];
-    set_uint32(connected_payload, htonl(conn-&gt;addr));
+    set_uint32(connected_payload, htonl(conn-&gt;addr.addr.in_addr.s_addr));
     set_uint32(connected_payload+4,
                htonl(dns_clip_ttl(edge_conn-&gt;address_ttl)));
     connection_edge_send_command(edge_conn,
@@ -2554,7 +2594,8 @@
 
   dirconn = TO_DIR_CONN(connection_new(CONN_TYPE_DIR, AF_INET));
 
-  dirconn-&gt;_base.addr = 0x7f000001;
+  dirconn-&gt;_base.addr.family = AF_INET;
+  dirconn-&gt;_base.addr.addr.in_addr.s_addr = 0x7f000001;
   dirconn-&gt;_base.port = 0;
   dirconn-&gt;_base.address = tor_strdup("Tor network");
   dirconn-&gt;_base.type = CONN_TYPE_DIR;
Index: or/dns.c
===================================================================
--- or/dns.c
+++ or/dns.c
@@ -413,7 +413,7 @@
     {
     case RESOLVED_TYPE_IPV4:
       buf[1] = 4;
-      set_uint32(buf+2, htonl(conn-&gt;_base.addr));
+      set_uint32(buf+2, htonl(conn-&gt;_base.addr.addr.in_addr.s_addr));
       set_uint32(buf+6, htonl(ttl));
       buflen = 10;
       break;
@@ -627,7 +627,8 @@
   /* first check if exitconn-&gt;_base.address is an IP. If so, we already
    * know the answer. */
   if (tor_inet_aton(exitconn-&gt;_base.address, &amp;in) != 0) {
-    exitconn-&gt;_base.addr = ntohl(in.s_addr);
+    exitconn-&gt;_base.addr.family = AF_INET;
+    exitconn-&gt;_base.addr.addr.in_addr.s_addr = ntohl(in.s_addr);
     exitconn-&gt;address_ttl = DEFAULT_DNS_TTL;
     return 1;
   }
@@ -694,7 +695,8 @@
           tor_assert(is_resolve);
           *hostname_out = tor_strdup(resolve-&gt;result.hostname);
         } else {
-          exitconn-&gt;_base.addr = resolve-&gt;result.addr;
+	  exitconn-&gt;_base.addr.family = AF_INET;
+          exitconn-&gt;_base.addr.addr.in_addr.s_addr = resolve-&gt;result.addr;
         }
         return 1;
       case CACHE_STATE_CACHED_FAILED:
@@ -1000,7 +1002,8 @@
     pendconn = pend-&gt;conn; /* don't pass complex things to the
                               connection_mark_for_close macro */
     assert_connection_ok(TO_CONN(pendconn),time(NULL));
-    pendconn-&gt;_base.addr = addr;
+    pendconn-&gt;_base.addr.family = AF_INET;
+    pendconn-&gt;_base.addr.addr.in_addr.s_addr = addr;
     pendconn-&gt;address_ttl = ttl;
 
     if (outcome != DNS_RESOLVE_SUCCEEDED) {
Index: or/or.h
===================================================================
--- or/or.h
+++ or/or.h
@@ -862,11 +862,7 @@
                                  * could write? */
   time_t timestamp_created; /**&lt; When was this connection_t created? */
 
-  /* XXXX020 make this ipv6-capable */
-  int socket_family; /**&lt; Address family of this connection's socket.  Usually
-                      * AF_INET, but it can also be AF_UNIX, or in the future
-                      * AF_INET6 */
-  uint32_t addr; /**&lt; IP of the other side of the connection; used to identify
+  tor_addr_t addr; /**&lt; IP of the other side of the connection; used to identify
                   * routers, along with port. */
   uint16_t port; /**&lt; If non-zero, port  on the other end
                   * of the connection. */
@@ -928,7 +924,7 @@
    * recent, we can rate limit it further. */
   time_t client_used;
 
-  uint32_t real_addr; /**DOCDOC */
+  struct tor_addr_t real_addr; /**&lt; DOCDOC*/
 
   circ_id_type_t circ_id_type:2; /**&lt; When we send CREATE cells along this
                                   * connection, which half of the space should
@@ -1598,8 +1594,8 @@
   char nickname[MAX_HEX_NICKNAME_LEN+1]; /**&lt; This router's nickname for
                                           * display. */
   char identity_digest[DIGEST_LEN]; /**&lt; Hash of this router's identity key. */
-  uint16_t port; /**&lt; OR port. */
-  uint32_t addr; /**&lt; IP address in host order. */
+  uint16_t port;         /**&lt; OR port. */
+  struct tor_addr_t addr; /**&lt; IP address. */
   crypto_pk_env_t *onion_key; /**&lt; Current onionskin key. */
 } extend_info_t;
 
@@ -1758,8 +1754,8 @@
   uint16_t n_circ_id;
   /** The port for the OR that is next in this circuit. */
   uint16_t n_port;
-  /** The IPv4 address of the OR that is next in this circuit. */
-  uint32_t n_addr;
+  /** The IP address of the OR that is next in this circuit. */
+  struct tor_addr_t n_addr;
 
   /** True iff we are waiting for n_conn_cells to become less full before
    * allowing p_streams to add any more cells. (Origin circuit only.) */
@@ -2598,7 +2594,7 @@
 int options_trial_assign(config_line_t *list, int use_defaults,
                          int clear_first, char **msg);
 int resolve_my_address(int warn_severity, or_options_t *options,
-                       uint32_t *addr, char **hostname_out);
+                       struct tor_addr_t *addr, char **hostname_out);
 int is_local_IP(uint32_t ip) ATTR_PURE;
 void options_init(or_options_t *options);
 int options_init_from_torrc(int argc, char **argv);
@@ -2647,7 +2643,7 @@
 
 void connection_expire_held_open(void);
 
-int connection_connect(connection_t *conn, const char *address, uint32_t addr,
+int connection_connect(connection_t *conn, const char *address, struct tor_addr_t \
addr,  uint16_t port);
 int retry_all_listeners(smartlist_t *replaced_conns,
                         smartlist_t *new_conns);
@@ -2800,7 +2796,7 @@
 int connection_or_finish_or_handshake(or_connection_t *conn);
 #endif
 
-or_connection_t *connection_or_connect(uint32_t addr, uint16_t port,
+or_connection_t *connection_or_connect(struct tor_addr_t addr, uint16_t port,
                                     const char *id_digest);
 
 int connection_tls_start_handshake(or_connection_t *conn, int receiving);
@@ -3381,6 +3377,12 @@
 void policies_parse_from_options(or_options_t *options);
 
 int cmp_addr_policies(addr_policy_t *a, addr_policy_t *b);
+/** compare the 2 given ipv4 or ipv6-addresses
+ *
+ * returns 0 if they are equal.
+ */
+int compare_addr(struct tor_addr_t a, struct tor_addr_t b);
+
 addr_policy_result_t compare_addr_to_addr_policy(uint32_t addr,
                               uint16_t port, addr_policy_t *policy);
 int policies_parse_exit_policy(config_line_t *cfg, addr_policy_t **dest,
@@ -3684,7 +3686,7 @@
 int router_digest_is_me(const char *digest);
 int router_is_me(routerinfo_t *router);
 int router_fingerprint_is_me(const char *fp);
-int router_pick_published_address(or_options_t *options, uint32_t *addr);
+int router_pick_published_address(or_options_t *options, struct tor_addr_t *addr);
 int router_rebuild_descriptor(int force);
 int router_dump_router_to_string(char *s, size_t maxlen, routerinfo_t *router,
                                  crypto_pk_env_t *ident_key);
Index: or/connection.c
===================================================================
--- or/connection.c
+++ or/connection.c
@@ -198,7 +198,7 @@
   conn-&gt;conn_array_index = -1; /* also default to 'not used' */
 
   conn-&gt;type = type;
-  conn-&gt;socket_family = socket_family;
+  conn-&gt;addr.family = socket_family;
   if (!connection_is_listener(conn)) { /* listeners never use their buf */
     conn-&gt;inbuf = buf_new();
     conn-&gt;outbuf = buf_new();
@@ -298,7 +298,7 @@
     buf_free(conn-&gt;inbuf);
     buf_free(conn-&gt;outbuf);
   } else {
-    if (conn-&gt;socket_family == AF_UNIX) {
+    if (conn-&gt;addr.family == AF_UNIX) {
       /* For now only control ports can be unix domain sockets
        * and listeners at the same time */
       tor_assert(conn-&gt;type == CONN_TYPE_CONTROL_LISTENER);
@@ -646,6 +646,44 @@
   });
 }
 
+/** Create an AF_INET6 listenaddr struct.
+ * &lt;b&gt;listenaddress&lt;/b&gt; provides the host and optionally the port information
+ * for the new structure.  If no port is provided in &lt;b&gt;listenaddress&lt;/b&gt; then
+ * &lt;b&gt;listenport&lt;/b&gt; is used.
+ *
+ * If not NULL &lt;b&gt;readable_addrress&lt;/b&gt; will contain a copy of the host part of
+ * &lt;b&gt;listenaddress&lt;/b&gt;.
+ *
+ * The listenaddr struct has to be freed by the caller.
+ */
+static struct sockaddr_in6 *
+create_inet6_sockaddr(const char *listenaddress, uint16_t listenport,
+                     char **readable_address) {
+  struct sockaddr_in6 *listenaddr = NULL;
+  struct in6_addr addr6;
+  uint16_t usePort = 0;
+
+  if (parse_addr6_port(LOG_WARN,
+                      listenaddress, readable_address, &amp;addr6, &amp;usePort)&lt;0) {
+    log_warn(LD_CONFIG,
+             "Error parsing/resolving ipv6 ListenAddress %s", listenaddress);
+    goto err;
+  }
+  if (usePort==0)
+    usePort = listenport;
+
+  listenaddr = tor_malloc_zero(sizeof(struct sockaddr_in6));
+  listenaddr-&gt;sin6_addr = addr6;
+  listenaddr-&gt;sin6_family = AF_INET;
+  listenaddr-&gt;sin6_port = htons((uint16_t) usePort);
+
+  return listenaddr;
+
+ err:
+  tor_free(listenaddr);
+  return NULL;
+}
+
 /** Create an AF_INET listenaddr struct.
  * &lt;b&gt;listenaddress&lt;/b&gt; provides the host and optionally the port information
  * for the new structure.  If no port is provided in &lt;b&gt;listenaddress&lt;/b&gt; then
@@ -748,7 +786,7 @@
     return NULL;
   }
 
-  if (listensockaddr-&gt;sa_family == AF_INET) {
+  if (listensockaddr-&gt;sa_family == AF_INET6) {
     int is_tcp = (type != CONN_TYPE_AP_DNS_LISTENER);
 #ifndef MS_WINDOWS
     int one=1;
@@ -757,6 +795,55 @@
       start_reading = 1;
 
     usePort = ntohs( (uint16_t)
+                     ((struct sockaddr_in6 *)listensockaddr)-&gt;sin6_port);
+
+    log_notice(LD_NET, "Opening %s on ipv6 %s:%d",
+               conn_type_to_string(type), address, usePort);
+
+    s = tor_open_socket(PF_INET6,
+                        is_tcp ? SOCK_STREAM : SOCK_DGRAM,
+                        is_tcp ? IPPROTO_TCP: IPPROTO_UDP);
+    if (s &lt; 0) {
+      log_warn(LD_NET,"ipv6 socket creation failed.");
+      goto err;
+    }
+
+#ifndef MS_WINDOWS
+    /* REUSEADDR on normal places means you can rebind to the port
+     * right after somebody else has let it go. But REUSEADDR on win32
+     * means you can bind to the port _even when somebody else
+     * already has it bound_. So, don't do that on Win32. */
+    setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (void*) &amp;one, sizeof(one));
+#endif
+
+    if (bind(s, listensockaddr, sizeof(struct sockaddr_in6)) &lt; 0) {
+      const char *helpfulhint = "";
+      int e = tor_socket_errno(s);
+      if (ERRNO_IS_EADDRINUSE(e))
+        helpfulhint = ". Is Tor already running?";
+      log_warn(LD_NET, "Could not bind to ipv6 %s:%u: %s%s", address, usePort,
+               tor_socket_strerror(e), helpfulhint);
+      tor_close_socket(s);
+      goto err;
+    }
+
+    if (is_tcp) {
+      if (listen(s,SOMAXCONN) &lt; 0) {
+        log_warn(LD_NET, "Could not listen on ipv6 %s:%u: %s", address, usePort,
+                 tor_socket_strerror(tor_socket_errno(s)));
+        tor_close_socket(s);
+        goto err;
+      }
+    }
+  } else if (listensockaddr-&gt;sa_family == AF_INET) {
+    int is_tcp = (type != CONN_TYPE_AP_DNS_LISTENER);
+#ifndef MS_WINDOWS
+    int one=1;
+#endif
+    if (is_tcp)
+      start_reading = 1;
+
+    usePort = ntohs( (uint16_t)
                      ((struct sockaddr_in *)listensockaddr)-&gt;sin_port);
 
     log_notice(LD_NET, "Opening %s on %s:%d",
@@ -844,7 +931,7 @@
   set_socket_nonblocking(s);
 
   conn = connection_new(type, listensockaddr-&gt;sa_family);
-  conn-&gt;socket_family = listensockaddr-&gt;sa_family;
+  conn-&gt;addr.family = listensockaddr-&gt;sa_family;
   conn-&gt;s = s;
   conn-&gt;address = tor_strdup(address);
   conn-&gt;port = usePort;
@@ -878,23 +965,41 @@
 check_sockaddr_in(struct sockaddr *sa, int len, int level)
 {
   int ok = 1;
-  struct sockaddr_in *sin=(struct sockaddr_in*)sa;
 
-  if (len != sizeof(struct sockaddr_in)) {
-    log_fn(level, LD_NET, "Length of address not as expected: %d vs %d",
-           len,(int)sizeof(struct sockaddr_in));
-    ok = 0;
-  }
-  if (sa-&gt;sa_family != AF_INET) {
+  if (sa-&gt;sa_family == AF_INET6) {
+     struct sockaddr_in6 *sin=(struct sockaddr_in6*)sa;
+
+     if (len != sizeof(struct sockaddr_in6)) {
+       log_fn(level, LD_NET, "Length of ipv6 address not as expected: %d vs %d",
+              len,(int)sizeof(struct sockaddr_in));
+       ok = 0;
+     }
+
+     if (sin-&gt;sin6_port == 0) {
+       log_fn(level, LD_NET,
+              "Address for new connection has port equal to zero.");
+       ok = 0;
+     }
+  } else if (sa-&gt;sa_family == AF_INET) {
+     struct sockaddr_in *sin=(struct sockaddr_in*)sa;
+
+     if (len != sizeof(struct sockaddr_in)) {
+       log_fn(level, LD_NET, "Length of ipv4 address not as expected: %d vs %d",
+              len,(int)sizeof(struct sockaddr_in));
+       ok = 0;
+     }
+
+     if (sin-&gt;sin_addr.s_addr == 0 || sin-&gt;sin_port == 0) {
+       log_fn(level, LD_NET,
+              "Address for new connection has address/port equal to zero.");
+       ok = 0;
+     }
+  } else {
     log_fn(level, LD_NET, "Family of address not as expected: %d vs %d",
            sa-&gt;sa_family, AF_INET);
     ok = 0;
   }
-  if (sin-&gt;sin_addr.s_addr == 0 || sin-&gt;sin_port == 0) {
-    log_fn(level, LD_NET,
-           "Address for new connection has address/port equal to zero.");
-    ok = 0;
-  }
+
   return ok ? 0 : -1;
 }
 
@@ -907,7 +1012,8 @@
   int news; /* the new socket */
   connection_t *newconn;
   /* information about the remote peer when connecting to other routers */
-  struct sockaddr_in remote;
+  struct sockaddr_in remote4;
+  struct sockaddr_in6 remote6;
   char addrbuf[256];
   /* length of the remote address. Must be whatever accept() needs. */
   socklen_t remotelen = sizeof(addrbuf);
@@ -917,7 +1023,7 @@
   tor_assert((size_t)remotelen &gt;= sizeof(struct sockaddr_in));
   memset(addrbuf, 0, sizeof(addrbuf));
 
-  news = accept(conn-&gt;s,(struct sockaddr *)&amp;addrbuf,&amp;remotelen);
+  news = accept(conn-&gt;s ,(struct sockaddr *)&amp;addrbuf, &amp;remotelen);
   if (news &lt; 0) { /* accept() error */
     int e = tor_socket_errno(conn-&gt;s);
     if (ERRNO_IS_ACCEPT_EAGAIN(e)) {
@@ -942,19 +1048,19 @@
   if (options-&gt;ConstrainedSockets)
     set_constrained_socket_buffers(news, (int)options-&gt;ConstrainedSockSize);
 
-  if (((struct sockaddr*)addrbuf)-&gt;sa_family != conn-&gt;socket_family) {
+  if (((struct sockaddr*)addrbuf)-&gt;sa_family != conn-&gt;addr.family) {
     /* This is annoying, but can apparently happen on some Darwins. */
     log_info(LD_BUG, "A listener connection returned a socket with a "
              "mismatched family. %s for addr_family %d gave us a socket "
              "with address family %d.  Dropping.",
              conn_type_to_string(conn-&gt;type),
-             (int)conn-&gt;socket_family,
+             (int)conn-&gt;addr.family,
              (int)((struct sockaddr*)addrbuf)-&gt;sa_family);
     tor_close_socket(news);
     return 0;
   }
 
-  if (conn-&gt;socket_family == AF_INET) {
+  if (conn-&gt;addr.family == AF_INET || conn-&gt;addr.family == AF_INET6) {
     if (check_sockaddr_in((struct sockaddr*)addrbuf, remotelen, LOG_INFO)&lt;0) {
       log_info(LD_NET,
                "accept() returned a strange address; trying getsockname().");
@@ -973,13 +1079,18 @@
         }
       }
     }
-    memcpy(&amp;remote, addrbuf, sizeof(struct sockaddr_in));
+    if (conn-&gt;addr.family == AF_INET6) {
+      memcpy(&amp;remote6, addrbuf, sizeof(struct sockaddr_in6));
+    } else {
+      memcpy(&amp;remote4, addrbuf, sizeof(struct sockaddr_in));
+    }
 
     /* process entrance policies here, before we even create the connection */
     if (new_type == CONN_TYPE_AP) {
       /* check sockspolicy to see if we should accept it */
-      if (socks_policy_permits_address(ntohl(remote.sin_addr.s_addr)) == 0) {
-        tor_inet_ntoa(&amp;remote.sin_addr, tmpbuf, sizeof(tmpbuf));
+      //TODO: support ipv6
+      if (conn-&gt;addr.family == AF_INET &amp;&amp; \
socks_policy_permits_address(ntohl(remote4.sin_addr.s_addr)) == 0) { +        \
tor_inet_ntoa(&amp;remote4.sin_addr, tmpbuf, sizeof(tmpbuf));  log_notice(LD_APP,
                    "Denying socks connection from untrusted address %s.",
                    tmpbuf);
@@ -989,8 +1100,9 @@
     }
     if (new_type == CONN_TYPE_DIR) {
       /* check dirpolicy to see if we should accept it */
-      if (dir_policy_permits_address(ntohl(remote.sin_addr.s_addr)) == 0) {
-        tor_inet_ntoa(&amp;remote.sin_addr, tmpbuf, sizeof(tmpbuf));
+      //TODO: support ipv6
+      if (conn-&gt;addr.family == AF_INET &amp;&amp; \
dir_policy_permits_address(ntohl(remote4.sin_addr.s_addr)) == 0) { +        \
tor_inet_ntoa(&amp;remote4.sin_addr, tmpbuf, sizeof(tmpbuf));  \
log_notice(LD_DIRSERV,"Denying dir connection from address %s.",  tmpbuf);
         tor_close_socket(news);
@@ -998,29 +1110,36 @@
       }
     }
 
-    newconn = connection_new(new_type, conn-&gt;socket_family);
+    newconn = connection_new(new_type, conn-&gt;addr.family);
     newconn-&gt;s = news;
 
     /* remember the remote address */
-    newconn-&gt;addr = ntohl(remote.sin_addr.s_addr);
-    newconn-&gt;port = ntohs(remote.sin_port);
-    newconn-&gt;address = tor_dup_addr(newconn-&gt;addr);
+    if (conn-&gt;addr.family == AF_INET6) {
+      newconn-&gt;addr.addr.in6_addr = remote6.sin6_addr;
+      newconn-&gt;port = ntohs(remote6.sin6_port);
+      newconn-&gt;address = tor_dup_addr6(newconn-&gt;addr.addr.in6_addr);
+    } else {
+      newconn-&gt;addr.addr.in_addr.s_addr = remote4.sin_addr.s_addr;
+      newconn-&gt;port = ntohs(remote4.sin_port);
+      newconn-&gt;address = tor_dup_addr(newconn-&gt;addr.addr.in_addr.s_addr);
+    }
+    newconn-&gt;addr.family = conn-&gt;addr.family;
 
-  } else if (conn-&gt;socket_family == AF_UNIX) {
+  } else if (conn-&gt;addr.family == AF_UNIX) {
     /* For now only control ports can be unix domain sockets
      * and listeners at the same time */
     tor_assert(conn-&gt;type == CONN_TYPE_CONTROL_LISTENER);
 
-    newconn = connection_new(new_type, conn-&gt;socket_family);
+    newconn = connection_new(new_type, conn-&gt;addr.family);
     newconn-&gt;s = news;
 
     /* remember the remote address -- do we have anything sane to put here? */
-    newconn-&gt;addr = 0;
+    newconn-&gt;addr.addr.in_addr.s_addr = 0;
     newconn-&gt;port = 1;
     newconn-&gt;address = tor_strdup(conn-&gt;address);
   } else {
     tor_assert(0);
-  };
+  }
 
   if (connection_add(newconn) &lt; 0) { /* no space, forget it */
     connection_free(newconn);
@@ -1072,7 +1191,8 @@
   return 0;
 }
 
-/** Take conn, make a nonblocking socket; try to connect to
+/** (called by connection_connect)
+ * Take conn, make a nonblocking socket; try to connect to
  * addr:port (they arrive in *host order*). If fail, return -1. Else
  * assign s to conn-\&gt;s: if connected return 1, if EAGAIN return 0.
  *
@@ -1081,7 +1201,7 @@
  * On success, add conn to the list of polled connections.
  */
 int
-connection_connect(connection_t *conn, const char *address,
+connection_connect4(connection_t *conn, const char *address,
                    uint32_t addr, uint16_t port)
 {
   int s, inprogress = 0;
@@ -1162,6 +1282,113 @@
   return inprogress ? 0 : 1;
 }
 
+/** (called by connection_connect)
+ * Take conn, make a nonblocking socket; try to connect to
+ * addr:port (they arrive in *host order*). If fail, return -1. Else
+ * assign s to conn-\&gt;s: if connected return 1, if EAGAIN return 0.
+ *
+ * address is used to make the logs useful.
+ *
+ * On success, add conn to the list of polled connections.
+ */
+int
+connection_connect6(connection_t *conn, const char *address,
+                   struct in6_addr addr6, uint16_t port)
+{
+  int s, inprogress = 0;
+  struct sockaddr_in6 dest_addr6;
+  or_options_t *options = get_options();
+
+  if (get_n_open_sockets() &gt;= get_options()-&gt;_ConnLimit-1) {
+    int n_conns = get_n_open_sockets();
+    log_warn(LD_NET,"Failing because we have %d connections already. Please "
+             "raise your ulimit -n.", n_conns);
+    control_event_general_status(LOG_WARN, "TOO_MANY_CONNECTIONS CURRENT=%d",
+                                 n_conns);
+    return -1;
+  }
+
+  s = tor_open_socket(PF_INET6, SOCK_STREAM, IPPROTO_TCP);
+  if (s &lt; 0) {
+    log_warn(LD_NET,"Error creating network socket: %s",
+             tor_socket_strerror(tor_socket_errno(-1)));
+    return -1;
+  }
+
+  if (options-&gt;OutboundBindAddress) {
+    struct sockaddr_in6 ext_addr6;
+
+    memset(&amp;ext_addr6, 0, sizeof(ext_addr6));
+    ext_addr6.sin6_family = AF_INET6;
+    ext_addr6.sin6_port = 0;
+    if (!tor_inet_aton6(options-&gt;OutboundBindAddress, &amp;ext_addr6.sin6_addr)) {
+      log_warn(LD_CONFIG,"Outbound ipv6 bind address '%s' didn't parse. Ignoring.",
+               options-&gt;OutboundBindAddress);
+    } else {
+      if (bind(s, (struct sockaddr*)&amp;ext_addr6, sizeof(ext_addr6)) &lt; 0) {
+        log_warn(LD_NET,"Error binding network ipv6 socket: %s",
+                 tor_socket_strerror(tor_socket_errno(s)));
+        tor_close_socket(s);
+        return -1;
+      }
+    }
+  }
+
+  set_socket_nonblocking(s);
+
+  if (options-&gt;ConstrainedSockets)
+    set_constrained_socket_buffers(s, (int)options-&gt;ConstrainedSockSize);
+
+  memset(&amp;dest_addr6, 0, sizeof(dest_addr6));
+  dest_addr6.sin6_family = AF_INET6;
+  dest_addr6.sin6_port = htons(port);
+  dest_addr6.sin6_addr = addr6;
+
+  log_debug(LD_NET, "Connecting to ipv6 %s:%u.", escaped_safe_str(address), port);
+
+  if (connect(s, (struct sockaddr *)&amp;dest_addr6, sizeof(dest_addr6)) &lt; 0) {
+    int e = tor_socket_errno(s);
+    if (!ERRNO_IS_CONN_EINPROGRESS(e)) {
+      /* yuck. kill it. */
+      log_info(LD_NET,
+               "connect() to ipv6 %s:%u failed: %s", escaped_safe_str(address),
+               port, tor_socket_strerror(e));
+      tor_close_socket(s);
+      return -1;
+    } else {
+      inprogress = 1;
+    }
+  }
+
+  if (!server_mode(options))
+    client_check_address_changed(s);
+
+  /* it succeeded. we're connected. */
+  log_fn(inprogress?LOG_DEBUG:LOG_INFO, LD_NET,
+         "Connection to ipv6 %s:%u %s (sock %d).", escaped_safe_str(address),
+         port, inprogress?"in progress":"established", s);
+  conn-&gt;s = s;
+  if (connection_add(conn) &lt; 0) /* no space, forget it */
+    return -1;
+  return inprogress ? 0 : 1;
+}
+/** Take conn, make a nonblocking socket; try to connect to
+ * addr:port (they arrive in *host order*). If fail, return -1. Else
+ * assign s to conn-\&gt;s: if connected return 1, if EAGAIN return 0.
+ *
+ * address is used to make the logs useful.
+ *
+ * On success, add conn to the list of polled connections.
+ */
+int
+connection_connect(connection_t *conn, const char *address,
+                   struct tor_addr_t addr, uint16_t port)
+{
+ if (addr.family == AF_INET)
+    return  connection_connect4(conn, address, addr.addr.in_addr.s_addr, port);
+ return  connection_connect6(conn, address, addr.addr.in6_addr, port);
+}
+
 /**
  * Launch any configured listener connections of type &lt;b&gt;type&lt;/b&gt;.  (A
  * listener is configured if &lt;b&gt;port_option&lt;/b&gt; is non-zero.  If any
@@ -1191,7 +1418,7 @@
   connection_t *conn;
   config_line_t *line;
 
-  tor_assert(socket_family == AF_INET || socket_family == AF_UNIX);
+  tor_assert(socket_family == AF_INET || socket_family == AF_INET6 || socket_family \
== AF_UNIX);  
   if (cfg &amp;&amp; port_option) {
     for (c = cfg; c; c = c-&gt;next) {
@@ -1214,7 +1441,7 @@
   SMARTLIST_FOREACH(conns, connection_t *, conn,
   {
     if (conn-&gt;type != type ||
-        conn-&gt;socket_family != socket_family ||
+        conn-&gt;addr.family != socket_family ||
         conn-&gt;marked_for_close)
       continue;
     /* Okay, so this is a listener.  Is it configured? */
@@ -1224,6 +1451,19 @@
         char *address=NULL;
         uint16_t port;
         switch (socket_family) {
+          case AF_INET6:
+            if (!parse_addr6_port(LOG_WARN,
+                                 wanted-&gt;value, &amp;address, NULL, &amp;port)) {
+              int addr_matches = !strcasecmp(address, conn-&gt;address);
+              tor_free(address);
+              if (! port)
+                port = port_option;
+              if (port == conn-&gt;port &amp;&amp; addr_matches) {
+                line = wanted;
+                break;
+              }
+            }
+            break;
           case AF_INET:
             if (!parse_addr_port(LOG_WARN,
                                  wanted-&gt;value, &amp;address, NULL, &amp;port)) {
@@ -1276,6 +1516,12 @@
         struct sockaddr *listensockaddr;
 
         switch (socket_family) {
+          case AF_INET6:
+            listensockaddr = (struct sockaddr *)
+                             create_inet6_sockaddr(cfg_line-&gt;value,
+                                                  (uint16_t) port_option,
+                                                  &amp;address);
+            break;
           case AF_INET:
             listensockaddr = (struct sockaddr *)
                              create_inet_sockaddr(cfg_line-&gt;value,
@@ -1343,7 +1589,12 @@
                       options-&gt;SocksPort, "127.0.0.1",
                       replaced_conns, new_conns, 0,
                       AF_INET)&lt;0)
-    return -1;
+    // maybe the user deliberately configured an ipv6-address to listen on
+    if (retry_listeners(CONN_TYPE_AP_LISTENER, options-&gt;SocksListenAddress, 
+                        options-&gt;SocksPort, "::1",
+                        replaced_conns, new_conns, 0,
+                        AF_INET6)&lt;0)
+      return -1;
   if (retry_listeners(CONN_TYPE_AP_TRANS_LISTENER, options-&gt;TransListenAddress,
                       options-&gt;TransPort, "127.0.0.1",
                       replaced_conns, new_conns, 0,
@@ -1381,7 +1632,7 @@
 static int
 connection_is_rate_limited(connection_t *conn)
 {
-  if (conn-&gt;linked || is_internal_IP(conn-&gt;addr, 0))
+  if (conn-&gt;linked || (conn-&gt;addr.family == AF_INET &amp;&amp; \
is_internal_IP(conn-&gt;addr.addr.in_addr.s_addr, 0)))  return 0;
   else
     return 1;
@@ -2331,7 +2582,8 @@
   SMARTLIST_FOREACH(conns, connection_t *, conn,
   {
     if (conn-&gt;type == CONN_TYPE_OR &amp;&amp;
-        conn-&gt;addr == addr &amp;&amp;
+        conn-&gt;addr.family == AF_INET &amp;&amp;
+        conn-&gt;addr.addr.in_addr.s_addr == addr &amp;&amp;
         conn-&gt;port == port &amp;&amp;
         !conn-&gt;marked_for_close &amp;&amp;
         (!best || best-&gt;_base.timestamp_created &lt; conn-&gt;timestamp_created))
@@ -2351,7 +2603,8 @@
   SMARTLIST_FOREACH(conns, connection_t *, conn,
   {
     if (conn-&gt;type == type &amp;&amp;
-        conn-&gt;addr == addr &amp;&amp;
+        conn-&gt;addr.family == AF_INET &amp;&amp;
+        conn-&gt;addr.addr.in_addr.s_addr == addr &amp;&amp;
         conn-&gt;port == port &amp;&amp;
         conn-&gt;purpose == purpose &amp;&amp;
         !conn-&gt;marked_for_close)
Index: or/rendcommon.c
===================================================================
--- or/rendcommon.c
+++ or/rendcommon.c
@@ -227,7 +227,11 @@
       goto done;
     }
     /* Assemble everything for this introduction point. */
-    address = tor_dup_addr(info-&gt;addr);
+    if (info-&gt;addr.family == AF_INET6) {
+      address = tor_dup_addr6(info-&gt;addr.addr.in6_addr);
+    } else {
+      address = tor_dup_addr(info-&gt;addr.addr.in_addr.s_addr);
+    }
     res = tor_snprintf(unenc + unenc_written, unenc_len - unenc_written,
                          "introduction-point %s\n"
                          "ip-address %s\n"
@@ -760,8 +764,11 @@
 {
   char key[REND_SERVICE_ID_LEN_BASE32+2]; /* &lt;version&gt;&lt;query&gt;\0 */
   tor_assert(rend_cache);
-  if (!rend_valid_service_id(query))
+  if (!rend_valid_service_id(query)) {
+    log_warn(LD_REND, "hidden service descriptor '%s.onion' ID is not legal.",
+             query);
     return -1;
+  }
   *e = NULL;
   if (version != 0) {
     tor_snprintf(key, sizeof(key), "2%s", query);
@@ -771,8 +778,13 @@
     tor_snprintf(key, sizeof(key), "0%s", query);
     *e = strmap_get_lc(rend_cache, key);
   }
-  if (!*e)
+  if (!*e) {
+    log_warn(LD_REND, "no cached rend_cache_entry_t for hidden service  '%s.onion' \
with version %i.", +             query,version);
     return 0;
+  }
+  log_warn(LD_REND, "we have a cached rend_cache_entry_t for hidden service  \
'%s.onion' with version %i.", +             query, version);
   return 1;
 }
 
Index: or/directory.c
===================================================================
--- or/directory.c
+++ or/directory.c
@@ -478,7 +478,7 @@
     routerinfo_t *me = router_get_my_routerinfo();
     if (me &amp;&amp;
         router_digest_is_me(conn-&gt;identity_digest) &amp;&amp;
-        me-&gt;addr == conn-&gt;_base.addr &amp;&amp;
+        me-&gt;addr == conn-&gt;_base.addr.addr.in_addr.s_addr &amp;&amp; //TODO: support \
directories on IPv6  me-&gt;dir_port == conn-&gt;_base.port)
       return 1;
   }
@@ -644,7 +644,8 @@
   conn = TO_DIR_CONN(connection_new(CONN_TYPE_DIR, AF_INET));
 
   /* set up conn so it's got all the data we need to remember */
-  conn-&gt;_base.addr = addr;
+  conn-&gt;_base.addr.family = AF_INET;
+  conn-&gt;_base.addr.addr.in_addr.s_addr = addr;
   conn-&gt;_base.port = use_begindir ? or_port : dir_port;
   conn-&gt;_base.address = tor_strdup(address);
   memcpy(conn-&gt;identity_digest, digest, DIGEST_LEN);
@@ -666,7 +667,10 @@
       dir_port = options-&gt;HttpProxyPort;
     }
 
-    switch (connection_connect(TO_CONN(conn), conn-&gt;_base.address, addr,
+    struct tor_addr_t connectaddr;
+    connectaddr.family = AF_INET;
+    connectaddr.addr.in_addr.s_addr = addr;
+    switch (connection_connect(TO_CONN(conn), conn-&gt;_base.address, connectaddr,
                                dir_port)) {
       case -1:
         connection_dir_request_failed(conn); /* retry if we want */
@@ -1948,7 +1952,7 @@
     tor_snprintf(cp, sizeof(tmp)-(cp-tmp), "Content-Type: %s\r\n", type);
     cp += strlen(cp);
   }
-  if (!is_internal_IP(conn-&gt;_base.addr, 0)) {
+  if (conn-&gt;_base.addr.family == AF_INET &amp;&amp; \
                !is_internal_IP(conn-&gt;_base.addr.addr.in_addr.s_addr, 0)) { //TODO: \
                support ipv6
     /* Don't report the source address for a localhost/private connection. */
     tor_snprintf(cp, sizeof(tmp)-(cp-tmp),
                  X_ADDRESS_HEADER "%s\r\n", conn-&gt;_base.address);
@@ -3130,7 +3134,7 @@
     /* Determine responsible dirs. */
     if (hid_serv_get_responsible_directories(responsible_dirs, desc_id) &lt; 0) {
       log_warn(LD_REND, "Could not determine the responsible hidden service "
-                        "directories to post descriptors to.");
+                        "directories to post descriptors to. desc_id=%s", desc_id);
       smartlist_free(responsible_dirs);
       return;
     }
@@ -3178,7 +3182,7 @@
   if (hid_serv_get_responsible_directories(responsible_dirs, desc_id) &lt; 0) {
     /* XXX020 make this louder once we have some v2hidservs */
     log_info(LD_REND, "Could not determine the responsible hidden service "
-                      "directories to fetch descriptors.");
+                      "directories to fetch descriptors. desc_id=%s", desc_id);
     smartlist_free(responsible_dirs);
     return;
   }
Index: or/routerparse.c
===================================================================
--- or/routerparse.c
+++ or/routerparse.c
@@ -3376,7 +3376,6 @@
   int i;
   directory_token_t *tok;
   extend_info_t *info;
-  struct in_addr ip;
   int result;
   tor_assert(parsed);
   tor_assert(intro_points_encrypted);
@@ -3449,12 +3448,22 @@
                   info-&gt;identity_digest, DIGEST_LEN);
     /* Parse IP address. */
     tok = find_first_by_keyword(tokens, R_IPO_IP_ADDRESS);
-    if (tor_inet_aton(tok-&gt;args[0], &amp;ip) == 0) {
-      log_warn(LD_REND, "Could not parse IP address.");
-      tor_free(info);
-      goto err;
+    struct tor_addr_t ip;
+    if (tor_inet_aton(tok-&gt;args[0], &amp;(ip.addr.in_addr)) == 0) {
+      if (tor_inet_aton6(tok-&gt;args[0], &amp;(ip.addr.in6_addr)) == 0) {
+        log_warn(LD_REND, "Could not parse IP address (tried IPv4 and IPv6).");
+        tor_free(info);
+        goto err;
+      } else {
+        // it's an IPv6-address
+        info-&gt;addr.family = AF_INET6;
+        info-&gt;addr = ip;
+      }
+    } else {
+      // it's an IPv4-address
+      info-&gt;addr.family = AF_INET;
+      info-&gt;addr.addr.in_addr.s_addr = ntohl(ip.addr.in_addr.s_addr);
     }
-    info-&gt;addr = ntohl(ip.s_addr);
     /* Parse onion port. */
     tok = find_first_by_keyword(tokens, R_IPO_ONION_PORT);
     info-&gt;port = (uint16_t) atoi(tok-&gt;args[0]);
Index: or/command.c
===================================================================
--- or/command.c
+++ or/command.c
@@ -554,7 +554,7 @@
     }
     if (other_addr_type == RESOLVED_TYPE_IPV4 &amp;&amp; other_addr_len == 4) {
       uint32_t addr = ntohl(get_uint32(cp));
-      if (addr == conn-&gt;real_addr) {
+      if (conn-&gt;real_addr.family == AF_INET &amp;&amp; addr == \
conn-&gt;real_addr.addr.in_addr.s_addr) {  conn-&gt;handshake_state-&gt;apparently_canonical = \
1;  break;
       }
Index: or/test.c
===================================================================
--- or/test.c
+++ or/test.c
@@ -3311,7 +3311,8 @@
     info-&gt;nickname[0] = '$';
     base16_encode(info-&gt;nickname + 1, sizeof(info-&gt;nickname) - 1,
                   info-&gt;identity_digest, DIGEST_LEN);
-    info-&gt;addr = crypto_rand_int(65536); /* Does not cover all IP addresses. */
+    info-&gt;addr.family = AF_INET;
+    info-&gt;addr.addr.in_addr.s_addr = crypto_rand_int(65536); /* Does not cover all \
IP addresses. */  info-&gt;port = crypto_rand_int(65536);
     generated-&gt;intro_points[i] = tor_strdup(info-&gt;nickname);
     generated-&gt;intro_point_extend_info[i] = info;
@@ -3346,7 +3347,7 @@
                DIGEST_LEN);
     test_streq(gen_info-&gt;nickname, par_info-&gt;nickname);
     test_streq(generated-&gt;intro_points[i], parsed-&gt;intro_points[i]);
-    test_eq(gen_info-&gt;addr, par_info-&gt;addr);
+    test_eq(gen_info-&gt;addr.addr.in_addr.s_addr, par_info-&gt;addr.addr.in_addr.s_addr);
     test_eq(gen_info-&gt;port, par_info-&gt;port);
   }
   tor_free(intro_points_encrypted);
Index: or/circuituse.c
===================================================================
--- or/circuituse.c
+++ or/circuituse.c
@@ -1261,7 +1261,7 @@
   conn_age = time(NULL) - conn-&gt;_base.timestamp_created;
 
   if (conn_age &gt;= get_options()-&gt;SocksTimeout) {
-    int severity = (!conn-&gt;_base.addr &amp;&amp; !conn-&gt;_base.port) ?
+    int severity = ((conn-&gt;_base.addr.family == AF_INET &amp;&amp; \
!conn-&gt;_base.addr.addr.in_addr.s_addr) &amp;&amp; !conn-&gt;_base.port) ?  LOG_INFO : \
LOG_NOTICE;  log_fn(severity, LD_APP,
            "Tried for %d seconds to get a connection to %s:%d. Giving up.",
Index: or/router.c
===================================================================
--- or/router.c
+++ or/router.c
@@ -1049,11 +1049,13 @@
 
   /* make sure it's resolved to something. this way we can't get a
      'maybe' below. */
-  if (!conn-&gt;_base.addr)
+  if (conn-&gt;_base.addr.family == AF_INET &amp;&amp; !conn-&gt;_base.addr.addr.in_addr.s_addr)
     return -1;
 
-  return compare_addr_to_addr_policy(conn-&gt;_base.addr, conn-&gt;_base.port,
-                   desc_routerinfo-&gt;exit_policy) != ADDR_POLICY_ACCEPTED;
+  if (conn-&gt;_base.addr.family == AF_INET)
+    return compare_addr_to_addr_policy(conn-&gt;_base.addr.addr.in_addr.s_addr, \
conn-&gt;_base.port, +                     desc_routerinfo-&gt;exit_policy) != \
ADDR_POLICY_ACCEPTED; +  return 0; //TODO: support an ipv6 exit-policy
 }
 
 /** Return true iff I'm a server and &lt;b&gt;digest&lt;/b&gt; is equal to
@@ -1128,13 +1130,13 @@
  * declaration verbatim rather than as digests. */
 static smartlist_t *warned_nonexistent_family = NULL;
 
-static int router_guess_address_from_dir_headers(uint32_t *guess);
+static int router_guess_address_from_dir_headers(struct tor_addr_t *guess);
 
 /** Return our current best guess at our address, either because
  * it's configured in torrc, or because we've learned it from
  * dirserver headers. */
 int
-router_pick_published_address(or_options_t *options, uint32_t *addr)
+router_pick_published_address(or_options_t *options, struct tor_addr_t *addr)
 {
   if (resolve_my_address(LOG_INFO, options, addr, NULL) &lt; 0) {
     log_info(LD_CONFIG, "Could not determine our address locally. "
@@ -1157,7 +1159,7 @@
 {
   routerinfo_t *ri;
   extrainfo_t *ei;
-  uint32_t addr;
+  tor_addr_t addr;
   char platform[256];
   int hibernating = we_are_hibernating();
   or_options_t *options = get_options();
@@ -1175,9 +1177,9 @@
 
   ri = tor_malloc_zero(sizeof(routerinfo_t));
   ri-&gt;cache_info.routerlist_index = -1;
-  ri-&gt;address = tor_dup_addr(addr);
+  ri-&gt;address = tor_dup_addr(addr.addr.in_addr.s_addr);
   ri-&gt;nickname = tor_strdup(options-&gt;Nickname);
-  ri-&gt;addr = addr;
+  ri-&gt;addr = addr.addr.in_addr.s_addr;
   ri-&gt;or_port = options-&gt;ORPort;
   ri-&gt;dir_port = options-&gt;DirPort;
   ri-&gt;cache_info.published_on = time(NULL);
@@ -1361,20 +1363,20 @@
 /** Note at log level severity that our best guess of address has changed from
  * &lt;b&gt;prev&lt;/b&gt; to &lt;b&gt;cur&lt;/b&gt;. */
 static void
-log_addr_has_changed(int severity, uint32_t prev, uint32_t cur)
+log_addr_has_changed(int severity, struct tor_addr_t prev, struct tor_addr_t cur)
 {
   char addrbuf_prev[INET_NTOA_BUF_LEN];
   char addrbuf_cur[INET_NTOA_BUF_LEN];
   struct in_addr in_prev;
   struct in_addr in_cur;
 
-  in_prev.s_addr = htonl(prev);
+  in_prev.s_addr = htonl(prev.addr.in_addr.s_addr);
   tor_inet_ntoa(&amp;in_prev, addrbuf_prev, sizeof(addrbuf_prev));
 
-  in_cur.s_addr = htonl(cur);
+  in_cur.s_addr = htonl(cur.addr.in_addr.s_addr);
   tor_inet_ntoa(&amp;in_cur, addrbuf_cur, sizeof(addrbuf_cur));
 
-  if (prev)
+  if (prev.addr.in_addr.s_addr)
     log_fn(severity, LD_GENERAL,
            "Our IP Address has changed from %s to %s; "
            "rebuilding descriptor.",
@@ -1391,20 +1393,21 @@
 void
 check_descriptor_ipaddress_changed(time_t now)
 {
-  uint32_t prev, cur;
+  struct tor_addr_t prev, cur;
   or_options_t *options = get_options();
   (void) now;
 
   if (!desc_routerinfo)
     return;
 
-  prev = desc_routerinfo-&gt;addr;
+  prev.family = AF_INET;
+  prev.addr.in_addr.s_addr = desc_routerinfo-&gt;addr;
   if (resolve_my_address(LOG_INFO, options, &amp;cur, NULL) &lt; 0) {
     log_info(LD_CONFIG,"options-&gt;Address didn't resolve into an IP.");
     return;
   }
 
-  if (prev != cur) {
+  if (compare_addr(prev, cur) != 0) {
     log_addr_has_changed(LOG_INFO, prev, cur);
     ip_address_changed(0);
   }
@@ -1420,7 +1423,11 @@
 void
 router_new_address_suggestion(const char *suggestion)
 {
-  uint32_t addr, cur = 0;
+  tor_addr_t addr, cur;
+  addr.family = AF_INET;
+  cur.family = AF_INET;
+  addr.addr.in_addr.s_addr = 0;
+  cur.addr.in_addr.s_addr = 0;
   struct in_addr in;
   or_options_t *options = get_options();
 
@@ -1430,21 +1437,22 @@
               escaped(suggestion));
     return;
   }
-  addr = ntohl(in.s_addr);
+  addr.family = AF_INET;
+  addr.addr.in_addr.s_addr = ntohl(in.s_addr);
 
   log_debug(LD_DIR, "Got X-Your-Address-Is: %s.", suggestion);
 
   if (!server_mode(options)) {
-    last_guessed_ip = addr; /* store it in case we need it later */
+    last_guessed_ip = addr.addr.in_addr.s_addr; /* store it in case we need it later \
*/  return;
   }
 
   if (resolve_my_address(LOG_INFO, options, &amp;cur, NULL) &gt;= 0) {
     /* We're all set -- we already know our address. Great. */
-    last_guessed_ip = cur; /* store it in case we need it later */
+    last_guessed_ip = cur.addr.in_addr.s_addr; /* store it in case we need it later \
*/  return;
   }
-  if (is_internal_IP(addr, 0)) {
+  if (is_internal_IP(addr.addr.in_addr.s_addr, 0)) {
     /* Don't believe anybody who says our IP is, say, 127.0.0.1. */
     return;
   }
@@ -1452,13 +1460,16 @@
   /* Okay.  We can't resolve our own address, and X-Your-Address-Is is giving
    * us an answer different from what we had the last time we managed to
    * resolve it. */
-  if (last_guessed_ip != addr) {
+  if (last_guessed_ip != addr.addr.in_addr.s_addr) {
     control_event_server_status(LOG_NOTICE,
                                 "EXTERNAL_ADDRESS ADDRESS=%s METHOD=DIRSERV",
                                 suggestion);
-    log_addr_has_changed(LOG_NOTICE, last_guessed_ip, addr);
+    struct tor_addr_t last;
+    last.family = AF_INET;
+    last.addr.in_addr.s_addr = last_guessed_ip;
+    log_addr_has_changed(LOG_NOTICE, last, addr);
     ip_address_changed(0);
-    last_guessed_ip = addr; /* router_rebuild_descriptor() will fetch it */
+    last_guessed_ip = addr.addr.in_addr.s_addr; /* router_rebuild_descriptor() will \
fetch it */  }
 }
 
@@ -1467,10 +1478,11 @@
  * about our address based on directory headers, answer it and return
  * 0; else return -1. */
 static int
-router_guess_address_from_dir_headers(uint32_t *guess)
+router_guess_address_from_dir_headers(struct tor_addr_t *guess)
 {
   if (last_guessed_ip) {
-    *guess = last_guessed_ip;
+    guess-&gt;family = AF_INET;
+    guess-&gt;addr.in_addr.s_addr = last_guessed_ip;
     return 0;
   }
   return -1;
Index: or/cpuworker.c
===================================================================
--- or/cpuworker.c
+++ or/cpuworker.c
@@ -468,7 +468,11 @@
       log_info(LD_OR,"circ-&gt;p_conn gone. Failing circ.");
       return -1;
     }
-    tag_pack(tag, circ-&gt;p_conn-&gt;_base.addr, circ-&gt;p_conn-&gt;_base.port,
+    if (circ-&gt;p_conn-&gt;_base.addr.family == AF_INET6) {
+      log_info(LD_OR,"we do not support ipv6 in assign_to_cpuworker().");
+      return -1;
+    }
+    tag_pack(tag, circ-&gt;p_conn-&gt;_base.addr.addr.in_addr.s_addr, \
circ-&gt;p_conn-&gt;_base.port,  circ-&gt;p_circ_id);
 
     cpuworker-&gt;state = CPUWORKER_STATE_BUSY_ONION;
Index: or/circuitbuild.c
===================================================================
--- or/circuitbuild.c
+++ or/circuitbuild.c
@@ -350,7 +350,11 @@
   tor_assert(firsthop-&gt;extend_info);
 
   /* now see if we're already connected to the first OR in 'route' */
-  in.s_addr = htonl(firsthop-&gt;extend_info-&gt;addr);
+  if (firsthop-&gt;extend_info-&gt;addr.family == AF_INET6) {
+     log_info(LD_CIRC,"we do not support Ipv6 for firsthop yet. Closing.");
+     return -END_CIRC_REASON_CONNECTFAILED;
+  }
+  in.s_addr = htonl(firsthop-&gt;extend_info-&gt;addr.addr.in_addr.s_addr);
   tor_inet_ntoa(&amp;in, tmpbuf, sizeof(tmpbuf));
   log_debug(LD_CIRC,"Looking for firsthop '%s:%u'",tmpbuf,
             firsthop-&gt;extend_info-&gt;port);
@@ -367,8 +371,8 @@
        router_digest_version_as_new_as(firsthop-&gt;extend_info-&gt;identity_digest,
                                        "0.1.1.9-alpha-cvs"))) {
     /* not currently connected */
-    circ-&gt;_base.n_addr = firsthop-&gt;extend_info-&gt;addr;
-    circ-&gt;_base.n_port = firsthop-&gt;extend_info-&gt;port;
+    circ-&gt;_base.n_addr  = firsthop-&gt;extend_info-&gt;addr;
+    circ-&gt;_base.n_port   = firsthop-&gt;extend_info-&gt;port;
 
     if (!n_conn || n_conn-&gt;_base.or_is_obsolete) { /* launch the connection */
       n_conn = connection_or_connect(firsthop-&gt;extend_info-&gt;addr,
@@ -399,6 +403,26 @@
   return 0;
 }
 
+/** compare the 2 given ipv4 or ipv6-addresses
+ *
+ * returns 0 if they are equal.
+ */
+int compare_addr(struct tor_addr_t a, struct tor_addr_t b) {
+
+  if (a.family != b.family)
+     return 1;
+
+  if (a.family == AF_INET)
+    return a.addr.in_addr.s_addr == b.addr.in_addr.s_addr;
+
+  int i;
+  for (i=0; i&lt;16; i++) {
+    if (a.addr.in6_addr.s6_addr[i] != b.addr.in6_addr.s6_addr[i])
+       return 1;
+  }
+  return 0;
+}
+
 /** Find any circuits that are waiting on &lt;b&gt;or_conn&lt;/b&gt; to become
  * open and get them to send their create cells forward.
  *
@@ -426,7 +450,7 @@
         continue;
       if (tor_digest_is_zero(circ-&gt;n_conn_id_digest)) {
         /* Look at addr/port. This is an unkeyed connection. */
-        if (circ-&gt;n_addr != or_conn-&gt;_base.addr ||
+        if ((compare_addr(circ-&gt;n_addr, or_conn-&gt;_base.addr) != 0) ||
             circ-&gt;n_port != or_conn-&gt;_base.port)
           continue;
         /* now teach circ the right identity_digest */
@@ -654,7 +678,12 @@
       return 0;
     }
 
-    set_uint32(payload, htonl(hop-&gt;extend_info-&gt;addr));
+    if (hop-&gt;extend_info-&gt;addr.family == AF_INET6) {
+        log(LOG_NOTICE, LD_GENERAL,
+            "circuit_send_next_onion_skin() - we do not support ipv6 for next hops \
yet. Ignoring."); +        return 0;
+    }
+    set_uint32(payload, htonl(hop-&gt;extend_info-&gt;addr.addr.in_addr.s_addr));
     set_uint16(payload+4, htons(hop-&gt;extend_info-&gt;port));
 
     onionskin = payload+2+4;
@@ -735,7 +764,8 @@
     return -1;
   }
 
-  circ-&gt;n_addr = ntohl(get_uint32(cell-&gt;payload+RELAY_HEADER_SIZE));
+  circ-&gt;n_addr.family = AF_INET;
+  circ-&gt;n_addr.addr.in_addr.s_addr = \
ntohl(get_uint32(cell-&gt;payload+RELAY_HEADER_SIZE));  circ-&gt;n_port = \
ntohs(get_uint16(cell-&gt;payload+RELAY_HEADER_SIZE+4));  
   onionskin = cell-&gt;payload+RELAY_HEADER_SIZE+4+2;
@@ -750,7 +780,11 @@
      router_digest_version_as_new_as(id_digest,"0.1.1.9-alpha-cvs"))) {
     struct in_addr in;
     char tmpbuf[INET_NTOA_BUF_LEN];
-    in.s_addr = htonl(circ-&gt;n_addr);
+    if (circ-&gt;n_addr.family == AF_INET6) {
+      log_info(LD_CIRC|LD_OR, "Next router is on an ipv6-address. we do not support \
this yet."); +      return 0;
+    }
+    in.s_addr = htonl(circ-&gt;n_addr.addr.in_addr.s_addr);
     tor_inet_ntoa(&amp;in,tmpbuf,sizeof(tmpbuf));
     log_info(LD_CIRC|LD_OR,"Next router (%s:%d) not connected. Connecting.",
              tmpbuf, circ-&gt;n_port);
@@ -767,6 +801,11 @@
       circ-&gt;n_port = n_conn-&gt;_base.port;
     } else {
      /* we should try to open a connection */
+      if (circ-&gt;n_addr.family == AF_INET6) {
+        log_info(LD_CIRC,"Cannot launch n_conn because we do not support ipv6 \
between nodes yet. Closing circuit."); +        circuit_mark_for_close(circ, \
END_CIRC_REASON_CONNECTFAILED); +        return 0;
+      }
       n_conn = connection_or_connect(circ-&gt;n_addr, circ-&gt;n_port, id_digest);
       if (!n_conn) {
         log_info(LD_CIRC,"Launching n_conn failed. Closing circuit.");
@@ -1010,7 +1049,16 @@
                                circ-&gt;p_conn, &amp;cell, CELL_DIRECTION_IN);
   log_debug(LD_CIRC,"Finished sending 'created' cell.");
 
-  if (!is_local_IP(circ-&gt;p_conn-&gt;_base.addr) &amp;&amp;
+  if (circ-&gt;p_conn-&gt;_base.addr.family == AF_INET6) {
+     log_debug(LD_CIRC,"not checking is_local_IP because we do not support ipv6 \
yet."); +     if(connection_or_nonopen_was_started_here(circ-&gt;p_conn)) {
+       /* record that we could process create cells from a non-local conn
+        * that we didn't initiate; presumably this means that create cells
+        * can reach us too. */
+       router_orport_found_reachable();
+      }
+  } else
+  if (!is_local_IP(circ-&gt;p_conn-&gt;_base.addr.addr.in_addr.s_addr) &amp;&amp;
       !connection_or_nonopen_was_started_here(circ-&gt;p_conn)) {
     /* record that we could process create cells from a non-local conn
      * that we didn't initiate; presumably this means that create cells
@@ -1751,7 +1799,8 @@
     strlcpy(info-&gt;nickname, nickname, sizeof(info-&gt;nickname));
   if (onion_key)
     info-&gt;onion_key = crypto_pk_dup_key(onion_key);
-  info-&gt;addr = addr;
+  info-&gt;addr.family = AF_INET;
+  info-&gt;addr.addr.in_addr.s_addr = addr;
   info-&gt;port = port;
   return info;
 }
Index: or/dnsserv.c
===================================================================
--- or/dnsserv.c
+++ or/dnsserv.c
@@ -116,9 +116,10 @@
   conn-&gt;_base.state = AP_CONN_STATE_RESOLVE_WAIT;
   conn-&gt;is_dns_request = 1;
 
-  TO_CONN(conn)-&gt;addr = ntohl(sin-&gt;sin_addr.s_addr);
+  TO_CONN(conn)-&gt;addr.family = AF_INET;
+  TO_CONN(conn)-&gt;addr.addr.in_addr.s_addr = ntohl(sin-&gt;sin_addr.s_addr);
   TO_CONN(conn)-&gt;port = ntohs(sin-&gt;sin_port);
-  TO_CONN(conn)-&gt;address = tor_dup_addr(TO_CONN(conn)-&gt;addr);
+  TO_CONN(conn)-&gt;address = tor_dup_addr(TO_CONN(conn)-&gt;addr.addr.in_addr.s_addr);
 
   if (q-&gt;type == EVDNS_TYPE_A)
     conn-&gt;socks_request-&gt;command = SOCKS_COMMAND_RESOLVE;
Index: or/rendclient.c
===================================================================
--- or/rendclient.c
+++ or/rendclient.c
@@ -117,10 +117,14 @@
   if (entry-&gt;parsed-&gt;protocols &amp; (1&lt;&lt;2)) {
     /* version 2 format */
     extend_info_t *extend_info = rendcirc-&gt;build_state-&gt;chosen_exit;
+    if (extend_info-&gt;addr.family == AF_INET6) {
+      log_warn(LD_BUG, "we do not support ipv6 in rend_client_send_introduction");
+      goto err;
+      }
     int klen;
     tmp[0] = 2; /* version 2 of the cell format */
     /* nul pads */
-    set_uint32(tmp+1, htonl(extend_info-&gt;addr));
+    set_uint32(tmp+1, htonl(extend_info-&gt;addr.addr.in_addr.s_addr));
     set_uint16(tmp+5, htons(extend_info-&gt;port));
     memcpy(tmp+7, extend_info-&gt;identity_digest, DIGEST_LEN);
     klen = crypto_pk_asn1_encode(extend_info-&gt;onion_key, tmp+7+DIGEST_LEN+2,
@@ -505,7 +509,7 @@
         entry-&gt;parsed-&gt;n_intro_points &gt; 0) {
       /* either this fetch worked, or it failed but there was a
        * valid entry from before which we should reuse */
-      log_info(LD_REND,"Rend desc is usable. Launching circuits.");
+      log_info(LD_REND,"Rend desc for hidden service '%s.onion' is usable. Launching \
circuits.", safe_str(query));  conn-&gt;_base.state = AP_CONN_STATE_CIRCUIT_WAIT;
 
       /* restart their timeout values, so they get a fair shake at
@@ -516,12 +520,12 @@
 
       if (connection_ap_handshake_attach_circuit(conn) &lt; 0) {
         /* it will never work */
-        log_warn(LD_REND,"Rendezvous attempt failed. Closing.");
+        log_warn(LD_REND,"Rendezvous attempt for hidden service '%s.onion' failed. \
                Closing.", safe_str(query));
         connection_mark_unattached_ap(conn, END_STREAM_REASON_CANT_ATTACH);
       }
     } else { /* 404, or fetch didn't get that far */
       log_notice(LD_REND,"Closing stream for '%s.onion': hidden service is "
-                 "unavailable (try again later).", safe_str(query));
+                 "unavailable (try again later). entry-&gt;parsed-&gt;n_intro_points=%i", \
                safe_str(query), entry-&gt;parsed-&gt;n_intro_points);
       connection_mark_unattached_ap(conn, END_STREAM_REASON_RESOLVEFAILED);
     }
   });
Index: common/util.c
===================================================================
--- common/util.c
+++ common/util.c
@@ -2223,13 +2223,13 @@
     _address = tor_strndup(addrport, colon-addrport);
     _port = (int) tor_parse_long(colon+1,10,1,65535,NULL,NULL);
     if (!_port) {
-      log_fn(severity, LD_GENERAL, "Port %s out of range", escaped(colon+1));
+      log_fn(severity, LD_GENERAL, "ipv4-Port %s out of range", escaped(colon+1));
       ok = 0;
     }
     if (!port_out) {
       char *esc_addrport = esc_for_log(addrport);
       log_fn(severity, LD_GENERAL,
-             "Port %s given on %s when not required",
+             "ipv4-Port %s given on %s when not required",
              escaped(colon+1), esc_addrport);
       tor_free(esc_addrport);
       ok = 0;
@@ -2241,10 +2241,13 @@
 
   if (addr) {
     /* There's an addr pointer, so we need to resolve the hostname. */
-    if (tor_lookup_hostname(_address,addr)) {
-      log_fn(severity, LD_NET, "Couldn't look up %s", escaped(_address));
+    struct tor_addr_t resolv;
+    if (tor_addr_lookup(_address, AF_INET, &amp;resolv)) {
+      log_fn(severity, LD_NET, "Couldn't look up ipv4 %s", escaped(_address));
       ok = 0;
       *addr = 0;
+    } else {
+      *addr = resolv.addr.in_addr.s_addr;
     }
   }
 
@@ -2260,7 +2263,84 @@
 
   return ok ? 0 : -1;
 }
+/** Parse a string of the form "[host]" and "[host]:port" from &lt;b&gt;addrport&lt;/b&gt;.  If
+ * &lt;b&gt;address&lt;/b&gt; is provided, set *&lt;b&gt;address&lt;/b&gt; to a copy of the
+ * host portion of the string.  If &lt;b&gt;addr&lt;/b&gt; is provided, try to
+ * resolve the host portion of the string and store it into
+ * *&lt;b&gt;addr&lt;/b&gt;.  If &lt;b&gt;port_out&lt;/b&gt; is provided,
+ * store the port number into *&lt;b&gt;port_out&lt;/b&gt;, or 0 if no port is given.
+ * If &lt;b&gt;port_out&lt;/b&gt; is NULL, then there must be no port number in
+ * &lt;b&gt;addrport&lt;/b&gt;.
+ * Return 0 on success, -1 on failure.
+ */
+int
+parse_addr6_port(int severity, const char *addrport, char **address,
+                struct in6_addr *addr, uint16_t *port_out)
+{
+  const char *colon;
+  char *_address = NULL;
+  int _port;
+  int ok = 1;
 
+  tor_assert(addrport);
+
+  colon = strstr(addrport, "]:");
+  if (colon) {
+    _address = tor_strndup(addrport, colon - addrport);
+    _port = (int) tor_parse_long(colon + 2, 10, 1, 65535, NULL, NULL);
+    log_fn(severity, LD_NET, "DEBUG ipv6 incl [ and ] is: %s port is %i", \
escaped(_address), _port); +    if (!_port) {
+      log_fn(severity, LD_GENERAL, "ipv6-Port %s out of range", escaped(colon+1));
+      ok = 0;
+    }
+    if (!port_out) {
+      char *esc_addrport = esc_for_log(addrport);
+      log_fn(severity, LD_GENERAL,
+             "ipv6-Port %s given on %s when not required",
+             escaped(colon+1), esc_addrport);
+      tor_free(esc_addrport);
+      ok = 0;
+    }
+  } else {
+    _address = tor_strdup(addrport);
+    _port = 0;
+    log_fn(severity, LD_NET, "DEBUG ipv6 incl [ and ] is: %s port is default", \
escaped(_address)); +  }
+  log_fn(severity, LD_NET, "DEBUG ipv6 incl [ and ] is: %s", escaped(_address));
+  const char *end = strstr(_address, "]");
+  if (end)
+    _address = tor_strndup(_address, end - _address);
+  log_fn(severity, LD_NET, "DEBUG ipv6 incl [ is: %s", escaped(_address));
+  const char *start = strstr(_address, "[");
+  if (start)
+    _address = (char *) start + 1;
+  log_fn(severity, LD_NET, "DEBUG ipv6 without [ is: %s", escaped(_address));
+
+  if (addr) {
+    /* There's an addr pointer, so we need to resolve the hostname. */
+    struct tor_addr_t resolv;
+    if (tor_addr_lookup(_address, AF_INET6, &amp;resolv)) {
+      log_fn(severity, LD_NET, "Couldn't look up ipv6 %s", escaped(_address));
+      ok = 0;
+      //*addr = 0;
+    } else {
+      *addr = resolv.addr.in6_addr;
+    }
+  }
+
+  if (address &amp;&amp; ok) {
+    *address = _address;
+  } else {
+    if (address)
+      *address = NULL;
+//TODO this may me a minor memory-leak of 42 byte once on startup    \
tor_free(_address); +  }
+  if (port_out)
+    *port_out = ok ? ((uint16_t) _port) : 0;
+
+  return ok ? 0 : -1;
+}
+
 /** If &lt;b&gt;mask&lt;/b&gt; is an address mask for a bit-prefix, return the number of
  * bits.  Otherwise, return -1. */
 int
@@ -2823,6 +2903,18 @@
   return -1; /* unknown address family, return unequal? */
 }
 
+/** Given an &lt;b&gt;addr&lt;/b&gt;, call tor_inet_ntop() on it
+ *  and return a strdup of the resulting address.
+ */
+char *
+tor_dup_addr6(struct in6_addr addr)
+{
+  char buf[42];
+
+  tor_inet_ntop(AF_INET6, &amp;addr, buf, sizeof(buf));
+  return tor_strdup(buf);
+}
+
 /** Given a host-order &lt;b&gt;addr&lt;/b&gt;, call tor_inet_ntop() on it
  *  and return a strdup of the resulting address.
  */
Index: common/util.h
===================================================================
--- common/util.h
+++ common/util.h
@@ -271,6 +271,8 @@
 int is_internal_IP(uint32_t ip, int for_listening) ATTR_PURE;
 int parse_addr_port(int severity, const char *addrport, char **address,
                     uint32_t *addr, uint16_t *port_out);
+int parse_addr6_port(int severity, const char *addrport, char **address,
+                    struct in6_addr *addr, uint16_t *port_out);
 int parse_port_range(const char *port, uint16_t *port_min_out,
                      uint16_t *port_max_out);
 int parse_addr_and_port_range(const char *s, uint32_t *addr_out,
@@ -280,6 +282,7 @@
 int addr_mask_cmp_bits(uint32_t a1, uint32_t a2, maskbits_t bits);
 int tor_inet_ntoa(const struct in_addr *in, char *buf, size_t buf_len);
 char *tor_dup_addr(uint32_t addr) ATTR_MALLOC;
+char *tor_dup_addr6(struct in6_addr addr) ATTR_MALLOC;
 int get_interface_address(int severity, uint32_t *addr);
 
 int get_interface_address6(int severity, sa_family_t family, tor_addr_t *addr);
Index: common/compat.c
===================================================================
--- common/compat.c
+++ common/compat.c
@@ -834,6 +834,16 @@
  * but works on Windows and Solaris.)
  */
 int
+tor_inet_aton6(const char *c, struct in6_addr* addr)
+{
+ return tor_inet_pton(AF_INET6, c, addr);
+}
+
+/** Set *addr to the IP address (in dotted-quad notation) stored in c.
+ * Return 1 on success, 0 if c is badly formatted.  (Like inet_aton(c,addr),
+ * but works on Windows and Solaris.)
+ */
+int
 tor_inet_aton(const char *c, struct in_addr* addr)
 {
 #ifdef HAVE_INET_ATON
@@ -1051,7 +1061,33 @@
  * (This function exists because standard windows gethostbyname
  * doesn't treat raw IP addresses properly.)
  */
+/*replaced by tor_addr_lookup
 int
+tor_lookup_hostname6(const char *name, struct in6_addr *addr)
+{
+  tor_addr_t myaddr;
+  int ret;
+
+  if ((ret = tor_addr_lookup(name, AF_INET6, &amp;myaddr)))
+    return ret;
+
+  if (IN_FAMILY(&amp;myaddr) == AF_INET6) {
+    *addr = (in6_addr)myaddr.addr;
+    return ret;
+  }
+
+  return -1;
+}
+*/
+/** Similar behavior to Unix gethostbyname: resolve &lt;b&gt;name&lt;/b&gt;, and set
+ * *&lt;b&gt;addr&lt;/b&gt; to the proper IP address, in host byte order.  Returns 0
+ * on success, -1 on failure; 1 on transient failure.
+ *
+ * (This function exists because standard windows gethostbyname
+ * doesn't treat raw IP addresses properly.)
+ */
+/* replaced by tor_addr_lookup
+int
 tor_lookup_hostname(const char *name, uint32_t *addr)
 {
   tor_addr_t myaddr;
@@ -1067,7 +1103,7 @@
 
   return -1;
 }
-
+*/
 /** Similar behavior to Unix gethostbyname: resolve &lt;b&gt;name&lt;/b&gt;, and set
  * *&lt;b&gt;addr&lt;/b&gt; to the proper IP address and family. The &lt;b&gt;family&lt;/b&gt;
  * argument (which must be AF_INET, AF_INET6, or AF_UNSPEC) declares a
@@ -1086,7 +1122,7 @@
   struct in6_addr iaddr6;
   tor_assert(name);
   tor_assert(addr);
-  tor_assert(family == AF_INET || family == AF_UNSPEC);
+  tor_assert(family == AF_INET || family == AF_INET6 || family == AF_UNSPEC);
   memset(addr, 0, sizeof(addr)); /* Clear the extraneous fields. */
   if (!*name) {
     /* Empty address is an error. */
Index: common/compat.h
===================================================================
--- common/compat.h
+++ common/compat.h
@@ -329,11 +329,11 @@
 struct in_addr;
 typedef struct tor_addr_t
 {
-  sa_family_t family;
+  sa_family_t family; // AF_INET or AF_INET6 or AF_UNIX
   union {
     struct in_addr in_addr;
     struct in6_addr in6_addr;
-  } addr;
+  } addr; // addr is ignored if AF_UNIX
 } tor_addr_t;
 
 /* XXXX020 rename these. */
@@ -383,9 +383,11 @@
 #define TOR_ADDR_BUF_LEN 46 /* ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255 */
 
 int tor_inet_aton(const char *cp, struct in_addr *addr) ATTR_NONNULL((1,2));
+int tor_inet_aton6(const char *cp, struct in6_addr *addr) ATTR_NONNULL((1,2));
 const char *tor_inet_ntop(int af, const void *src, char *dst, size_t len);
 int tor_inet_pton(int af, const char *src, void *dst);
 int tor_lookup_hostname(const char *name, uint32_t *addr) ATTR_NONNULL((1,2));
+int tor_lookup_hostname6(const char *name, struct in6_addr *addr) \
ATTR_NONNULL((1,2));  void set_socket_nonblocking(int socket);
 int tor_socketpair(int family, int type, int protocol, int fd[2]);
 int network_init(void);


["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20071208142359</emailId><senderName></senderName><senderEmail>phobos</senderEmail><timestampReceived>2007-12-08 14:23:59-0400</timestampReceived><subject>Re: win32 installer patch</subject><body>

On Thu, Dec 06, 2007 at 11:17:18PM -0600, arrakistor@gmail.com wrote 0.3K bytes in 8 lines about:
:  Yes, functions galore. The command line parameters at the bottom are the big
: deal, the rest is all spit and polish. While I was at it I updated the look of
: the installer to bring it out of 1998 and up to a respectable 2005. Thanks for
: the push on implementation.

Ok, most of this is good.  The orange theme burns my eyes.  I'll try out
some other themes.  

-- 
Andrew
</body></email><email><emailId>20071210110702</emailId><senderName>Heiko_Gro</senderName><senderEmail>heiko@kallisti.de</senderEmail><timestampReceived>2007-12-10 11:07:02-0400</timestampReceived><subject>Topic of a diploma</subject><body>

Hi there,

During the last weeks I've done research. I'm looking for a topic for my 
diploma which should be close to anomity/tor. I've read quit a few about 
cicuit-building, geoip and node-exclusion in order to build 
"Vorratsdatenspeicherungs"-proof circuits. At the beginning of my 
research I thought it would be suitable to just restrict the choice of 
the nodes by writing a special controller, but later on I became aware 
of other possible kinds of attacks such as statistic attacks on both 
ends of the communication.
Where are you guys right now at? Is there anything I can do?
I'm looking forward to find some working specially at this kind of problem.

Greets

Heiko

</body></email><email><emailId>20071215201533</emailId><senderName>Karsten Loesing</senderName><senderEmail>karsten.loesing@gmx.net</senderEmail><timestampReceived>2007-12-15 20:15:33-0400</timestampReceived><subject>Re: Comments on Proposal 121 [was Re: Proposal: Hidden Service Authentication]</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Hi,

&gt; thanks for your comments on our proposal 121! It's been two months since
&gt; your mail, but now that most patches for proposal 114 are applied, I am
&gt; finally able to do some work on this proposal.

&gt; The essence of your comments is now added to the proposal as r12725. I
&gt; will keep on working on the proposal, but will try to keep the course of
&gt; changes comprehensible. Please feel free to make further comments at any
&gt; stage! :)

Now there is an all new version of proposal 121 (hidden service
authentication):

https://tor-svn.freehaven.net/svn/tor/trunk/doc/spec/proposals/121-hidden-service-authentication.txt

This version is based on the comments by Nick and contains a (hopefully)
improved authentication protocol.

Please feel free to post comments! :)

- --Karsten
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFHZDXl0M+WPffBEmURAmGCAJ98QWrQIeE4Ns7KsBA0mwa1KivNxgCgxBto
9WKmMjPXEnOTaX98ty57qLI=
=1TGm
-----END PGP SIGNATURE-----
</body></email><email><emailId>20071228031643</emailId><senderName>"Kyle Williams"</senderName><senderEmail>kyle.kwilliams@gmail.com</senderEmail><timestampReceived>2007-12-28 03:16:43-0400</timestampReceived><subject>[ANNOUNCE] Tor-UPNP.  Need feedback.</subject><body>

Download at:  http://www.janusvm.com/pub/Tor-UPNP.zip
------------------------------------------------------------------------
Tor-UPNP is based on the PERL UPNP project: http://perlupnp.sourceforge.net/
It's been over 5 years since I worked with PERL, so things might be a bit
funky.  The zip file includes a EXE for windows built with the PerlDEV Kit.

I had to make some heavy modifications to the upnpgwtool.pl and a few lite
modifications to Gateway.pm module to get this working with PPP and DHCP. I
also removed the 'delete' and 'list' features from this tool. Reason being
that I wasn't able to get a single successful test using those commands. I
even tried using Intel's UPNP Tools with Wireshark and have come to the
conclusion that my ActionTec router is a piece of shit. However, I'm not
worried about being able to remove entries right now.  Apple, Microsoft, and
Sony just add a new port forwarding entry without checking to see if the
entry already exists.  I'm starting to think that maybe their reason is the
same as mine.

Anyhow..
The Gateway.pm module was using only:
'urn:schemas-upnp-org:service:WANIPConnection:1'
when some routers only respond to:
'urn:schemas-upnp-org:service:WANPPPConnection:1'.

Routers that respond to WANPPPConnection are using PPPoE to get an IP.
Routers that respond to WANIPConnection are using DHCP to get an IP.

With Tor-UPNP, it will attempt to try WANIPConnection first.  
If WANIPConnection fails then it will try to use WANPPPConnection.
If WANPPPConnection fails then it will give an error message and die.

This tool will automatically probe for the external IP address, your
internal IP address, then attempt to setup the port forwarding on the ports
you specify on the command line.

SYNTAX: Tor-UPNP.exe OR_Port [DIR_Port]

Please post feedback.  I would appreciate knowing:
- Did it work or fail
- What brand and model of router you are using.

This is licensed under the GPL...it's free.  
Use it for whatever you want.  Source code included!!!
I don't even care if I get credit, but it would be nice.
We will be including this in the next release of JanusVM.
I just want Tor to use UPNP!! Setup those Exit nodes by default, then let
someone opt out if they want to. :)

Enjoy!


- Kyle

</body></email><email><emailId>20071228102937</emailId><senderName>unknown</senderName><senderEmail>unknown@pgpru.com</senderEmail><timestampReceived>2007-12-28 10:29:37-0400</timestampReceived><subject>Multiple Directory Authorities' keys compromise: a partial solution</subject><body>

Multiple Directory Authorities' keys compromise: a partial solution for Tor clients \
protection.

The core problem with Tor is the lack of directory authorities which one need to \
unconditionally trust. Despite the mechanisms of DAs consensus voting and client \
comparing signed data downloaded from different DAs, an opponent controlling more \
than half of DAs' keys is able to conduct a multitude of attacks.

Unfortunately, we have a really small set of semi-trusted authorities and more than a \
half of them are in the single jurisdiction (US), so we are forced to believe that \
owners of these servers really protect their servers' keys from compromise, and \
operators themselves are free from any third-party malicious influence ;-)

Main security and trust problems were improved in v3 directory authority protocol, \
but not resolved completely.

If the third-party agent Mallory possesses more than half of semi-trusted DA keys and \
has an ISP-level access to user traffic, he still can make an MITM-based virtual \
network simulation for that user, like this:

Normal client activity:

Alice -&gt; encrypted traffic -&gt; [real Tor cloud] -&gt; decrypted traffic from exitnode -&gt; \
Bob

Intercepted client activity:

Alice -&gt; encrypted traffic -&gt; [Mellory's virtual Tor network simulation] -&gt; decrypted \
                traffic for Mellory -&gt;
-&gt; [Mellory's Tor client using Alice's circuits] -&gt; [real Tor cloud] -&gt; decrypted \
traffic from exitnode -&gt; Bob

###

We propose a partial (very limited, but adequate) solution: Tor client with active \
connection and relatively "fresh" stats cache can resort to "heuristic" analysis for \
suspicious stats changes.

At most two criteria can be analyzed:

1) An attempt to download stats from all of the mirrors is blocked or gives the stats \
with invalid signatures. As a result, it could be downloaded only from semi-trusted \
DAs. (Possibility of a legitimate DA's IP substituted with a malicious one, and data \
authenticated with compromised keys).

2) Tor-nodes' keys signed by a DA are changed significantly (for example, &gt;90% of all \
keys) during a very short period of time. (This case rises a suspicion about fake \
stats injection for user cache.)

Some questions remains: How many keys have to be affected by this attack to rise a \
suspicion? What the minimum time period threshold should be?

...) What's about other criteria of suspicious activity or formal model of other \
possible attacks detection for Tor clients?

We propose next log messages for the Tor client as an indication of probable \
attack-in-progress:

-&gt; Warning! Warning: a lot of tor-nodes' keys were changed during a short period of \
                time!
-&gt; If more than a half of Directory Authorities' keys are compromised, stats could be \
poisoned with a fake data.

As a paranoid option listed in config file (client-only section) one may use:

StopTorIfTooManyKeysChanged 0|1

Another open questions: Suppose user has this option enabled. Is it then sufficient \
to stop Tor-client when before-mentioned log event comes up or should also be done \
some other things too? What are the right things to do for users who got that log \
event? What's the right procedure to run Tor-client for users who have an outdated \
cache to be safe from this attack?

There is a long discussion on this problem on our site where we continue to propose a \
lot of ideas related to the topic.

"OpenPGP-in-Russia Team"


</body></email><email><emailId>20071231203523</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-12-31 20:35:23-0400</timestampReceived><subject>Re: Tor and privoxy had been ported to iphone and works very well.</subject><body>


On Mon, Dec 24, 2007 at 05:17:27PM +0800, cjacker huang wrote:
&gt; Here is the debug.log,
&gt; Any suggestion?
&gt; 

If there's any way you can get a stack trace the next time this
happens, that would help a lot in debugging it.  It looks like there's
a directory connection object with its purpose uninitialized, but it's
not clear what's creating it.

yrs,
-- 
Nick

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20071129205816</emailId><senderName>Robert Hogan</senderName><senderEmail>robert@roberthogan.net</senderEmail><timestampReceived>2007-11-29 20:58:16-0400</timestampReceived><subject>Re: [or-cvs] r12599: more progress on the geoip proposal  (tor/trunk/doc/spec/proposals)</subject><body>


&gt;Is it sufficient just to add a new GETINFO command?
&gt;    GETINFO ip-to-country/128.31.0.34
&gt;  250+ip-to-country/128.31.0.34="US","USA","UNITED STATES"

Other commands that would be useful:

1. 'getinfo servers/[COUNTRYCODE]' giving a list of servers with that 
countrycode
2. setconf  ExcludeCountryCodes
3. setconf IncludeCountryCodes

But why not absorb the countrycode into the server descriptor and have it 
assigned by the authorities?

This would:

- prevent possible partitioning attacks arising from different versions of the 
geoip db floating around (if bootstrap versions are supplied).
- save bandwidth (the db would be shared by authorities only)
- save client/relay processing power

Something like:

@downloaded-at 2007-11-29 19:45:13
@source "86.59.21.38"
@geoip US Boston X-ordinate Y-ordinate

maybe?


     

["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20071204082244</emailId><senderName>Arrakis</senderName><senderEmail>arrakistor@gmail.com</senderEmail><timestampReceived>2007-12-04 08:22:44-0400</timestampReceived><subject>win32 installer patch</subject><body>

Index: tor-mingw.nsi.in
===================================================================
--- tor-mingw.nsi.in	(revision 12660)
+++ tor-mingw.nsi.in	(working copy)
@@ -1,19 +1,24 @@
 ;tor.nsi - A basic win32 installer for Tor
 ; Originally written by J Doe.
+; Modified by Steve Topletz
 ; See LICENSE for licensing information
 ;-----------------------------------------
 ;
 !include "MUI.nsh"
+!include "LogicLib.nsh"
+!include FileFunc.nsh
+	!insertmacro GetParameters

 !define VERSION "0.2.0.12-alpha-dev"
 !define INSTALLER "tor-${VERSION}-win32.exe"
 !define WEBSITE "https://www.torproject.org/"

 !define LICENSE "LICENSE"
-;BIN is where it expects to find tor.exe, tor-resolve.exe, libcrypto.a and libssl.a
-!define BIN "..\bin"
+!define BIN "..\bin" ;BIN is where it expects to find tor.exe, tor-resolve.exe, \
libcrypto.a and libssl.a

-SetCompressor lzma
+
+SetCompressor /SOLID LZMA ;Tighter compression
+RequestExecutionLevel user ;Updated for Vista compatibility
 OutFile ${INSTALLER}
 InstallDir $PROGRAMFILES\Tor
 SetOverWrite ifnewer
@@ -25,27 +30,28 @@
 XPStyle on
 VIProductVersion "${VERSION}"
 VIAddVersionKey "ProductName" "The Onion Router: Tor"
-VIAddVersionKey "Comments" "https://www.torproject.org/"
+VIAddVersionKey "Comments" "${WEBSITE}"
 VIAddVersionKey "LegalTrademarks" "Three line BSD"
 VIAddVersionKey "LegalCopyright" "2004-2007, Roger Dingledine, Nick Mathewson"
-VIAddVersionKey "FileDescription" "Tor is an implementation of Onion Routing. You \
can read more at https://www.torproject.org/" +VIAddVersionKey "FileDescription" "Tor \
is an implementation of Onion Routing. You can read more at ${WEBSITE}"  \
VIAddVersionKey "FileVersion" "${VERSION}"

 !define MUI_WELCOMEPAGE_TITLE "Welcome to the Tor ${VERSION} Setup Wizard"
-!define MUI_WELCOMEPAGE_TEXT "This wizard will guide you through the installation of \
Tor ${VERSION}.\r\n\r\nIf you have previously installed Tor and it is currently \
running, please exit Tor first before continuing this installation.\r\n\r\n$_CLICK" \
+!define MUI_WELCOMEPAGE_TEXT "This wizard will guide you through the installation of \
Tor.\r\n\r\nIf you have previously installed Tor and it is currently running, please \
                exit Tor first before continuing this installation.\r\n\r\n$_CLICK"
 !define MUI_ABORTWARNING
-!define MUI_ICON "${NSISDIR}\Contrib\Graphics\Icons\win-install.ico"
-!define MUI_UNICON "${NSISDIR}\Contrib\Graphics\Icons\win-uninstall.ico"
-!define MUI_HEADERIMAGE_BITMAP "${NSISDIR}\Contrib\Graphics\Header\win.bmp"
+!define MUI_ICON "${NSISDIR}\Contrib\Graphics\Icons\orange-install.ico"
+!define MUI_UNICON "${NSISDIR}\Contrib\Graphics\Icons\orange-uninstall.ico"
+!define MUI_HEADERIMAGE_BITMAP "${NSISDIR}\Contrib\Graphics\Header\orange.bmp"
+!define MUI_WELCOMEFINISHPAGE_BITMAP "${NSISDIR}\Contrib\Graphics\Wizard\orange.bmp"
+!define MUI_UNWELCOMEFINISHPAGE_BITMAP \
                "${NSISDIR}\Contrib\Graphics\Wizard\orange-uninstall.bmp"
 !define MUI_HEADERIMAGE
 !define MUI_FINISHPAGE_RUN "$INSTDIR\tor.exe"
 !define MUI_FINISHPAGE_LINK "Visit the Tor website for the latest updates."
 !define MUI_FINISHPAGE_LINK_LOCATION ${WEBSITE}

 !insertmacro MUI_PAGE_WELCOME
-; There's no point in having a clickthrough license: Our license adds
-; certain rights, but doesn't remove them.
-; !insertmacro MUI_PAGE_LICENSE "${LICENSE}"
+;(There's no point in having a clickthrough license: Our license adds certain \
rights, but doesn't remove them.) +; !insertmacro MUI_PAGE_LICENSE "${LICENSE}"
 !insertmacro MUI_PAGE_COMPONENTS
 !insertmacro MUI_PAGE_DIRECTORY
 !insertmacro MUI_PAGE_INSTFILES
@@ -56,67 +62,48 @@
 !insertmacro MUI_UNPAGE_FINISH
 !insertmacro MUI_LANGUAGE "English"

-Var configdir
-Var configfile
+Var CONFIGDIR
+Var CONFIGFILE

+Function .onInit
+	Call ParseCmdLine
+FunctionEnd
+
 ;Sections
 ;--------

 Section "Tor" Tor
 ;Files that have to be installed for tor to run and that the user
 ;cannot choose not to install
-   SectionIn RO
-   SetOutPath $INSTDIR
-   File "${BIN}\tor.exe"
-   File "${BIN}\tor-resolve.exe"
-   File "${BIN}\tor.ico"
-   WriteIniStr "$INSTDIR\Tor Website.url" "InternetShortcut" "URL" ${WEBSITE}
+	SectionIn RO
+	SetOutPath $INSTDIR
+	Call ExtractBinaries
+	Call ExtractIcon
+	WriteINIStr "$INSTDIR\Tor Website.url" "InternetShortcut" "URL" ${WEBSITE}

-   StrCpy $configfile "torrc"
-   StrCpy $configdir $APPDATA\Tor
+	StrCpy $CONFIGFILE "torrc"
+	StrCpy $CONFIGDIR $APPDATA\Tor
 ;   ;If $APPDATA isn't valid here (Early win95 releases with no updated
 ;   ; shfolder.dll) then we put it in the program directory instead.
 ;   StrCmp $APPDATA "" "" +2
-;      StrCpy $configdir $INSTDIR
-   SetOutPath $configdir
-   ;If there's already a torrc config file, ask if they want to
-   ;overwrite it with the new one.
-   IfFileExists "$configdir\torrc" "" endiftorrc
-      MessageBox MB_ICONQUESTION|MB_YESNO "You already have a Tor config \
file.$\r$\nDo you want to overwrite it with the default sample config file?" IDNO \
                yesreplace
-      Delete $configdir\torrc
-      Goto endiftorrc
-     yesreplace:
-      StrCpy $configfile "torrc.sample"
-   endiftorrc:
-   File /oname=$configfile "..\src\config\torrc.sample"
+;      StrCpy $CONFIGDIR $INSTDIR
+	SetOutPath $CONFIGDIR
+	;If there's already a torrc config file, ask if they want to
+	;overwrite it with the new one.
+	${If} ${FileExists} "$CONFIGDIR\torrc"
+		MessageBox MB_ICONQUESTION|MB_YESNO "You already have a Tor config file.$\r$\nDo \
you want to overwrite it with the default sample config file?" IDYES Yes IDNO No \
+		Yes: +			Delete $CONFIGDIR\torrc
+			Goto Next
+		No:
+			StrCpy $CONFIGFILE "torrc.sample"
+		Next:
+	${EndIf}
+	File /oname=$CONFIGFILE "..\src\config\torrc.sample"
 SectionEnd

 Section "Documents" Docs
-   SetOutPath "$INSTDIR\Documents"
-   ;File "doc\FAQ"
-   File "..\doc\HACKING"
-   File "..\doc\spec\address-spec.txt"
-   File "..\doc\spec\control-spec.txt"
-   File "..\doc\spec\control-spec-v0.txt"
-   File "..\doc\spec\dir-spec.txt"
-   File "..\doc\spec\dir-spec-v1.txt"
-   File "..\doc\spec\path-spec.txt"
-   File "..\doc\spec\rend-spec.txt"
-   File "..\doc\spec\socks-extensions.txt"
-   File "..\doc\spec\tor-spec.txt"
-   File "..\doc\spec\version-spec.txt"
-   ;
-   ; WEBSITE-FILES-HERE
-   ;
-   File "..\doc\tor-resolve.html"
-   File "..\doc\tor-reference.html"
-   ;
-   File "..\doc\design-paper\tor-design.pdf"
-   ;
-   File "..\README"
-   File "..\AUTHORS"
-   File "..\ChangeLog"
-   File "..\LICENSE"
+	Call ExtractDocuments
 SectionEnd

 ;Section "TorButton for FireFox" Torbutton
@@ -136,19 +123,13 @@

 Section "Start Menu" StartMenu
    SetOutPath $INSTDIR
-   IfFileExists "$SMPROGRAMS\Tor\*.*" "" +2
-      RMDir /r "$SMPROGRAMS\Tor"
-   CreateDirectory "$SMPROGRAMS\Tor"
-   CreateShortCut "$SMPROGRAMS\Tor\Tor.lnk" "$INSTDIR\tor.exe" "" "$INSTDIR\tor.ico"
-   CreateShortCut "$SMPROGRAMS\Tor\Torrc.lnk" "Notepad.exe" "$configdir\torrc"
-   CreateShortCut "$SMPROGRAMS\Tor\Tor Website.lnk" "$INSTDIR\Tor Website.url"
-   CreateShortCut "$SMPROGRAMS\Tor\Uninstall.lnk" "$INSTDIR\Uninstall.exe"
-   IfFileExists "$INSTDIR\Documents\*.*" "" endifdocs
-      CreateDirectory "$SMPROGRAMS\Tor\Documents"
-      CreateShortCut "$SMPROGRAMS\Tor\Documents\Tor Manual.lnk" \
                "$INSTDIR\Documents\tor-reference.html"
-      CreateShortCut "$SMPROGRAMS\Tor\Documents\Tor Documentation.lnk" \
                "$INSTDIR\Documents"
-      CreateShortCut "$SMPROGRAMS\Tor\Documents\Tor Specification.lnk" \
                "$INSTDIR\Documents\tor-spec.txt"
-   endifdocs:
+   ${If} ${FileExists} "$SMPROGRAMS\Tor\*.*"
+         RMDir /r "$SMPROGRAMS\Tor"
+   ${EndIf}
+   Call CreateTorLinks
+   ${If} ${FileExists} "$INSTDIR\Documents\*.*"
+		Call CreateDocLinks
+   ${EndIf}
 SectionEnd

 Section "Desktop" Desktop
@@ -164,24 +145,7 @@
 SubSectionEnd

 Section "Uninstall"
-   Delete "$DESKTOP\Tor.lnk"
-   Delete "$INSTDIR\libcrypto.a"
-   Delete "$INSTDIR\libssl.a"
-   Delete "$INSTDIR\tor.exe"
-   Delete "$INSTDIR\tor-resolve.exe"
-   Delete "$INSTDIR\Tor Website.url"
-   Delete "$INSTDIR\torrc"
-   Delete "$INSTDIR\torrc.sample"
-   Delete "$INSTDIR\tor.ico"
-   StrCmp $configdir $INSTDIR +2 ""
-      RMDir /r $configdir
-   Delete "$INSTDIR\Uninstall.exe"
-   RMDir /r "$INSTDIR\Documents"
-   RMDir $INSTDIR
-   RMDir /r "$SMPROGRAMS\Tor"
-   RMDir /r "$APPDATA\Tor"
-   Delete "$SMSTARTUP\Tor.lnk"
-   DeleteRegKey HKLM "SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\Tor"
+   Call un.InstallPackage
 SectionEnd

 Section -End
@@ -193,11 +157,127 @@
 SectionEnd

 !insertmacro MUI_FUNCTION_DESCRIPTION_BEGIN
-  !insertmacro MUI_DESCRIPTION_TEXT ${Tor} "The core executable and config files \
                needed for Tor to run."
-  !insertmacro MUI_DESCRIPTION_TEXT ${Docs} "Documentation about Tor."
-  !insertmacro MUI_DESCRIPTION_TEXT ${ShortCuts} "Shortcuts to easily start Tor"
-  !insertmacro MUI_DESCRIPTION_TEXT ${StartMenu} "Shortcuts to access Tor and it's \
                documentation from the Start Menu"
-  !insertmacro MUI_DESCRIPTION_TEXT ${Desktop} "A shortcut to start Tor from the \
                desktop"
-  !insertmacro MUI_DESCRIPTION_TEXT ${Startup} "Launches Tor automatically at \
startup in a minimized window" +	!insertmacro MUI_DESCRIPTION_TEXT ${Tor} "The core \
executable and config files needed for Tor to run." +	!insertmacro \
MUI_DESCRIPTION_TEXT ${Docs} "Documentation about Tor." +	!insertmacro \
MUI_DESCRIPTION_TEXT ${ShortCuts} "Shortcuts to easily start Tor" +	!insertmacro \
MUI_DESCRIPTION_TEXT ${StartMenu} "Shortcuts to access Tor and it's documentation \
from the Start Menu" +	!insertmacro MUI_DESCRIPTION_TEXT ${Desktop} "A shortcut to \
start Tor from the desktop" +	!insertmacro MUI_DESCRIPTION_TEXT ${Startup} "Launches \
                Tor automatically at startup in a minimized window"
 !insertmacro MUI_FUNCTION_DESCRIPTION_END

+;####################Functions#########################
+
+Function ExtractBinaries
+	File "${BIN}\tor.exe"
+	File "${BIN}\tor-resolve.exe"
+FunctionEnd
+
+Function ExtractIcon
+	File "${BIN}\tor.ico"
+FunctionEnd
+
+Function ExtractSpecs
+	;File "doc\FAQ"
+	File "..\doc\HACKING"
+	File "..\doc\spec\address-spec.txt"
+	File "..\doc\spec\control-spec.txt"
+	File "..\doc\spec\control-spec-v0.txt"
+	File "..\doc\spec\dir-spec.txt"
+	File "..\doc\spec\dir-spec-v1.txt"
+	File "..\doc\spec\path-spec.txt"
+	File "..\doc\spec\rend-spec.txt"
+	File "..\doc\spec\socks-extensions.txt"
+	File "..\doc\spec\tor-spec.txt"
+	File "..\doc\spec\version-spec.txt"
+FunctionEnd
+
+Function ExtractHTML
+	File "..\doc\tor-resolve.html"
+	File "..\doc\tor-reference.html"
+FunctionEnd
+
+Function ExtractDesignDocs
+	File "..\doc\design-paper\tor-design.pdf"
+FunctionEnd
+
+Function ExtractReleaseDocs
+	File "..\README"
+	File "..\AUTHORS"
+	File "..\ChangeLog"
+	File "..\LICENSE"
+FunctionEnd
+
+Function ExtractDocuments
+	SetOutPath "$INSTDIR\Documents"
+	Call ExtractSpecs
+	Call ExtractHTML
+	Call ExtractDesignDocs
+	Call ExtractReleaseDocs
+FunctionEnd
+
+Function un.InstallFiles
+	Delete "$DESKTOP\Tor.lnk"
+	Delete "$INSTDIR\libcrypto.a"
+	Delete "$INSTDIR\libssl.a"
+	Delete "$INSTDIR\tor.exe"
+	Delete "$INSTDIR\tor-resolve.exe"
+	Delete "$INSTDIR\Tor Website.url"
+	Delete "$INSTDIR\torrc"
+	Delete "$INSTDIR\torrc.sample"
+	Delete "$INSTDIR\tor.ico"
+	Delete "$SMSTARTUP\Tor.lnk"
+	Delete "$INSTDIR\Uninstall.exe"
+FunctionEnd
+
+Function un.InstallDirectories
+	${If} $CONFIGDIR == $INSTDIR
+		RMDir /r $CONFIGDIR
+	${EndIf}
+	RMDir /r "$INSTDIR\Documents"
+	RMDir $INSTDIR
+	RMDir /r "$SMPROGRAMS\Tor"
+	RMDir /r "$APPDATA\Tor"
+FunctionEnd
+
+Function un.WriteRegistry
+	DeleteRegKey HKLM "SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\Tor"
+FunctionEnd
+
+Function un.InstallPackage
+	Call un.InstallFiles
+	Call un.InstallDirectories
+	Call un.WriteRegistry
+FunctionEnd
+
+Function CreateTorLinks
+	CreateDirectory "$SMPROGRAMS\Tor"
+	CreateShortCut "$SMPROGRAMS\Tor\Tor.lnk" "$INSTDIR\tor.exe" "" "$INSTDIR\tor.ico"
+	CreateShortCut "$SMPROGRAMS\Tor\Torrc.lnk" "Notepad.exe" "$CONFIGDIR\torrc"
+	CreateShortCut "$SMPROGRAMS\Tor\Tor Website.lnk" "$INSTDIR\Tor Website.url"
+	CreateShortCut "$SMPROGRAMS\Tor\Uninstall.lnk" "$INSTDIR\Uninstall.exe"
+FunctionEnd
+
+Function CreateDocLinks
+	CreateDirectory "$SMPROGRAMS\Tor\Documents"
+	CreateShortCut "$SMPROGRAMS\Tor\Documents\Tor Manual.lnk" \
"$INSTDIR\Documents\tor-reference.html" +	CreateShortCut \
"$SMPROGRAMS\Tor\Documents\Tor Documentation.lnk" "$INSTDIR\Documents" \
+	CreateShortCut "$SMPROGRAMS\Tor\Documents\Tor Specification.lnk" \
"$INSTDIR\Documents\tor-spec.txt" +FunctionEnd
+
+Function ParseCmdLine
+	${GetParameters} $1
+	${If} $1 == "-x" ;Extract All Files
+		StrCpy $INSTDIR $EXEDIR
+		Call ExtractBinaries
+		Call ExtractDocuments
+		Quit
+	${ElseIf} $1 == "-b" ;Extract Binaries Only
+		StrCpy $INSTDIR $EXEDIR
+		Call ExtractBinaries
+		Quit
+	${ElseIf} $1 != ""
+		MessageBox MB_OK|MB_TOPMOST `${Installer} [-x|-b]$\r$\n$\r$\n  -x    Extract all \
files$\r$\n  -b    Extract binary files only` +		Quit
+	${EndIf}
+FunctionEnd
+


</body></email><email><emailId>20071209003141</emailId><senderName>Karsten Loesing</senderName><senderEmail>karsten.loesing@gmx.net</senderEmail><timestampReceived>2007-12-09 00:31:41-0400</timestampReceived><subject>Re: Comments on Proposal 121 [was Re: Proposal: Hidden Service Authentication]</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Hi Nick,

thanks for your comments on our proposal 121! It's been two months since
your mail, but now that most patches for proposal 114 are applied, I am
finally able to do some work on this proposal.

&gt; These versions are getting me very confused. [...]
&gt; Is there any way to straighten out this mess and be clear about which
&gt; version number is which?

Yes, rend-spec now includes the new section 0.4 which contains a version
overview. However, versioning of INTRODUCE1 cells is not listed there,
because it's new in this proposal.

&gt; FWIW, the fields you mention are only listed in the spec for a
&gt; descriptor format that was never used.  They were part of the
&gt; RELAY_INTRODUCE2 cell payload, and so were *not* ever encrypted with
&gt; the service's public key.

Right. Version 3 INTRODUCE cells are not in use yet, but we would like
to change that by implementing them.

It would also make sense to incorporate the IPv6 stuff that is described
for the v3 intro protocol. This should be done when incorporating the
other IPv6 code.

But I think you are wrong in saying that INTRODUCE2 cells are not
encrypted (see rend-spec 1.8). Depending on the hidden service
descriptor version they are either encrypted with the service's public
key (v0 descriptors) or the fresh key contained in the v2 descriptor.

&gt;&gt; Bob will only build
&gt;&gt; the circuit to the rendezvous point if the provided authentication data
&gt;&gt; is valid, otherwise he will drop the cell. This will improve security due
&gt;&gt; to preventing communication between Bob and Alice if she is an
&gt;&gt; attacker.
&gt; 
&gt; Having authorization _at the introduction point_ achieves this
&gt; property.  If the introduction point relays the message to Bob, Bob is
&gt; already "communicating" with Alice in the sense that Alice can make
&gt; Bob get a cell whenever she likes.  For many attackers, this is
&gt; enough, but these attackers probably win anyway.

Authorization at the introduction point level may only be considered
optional, because introduction points might be untrustworthy. Therefore,
authorization at the hidden service is required.

The proposal was meant to say that there is no communication _from_ Bob
_to_ Alice, regardless of the fact that there will be communication in
the other direction. This is important, because an unauthorized Alice
_cannot_ force Bob to build circuits to her rendezvous point, making the
attack described by Lasse and Paul in "Locating Hidden Servers"
impossible. If Bob is not convinced that Alice is authorized to contact
him, he will simply drop the request. I now changed the proposal to put
special emphasis on this.

&gt; In other words, there are two big ideas here that could be separated
&gt; pretty easily:
&gt;   (A) "A generic authentication mechanism for hidden services"
&gt;   (B) "Some specific kinds of authentication"
&gt; 
&gt; I think it's a good idea to split these up better, because I think
&gt; what the proposal specifies for (A) is a lot more solid than what it
&gt; specifies for (B).

Sounds good. I also reduced the number of proposed protocols to one,
i.e. the cookie-based approach, leaving the public-key protocol out. It
might be more important to have a good infrastructure and a simple
solution specified and implemented cleanly before thinking about more
elaborate solutions. Apart from our public-key protocol there will be a
number of smarter solutions out there in Cryptoland that I have never
heard of.

&gt; It's probably better for Bob to store H(salt|H(x)).
&gt; 
&gt; For Alice, instead of H(x), it might be a good idea to use some
&gt; version of the s2k algorithm in RFC2440, to prevent anybody who sees
&gt; it from reversing it.  (This matters more for authentication at the
&gt; introduction point than for authentication for Bob.)

Hmm. I am not sure if I like the idea of salting the password. It would
make it impossible for both Alice and Bob to read the password and
display it in a GUI. Further, it's still unclear in which direction
passwords will be exchanged, i.e. from Alice to Bob or the other way around.

For the moment I would rather store the passwords in plain text files
and rely on file system security for confidentiality. :)

This could be enhanced at any time, but for now I think that the other
problems with this proposal (authentication protocols) are more serious.

&gt; There is also an anonymity issue in this method: it makes all requests
&gt; by users with the same password linkable.

I'm not sure if I understand you right, so I will guess: Do you mean
being linkable to the service? If so, sure! But that's not a problem, is
it? To say it another way: It's hard -- if not even impossible -- for a
client to stay anonymous towards a server when using client-specific
authentication data. I don't know if it should be a design goal that
clients can stay anonymous towards the service. Well, should it be in
your opinion?

IMHO it's more important for a client to stay anonymous towards the
untrusted introduction point in this context -- like the server is since
the introduction of fresh service keys with v2 descriptors.

&gt;&gt; The premise to use password authentication is that Bob must send the
&gt;&gt; password to Alice outside Tor.
&gt; 
&gt; Above you say Alice sends it to Bob.  Presumably you mean "either."

You see, we are still undecided about who sends the data to whom.

&gt;&gt; When Alice wants to use this authentication method she sets "AUTHT" to
&gt;&gt; "2" and "AUTHL" to "128" which is the size of the encrypted data.
&gt; 
&gt; It's not necessary or even desirable to use a fixed key size here;
&gt; this should probably be specified in terms of the key size.

Right.

&gt;&gt; (1) Alice creates a private key e and sends the corresponding public key
&gt;&gt;     d to Bob out of band.
&gt;&gt; (2) Alice generates a random rendezvous cookie r, computes PKSign(e, r),
&gt;&gt;     encrypts it with Bob's fresh service key (see proposal 114), and
&gt;&gt;     sends the result to Bob.
&gt;&gt; (3) Bob decrypts Alice's message using his private service key (see
&gt;&gt;     proposal 114) and verifies PKSign(e, r) with d.
&gt; 
&gt; This is really awful in terms of performance if there is more than one
&gt; authorized Alice.  If there are N authorized users, Bob needs to try
&gt; PKSign(e, r) on average N times before he can be sure that a user is
&gt; unauthorized.
&gt; 
&gt; It would probably be better to include some indication of which key
&gt; Bob is supposed to use to check the signature.

Yes, adding the public key hash h(d) to the message sent in (2) would be
useful. As mentioned above, I removed the whole protocol from the
proposal, but left a note in my records, that whenever we would put it
in again, we would incorporate that hash.

&gt;&gt; It is important to notice that the IPo may not be trustworthy, and
&gt;&gt; therefore can not replace authentication at the HS OP itself. Nor should
&gt;&gt; the IPo get hold of critical authentication information (because it could
&gt;&gt; try to access the service itself).
&gt; 
&gt; Ideally, it would also be possible for Bob to verify that the IPo is
&gt; not relaying any unauthorized requests.

Bob could exclude those introduction points relaying unauthorized
requests. But before, we need to make sure that neither untrustworthy
introduction points nor clients can denounce an introduction point by
this way. Added it to the proposal.

&gt; I don't see the challenge-response aspect here.  The introduction
&gt; point, in the protocol below, isn't actually issuing any challenge to
&gt; Alice.  The "challenge" comes from Bob in the encrypted portion of the
&gt; hidden service descriptor, but since the challenge is the same every
&gt; time Alice connects to any introduction point while the descriptor is
&gt; valid, Alice's responses will be replayable.  This defeats the whole
&gt; point of a challenge-response protocol.

Right, the "challenge" is not sent per request. But we are able to
create a new "challenge" for every establishment of an introduction
point for a hidden service. This property can be used to make
authentication requests from the same client to the same service
unlinkable for a relay that is picked as introduction point twice. I
guess this has to do with our decision to call it "challenge". But you
are right, it's not the correct term here.

In order to create a "real" challenge-response protocol we would have to
change the hidden service protocol by introducing two more cell types
between INTRODUCE1 and INTRODUCE2/INTRO_ACK. But this would have
increased protocol complexity and further worsened performance. If
possible, we would like to avoid both of that.

&gt; The authenticated h(h(x)|y) value seems to be completely replayable;
&gt; any of Alice's introduction point can impersonate Alice to any of the
&gt; other introduction points.  This isn't what I'd consider a
&gt; challenge-response protocol.

Well, this seems to be a little bit underspecified. What we meant is
that y is introduction-point specific, so that an introduction point
cannot replay Alice's message to any of the other introduction points.
The v2 descriptor format has two fields for hidden-service specific and
introduction-point specific authentication data.

However, what we did not cover is a replay attack conducted by the
introduction point to the hidden service. Why not replay a correct
introduce cell and force the service to create circuits to the
rendezvous point? This would allow the attack as described by Lasse and
Paul, at least for the introduction points. Maybe it would be a solution
to keep a history of connection attempts for each introduction point, so
that it allows only a limited number of requests from the same user
within a certain time, before being discarded by the hidden service.

Further, an introduction point would be able to monitor consecutive
connection attempts by the same user. But since the introduction point
can neither identify the server nor the client, this information is IMHO
rather useless.

&gt; Stepping back a little, it looks like what you want is some protocol
&gt; where Alice has a password x, and Bob knows some f(x), and Bob tells
&gt; the IPo some g(f(x)).  Later, Alice sends an INTRODUCE1 cell whose
&gt; unencrypted portion includes i(x) and whose encrypted portion includes
&gt; j(x), and this is enough for everybody to authenticate Alice.
&gt; We'd also like it to be the case that nobody, not even another IPo
&gt; that has seen Alice authenticate, can convince an IPo or Bob that it
&gt; is Alice.
&gt; 
&gt; It seems to me that this is probably one of the solved problems in the
&gt; field of cryptography, and it would be a little silly and error-prone
&gt; of us to make up our own protocol to do this.

The description almost matches, except for Alice having two distinct
passwords for authenticating towards the introduction point and the
actual service.

Well, introducing authentication to the hidden service protocol is a
rather complex scenario, so I doubt there will be an easy solution in
the literature. But you are right that the parts should already be
solved somewhere and only wait for being put together correctly.

&gt; Cells are only so long -- 512 bytes at the moment, with only 498 of
&gt; that available for relay payloads.  Assuming 1024-bit keys, the fields
&gt; above other than AUTHD fill 283 bytes.  If I'm counting right, that
&gt; leaves only 215 bytes for AUTHD.  This is enough room for only 10
&gt; users with your password authentication scheme, and only 1 user with
&gt; your public-key scheme.
&gt; 
&gt; That's not so good.  On the one hand, it would be unpleasant to allow
&gt; Bob to claim an arbitrary amount of storage on the introduction point,
&gt; and unpleasant to require him to transmit it all regularly.  But on
&gt; the other hand, having the number of supported users limited by the
&gt; cell size is really awful.

This is another open problem. It could be solved, either a) by finding a
protocol that is space-independent, b) by extending cell size, or c) by
sending multiple cells for a request.

&gt; I hope these comments help; the idea is a sound one, but the execution
&gt; needs more work before I'd be comfortable putting it into Tor.

Yes, your comments were really helpful!

The essence of your comments is now added to the proposal as r12725. I
will keep on working on the proposal, but will try to keep the course of
changes comprehensible. Please feel free to make further comments at any
stage! :)

Thanks!
- --Karsten
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFHWzdt0M+WPffBEmURAsW+AJ9qkGdPXwb66hZn4PUtNzuFY390WwCeMNRw
VKTwJPSD1XCA/VLdUfrXbmo=
=gB+z
-----END PGP SIGNATURE-----
</body></email><email><emailId>20071217092557</emailId><senderName>"cjacker huang"</senderName><senderEmail>cjacker@gmail.com</senderEmail><timestampReceived>2007-12-17 09:25:57-0400</timestampReceived><subject>Tor and privoxy had been ported to iphone and works very well.</subject><body>

Hi, there,
   I just ported libevent, tor-0.1.2.18 and privoxy to iphone 1.1.1 fw.
and finished a iPhone app named iTor.app.

There is almost no need to change the code.
just modify the project files(disable some configure tests and set
some default definitions) and a little code.(the default
MAXCONNECTIONS 15000 is too big, I use cygwin's value 3200).

these three definitions had been set to 1 by default:

USING_TWOS_COMPLEMENT
NULL_REP_IS_ZERO_BYTES
TIME_T_IS_SIGNED


It works pretty good on iphone. also I tested it with privoxy on PC
and tor on iphone.

for more infomation and source.
http://www.linux-ren.org/modules/everestblog/?p=161

the patch is below, compile it with:

$autoconf
$./configure --host=arm-apple-darwin --enable-iphone



diff -Nur tor-0.1.2.18/configure.in tor-0.1.2.18n/configure.in
--- tor-0.1.2.18/configure.in	2007-10-28 19:17:47.000000000 +0800
+++ tor-0.1.2.18n/configure.in	2007-12-17 17:16:19.000000000 +0800
@@ -19,6 +19,13 @@
     CFLAGS="$CFLAGS -g"
 fi])

+AC_ARG_ENABLE(iphone,
+ AC_HELP_STRING(--enable-iphone, compile with iphone),
+[if test x$enableval = xyes; then
+	iphone=true
+    CFLAGS="$CFLAGS -D__DARWIN_UNIX03 -D__IPHONE"
+fi])
+
 AC_ARG_ENABLE(eventdns,
      AC_HELP_STRING(--enable-eventdns, enable asynchronous dns module),
      [case "${enableval}" in
@@ -395,8 +402,8 @@
     CPPFLAGS="-I$tor_cv_openssl_dir $CPPFLAGS"
   fi
 fi
-
-if test -z "$CROSS_COMPILE"
+if test $iphone = false; then
+if test -z "$CROSS_COMPILE"
 then
 AC_CACHE_CHECK([whether we need extra options to link OpenSSL],
                tor_cv_openssl_linker_option, [
@@ -458,7 +465,7 @@
    LDFLAGS="$tor_cv_openssl_linker_option $LDFLAGS"
 fi
 fi
-
+fi
 dnl Make sure to enable support for large off_t if avalable.

 AC_SYS_LARGEFILE
@@ -584,7 +591,7 @@
 #ifdef HAVE_SYS_SOCKET_H
 #include &lt;sys/socket.h&gt;
 #endif])
-
+if test $iphone = false; then
 if test -z "$CROSS_COMPILE"; then
 AC_CACHE_CHECK([whether time_t is signed], tor_cv_time_t_signed, [
 AC_TRY_RUN([
@@ -610,6 +617,13 @@
   AC_DEFINE([TIME_T_IS_SIGNED], 1,
             [Define to 1 iff time_t is signed])
 fi
+fi
+
+if test $iphone = true; then
+  AC_DEFINE([TIME_T_IS_SIGNED], 1,
+            [Define to 1 iff time_t is signed])
+fi
+

 AC_CHECK_SIZEOF(socklen_t, , [AC_INCLUDES_DEFAULT()
 #ifdef HAVE_SYS_SOCKET_H
@@ -648,6 +662,11 @@
             [Define to 1 iff memset(0) sets pointers to NULL])
 fi

+if test $iphone = true; then
+  AC_DEFINE([NULL_REP_IS_ZERO_BYTES], 1,
+            [Define to 1 iff memset(0) sets pointers to NULL])
+fi
+
 # And what happens when we malloc zero?

 if test -z "$CROSS_COMPILE"; then
@@ -696,6 +715,11 @@
             [Define to 1 iff we represent negative integers with
two's complement])
 fi

+if test $iphone = true; then
+  AC_DEFINE([USING_TWOS_COMPLEMENT], 1,
+            [Define to 1 iff we represent negative integers with
two's complement])
+fi
+
 # Whether we should use the dmalloc memory allocation debugging library.
 AC_MSG_CHECKING(whether to use dmalloc (debug memory allocation library))
 AC_ARG_WITH(dmalloc,
diff -Nur tor-0.1.2.18/src/or/or.h tor-0.1.2.18n/src/or/or.h
--- tor-0.1.2.18/src/or/or.h	2007-10-14 19:06:52.000000000 +0800
+++ tor-0.1.2.18n/src/or/or.h	2007-12-17 17:16:23.000000000 +0800
@@ -80,7 +80,7 @@

 /** Upper bound on maximum simultaneous connections; can be lowered by
  * config file. */
-#if defined(CYGWIN) || defined(__CYGWIN__)
+#if defined(CYGWIN) || defined(__CYGWIN__) || (__IPHONE)
 /* http://archives.seul.org/or/talk/Aug-2006/msg00210.html */
 #define MAXCONNECTIONS 3200
 #else


-- 
This is Cjacker.
</body></email><email><emailId>20071220053141</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-12-20 05:31:41-0400</timestampReceived><subject>Re: Tor and privoxy had been ported to iphone and works very well.</subject><body>


On Mon, Dec 17, 2007 at 05:25:57PM +0800, cjacker huang wrote:
&gt; Hi, there,
&gt;    I just ported libevent, tor-0.1.2.18 and privoxy to iphone 1.1.1 fw.
&gt; and finished a iPhone app named iTor.app.

Hi!  Good work; I'd like to get this into the main Tor distribution as
soon as I can.  I have a couple of questions, though:

Q1: You seem to be defining two macros: __DARWIN_UNIX03 and __IPHONE.
I see that __DARWIN_UNIX03 is used in various header files.  But I
don't get any relevant hits searching for __IPHONE.  Does anything in
the system headers use it by that name, or should it be called
"IPHONE" instead?

&gt; these three definitions had been set to 1 by default:
&gt; 
&gt; USING_TWOS_COMPLEMENT
&gt; NULL_REP_IS_ZERO_BYTES
&gt; TIME_T_IS_SIGNED

Q2: Are you cross-compiling, or do these tests get run and then give a
result of false?  In other words, what goes wrong then these changes
aren't in?

(I'm trying to tell whether this is an iphone-specific issue or a more
general problem with cross-compiling.)

many thanks,
-- 
Nick
[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20071223080912</emailId><senderName>"cjacker huang"</senderName><senderEmail>cjacker@gmail.com</senderEmail><timestampReceived>2007-12-23 08:09:12-0400</timestampReceived><subject>Re: Tor and privoxy had been ported to iphone and works very well.</subject><body>

__IPHONE is just a flag I defined, actually It can be called IPHONE or
anything else.

diff -Nur tor-0.1.2.18/src/or/or.h tor-0.1.2.18n/src/or/or.h
--- tor-0.1.2.18/src/or/or.h	2007-10-14 19:06:52.000000000 +0800
+++ tor-0.1.2.18n/src/or/or.h	2007-12-17 17:16:23.000000000 +0800
@@ -80,7 +80,7 @@

 /** Upper bound on maximum simultaneous connections; can be lowered by
  * config file. */
-#if defined(CYGWIN) || defined(__CYGWIN__)
+#if defined(CYGWIN) || defined(__CYGWIN__) || (__IPHONE)
 /* http://archives.seul.org/or/talk/Aug-2006/msg00210.html */
 #define MAXCONNECTIONS 3200
 #else

As I test: the definition of MAXCONNECTIONS to 15000 is too large,
10000 should works.


for these:
USING_TWOS_COMPLEMENT
NULL_REP_IS_ZERO_BYTES
TIME_T_IS_SIGNED

Because I use cross compiling(under x86 linux), these tests during
configuration can not run directly, so I disable these tests in
configure file and set value directly in headers.

Actually, all we need to change it to set MAXCONNECTIONS to less than
10000 if we do a native compilation.
Since up to now, we can only generate iphone binary under Linux or Mac
OS X, these tests can not run and get results, So I add a workaround
here.


On Dec 20, 2007 1:31 PM, Nick Mathewson &lt;nickm@freehaven.net&gt; wrote:
&gt; On Mon, Dec 17, 2007 at 05:25:57PM +0800, cjacker huang wrote:
&gt; &gt; Hi, there,
&gt; &gt;    I just ported libevent, tor-0.1.2.18 and privoxy to iphone 1.1.1 fw.
&gt; &gt; and finished a iPhone app named iTor.app.
&gt;
&gt; Hi!  Good work; I'd like to get this into the main Tor distribution as
&gt; soon as I can.  I have a couple of questions, though:
&gt;
&gt; Q1: You seem to be defining two macros: __DARWIN_UNIX03 and __IPHONE.
&gt; I see that __DARWIN_UNIX03 is used in various header files.  But I
&gt; don't get any relevant hits searching for __IPHONE.  Does anything in
&gt; the system headers use it by that name, or should it be called
&gt; "IPHONE" instead?
&gt;
&gt; &gt; these three definitions had been set to 1 by default:
&gt; &gt;
&gt; &gt; USING_TWOS_COMPLEMENT
&gt; &gt; NULL_REP_IS_ZERO_BYTES
&gt; &gt; TIME_T_IS_SIGNED
&gt;
&gt; Q2: Are you cross-compiling, or do these tests get run and then give a
&gt; result of false?  In other words, what goes wrong then these changes
&gt; aren't in?
&gt;
&gt; (I'm trying to tell whether this is an iphone-specific issue or a more
&gt; general problem with cross-compiling.)
&gt;
&gt; many thanks,
&gt; --
&gt; Nick



-- 
This is Cjacker.
</body></email><email><emailId>20071223183252</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-12-23 18:32:52-0400</timestampReceived><subject>Re: Tor and privoxy had been ported to iphone and works very well.</subject><body>


On Sun, Dec 23, 2007 at 04:09:12PM +0800, cjacker huang wrote:
 [...]

Okay, I've checked in a version of your patch as r12946 in subversion
trunk.  If you can check out the subversion repository from
https://tor-svn.freehaven.net/svn/tor/trunk , could you let me know
whether it works for you?

(Instead of skipping the tests when running in iphone mode, I tried to
use autoconf's cross compilation support correctly, but I might have
messed up.)

Many thanks,
--=20
Nick


[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20071224085958</emailId><senderName>"cjacker huang"</senderName><senderEmail>cjacker@gmail.com</senderEmail><timestampReceived>2007-12-24 08:59:58-0400</timestampReceived><subject>Re: Tor and privoxy had been ported to iphone and works very well.</subject><body>

I had check it out.

use libevent-1.3d compiles with:
CFLAGS=-D__DARWIN_UNIX03 ./configure --host=arm-apple-darwin --disable-shared

I find that this is a typo  at line 34 in configure.in
It should be -D__DARWIN_UNIX03 instead of -D__DARWIN_UINX03

after that it had been compiled with:
./configure --host=arm-apple-darwin --enable-iphone

when I run it at iphone, get search result:

./tor
Dec 24 16:55:09.146 [notice] Tor v0.2.0.14-alpha-dev. This is
experimental software. Do not rely on it for strong anonymity.
(Running on Darwin iPhone1,1)
Dec 24 16:55:09.169 [notice] Initialized libevent version 1.3d using
method poll. Good.
Dec 24 16:55:09.170 [notice] Opening Socks listener on 127.0.0.1:9050
Dec 24 16:55:09.179 [warn] You are running Tor as root. You don't need
to, and you probably shouldn't.
Dec 24 16:55:21.464 [notice] I learned some more directory
information, but not enough to build a circuit: We have no
network-status consensus.
Dec 24 16:55:28.940 [notice] No current certificate known for
authority moria1; launching request.
Dec 24 16:55:28.941 [notice] No current certificate known for
authority tor26; launching request.
Dec 24 16:55:28.941 [notice] No current certificate known for
authority lefkada; launching request.
Dec 24 16:55:28.941 [notice] No current certificate known for
authority ides; launching request.
Dec 24 16:55:36.384 [err] Bug: connection.c:2943:
assert_connection_ok: Assertion conn-&gt;purpose &gt;= _DIR_PURPOSE_MIN
failed; aborting.
connection.c:2943 assert_connection_ok: Assertion conn-&gt;purpose &gt;=
_DIR_PURPOSE_MIN failed; aborting.
zsh: abort      ./tor

On Dec 24, 2007 2:32 AM, Nick Mathewson &lt;nickm@freehaven.net&gt; wrote:
&gt; On Sun, Dec 23, 2007 at 04:09:12PM +0800, cjacker huang wrote:
&gt;  [...]
&gt;
&gt; Okay, I've checked in a version of your patch as r12946 in subversion
&gt; trunk.  If you can check out the subversion repository from
&gt; https://tor-svn.freehaven.net/svn/tor/trunk , could you let me know
&gt; whether it works for you?
&gt;
&gt; (Instead of skipping the tests when running in iphone mode, I tried to
&gt; use autoconf's cross compilation support correctly, but I might have
&gt; messed up.)
&gt;
&gt; Many thanks,
&gt; --
&gt; Nick
&gt;
&gt;



-- 
This is Cjacker.
</body></email><email><emailId>20071207050645</emailId><senderName></senderName><senderEmail>phobos</senderEmail><timestampReceived>2007-12-07 05:06:45-0400</timestampReceived><subject>Re: win32 installer patch</subject><body>

On Tue, Dec 04, 2007 at 02:22:44AM -0600, arrakistor@gmail.com wrote 12K bytes in 353 lines about:

Steve,

Thanks for the updates to the tor-mingw.nsi.  I've updated trunk with
a few of the obvious things updated.  I need to test the rest and think
more about the changes.  Most of these seem to be style differences.
You clearly like functions vs. the simple layout we had before.  I'll
walk through this over the weekend.  Thanks.

-- 
Andrew
</body></email><email><emailId>20071207051718</emailId><senderName>Arrakis</senderName><senderEmail>arrakistor@gmail.com</senderEmail><timestampReceived>2007-12-07 05:17:18-0400</timestampReceived><subject>Re: win32 installer patch</subject><body>

Andrew,

 Yes, functions galore. The command line parameters at the bottom are the big
deal, the rest is all spit and polish. While I was at it I updated the look of
the installer to bring it out of 1998 and up to a respectable 2005. Thanks for
the push on implementation.

Steve
</body></email><email><emailId>20071203112427</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-12-03 11:24:27-0400</timestampReceived><subject>Re: [or-cvs] r12599: more progress on the geoip proposal  (tor/trunk/doc/spec/proposals)</subject><body>

On Thu, Nov 29, 2007 at 08:58:16PM +0000, Robert Hogan wrote:
&gt; &gt;Is it sufficient just to add a new GETINFO command?
&gt; &gt;    GETINFO ip-to-country/128.31.0.34
&gt; &gt;  250+ip-to-country/128.31.0.34="US","USA","UNITED STATES"
&gt; 
&gt; Other commands that would be useful:

Speaking of which, I hear that Tork lets users specify entry / exit by
country. Can you describe how this works? (What the interface for the
user is, how Tork obtains the geoip data and how much it can be trusted
and what attacks exist, what part of the the controller interface it uses
with tor, any issues you ran into it adding it, whether the geoip proposal
I've been working on would complement it or force a redesign, etc?)

Thanks!
--Roger

</body></email><email><emailId>20071203211632</emailId><senderName>Robert Hogan</senderName><senderEmail>robert@roberthogan.net</senderEmail><timestampReceived>2007-12-03 21:16:32-0400</timestampReceived><subject>Re: [or-cvs] r12599: more progress on the geoip proposal  (tor/trunk/doc/spec/proposals)</subject><body>


On Monday 03 December 2007 11:24:27 you wrote:
&gt; On Thu, Nov 29, 2007 at 08:58:16PM +0000, Robert Hogan wrote:
&gt; &gt; &gt;Is it sufficient just to add a new GETINFO command?
&gt; &gt; &gt;    GETINFO ip-to-country/128.31.0.34
&gt; &gt; &gt;  250+ip-to-country/128.31.0.34="US","USA","UNITED STATES"
&gt; &gt;
&gt; &gt; Other commands that would be useful:
&gt;
&gt; Speaking of which, I hear that Tork lets users specify entry / exit by
&gt; country. 

Only exit by country.

&gt; Can you describe how this works? (What the interface for the 
&gt; user is, 

http://roberthogan.net/images/preferredexits.jpg
http://roberthogan.net/images/selectingservers.jpg
http://roberthogan.net/images/excludeexits.jpg

 The user can prefer/exclude servers from the network server list (the list 
can be filtered in multiple ways to allow easy selection of multiple servers 
at a time). 

There's also a pseudonymous browsing button ('Citizen of') which allows you to 
select the country you would like to 'browse from'. TorK then tells tor to 
only use exits from that country.

&gt; how Tork obtains the geoip data and how much it can be trusted 

The geoip data is bundled with tork. There's no mechanism for updating it 
currently, but i do refresh it between releases. Tork uses the geoip country 
db only. It seems to be fairly reliable - I've never noticed a whois on a 
server entry contradict the server's flag, for what that's worth. The older 
the database the more 'unknown' servers you get - TorK indicates these with a 
question mark icon.

&gt; and what attacks exist, 

I wonder .. ;-)

&gt; what part of the the controller interface it uses with tor,

exitnodes, strictexitnodes, exludenodes, strictexcludenodes

&gt;  any issues you ran into it adding it, 

the most annoying thing is having to manage references to the fp's everywhere. 
I haven't done this elegantly but it appears to be reliable. overall it was 
quite a straightforward feature to add.


&gt; whether the geoip proposal 
&gt; I've been working on would complement it or force a redesign, etc?)
complement, I would say!


&gt;
&gt; Thanks!
&gt; --Roger



["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20071203214613</emailId><senderName>Robert Hogan</senderName><senderEmail>robert@roberthogan.net</senderEmail><timestampReceived>2007-12-03 21:46:13-0400</timestampReceived><subject>Re: [or-cvs] r12599: more progress on the geoip proposal  (tor/trunk/doc/spec/proposals)</subject><body>


On Friday 30 November 2007 08:13:18 you wrote:

&gt;
&gt; &gt; 2. setconf  ExcludeCountryCodes
&gt; &gt; 3. setconf IncludeCountryCodes
&gt;
&gt; Hm. Most people I've talked to care about the position in the path too --
&gt; they don't just want to skip a given country entirely, they want to only
&gt; skip it at the beginning, or the end, or something like that.
&gt;
&gt; And what would IncludeCountryCodes do? Only use relays from those
&gt; countries in all positions in the circuit?

Yes, a bit half-baked. Disengaging gently from auto-pilot:

ExcludeExitCountryCodes US,DE

StrictExitCountryCodes 1|0
ExitCountryCodes US,DE

EntryCountryCodes US,DE
StrictEntryCountryCodes 1|0

# For non-entry and non-exit servers
RelayCountryCodes US,DE
StrictRelayCountryCodes 1|0

So that the user can see what servers are being excluded by these choices:

getinfo servers/[countrycode] - giving network-statuses
getinfo names/countrycode - giving an fp list maybe.
um, that's it.

&gt;
&gt; &gt;
&gt; &gt; @downloaded-at 2007-11-29 19:45:13
&gt; &gt; @source "86.59.21.38"
&gt; &gt; @geoip US Boston X-ordinate Y-ordinate
&gt;
&gt; The "router annotations" you describe here are added locally by the Tor
&gt; that receives the router descriptor. They're not published in any signed
&gt; way. If we were to add the countrycode into the server descriptor, then
&gt; we would have to trust the server to write the correct countrycode into
&gt; his signed descriptor, and if we decided he was lying our only recourse
&gt; would be to not list that descriptor.
&gt;
&gt; If we want to provide the countrycode info for each router, signed by
&gt; authorities, we could put it into that router's entry in the networkstatus
&gt; consensus -- that's my "Option B" in Section 4.2.
&gt;

Ah. Whoops.

&gt; But I'm still not very happy about putting it in the networkstatus,
&gt; since the IP to GeoIP mapping will be relatively static, so we'll be
&gt; wasting a lot of bandwidth as caches mirror redundant information,
&gt; and as clients fetch information they already know.
&gt;
This is the definiitely the big downside with centralizing the geoip data to 
the authorities. 

That said, tt would be just an extra three bytes per status (including the 
space) if you were  to provide country code, roughly 4-5K at current volumes. 
If country code is enough for the near future then this might be the way to 
go. The x-y co-ordinates could then be an opt field in the network-status 
document, if a client needs them.

Again imvho the merits/demerits of centralizing come down to whether country 
code is enough in the immediate future for the feature's goal - if it is then 
the security advantages [reduced partitioning opportunities] of keeping it to 
the authorities may outweigh the small(?) bw penalty it incurs.

Given that bw is something to conserve, perhaps a few wasteful bytes from the 
network-status could be removed for 0.2, e.g.. the '-'  and ':' in the date 
and time stamps. Maybe the status flags could be abbreviated? These two alone 
would make enough room for country code and co-ordinates! ;-) I know what a 
hack that would be to code around, but...

 
&gt; Since most of the answers won't change from hour to hour, the obvious
&gt; solution is to only ask questions about the ones you don't already know
&gt; the answer to -- which is exactly what Vidalia already does.
&gt;
&gt; But I haven't thought of a better way yet. Perhaps we'll have found one
&gt; by the time we get around to switching from "Option A" to "Option B". :)
&gt;
&gt; Thanks,
&gt; --Roger



["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20071106232114</emailId><senderName>Steven Murdoch</senderName><senderEmail>tor+steven.murdoch@cl.cam.ac.uk</senderEmail><timestampReceived>2007-11-06 23:21:14-0400</timestampReceived><subject>Re: Proposal for revised TLS handshake</subject><body>


On Tue, Nov 06, 2007 at 10:41:13PM +0000, Steven Murdoch wrote:
&gt; The draft proposal of the protocol and other issues can be found at:
&gt; 
&gt;  http://www.cl.cam.ac.uk/~sjm217/volatile/xxx-tls-certificates.txt

For those of you who read email off-line, it might help to have the
entire content, rather than just a URL:

----
Filename: xxx-tls-certificates.txt
Title: Blocking resistant TLS certificate usage
Version: $Revision: XXX $
Last-Modified: $Date: XXX $
Author: Steven J. Murdoch
Created: 2007-10-25
Status: Needs-Revision

Overview:

  To be less distinguishable from HTTPS web browsing, only Tor servers should
  present TLS certificates. This should be done whilst maintaining backwards
  compatibility with Tor nodes which present and expect client certificates, and
  while preserving existing security properties. This specification describes
  the negotiation protocol, what certificates should be presented during the TLS
  negotiation, and how to move the client authentication within the encrypted
  tunnel.

Motivation:

  In Tor's current TLS [1] handshake, both client and server present a
  two-certificate chain. Since TLS performs authentication prior to establishing
  the encrypted tunnel, the contents of these certificates are visible to an
  eavesdropper. In contrast, during normal HTTPS web browsing, the server
  presents a single certificate, signed by a root CA and the client presents no
  certificate. Hence it is possible to distinguish Tor from HTTP by identifying
  this pattern.

  To resist blocking based on traffic identification, Tor should behave as close
  to HTTPS as possible, i.e. servers should offer a single certificate and not
  request a client certificate; clients should present no certificate. This
  presents two difficulties: clients are no longer authenticated and servers are
  authenticated by the connection key, rather than identity key. The link
  protocol must thus be modified to preserve the old security semantics.

  Finally, in order to maintain backwards compatibility, servers must correctly
  identify whether the client supports the modified certificate handling. This
  is achieved by modifying the cipher suites that clients advertise support
  for. These cipher suites are selected to be similar to those chosen by web
  browsers, in order to resist blocking based on client hello.

Terminology:

  Initiator: OP or OR which initiates a TLS connection ("client" in TLS
   terminology)
  
  Responder: OR which receives an incoming TLS connection ("server" in TLS
   terminology) 

Version negotiation and cipher suite selection:

  In the modified TLS handshake, the responder does not request a certificate
  from the initiator. This request would normally occur immediately after the
  responder receives the client hello (the first message in a TLS handshake) and
  so the responder must decide whether to request a certificate based only on
  the information in the client hello. This is achieved by examining the cipher
  suites in the client hello.

   List 1: cipher suites lists offered by version 0/1 Tor

   From src/common/tortls.c, revision 12086:
    TLS1_TXT_DHE_RSA_WITH_AES_128_SHA 
    TLS1_TXT_DHE_RSA_WITH_AES_128_SHA : SSL3_TXT_EDH_RSA_DES_192_CBC3_SHA
    SSL3_TXT_EDH_RSA_DES_192_CBC3_SHA

 Client hello sent by initiator:

  Initiators supporting version 2 of the Tor connection protocol MUST
  offer a different cipher suite list from those sent by pre-version 2
  Tors, contained in List 1. To maintain compatibility with older Tor
  versions and common browsers, the cipher suite list MUST include
  support for:

   TLS_DHE_RSA_WITH_AES_256_CBC_SHA
   TLS_DHE_RSA_WITH_AES_128_CBC_SHA
   SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA
   SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA

 Client hello received by responder/server hello sent by responder:

  Responders supporting version 2 of the Tor connection protocol should compare
  the cipher suite list in the client hello with those in List 1. If it matches
  any in the list then the responder should assume that the initiatior supports
  version 1, and should thus should maintain the version 1 behavior, i.e. send a
  two-certificate chain, request a client certificate and do not send or expect
  a VERSIONS cell [2].

  Otherwise, the responder should assume version 2 behavior and select a cipher
  suite following TLS [1] behavior, i.e. select the first entry from the client
  hello cipher list which is acceptable. Responders MUST NOT select any suite
  that lacks ephemeral keys, or whose symmetric keys are less then KEY_LEN bits,
  or whose digests are less than HASH_LEN bits. Implementations SHOULD NOT
  allow other SSLv3 ciphersuites. 

  Should no mutually acceptable cipher suite be found, the connection MUST be
  closed.

  If the responder is implementing version 2 of the connection protocol it
  SHOULD send a server certificate with random contents. The organizationName
  field MUST NOT be "Tor", "TOR" or "t o r".

 Server certificate received by initiator:

  If the server certificate has an organizationName of "Tor", "TOR" or "t o r",
  the initiator should assume that the responder does not support version 2 of
  the connection protocol. In which case the initiator should respond following
  version 1, i.e. send a two-certificate client chain and do not send or expect
  a VERSIONS cell.

  [SJM: We could also use the fact that a client certificate request was sent]
  
  If the server hello contains a ciphersuite which does not comply with the key
  length requirements above, even if it was one offered in the client hello, the
  connection MUST be closed. This will only occur if the responder is not a Tor
  server.

 Backward compatibility:

  v1 Initiator, v1 Responder: No change
  v1 Initiator, v2 Responder: Responder detects v1 initiator by client hello
  v2 Initiator, v1 Responder: Responder accepts v2 client hello. Initiator
   detects v1 server certificate and continues with v1 protocol
  v2 Initiator, v2 Responder: Responder accepts v2 client hello. Initiator
   detects v2 server certificate and continues with v2 protocol.

 Additional link authentication process:

  Following VERSION and NETINFO negotiation, both responder and
  initiator MUST send a certification chain in a CERT cell. If one
  party does not have a certificate, the CERT cell MUST still be sent,
  but with a length of zero.

  A CERT cell is a variable length cell, of the format
        CircID                                [2 bytes]
        Command                               [1 byte]
        Length                                [2 bytes]
        Payload                               [&lt;length&gt; bytes]

  CircID MUST set to be 0x0000
  Command is [SJM: TODO]
  Length is the length of the payload
  Payload contains 0 or more certificates, each is of the format:
        Cert_Length  [2 bytes]
        Certificate  [&lt;cert_length&gt; bytes]

  Each certificate MUST sign the one prececeding it. The initator MUST
  place its connection certificate first; the responder, having
  already sent its connection certificate as part of the TLS handshake
  MUST place its identity certificate first.

  Initiators who send a CERT cell MUST follow that with an LINK_AUTH
  cell to prove that they posess the corresponding private key.  

  A LINK_AUTH cell is fixed-lenth, of the format:
         CircID                                [2 bytes]
         Command                               [1 byte]
         Length                                [2 bytes]
         Payload (padded with 0 bytes)         [PAYLOAD_LEN - 2 bytes]

  CircID MUST set to be 0x0000
  Command is [SJM: TODO]
  Length is the valid portion of the payload
  Payload is of the format:
         Signature version                     [1 byte]
         Signature                             [&lt;length&gt; - 1 bytes]
         Padding                               [PAYLOAD_LEN - &lt;length&gt; - 2 bytes]

  Signature version: Identifies the type of signature, currently 0x00
  Signature: Digital signature under the initiator's connection key of the
   following item, in PKCS #1 block type 1 [3] format:

    HMAC-SHA1, using the TLS master secret as key, of the
    following elements concatenated:
     - The signature version (0x00)
     - The NUL terminated ASCII string: "Tor initiator certificate verification"
     - client_random, as sent in the Client Hello
     - server_random, as sent in the Server Hello
     - SHA-1 hash of the initiator connection certificate
     - SHA-1 hash of the responder connection certificate

  Security checks:

    - Before sending a LINK_AUTH cell, a node MUST ensure that the TLS
      connection is authenticated by the responder key.
    - For the handshake to have succeeded, the initiator MUST confirm:
       - That the TLS handshake was authenticated by the 
         responder connection key
       - That the responder connection key was signed by the first
         certificate in the CERT cell
       - That each certificate in the CERT cell was signed by the
         following certificate, with the exception of the last
       - That the last certificate in the CERT cell is the expected
         identity certificate for the node being connected to
    - For the handshake to have succeeded, the responder MUST confirm
      either:
       A) - A zero length CERT cell was sent and no LINK_AUTH cell was
            sent
          In which case the responder shall treat the identity of the
          initiator as unknown
        or
       B) - That the LINK_AUTH MAC contains a signature by the first
            certificate in the CERT cell
          - That the MAC signed matches the expected value
          - That each certificate in the CERT cell was signed by the
            following certificate, with the exception of the last
          In which case the responder shall treat the identity of the
          initiator as that of the last certificate in the CERT cell

  Protocol summary:

  1. I(nitiator) &lt;-&gt; R(esponder): TLS handshake, including responder
                               authentication under connection certificate R_c
  2. I &lt;-&gt;: VERSION and NETINFO negotiation
  3. R -&gt; I: CERT (Responder identity certificate R_i (which signs R_c))
  4. I -&gt; R: CERT (Initiator connection certificate I_c, 
                   Initiator identity certificate I_i (which signs I_c)
  5. I -&gt; R: LINK_AUTH (Signature, under I_c of HMAC-SHA1(master_secret,
                    "Tor initiator certificate verification" ||
                    client_random || server_random ||
                    I_c hash || R_c hash)

  Notes: I -&gt; R doesn't need to wait for R_i before sending its own
   messages (reduces round-trips).
   Certificate hash is calculated like identity hash in CREATE cells.
   Initiator signature is calculated in a similar way to Certificate
   Verify messages in TLS 1.1 (RFC4346, Sections 7.4.8 and 4.7).
   If I is an OP, a zero length certificate chain may be sent in step 4;
   In which case, step 5 is not performed

  Rationale: 

  - Version and netinfo negotiation before authentication: The version cell needs
   to come before before the rest of the protocol, since we may choose to alter
   the rest at some later point, e.g switch to a different MAC/signature scheme.
   It is useful to keep the NETINFO and VERSION cells close to each other, since
   the time between them is used to check if there is a delay-attack. Still, a
   server might want to not act on NETINFO data from an initiator until the
   authentication is complete.

Appendix A: Cipher suite choices

  This specification intentionally does not put any constraints on the
  TLS ciphersuite lists presented by clients, other than a minimum
  required for compatibility. However, to maximize blocking
  resistance, ciphersuite lists should be carefully selected.

   Recommended client ciphersuite list

     Source: http://lxr.mozilla.org/security/source/security/nss/lib/ssl/sslproto.h

     0xc00a: TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA  
     0xc014: TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA 
     0x0039: TLS_DHE_RSA_WITH_AES_256_CBC_SHA 
     0x0038: TLS_DHE_DSS_WITH_AES_256_CBC_SHA
     0xc00f: TLS_ECDH_RSA_WITH_AES_256_CBC_SHA 
     0xc005: TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA 
     0x0035: TLS_RSA_WITH_AES_256_CBC_SHA
     0xc007: TLS_ECDHE_ECDSA_WITH_RC4_128_SHA 
     0xc009: TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA 
     0xc011: TLS_ECDHE_RSA_WITH_RC4_128_SHA
     0xc013: TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA 
     0x0033: TLS_DHE_RSA_WITH_AES_128_CBC_SHA 
     0x0032: TLS_DHE_DSS_WITH_AES_128_CBC_SHA 
     0xc00c: TLS_ECDH_RSA_WITH_RC4_128_SHA
     0xc00e: TLS_ECDH_RSA_WITH_AES_128_CBC_SHA
     0xc002: TLS_ECDH_ECDSA_WITH_RC4_128_SHA  
     0xc004: TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA 
     0x0004: SSL_RSA_WITH_RC4_128_MD5 
     0x0005: SSL_RSA_WITH_RC4_128_SHA 
     0x002f: TLS_RSA_WITH_AES_128_CBC_SHA 
     0xc008: TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA 
     0xc012: TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA
     0x0016: SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA  
     0x0013: SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA 
     0xc00d: TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA 
     0xc003: TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA
     0xfeff: SSL_RSA_FIPS_WITH_3DES_EDE_CBC_SHA (168-bit Triple DES with RSA and a SHA1 MAC)
     0x000a: SSL_RSA_WITH_3DES_EDE_CBC_SHA 

     Order specified in:
      http://lxr.mozilla.org/security/source/security/nss/lib/ssl/sslenum.c#47

   Recommended options:
      0x0000: Server Name Indication [4]
      0x000a: Supported Elliptic Curves [5]
      0x000b: Supported Point Formats [5]

   Recommended compression:
      0x00

   Recommended server ciphersuite selection:

     The responder should select the first entry in this list which is
     listed in the client hello:

     0x0039: TLS_DHE_RSA_WITH_AES_256_CBC_SHA  [ Common Firefox choice ]
     0x0033: TLS_DHE_RSA_WITH_AES_128_CBC_SHA  [ Tor v1 default ] 
     0x0016: SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA [ Tor v1 fallback ]
     0x0013: SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA [ Valid IE option ]

References:

[1] The Transport Layer Security (TLS) Protocol, Version 1.1, RFC4346, IETF

[2] Version negotiation for the Tor protocol, Tor proposal 105

[3] B. Kaliski, "Public-Key Cryptography Standards (PKCS) #1:
    RSA Cryptography Specifications Version 1.5", RFC 2313,
    March 1998.

[4] TLS Extensions, RFC 3546

[5] Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS)

% &lt;!-- Local IspellDict: american --&gt;
----

-- 
w: http://www.cl.cam.ac.uk/users/sjm217/

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20071118091151</emailId><senderName>Robert Hogan</senderName><senderEmail>robert@roberthogan.net</senderEmail><timestampReceived>2007-11-18 09:11:51-0400</timestampReceived><subject>Re: Lock Control Port</subject><body>


On Sunday 14 October 2007 01:27:58 you wrote:
&gt; On Saturday 13 October 2007 21:27:01 Roger Dingledine wrote:
&gt; &gt; On Sat, Oct 13, 2007 at 10:50:16AM +0100, Robert Hogan wrote:
&gt; &gt; &gt; While we're all still 'getting there', controllers could have the
&gt; &gt; &gt; option of locking the control port if no auth mechanism is enabled, and
&gt; &gt; &gt; even when it is. Given that users tend not to share installations and
&gt; &gt; &gt; most run their controller concurrently with tor at all times this would
&gt; &gt; &gt; be a useful fallback measure.
&gt; &gt;
&gt; &gt; Why not have your controller enable authentication when it connects and
&gt; &gt; doesn't like what it finds? If you want, you can then disable it when
&gt; &gt; you disconnect.
&gt; &gt;
&gt; &gt; This approach would seem to have all the same properties of your
&gt; &gt; lock/unlock without any new commands or code.
&gt;
&gt; Duh. Don't know where I was going with that one.

On second thoughts,  it might be a useful default behaviour to lock the 
control port automatically whenever an unauthenticated connection is made. 
The active controller could then choose to unlock the port once connected.

I can't think of a use-case for more than one simultaneous connection to the 
control port, so even if implicit locking is a bit extreme it might be a good 
idea to notify current control port users when someone else creates a new 
control session, regardless of authentication. It would also be useful to 
learn of any other active control sessions when you first connect. 

The problem with using a random password to 'lock' the control port is that 
the genuine user is locked out if their control session disconnects 
unexpectedly. Of course this shouldn't happen but ...


["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20071125232220</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-11-25 23:22:20-0400</timestampReceived><subject>Re: Revised TSL handshake proposal question</subject><body>

On Wed, Nov 21, 2007 at 07:30:22AM +0100, Lucky Green wrote:
&gt; SSLv3 and TLS permit either the client or the server to request an SSL 
&gt; renegotiation. The content of the renegotiation and any certificates 
&gt; exchanged during the renegotiation are encrypted using the SSL connection 
&gt; that was previously established.

Very interesting.

&gt; This means that an SSL renegotiation permits the client to present an SSL 
&gt; client cert to the server inside the initial SSL encrypted connection. Not 
&gt; revealing the client cert to an observer was very much one of the use 
&gt; cases considered during the initial SSLv3 and later TLS specification 
&gt; efforts. The idea at the time was that clients may store a great many 
&gt; certificates, one for each services they wish to access. For example, a 
&gt; website portal containing health education information may offer a number 
&gt; of forums, one for those suffering from cancer, another for those 
&gt; suffering from AIDS. Each using a client cert rather than UID/PW to access 
&gt; the forum. You wouldn't want the observer to be able to determine which 
&gt; particular forum a visitor is logging into or that they are logging into a 
&gt; forum at all.

Does the SSL connection prevent an observer from learning the fact that a
renegotiation is taking place? (that is, an observer who does filtering
on payloads -- an observer who does timing attacks is probably in fine
shape against Tor, as you note)

I would hope that it does, but your summary above doesn't include that.

&gt; While client certificates have not yet become as ubiquitous as was 
&gt; considered possible during the SSLv3 specification days with individual 
&gt; users potentially holding hundreds of certificates, the ability to request 
&gt; a renegotiation of an SSL session to step up from a server authenticated 
&gt; to a client authenticated connection is built into every major SSL/TLS 
&gt; implementation, including OpenSSL.

That's very useful -- we've been wondering how much compatibility we
would break in other crypto libs by proposal 124.

Of course, we still need to fake some Firefox ciphers in the initial
handshake, and that appears to be not supported well by OpenSSL, and is
probably not supported well by other crypto libs too. So be it.

&gt; With this in mind, it is not clear to me which security properties the 
&gt; proposal will give you that you cannot natively obtain from TLS.

Right. Steven pointed out that we waste bandwidth by sending a duplicate
server-side cert during the renegotiation. But I think that's a small
price to pay for the simplified design.

&gt; I of course recognize that an observer may be able to determine from 
&gt; watching the number of encrypted bits exchanged that the encrypted SSL 
&gt; connection likely contains an SSL renegotiation payload. Alas, there are 
&gt; many aspects of Tor that would permit for protocol identification based on 
&gt; traffic analysis.
&gt; 
&gt; You may wish to consider using TLS-native capabilities to obscure the 
&gt; client certificate exchange by using SSL renegotiation instead.

Agreed. Thanks for helping us catch this before we'd gone too far.

--Roger

</body></email><email><emailId>20071126022457</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-11-26 02:24:57-0400</timestampReceived><subject>Re: bug with entry guards on 0.2.0.9-alpha</subject><body>

On Mon, Nov 19, 2007 at 08:14:27PM -0800, tor user wrote:
&gt; I think I've found a bug with entry guard selection
&gt; starting with 0.2.0.9-alpha. The problem first appears
&gt; after revision 12038. 
&gt; 
&gt; After poking at it a bit, starting with a clean ~/.tor
&gt; directory, it turned out that every time tor was
&gt; started, it would pick out more guards and add them.

Thanks for the bug report. You're right.

I've fixed this in
http://archives.seul.org/or/cvs/Nov-2007/msg00265.html

It also fixes bug 448:
http://bugs.noreply.org/flyspray/index.php?do=details&amp;id=448

Thanks!
--Roger

</body></email><email><emailId>20071128032544</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-11-28 03:25:44-0400</timestampReceived><subject>Re: FEATURE IDEA: Hidden Directory Authorities</subject><body>

On Mon, Nov 19, 2007 at 12:29:53AM -0800, Kyle Williams wrote:
&gt; I know that Tor has the PrivateDir option, which uses an Onion Router
&gt; to make the request to the DA to retrieve updated cached-* documents.
&gt; However, this option will not
&gt; function without a pre-cached copy of the cached-routers documents
&gt; because it wouldn't know of an Onion Routers to tunnel the request
&gt; through.
&gt; Basically you need a pre-cached copy of cached-routers for PrivateDir
&gt; to work, right?
&gt; (Please correct me if I am wrong here.)

Right.

Actually, the config option is called __AllDirActionsPrivate. The "__"
at the front means that it's a config option that's meant to be settable
by the Tor controller -- it assumes the controller is using an alternate
mechanism for bootstrapping. It also means that when the controller
issues a 'saveconf' command, that config option doesn't get saved.

&gt; So the questions that entered my mind were:
&gt; * Could Directory Authorities use an .onion address instead of an IP
&gt; address if a pre-cached copy of cached-routers was distributed with
&gt; the initial download of Tor?

Yes, in theory this would work.

&gt; * Would this make the Directory Authorities more resistant to digital
&gt; &amp; physical attack?

Yes, against a weak attacker. Against a stronger attacker, my impression
is that hidden services are less secure than normal Tor circuits. This is
because the hidden service stays in one place and makes an ever-growing
pile of hints for the attacker. Entry guards help but don't totally
resolve the issue. But as usual, more research remains. :)

&gt; * Are "guard" nodes[2] the same as "valet" nodes[1]?
&gt; The wording of "guard" nodes [2] sounds very similar to the concept of
&gt; "valet" nodes [1], but I'm not quite sure if these are the same.  Are
&gt; they?

&gt; [1] Making Anonymous Communications
&gt; ( http://www.onion-router.net/Publications/Briefing-2004.pdf )
&gt; [2] Locating Hidden Servers
&gt; ( http://www.onion-router.net/Publications/locating-hidden-servers.pdf )

No, they're different. Btw, for your [1], you should actually be
looking at http://freehaven.net/anonbib/#valet:pet2006

&gt; Since the DAs would be the most logical place for an attacker to DoS
&gt; or attack, I was thinking that it would make sense if the DAs couldn't
&gt; be found physically or by IP.
&gt; To start a network, I was think of using 3 DAs with 8 nodes.  The
&gt; nodes would act as rendezvous points, introduction points, valet/guard
&gt; points, entry, middle, and exit nodes.
&gt; If the DAs .onion information and 8 startup nodes information was
&gt; pre-cached when Tor is download, would that be enough to keep the DA's
&gt; hidden?

You would effectively still be limited by the robustness of those
8 nodes. If you're fine with that, why not make all 8 of them into
directory authorities?

&gt; Now the big question.  What type of attacks would this be prone to?
&gt; After reading [2], it became clear that someone could attack
&gt; Introduction Points to reveal the true location of the hidden service.
&gt;  But the 'valet' (or 'guard'?) node design model would significantly
&gt; help reduce the probability of this attack being successful.

Last I checked, the valet design needed more thinking before I was
convinced it would work well in practice. For one, somebody needs to
take it from the 'research paper' phase to the 'spec proposal' phase.

&gt;  So, if
&gt; the DA's are acting as a hidden service, in theory, Introduction and
&gt; Valet Points wouldn't be able to distinguish regular hidden services
&gt; from the DA's hidden service.
&gt; 
&gt; I know that by hiding the DA's, every downloaded package of Tor would
&gt; have to contain an up-to-date copy of the cached-routers.  Could a
&gt; "cached-onions" file be introduced into the design to make it clear
&gt; which are Onion Routers and which are Hidden Services?

I don't follow.

Also, note that not all "main" directory authorities need to be hidden
service directory authorities, and vice versa.

Hope that helps,
--Roger

</body></email><email><emailId>20071129150025</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-11-29 15:00:25-0400</timestampReceived><subject>Re: bridge and bridge authority proposal</subject><body>

On Thu, Nov 29, 2007 at 09:27:42AM -0500, Roger Dingledine wrote:
&gt; But! There is a problem. See Section 1.4 of dir-spec.txt. There is a
[snip]
&gt; We could also make it 3/4 and 1/4, for better fairness. But this still
&gt; raises the issue that over time we can distinguish a Tor client that
&gt; never asks in the last fraction of the interval. Does this mean that
&gt; *all* clients should fetch in only the first fraction of the interval,
&gt; to hide whether they're using this more aggressive schedule?

Just to move the discussion along, here's my preference: we should
make all ordinary clients fetch the consensus in the first 90% of the
available client interval. Then subclients should fetch it in the last
10% of the available client interval.

Thus we don't get into the issue of using no-longer-valid consensus
documents, and we avoid the all-bridge-users-download-at-once issue
that might come up if a bridge happens to attract many users and they
all download at exactly the cutoff.

Then Tor would decide if it's a "normal" client or a "sub" client based
on the UseBridges config option, and/or on some later config option we
add if we need one particularly for this purpose.

The values of "90" and "10" are fuzzy, of course.

--Roger

</body></email><email><emailId>20071130081318</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-11-30 08:13:18-0400</timestampReceived><subject>Re: [or-cvs] r12599: more progress on the geoip proposal  (tor/trunk/doc/spec/proposals)</subject><body>

For those following along at home, we're discussing my in-progress
draft at
https://www.torproject.org/svn/trunk/doc/spec/proposals/126-geoip-reporting.txt

On Thu, Nov 29, 2007 at 08:58:16PM +0000, Robert Hogan wrote:
&gt; &gt;Is it sufficient just to add a new GETINFO command?
&gt; &gt;    GETINFO ip-to-country/128.31.0.34
&gt; &gt;  250+ip-to-country/128.31.0.34="US","USA","UNITED STATES"
&gt; 
&gt; Other commands that would be useful:
&gt; 
&gt; 1. 'getinfo servers/[COUNTRYCODE]' giving a list of servers with that 
&gt; countrycode

True. I guess it depends how much work we want to do inside Tor vs how
much we want to expect the controller to do. If we offer this, don't we
also want to offer getinfo countrycode/names and other options like this?
We could instead just let the controller do a lookup on each server it
cares about, and keep its own lists.

&gt; 2. setconf  ExcludeCountryCodes
&gt; 3. setconf IncludeCountryCodes

Hm. Most people I've talked to care about the position in the path too --
they don't just want to skip a given country entirely, they want to only
skip it at the beginning, or the end, or something like that.

And what would IncludeCountryCodes do? Only use relays from those
countries in all positions in the circuit? 

&gt; But why not absorb the countrycode into the server descriptor and have it 
&gt; assigned by the authorities?
&gt; 
&gt; This would:
&gt; 
&gt; - prevent possible partitioning attacks arising from different versions of the 
&gt; geoip db floating around (if bootstrap versions are supplied).
&gt; - save bandwidth (the db would be shared by authorities only)
&gt; - save client/relay processing power
&gt; 
&gt; Something like:
&gt; 
&gt; @downloaded-at 2007-11-29 19:45:13
&gt; @source "86.59.21.38"
&gt; @geoip US Boston X-ordinate Y-ordinate

The "router annotations" you describe here are added locally by the Tor
that receives the router descriptor. They're not published in any signed
way. If we were to add the countrycode into the server descriptor, then
we would have to trust the server to write the correct countrycode into
his signed descriptor, and if we decided he was lying our only recourse
would be to not list that descriptor.

If we want to provide the countrycode info for each router, signed by
authorities, we could put it into that router's entry in the networkstatus
consensus -- that's my "Option B" in Section 4.2.

But I'm still not very happy about putting it in the networkstatus,
since the IP to GeoIP mapping will be relatively static, so we'll be
wasting a lot of bandwidth as caches mirror redundant information,
and as clients fetch information they already know.

Since most of the answers won't change from hour to hour, the obvious
solution is to only ask questions about the ones you don't already know
the answer to -- which is exactly what Vidalia already does.

But I haven't thought of a better way yet. Perhaps we'll have found one
by the time we get around to switching from "Option A" to "Option B". :)

Thanks,
--Roger

</body></email><email><emailId>20071121063022</emailId><senderName>Lucky Green</senderName><senderEmail>shamrock@cypherpunks.to</senderEmail><timestampReceived>2007-11-21 06:30:22-0400</timestampReceived><subject>Revised TSL handshake proposal question</subject><body>

Folks,
I read Steven.s proposal to change the Tor SSL handshake at 
https://www.torproject.org/svn/trunk/doc/spec/proposals/124-tls-certificates.txt

If I understand the preamble correctly, the goal of this proposal is to 
solve the following problem:

- common https connections only involve presentation of an SSL server 
cert.
- https connections that use client certificates are relatively rare.
- Tor authenticates both sides of the SSL connection using both server and 
client certificates.
- A passive observer can therefore distinguish common https traffic from 
Tor traffic by watching for a client cert being presented in the initial 
SSL handshake.

It is therefore desirable to present the client cert after the initial 
SSL-encrypted tunnel only using a server cert has been established. The 
spec proposes a method to implement such capability.

If I misunderstand the goals of this proposal, you may ignore the 
remainder of this post.

SSLv3 and TLS permit either the client or the server to request an SSL 
renegotiation. The content of the renegotiation and any certificates 
exchanged during the renegotiation are encrypted using the SSL connection 
that was previously established.

This means that an SSL renegotiation permits the client to present an SSL 
client cert to the server inside the initial SSL encrypted connection. Not 
revealing the client cert to an observer was very much one of the use 
cases considered during the initial SSLv3 and later TLS specification 
efforts. The idea at the time was that clients may store a great many 
certificates, one for each services they wish to access. For example, a 
website portal containing health education information may offer a number 
of forums, one for those suffering from cancer, another for those 
suffering from AIDS. Each using a client cert rather than UID/PW to access 
the forum. You wouldn't want the observer to be able to determine which 
particular forum a visitor is logging into or that they are logging into a 
forum at all.

While client certificates have not yet become as ubiquitous as was 
considered possible during the SSLv3 specification days with individual 
users potentially holding hundreds of certificates, the ability to request 
a renegotiation of an SSL session to step up from a server authenticated 
to a client authenticated connection is built into every major SSL/TLS 
implementation, including OpenSSL.

With this in mind, it is not clear to me which security properties the 
proposal will give you that you cannot natively obtain from TLS.

I of course recognize that an observer may be able to determine from 
watching the number of encrypted bits exchanged that the encrypted SSL 
connection likely contains an SSL renegotiation payload. Alas, there are 
many aspects of Tor that would permit for protocol identification based on 
traffic analysis.

You may wish to consider using TLS-native capabilities to obscure the 
client certificate exchange by using SSL renegotiation instead.

--Lucky
</body></email><email><emailId>20071120041427</emailId><senderName>tor user</senderName><senderEmail>tor_user@yahoo.com</senderEmail><timestampReceived>2007-11-20 04:14:27-0400</timestampReceived><subject>bug with entry guards on 0.2.0.9-alpha</subject><body>

Greetings, 

I think I've found a bug with entry guard selection
starting with 0.2.0.9-alpha. The problem first appears
after revision 12038. 

My state file had 49 entry guards saved in it when I
happened to look earlier today. Thinking that was a
bit odd to have so many (it was only for the past
couple of months, and I don't use tor that often), I
did some testing to see what was happening. 

After poking at it a bit, starting with a clean ~/.tor
directory, it turned out that every time tor was
started, it would pick out more guards and add them.
The saved guards would always be marked as unlisted
initially (even if they weren't!), and new guards
would be used. 

It would build circuits with the new guards for a
while (about an hour) before noticing that the old
guards were actually up and switching back to using
them. That's probably not so good for anonymity. 

The behavior could be easily reproduced with default
settings. Each time tor was started and stopped, the
saved entry guard list would grow larger. 

Here's a snippet of a log file showing where tor is
failing to re-use entry guards that it saved on a
previous run only a few minutes earlier: 

Nov 19 20:45:03.730 [info] entry_guard_set_status():
Entry guard mehl
(13D31C1811B9A97FB2BE573E49543EAC668619AE) is
unlisted: marking as unusable.
Nov 19 20:45:03.730 [info]
entry_guards_compute_status(): Summary: Entry 'mehl'
is reachable, unusable and not live.
Nov 19 20:45:03.730 [info] entry_guard_set_status():
Entry guard clayman
(DA885246AA68E85698EA6A2585778942090C5AE9) is
unlisted: marking as unusable.
Nov 19 20:45:03.730 [info]
entry_guards_compute_status(): Summary: Entry
'clayman' is reachable, unusable and not live.
Nov 19 20:45:03.730 [info] entry_guard_set_status():
Entry guard h760662
(554EC782556A47590FB5B4DEFF56A5B52DB9CD59) is
unlisted: marking as unusable.
Nov 19 20:45:03.730 [info]
entry_guards_compute_status(): Summary: Entry
'h760662' is reachable, unusable and not live.
Nov 19 20:45:03.730 [info]
entry_guards_compute_status():     (0/3 entry guards
are usable/new)
Nov 19 20:45:03.730 [info] log_entry_guards(): mehl
(down made-contact),clayman (down
made-contact),h760662 (down made-contact)

All of the mentioned guards were actually listed, and
tor had made contact to them on the previous run. 

I tracked it back to revision 12038 where
routers_update_all_from_networkstatus() is called from
router_reload_consensus_networkstatus(). I don't know
what the function does, but commenting it out fixes
the problem and tor stops adding new guards at every
startup. 

There is probably a better fix than that, though. 

Here's a patch against 0.2.0.12-alpha with the above
change. 



      ____________________________________________________________________________________
Never miss a thing.  Make Yahoo your home page. 
http://www.yahoo.com/r/hs
["test2.patch" (application/octet-stream)]

diff -udr tor-0.2.0.12-alpha.orig/src/or/networkstatus.c tor-0.2.0.12-alpha/src/or/networkstatus.c
--- tor-0.2.0.12-alpha.orig/src/or/networkstatus.c	2007-11-11 11:38:00.000000000 -0600
+++ tor-0.2.0.12-alpha/src/or/networkstatus.c	2007-11-19 18:39:21.000000000 -0600
@@ -202,7 +202,7 @@
     }
   }
 
-  routers_update_all_from_networkstatus(time(NULL), 3);
+  //routers_update_all_from_networkstatus(time(NULL), 3);
 
   return 0;
 }


</body></email><email><emailId>20071001071333</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-10-01 07:13:33-0400</timestampReceived><subject>Re: Tor crash</subject><body>


On Sat, Sep 29, 2007 at 06:51:51PM -0700, Michael_google gmail_Gersten wrote:
&gt; &gt; Interesting!  Is this reproducible?
&gt; Don't know yet.
&gt; 
&gt; &gt; Oh!  By any chance is your ORListenAddress set in your torrc?
&gt; Nope
&gt; 
&gt; &gt; Did you get a core?  Was there anything useful in tor.crash.log?
&gt; No core.
&gt; Here's the crash log:
&gt; 
&gt; 
&gt; Host Name:      stbmac
&gt; Date/Time:      2007-09-27 16:24:10.933 -0700
&gt; OS Version:     10.4.10 (Build 8R218)
&gt; Report Version: 4
&gt; 
&gt; Command: tor
&gt; Path:    /Library/Tor/tor
&gt; Parent:  bash [389]
&gt; 
&gt; Version: ??? (???)
&gt; 
&gt; PID:    23808
&gt; Thread: 0
&gt; 
&gt; Exception:  EXC_BAD_ACCESS (0x0001)
&gt; Codes:      KERN_INVALID_ADDRESS (0x0001) at 0xca5ad9b6
&gt; 
&gt; Thread 0 Crashed:
&gt; 0   tor                 0x00087c04 event_del + 44 (event.c:697)
&gt; 1   tor                 0x0006cdd4 nameserver_up + 84 (eventdns.c:533)
&gt; 2   tor                 0x0006cee0 reply_callback + 112 (eventdns.c:648)
&gt; 3   tor                 0x0006fc6c reply_handle + 684 (eventdns.c:740)
&gt; 4   tor                 0x000714cc nameserver_ready_callback + 1564
&gt; (eventdns.c:925)
&gt; 5   tor                 0x00087364 event_process_active + 240 (event.c:332)
&gt; 6   tor                 0x00087634 event_base_loop + 340 (event.c:448)
&gt; 7   tor                 0x000874cc event_loop + 40 (event.c:382)
&gt; 8   tor                 0x000873d0 event_dispatch + 20 (event.c:346)
&gt; 9   tor                 0x0004b8b0 tor_main + 656 (main.c:1270)
&gt; 10  tor                 0x0000277c _start + 760
&gt; 11  tor                 0x00002480 start + 48

Okay.  This part  is _profoundly_ useful; it says where the crash
happened.  It looks like the failing operation is event_del (which is
called as evtimer_del) from eventdns.c around line 533.  The function
in question gets called when a name server which we believed was down
gives us a reply anyway.  eventdns.c says "oh, wonderful!".. and
deletes the timeout event that was going to tell us to test the
nameserver later on.

But this is after shutting down and restarting ORPort!  My guess is
that somewhere along the line we freed or removed the timeout event,
but did not remove the request that's making this code get called.

I'll check this out more tomorrow, once I've gotten a little sleep.

                                 ===

Can I take this opportunity to personally thank whoever at Apple
decided that saving a stack trace, in text, for every crash was a good
idea?  Thank you!  I hope some Linux distribution copies this soon.

&gt; 
&gt; Thread 1:
&gt; 0   libSystem.B.dylib   0x90023c60 recvfrom + 12
&gt; 1   tor                 0x000350c4 cpuworker_main + 148 (cpuworker.c:254)
&gt; 2   tor                 0x0007800c tor_pthread_helper_fn + 76 (compat.c:1016)
&gt; 3   libSystem.B.dylib   0x9002bd08 _pthread_body + 96

This other thread is just being a cpuworker, and waiting for the main
thread to ask it to do something.

yrs,
-- 
Nick Mathewson

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20071001131639</emailId><senderName>Pat Double</senderName><senderEmail>pat@patdouble.com</senderEmail><timestampReceived>2007-10-01 13:16:39-0400</timestampReceived><subject>Incognito Live CD using Polipo</subject><body>


First of all, if this is not an appropriate mailing list for discussing of 
Incognito development, please let me know. I'll move to or-talk, although I'd 
rather not clutter the discussion. Seems or-talk has a lot of noise.

I am considering changing the Incognito LiveCD to use Polipo. I have a branch 
with it enabled. Currently it is using a squid/privoxy combination. I need to 
know:
1. An appropriate polipo config.
2. Features in privoxy should be implemented in other ways. 
3. I have a short link of forbidden domains to block ads. Other 
undesirable/dangerous domains can be added.

See the links below:

Incognito description - 
http://www.patdouble.com/index.php?option=com_content&amp;task=blogsection&amp;id=3&amp;Itemid=6

Polipo config - 
https://tor-svn.freehaven.net/svn/incognito/branches/polipo/root_overlay/etc/polipo/config

Banned URLs - (regular expressions) 
https://tor-svn.freehaven.net/svn/incognito/branches/polipo/root_overlay/etc/polipo/forbidden.d/

Thanks.

-- 
Pat Double, pat@patdouble.com
"Ye must be born again." - John 3:7

["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20071010021835</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-10-10 02:18:35-0400</timestampReceived><subject>Comments on Proposal 121 [was Re: Proposal: Hidden Service Authentication]</subject><body>


On Wed, Sep 26, 2007 at 04:20:29PM +0200, Karsten Loesing wrote:

Hi!  Here are my first comments on proposal 121.  On the whole, it
looks good, but there are some things that need to be changed, and
other things that could be done better.  I've tried to note which is
which.

 [...]
&gt; Motivation:
&gt; 
&gt;   The currently used implementation of hidden services does not provide any
&gt;   kind of authentication. The v2 implementation adds an authentication
&gt;   mechanism at the directory server. Security can be further improved by
&gt;   adding two more authentication authorities at the introduction point
&gt;   (IPo) and the OP.

These versions are getting me very confused.  As implemented in Tor
now, there are version 0, version 1, and version 2 RELAY_INTRODUCE2
cells.  Thus, there is already in some sense a "version 2" of the
protocol.  In fact, below the proposal acknowledges this by using "3"
as the version for its RELAY_INTRODUCE1 cells.

Even more confusingly, proposal 114 introduces a new version of
rendezvous descriptors, which it calls "v2" if I understand correctly.

Is there any way to straighten out this mess and be clear about which
version number is which?

 [...]
&gt; Details:
&gt; 
&gt;   /1/ Client authentication at the hidden service
&gt; 
&gt;   In proposal 114 a client (Alice) who has a valid secret cookie, which may
&gt;   be considered as a form of authentication, and a service ID is able to
&gt;   connect to Bob if he is online. He can not distinguish between Alice
&gt;   being intentionally authorized by himself or being an attacker.
&gt;   Integrating authentication in Tor HS will ensure Bob that Alice is only
&gt;   able to use the service if she is authorized by him.
&gt; 
&gt;   Authentication data will be transmitted via the RELAY_INTRODUCE1 cell
&gt;   from Alice to Bob that is forwarded by the IPo. For this message several
&gt;   format versions are specified in the rend-spec in section 1.8. We will
&gt;   use the format version 3.

 [see above about versions.]

&gt;                            This specification already contains the fields
&gt;   "AUTHT" (to specify the authentication method), "AUTHL" (length of the
&gt;   authentication data), and "AUTHD" (the authentication data) that will be
&gt;   used to store authentication data. Since these fields are encrypted with
&gt;   the service's public key, sniffing attacks will fail.

FWIW, the fields you mention are only listed in the spec for a
descriptor format that was never used.  They were part of the
RELAY_INTRODUCE2 cell payload, and so were *not* ever encrypted with
the service's public key.

If I understand you correctly, you're proposing that they be added,
not saying that they are already there in the RELAY_INTRODUCE2 cell,
right?

&gt;                                                         Bob will only build
&gt;   the circuit to the rendezvous point if the provided authentication data
&gt;   is valid, otherwise he will drop the cell. This will improve security due
&gt;   to preventing communication between Bob and Alice if she is an
&gt;   attacker.

Having authorization _at the introduction point_ achieves this
property.  If the introduction point relays the message to Bob, Bob is
already "communicating" with Alice in the sense that Alice can make
Bob get a cell whenever she likes.  For many attackers, this is
enough, but these attackers probably win anyway.

(It's still worthwhile for Bob to get the authentication information
too, however: it gives him a chance to make sure the introduction
point is really checking it.)

(No change is needed here except to the writeup.)

&gt;  As a positive side effect it reduces network traffic because it avoids
&gt;   Bob from building unnecessary circuits to the rendezvous points.
&gt;   Authentication at the HS should be the last gatekeeper and the number of
&gt;   cases in which a client successfully passes the introduction point, but
&gt;   fails at the HS should be almost zero. Therefore it is very important to
&gt;   perform fine-grained access control already at the IPo (but without
&gt;   relying on it).

Agreed.

&gt;   The first authentication mechanism that will be supported is password
&gt;   (symmetric secret) authentication. "AUTHT" is set to "1" for this
&gt;   authentication method while the "AUTHL" field is set to "20", the length
&gt;   of the SHA-1 digest of the password.

When this gets merged into rend-spec.txt, it probably makes sense to
describe when and where authentication information is passed, but not
specify actual AUTHT values until their own section.

In other words, there are two big ideas here that could be separated
pretty easily:
  (A) "A generic authentication mechanism for hidden services"
  (B) "Some specific kinds of authentication"

I think it's a good idea to split these up better, because I think
what the proposal specifies for (A) is a lot more solid than what it
specifies for (B).

&gt;   (1) Alice creates a password x and sends the password digest h(x) to Bob
&gt;       out of band.
&gt;   (2) Alice sends h(x) to Bob, encrypted with Bob's fresh service key (not
&gt;       subject to this proposal, see proposal 114).
&gt;   (3) Bob decrypts Alice's message using his private service key (see
&gt;       proposal 114) and compares the contained h(x) with what he knows what
&gt;       Alice's password digest h(x) should be.

It's probably better for Bob to store H(salt|H(x)).

For Alice, instead of H(x), it might be a good idea to use some
version of the s2k algorithm in RFC2440, to prevent anybody who sees
it from reversing it.  (This matters more for authentication at the
introduction point than for authentication for Bob.)

[For more on authentication at the introduction point, see below.]

&gt;   This kind of authentication is well-known. It has the known disadvantage
&gt;   of weak passwords that are vulnerable to dictionary or brute-force
&gt;   attacks. Nevertheless it seems to be an appropriate solution since safe
&gt;   passwords can be randomly generated by Tor. Cracking methods that rely on
&gt;   guessing passwords should not be effective in the constantly changing
&gt;   network infrastructure. A usability advantage is that this method is easy
&gt;   to perform even for unexperienced users. The authenticationdata will be
&gt;   the SHA-1 secure hash (see tor-spec) of the shared secret
&gt;   (password).

There is also an anonymity issue in this method: it makes all requests
by users with the same password linkable.

&gt;   The premise to use password authentication is that Bob must send the
&gt;   password to Alice outside Tor.

Above you say Alice sends it to Bob.  Presumably you mean "either."

&gt; If at the same time the secret cookie is
&gt;   transmitted and the message is intercepted the attacker can gain access
&gt;   to the service. Therefore, a secure way to exchange this information must
&gt;   be established.
&gt; 
&gt;   The second authentication mechanism is public-key authentication. The
&gt;   well-known RSA implementation will be used as cipher (see tor-spec). 
&gt;   Authentication data will be the hash of the rendezvous cookie, signed
&gt;   with the private key (SK).
&gt; 
&gt;   When Alice wants to use this authentication method she sets "AUTHT" to
&gt;   "2" and "AUTHL" to "128" which is the size of the encrypted data. Since
&gt;   the rendezvous cookie changes each time Alice connects, replay attacks
&gt;   can be easily prevented.

It's not necessary or even desirable to use a fixed key size here;
this should probably be specified in terms of the key size.

&gt;   (1) Alice creates a private key e and sends the corresponding public key
&gt;       d to Bob out of band.
&gt;   (2) Alice generates a random rendezvous cookie r, computes PKSign(e, r),
&gt;       encrypts it with Bob's fresh service key (see proposal 114), and
&gt;       sends the result to Bob.
&gt;   (3) Bob decrypts Alice's message using his private service key (see
&gt;       proposal 114) and verifies PKSign(e, r) with d.

This is really awful in terms of performance if there is more than one
authorized Alice.  If there are N authorized users, Bob needs to try
PKSign(e, r) on average N times before he can be sure that a user is
unauthorized.

It would probably be better to include some indication of which key
Bob is supposed to use to check the signature.

 [...]
&gt;   /2/ Client authentication at the introduction point 	
&gt; 
&gt;   In addition to authentication at the HS OP, the IPo should be able to
&gt;   detect and abandon all unauthorized requests. This would help to raise
&gt;   the level of privacy and therefore also the level of security for Bob by
&gt;   better hiding his online activity from unauthorized users. Especially if
&gt;   Alice still has access to the secret cookie. This can be the case if she
&gt;   had access to the service earlier, but is no longer authorized or the
&gt;   directory is outdated. Another advantage of this additional "gate keeper"
&gt;   would be reduced traffic in the network, because unauthorized requests
&gt;   could already be detected and declined at the IPo.

Agreed; this is critical.

&gt;   It is important to notice that the IPo may not be trustworthy, and
&gt;   therefore can not replace authentication at the HS OP itself. Nor should
&gt;   the IPo get hold of critical authentication information (because it could
&gt;   try to access the service itself).

Ideally, it would also be possible for Bob to verify that the IPo is
not relaying any unauthorized requests.

&gt;   A challenge-response authentication protocol is used to address these
&gt;   issues. This means that a challenge is needed to be solved by Alice to
&gt;   get forwarded to Bob by the IPo.
&gt; 

I don't see the challenge-response aspect here.  The introduction
point, in the protocol below, isn't actually issuing any challenge to
Alice.  The "challenge" comes from Bob in the encrypted portion of the
hidden service descriptor, but since the challenge is the same every
time Alice connects to any introduction point while the descriptor is
valid, Alice's responses will be replayable.  This defeats the whole
point of a challenge-response protocol.

&gt;   Two types of authentication are supported and need to be preconfigured by
&gt;   Bob when creating the service: password and public-key authentication.
&gt;   Again it is up to Alice what kind of authentication mechanism she wants
&gt;   to use, given that Bob knows both her password and her public key.
&gt; 
&gt;   If Alice uses a password to authenticate herself at the IPo, the
&gt;   authentication is based on a symmetric challenge-response authentication
&gt;   protocol. In this case the challenge for Alice is to send h(x|y) where x
&gt;   is a user-specific password, which should be different from the password
&gt;   needed for authentication at the hidden service and y is a randomly
&gt;   generated value. Alice gets hold of her password out of band.
&gt; 
&gt;   With the initial RELAY_ESTABLISH_INTRO cell, the IPo gets a list of
&gt;   h(x|y)'s which it stores locally. Upon a request of Alice it compares her
&gt;   provided authentication data with the list entries. If there is a
&gt;   matching entry in its list, Alice's request is valid and can be forwarded
&gt;   to Bob. To generate the hash, Alice needs to know the password (which she
&gt;   will get out of band) and the random value y. This value is contained in
&gt;   the cookie-encrypted part of the hidden service descriptor which Alice
&gt;   can retrieve from the directory using her secret cookie.

So y is a secret that anybody who knows the cookie can get, and x is
(you say below) a hash of the Alice's password?  Using "x" to mean
"h(x)" is a little confusing here.

The authenticated h(h(x)|y) value seems to be completely replayable;
any of Alice's introduction point can impersonate Alice to any of the
other introduction points.  This isn't what I'd consider a
challenge-response protocol.

&gt;   (1) Alice creates a password x and sends the password digest h(x) to Bob
&gt;       out of band.
&gt;   (2) Bob creates a random value y, computes h(h(x)|y), and sends the
&gt;       result to the introduction point.
&gt;   (3) Bob encrypts y with a secret cookie (see proposal 114) and writes it
&gt;       to a rendezvous service descriptor.
&gt;   (4) Alice fetches Bob's rendezvous service descriptor, decrypts y using
&gt;       the secret cookie (see proposal 114), computes h(h(x)|y), encrypts
&gt;       it with the public key of the introduction point, and sends it to
&gt;       that introduction point.
&gt;   (5) The introduction point decrypts h(h(x)|y) from Alice's message and
&gt;       compares it to the value it knows from Bob (from step 2).

Stepping back a little, it looks like what you want is some protocol
where Alice has a password x, and Bob knows some f(x), and Bob tells
the IPo some g(f(x)).  Later, Alice sends an INTRODUCE1 cell whose
unencrypted portion includes i(x) and whose encrypted portion includes
j(x), and this is enough for everybody to authenticate Alice.
We'd also like it to be the case that nobody, not even another IPo
that has seen Alice authenticate, can convince an IPo or Bob that it
is Alice.

It seems to me that this is probably one of the solved problems in the
field of cryptography, and it would be a little silly and error-prone
of us to make up our own protocol to do this.

&gt;   If Alice wants to use public-key authentication to authenticate herself
&gt;   at Bob's HS, the challenge-response authentication protocol is slightly
&gt;   different.

Presumably you mean "IPo" here, not "HS".

&gt; 
&gt;   The IPo's are provided with a list of random value hashes h(r) with an
&gt;   entry for each user via the RELAY_ESTABLISH_INTRO cell. For public-key
&gt;   authentication Alice uses an RSA public/private-key pair (as specified in
&gt;   tor-spec). The public key is made known to Bob out of band. The IPo's
&gt;   will now be sent a new ESTABLISH_INTRO cell with an additional random
&gt;   value hash for Alice and a new descriptor is uploaded to the responsible
&gt;   directories.  The public-key authentication part of the service descriptor
&gt;   holds a blank separated list of key-value pairs with one pair for every
&gt;   authorized user. The hash of the public key of a user serves as a key,
&gt;   while the PK-encrypted r represents the value. Authorized users can now
&gt;   find their respective key-value pair and decrypt the value of h(r). This
&gt;   result serves as an authorization token at the IPo in the same way as
&gt;   with password authentication. The IPo does not know which authentication
&gt;   method was used since the tokens always have the same format.
&gt; 
&gt;   (1) Alice creates a private key e and sends the corresponding public key
&gt;       d to Bob out of band.
&gt;   (2) Bob creates a random value y and sends it to the introduction point.
&gt;   (3) Bob computes PKEncrypt(d, y), encrypts the result with a secret
&gt;       cookie (see proposal 114), and writes it to a rendezvous service
&gt;       descriptor.
&gt;   (4) Alice fetches Bob's rendezvous service descriptor, decrypts
&gt;       PKEncrypt(d, y) using the secret cookie (see proposal 114), decrypts
&gt;       y from it using her private key e, and sends it to the introduction
&gt;       point.
&gt;   (5) The introduction point compares y with the value it knows from Bob
&gt;       (from step 2).
&gt; 
&gt;   To remove a user from a group, Bob needs to update the random value list
&gt;   at the IPo's.

Again, this is replayable.  Also, it's another one of the solved
problems in crypto, and using an established and analyzed protocol
would be better than making up our own thing here.

&gt;   The changes needed in Tor to realize these two challenge-response
&gt;   variations affect the RELAY_ESTABLISH_INTRO and RELAY_INTRODUCE1 relay
&gt;   cells, the service descriptor and the code parts in Tor where these cells
&gt;   and the descriptor are handled.
&gt; 
&gt;   The RELAY_ESTABLISH_INTRO cell is now structured as follows:
&gt; 
&gt;   V      Format byte: set to 255             [1 octet]
&gt;   V      Version byte: set to 2              [1 octet]
&gt;   KL     Key length                         [2 octets]
&gt;   PK     Bob's public key                  [KL octets]
&gt;   HS     Hash of session info              [20 octets]
&gt;   AUTHT  The auth type that is supported     [1 octet]
&gt;   AUTHL  Length of auth data                [2 octets]
&gt;   AUTHD  Auth data                          [variable]
&gt;   SIG    Signature of above information     [variable]
&gt; 
&gt;   "AUTHT" is set to "1" for password/public-key authentication.
&gt;   "AUTHD" is a list of 20 octet long challenges for clients.
&gt; 
&gt;   The service descriptor as specified in 114-distributed-storage is used in
&gt;   our implementation.

Cells are only so long -- 512 bytes at the moment, with only 498 of
that available for relay payloads.  Assuming 1024-bit keys, the fields
above other than AUTHD fill 283 bytes.  If I'm counting right, that
leaves only 215 bytes for AUTHD.  This is enough room for only 10
users with your password authentication scheme, and only 1 user with
your public-key scheme.

That's not so good.  On the one hand, it would be unpleasant to allow
Bob to claim an arbitrary amount of storage on the introduction point,
and unpleasant to require him to transmit it all regularly.  But on
the other hand, having the number of supported users limited by the
cell size is really awful.

I hope these comments help; the idea is a sound one, but the execution
needs more work before I'd be comfortable putting it into Tor.

peace,
-- 
Nick Mathewson

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20071010040120</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-10-10 04:01:20-0400</timestampReceived><subject>Re: Turning off a server</subject><body>


 [off-list]

On Tue, Oct 09, 2007 at 06:59:47PM -0400, Roger Dingledine wrote:
&gt; On Tue, Oct 09, 2007 at 06:54:33PM -0400, Roger Dingledine wrote:
&gt; &gt; &gt; I think that's the "missing" element. There is no way that I know of
&gt; &gt; &gt; for a circuit to refuse any new TCP connection while still staying
&gt; &gt; &gt; open for existing ones.
&gt; &gt; 
&gt; &gt; Actually, that feature exists right now. Look for calls to
&gt; &gt; we_are_hibernating() in various places in the code (command.c and
&gt; &gt; connection_edge.c in particular).
&gt; 
&gt; I think it might be smart to instead check "are we hibernating, or are
&gt; we not a server anymore" in these various places. I'd be happy to apply
&gt; a patch for that if one appeared. :)
&gt; 
&gt; It's not quite what Robert asked for originally though, since it won't
&gt; affect a very active stream that stays very active.
&gt; 
&gt; Perhaps a combination of refusing new requests plus throttling via
&gt; RelayBandwidthRate would be sufficient?

Added to the bugtracker as bug 525 so we don't forget it.

yrs,
-- 
Nick Mathewson

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20071012080034</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-10-12 08:00:34-0400</timestampReceived><subject>Re: [or-cvs] r11855: let bridge authorities write bridge descriptors to their cac (tor/trunk/src/or)</subject><body>

On Wed, Oct 10, 2007 at 08:13:29PM -0400, Nick Mathewson wrote:
&gt; &gt; Log:
&gt; &gt; let bridge authorities write bridge descriptors to their
&gt; &gt; cached-descriptors* files.
&gt; &gt; 
&gt; &gt; nick, did i get this right?
&gt; 
&gt; This looks fine to me, except for two points:
&gt; 
&gt;   1) Your patch removes an assert from dirserv.c, in
&gt;      dirserv_add_multiple_descriptors().  It's checking for
&gt;      correctness in some fairly complicated code, so I'm putting it
&gt;      back in.

Great.

&gt;   2) The patch also changes the behavior of descriptors added via the
&gt;      control interface: previously, they were cached or not cached
&gt;      depending on their purpose.  Now, they're all cached.

Right. I believe the old behavior was viewed as a bug from the perspective
of the one controller that used this feature (Blossom). As far as I know,
no current controllers use it.

&gt;      For compatibility, it's probably better to have the controller
&gt;      POSTDESC command take a cache=0/1 argument, and have the defaults
&gt;      mirror the old behavior.

Committed as r11892.

I plan to eventually change the default to cache=yes, so controllers
should explicitly pick one if they care.

--Roger

</body></email><email><emailId>20071014002758</emailId><senderName>Robert Hogan</senderName><senderEmail>robert@roberthogan.net</senderEmail><timestampReceived>2007-10-14 00:27:58-0400</timestampReceived><subject>Re: Lock Control Port</subject><body>


On Saturday 13 October 2007 21:27:01 Roger Dingledine wrote:
&gt; On Sat, Oct 13, 2007 at 10:50:16AM +0100, Robert Hogan wrote:
&gt; &gt; While we're all still 'getting there', controllers could have the option
&gt; &gt; of locking the control port if no auth mechanism is enabled, and even
&gt; &gt; when it is. Given that users tend not to share installations and most run
&gt; &gt; their controller concurrently with tor at all times this would be a
&gt; &gt; useful fallback measure.
&gt;
&gt; Why not have your controller enable authentication when it connects and
&gt; doesn't like what it finds? If you want, you can then disable it when
&gt; you disconnect.
&gt;
&gt; This approach would seem to have all the same properties of your
&gt; lock/unlock without any new commands or code.
&gt;

Duh. Don't know where I was going with that one.


["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20071015172829</emailId><senderName>"Michael_google gmail_Gersten"</senderName><senderEmail>keybounce@gmail.com</senderEmail><timestampReceived>2007-10-15 17:28:29-0400</timestampReceived><subject>Problem with exit nodes DNS</subject><body>

With the recent discussion about nasty exit nodes, I decided to try to
use a fixed set of exit nodes.

I found out that if my exit node was "whistlersmother" or
"BostonUCompSci", then attempts to connect to "adultswim.com" or
"www.adultswim.com" would fail, with an unresolvable name error.

Those sites do exist, and could be found with other exit nodes.

Now, my guess is that these sites are running some sort of "anti
X-rated site" filter on their DNS, and it's making some bad guesses.
But more importantly, how can we check for bad DNS resolves better
than we currently do?
</body></email><email><emailId>20071016165959</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-10-16 16:59:59-0400</timestampReceived><subject>Re: Proposal: autonaming</subject><body>


On Thu, Oct 11, 2007 at 12:50:18AM +0200, Peter Palfrader wrote:
&gt; Filename: xxx-autonaming.txt

Added as proposal 123.

--=20
Nick Mathewson

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20071119082953</emailId><senderName>"Kyle Williams"</senderName><senderEmail>kyle.kwilliams@gmail.com</senderEmail><timestampReceived>2007-11-19 08:29:53-0400</timestampReceived><subject>FEATURE IDEA: Hidden Directory Authorities</subject><body>

Any suggestions, questions, or comments are encouraged.

I know that Tor has the PrivateDir option, which uses an Onion Router
to make the request to the DA to retrieve updated cached-* documents.
However, this option will not
function without a pre-cached copy of the cached-routers documents
because it wouldn't know of an Onion Routers to tunnel the request
through.
Basically you need a pre-cached copy of cached-routers for PrivateDir
to work, right?
(Please correct me if I am wrong here.)

So the questions that entered my mind were:
* Could Directory Authorities use an .onion address instead of an IP
address if a pre-cached copy of cached-routers was distributed with
the initial download of Tor?
* Would this make the Directory Authorities more resistant to digital
&amp; physical attack?
* Are "guard" nodes[2] the same as "valet" nodes[1]?
The wording of "guard" nodes [2] sounds very similar to the concept of
"valet" nodes [1], but I'm not quite sure if these are the same.  Are
they?

Since the DAs would be the most logical place for an attacker to DoS
or attack, I was thinking that it would make sense if the DAs couldn't
be found physically or by IP.
To start a network, I was think of using 3 DAs with 8 nodes.  The
nodes would act as rendezvous points, introduction points, valet/guard
points, entry, middle, and exit nodes.
If the DAs .onion information and 8 startup nodes information was
pre-cached when Tor is download, would that be enough to keep the DA's
hidden?

Now the big question.  What type of attacks would this be prone to?
After reading [2], it became clear that someone could attack
Introduction Points to reveal the true location of the hidden service.
 But the 'valet' (or 'guard'?) node design model would significantly
help reduce the probability of this attack being successful.  So, if
the DA's are acting as a hidden service, in theory, Introduction and
Valet Points wouldn't be able to distinguish regular hidden services
from the DA's hidden service.

I know that by hiding the DA's, every downloaded package of Tor would
have to contain an up-to-date copy of the cached-routers.  Could a
"cached-onions" file be introduced into the design to make it clear
which are Onion Routers and which are Hidden Services?

This idea was something that been going through my mind the last few
weeks.  What do you think?
Paul, if you're reading this, I would really like to hear what you
think about this.
Any feedback from anyone is appreciated.


Best Regards,
Kyle

-------------------------------------------------------------------------------------
References:
[1] Making Anonymous Communications
( http://www.onion-router.net/Publications/Briefing-2004.pdf )

[2] Locating Hidden Servers
( http://www.onion-router.net/Publications/locating-hidden-servers.pdf )
</body></email><email><emailId>200711190829530</emailId><senderName>"Kyle Williams"</senderName><senderEmail>kyle.kwilliams@gmail.com</senderEmail><timestampReceived>2007-11-19 08:29:53-0400</timestampReceived><subject>FEATURE IDEA: Hidden Directory Authorities</subject><body>

Any suggestions, questions, or comments are encouraged.

I know that Tor has the PrivateDir option, which uses an Onion Router
to make the request to the DA to retrieve updated cached-* documents.
However, this option will not
function without a pre-cached copy of the cached-routers documents
because it wouldn't know of an Onion Routers to tunnel the request
through.
Basically you need a pre-cached copy of cached-routers for PrivateDir
to work, right?
(Please correct me if I am wrong here.)

So the questions that entered my mind were:
* Could Directory Authorities use an .onion address instead of an IP
address if a pre-cached copy of cached-routers was distributed with
the initial download of Tor?
* Would this make the Directory Authorities more resistant to digital
&amp; physical attack?
* Are "guard" nodes[2] the same as "valet" nodes[1]?
The wording of "guard" nodes [2] sounds very similar to the concept of
"valet" nodes [1], but I'm not quite sure if these are the same.  Are
they?

Since the DAs would be the most logical place for an attacker to DoS
or attack, I was thinking that it would make sense if the DAs couldn't
be found physically or by IP.
To start a network, I was think of using 3 DAs with 8 nodes.  The
nodes would act as rendezvous points, introduction points, valet/guard
points, entry, middle, and exit nodes.
If the DAs .onion information and 8 startup nodes information was
pre-cached when Tor is download, would that be enough to keep the DA's
hidden?

Now the big question.  What type of attacks would this be prone to?
After reading [2], it became clear that someone could attack
Introduction Points to reveal the true location of the hidden service.
 But the 'valet' (or 'guard'?) node design model would significantly
help reduce the probability of this attack being successful.  So, if
the DA's are acting as a hidden service, in theory, Introduction and
Valet Points wouldn't be able to distinguish regular hidden services
from the DA's hidden service.

I know that by hiding the DA's, every downloaded package of Tor would
have to contain an up-to-date copy of the cached-routers.  Could a
"cached-onions" file be introduced into the design to make it clear
which are Onion Routers and which are Hidden Services?

This idea was something that been going through my mind the last few
weeks.  What do you think?
Paul, if you're reading this, I would really like to hear what you
think about this.
Any feedback from anyone is appreciated.


Best Regards,
Kyle

-------------------------------------------------------------------------------------
References:
[1] Making Anonymous Communications
( http://www.onion-router.net/Publications/Briefing-2004.pdf )

[2] Locating Hidden Servers
( http://www.onion-router.net/Publications/locating-hidden-servers.pdf )
</body></email><email><emailId>20071111205452</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-11-11 20:54:52-0400</timestampReceived><subject>Re: bridge and bridge authority proposal</subject><body>

On Sun, May 06, 2007 at 11:42:25PM -0400, Roger Dingledine wrote:
&gt; Here are some details on my plans for bridges and bridge authorities.
&gt; They're still fluid because I haven't actually built it, so it's hard
&gt; to know if they will turn out to be the right plans when it comes down
&gt; to coding, but it's at least a start.

Here is a much more fleshed out version, describing the current design
as well as the current state of implementation.


Behavior for bridge users, bridge relays, and bridge authorities

0. Preface

  This document describes the design decisions around support for bridge
  users, bridge relays, and bridge authorities. It acts as an overview
  of the bridge design and deployment for developers, and it also tries
  to point out limitations in the current design and implementation.

  For more details on what all of these mean, look at blocking.tex in
  /doc/design-paper/

1. Bridge relays

  Bridge relays are just like normal Tor relays except they don't publish
  their server descriptors to the main directory authorities.

1.1. PublishServerDescriptor

  To configure your relay to be a bridge relay, just add
    PublishServerDescriptor bridge
  to your torrc. This will cause your relay to publish its descriptor
  to the bridge authorities rather than to the default authorities.

  Alternatively, you can say
    PublishServerDescriptor 0
  which will cause your relay to not publish anywhere. This could be
  useful for private bridges.

1.2. Defining DirPort

  Bridges need to answer BEGIN_DIR requests, both so they can answer
  "/server/authority" questions ("what's your descriptor?") and so they
  can supply their bridge users with cached copies of all the various
  Tor network information.

  Right now (0.2.0.11-alpha) we require that bridges turn their DirPort on
  -- which means both that we answer BEGIN_DIR requests and that we fetch
  and cache directory information in an aggressive way like other servers.

  But:
  a) we don't enforce that DirPort is on, since it's not clear how to
  detect if the user meant to be a bridge. So it's easy to set up a bridge
  relay that silently refuses BEGIN_DIR requests and is thus useless.
  b) We don't actually care if they have an open or reachable DirPort. So
  at some point we should separate having an open DirPort from answering
  directory questions. Which leads to:
  c) We need to investigate if there are any anonymity worries with
  answering BEGIN_DIR requests when our DirPort is off. If there aren't,
  we should drop the DirPort requirement.

  I claim that we don't open any new attacks by answering BEGIN_DIR
  questions when DirPort is off: it's still a fine question to ask what
  partitioning attacks there are when you can query a Tor client about
  its current directory opinions, but these attacks already exist when
  DirPort is on.

  We need to answer this issue in 0.2.0.x.

1.3. Exit policy

  Bridge relays should use an exit policy of "reject *:*". This is
  because they only need to relay traffic between the bridge users
  and the rest of the Tor network, so there's no need to let people
  exit directly from them.

1.4. RelayBandwidthRate / RelayBandwidthBurst

  We invented the RelayBandwidth* options for this situation: Tor clients
  who want to allow relaying too. See proposal 111 for details. Relay
  operators should feel free to rate-limit their relayed traffic.

1.5. Helping the user with port forwarding, NAT, etc.

  Just as for operating normal relays, our documentation and hints for
  how to make your ORPort reachable are inadequate for normal users.

  We need to work harder on this step, perhaps in 0.2.1.x.

1.6. Vidalia integration

  Vidalia 0.0.15 has turned its "Relay" settings page into a tri-state
  "Don't relay" / "Relay for the Tor network" / "Help censored users".

  If you click the third choice, it forces your exit policy to reject *:*,
  and it forces your DirPort to 9030 (but see Sec 1.2 above about DirPort).

  If all the bridges end up on port 9001, that's not so good. On the
  other hand, putting the bridges on a low-numbered port in the Unix
  world requires jumping through extra hoops. The current compromise is
  that Vidalia makes the ORPort default to 443 on Windows, and 9001 on
  other platforms.

  At the bottom of the relay config settings window, Vidalia displays
  the bridge identifier to the operator (see Section 3.1) so he can pass
  it on to bridge users.

1.7. What if the default ORPort is already used?

  If the user already has a webserver or some other application
  bound to port 443, then Tor will fail to bind it and complain to the
  user, probably in a cryptic way. Rather than just working on a better
  error message (though we should do this), we should consider an
  "ORPort auto" option that tells Tor to try to find something that's
  bindable and reachable. This would also help us tolerate ISPs that
  filter incoming connections on port 80 and port 443. But this should
  be a different proposal, and can wait until 0.2.1.x.

2. Bridge authorities.

  Bridge authorities are like normal directory authorities, except they
  don't create their own network-status documents or votes. So if you
  ask an authority for a network-status document or consensus, they
  behave like a directory mirror: they give you one from one of the main
  authorities. But if you ask the bridge authority for the descriptor
  corresponding to a particular identity fingerprint, it will happily
  give you the latest descriptor for that fingerprint.

  To become a bridge authority, add these lines to your torrc:
    AuthoritativeDirectory 1
    BridgeAuthoritativeDir 1

  Right now there's one bridge authority, running on the Tonga relay.

2.1. Exporting bridge-purpose descriptors

  We've added a new purpose for server descriptors: the "bridge"
  purpose. With the new router-descriptors file format that includes
  annotations, it's easy to look through it and find the bridge-purpose
  descriptors.

  We should work with Tonga to export its router-descriptors file to
  some place where we can distribute the bridge addresses according to
  the policies in blocking.pdf. It might even be easier to have it write
  out a separate file, just for export, that includes only the bridge
  descriptors; or maybe a six-liner perl postprocessing script is the
  better plan there to create a file for export.

2.2. Reachability/uptime testing

  Right now the bridge authorities just passively collect bridge
  descriptors, and give them out on request. At some point we are going
  to want to recommend new bridges to users, and we'll want to have
  some way of deciding which ones are up right now, which ones have
  been around for a while, etc. We should have the bridge authorities
  do active measurements of bridges just as the normal authorities do
  active measurements of normal relays. Then we can export the results
  just like in Section 2.1. above.

  In the design document, we suggested that bridges should publish
  anonymously (i.e. via Tor) to the bridge authority, so somebody watching
  the bridge authority can't just enumerate all the bridges. But if we're
  doing active measurement, the game is up. Perhaps we should back off on
  this goal, or perhaps we should do our active measurement anonymously?

  Answering this issue is scheduled for 0.2.1.x.

2.3. Migrating to multiple bridge authorities

  Having only one bridge authority is both a trust bottleneck (if you
  break into one place you learn about every single bridge we've got)
  and a robustness bottleneck (when it's down, bridge users become sad).

  Right now if we put up a second bridge authority, all the bridges would
  publish to it, and (assuming the code works) bridge users would query
  a random bridge authority. This resolves the robustness bottleneck,
  but makes the trust bottleneck even worse.

  In 0.2.1.x and later we should think about better ways to have multiple
  bridge authorities.

3. Bridge users.

  Bridge users are like ordinary Tor users except they use encrypted
  directory connections by default, and they use bridge relays as both
  entry guards (their first hop) and directory guards (the source of
  all their directory information).

  To become a bridge user, add the following two lines to your torrc:

    UseBridges 1
    TunnelDirConns 1

  and then add at least one "Bridge" line to your torrc based on the
  format below.

3.1. Format of the bridge identifier.

  The canonical format for a bridge identifier contains an IP address,
  an ORPort, and an identity fingerprint:
    bridge 128.31.0.34:9009 4C17 FB53 2E20 B2A8 AC19 9441 ECD2 B017 7B39 E4B1

  However, the identity fingerprint can be left out, in which case the
  bridge user will connect to that relay and use it as a bridge regardless
  of what identity key it presents:
    bridge 128.31.0.34:9009
  This might be useful for cases where only short bridge identifiers
  can be communicated to bridge users.

  In a future version we may also support bridge identifiers that are
  only a key fingerprint:
    bridge 4C17 FB53 2E20 B2A8 AC19 9441 ECD2 B017 7B39 E4B1
  and the bridge user can fetch the latest descriptor from the bridge
  authority (see Section 3.4).

3.2. Bridges as entry guards

  For now, bridge users add their bridge relays to their list of "entry
  guards" (see path-spec.txt for background on entry guards). They are
  managed by the entry guard algorithms exactly as if they were a normal
  entry guard -- their keys and timing get cached in the "state" file,
  etc. This means that when the Tor user starts up with "UseBridges"
  disabled, he will skip past the bridge entries since they won't be
  listed as up and usable in his networkstatus consensus. But to be clear,
  the "entry_guards" list doesn't currently distinguish guards by purpose.

  Internally, each bridge user keeps a smartlist of "bridge_info_t"
  that reflects the "bridge" lines from his torrc along with a download
  schedule (see Section 3.5 below). When he starts Tor, he attempts
  to fetch a descriptor for each configured bridge (see Section 3.4
  below). When he succeeds at getting a descriptor for one of the bridges
  in his list, he adds it directly to the entry guard list using the
  normal add_an_entry_guard() interface. Once a bridge descriptor has
  been added, should_delay_dir_fetches() will stop delaying further
  directory fetches, and the user begins to bootstrap his directory
  information from that bridge (see Section 3.3).

  Currently bridge users cache their bridge descriptors to the
  "cached-descriptors" file (annotated with purpose "bridge"), but
  they don't make any attempt to reuse descriptors they find in this
  file. The theory is that either the bridge is available now, in which
  case you can get a fresh descriptor, or it's not, in which case an
  old descriptor won't do you much good.

  We could disable writing out the bridge lines to the state file, if
  we think this is a problem.

  As an exception, if we get an application request when we have one
  or more bridge descriptors but we believe none of them are running,
  we mark them all as running again. This is similar to the exception
  already in place to help long-idle Tor clients realize they should
  fetch fresh directory information rather than just refuse requests.

3.3. Bridges as directory guards

  In addition to using bridges as the first hop in their circuits, bridge
  users also use them to fetch directory updates. Other than initial
  bootstrapping to find a working bridge descriptor (see Section 3.4
  below), all further non-anonymized directory fetches will be redirected
  to the bridge.

  This means that bridge relays need to have cached answers for all
  questions the bridge user might ask. This makes the upgrade path
  tricky --- for example, if we migrate to a v4 directory design, the
  bridge user would need to keep using v3 so long as his bridge relays
  only knew how to answer v3 queries.

  In a future design, for cases where the user has enough information
  to build circuits yet the chosen bridge doesn't know how to answer a
  given query, we might teach bridge users to make an anonymized request
  to a more suitable directory server.

3.4. How bridge users get their bridge descriptor

  Bridge users can fetch bridge descriptors in two ways: by going directly
  to the bridge and asking for "/tor/server/authority", or by going to
  the bridge authority and asking for "/tor/server/fp/ID". By default,
  they will only try the direct queries. If the user sets
    UpdateBridgesFromAuthority 1
  in his config file, then he will try querying the bridge authority
  first for bridges where he knows a digest (if he only knows an IP
  address and ORPort, then his only option is a direct query).

  If the user has at least one working bridge, then he will do further
  queries to the bridge authority through a full three-hop Tor circuit.
  But when bootstrapping, he will make a direct begin_dir-style connection
  to the bridge authority.

  As of Tor 0.2.0.10-alpha, if the user attempts to fetch a descriptor
  from the bridge authority and it returns a 404 not found, the user
  will automatically fall back to trying a direct query. Therefore it is
  recommended that bridge users always set UpdateBridgesFromAuthority,
  since at worst it will delay their fetches a little bit and notify
  the bridge authority of the identity fingerprint (but not location)
  of their intended bridges.

3.5. Bridge descriptor retry schedule

  Bridge users try to fetch a descriptor for each bridge (using the
  steps in Section 3.4 above) on startup. Whenever they receive a
  bridge descriptor, they reschedule a new descriptor download for 1
  hour from then.

  If on the other hand it fails, they try again after 15 minutes for the
  first attempt, after 15 minutes for the second attempt, and after 60
  minutes for subsequent attempts.

  In 0.2.1.x we should come up with some smarter retry schedules.

3.6. Vidalia integration

  Vidalia 0.0.15 has a new checkbox in its Network config window called
  "My ISP blocks connections to the Tor network." Users who click that
  box change their configuration to:
    TunnelDirConns 1
    PreferTunneledDirConns 1

  Once the box is checked, there is also a section for adding bridge
  identifiers. When at least one bridge identifier is present, Vidalia
  also changes their config to:
    UseBridges 1
    UpdateBridgesFromAuthority 1
  and updates their Bridge config option accordingly.

3.7. When should we make TunnelDirConns default?

  Right now Tor's directory requests can be filtered on the network,
  and some tools used by Middle Eastern governments even do this. A user
  who wants to circumvent these filters should click the above box in
  Vidalia 0.0.15. But at what point should we make tunneled directory
  requests the default?

  Once proposal 124 (modified TLS handshake) is in place, we should
  consider doing the switch. This might even be in the 0.2.0.x timeframe.

</body></email><email><emailId>20071117222254</emailId><senderName>"Michael_google gmail_Gersten"</senderName><senderEmail>keybounce@gmail.com</senderEmail><timestampReceived>2007-11-17 22:22:54-0400</timestampReceived><subject>Re: bridge and bridge authority proposal</subject><body>

I want to see if I understand bridges and their uses correctly.

A bridge is a Tor node, that talks to the rest of the tor network, and
acts as an entry guard. However, unlike normal tor nodes/entry guards,
there is no public list of all bridges; instead, you have to know a
bridge's IP address, or identity key. There are central servers that
can be queried for a key, and will return an IP address, but without
some privately passed information, there is no tor.

The intent of bridges is to act like an HTTPS: server -- the
communication between entry node and bridge user looks just like an
secure web page. The idea is to hide that you are using Tor. For this,
they act, by default, on port 443 where possible. If not, they
currently use 9001.

If I understand that much, then my I suggest using 8000, or 8080, or
some other "user web server" port? 9001 is a normal tor port, and
easily blocked by someone trying to block tor.
</body></email><email><emailId>20071011001329</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-10-11 00:13:29-0400</timestampReceived><subject>Re: [or-cvs] r11855: let bridge authorities write bridge descriptors to their cac (tor/trunk/src/or)</subject><body>


On Wed, Oct 10, 2007 at 07:11:53PM -0400, arma@seul.org wrote:
&gt; Author: arma
&gt; Date: 2007-10-10 19:11:53 -0400 (Wed, 10 Oct 2007)
&gt; New Revision: 11855
&gt; 
&gt; Modified:
&gt;    tor/trunk/src/or/dirserv.c
&gt;    tor/trunk/src/or/routerlist.c
&gt; Log:
&gt; let bridge authorities write bridge descriptors to their
&gt; cached-descriptors* files.
&gt; 
&gt; nick, did i get this right?

This looks fine to me, except for two points:

  1) Your patch removes an assert from dirserv.c, in
     dirserv_add_multiple_descriptors().  It's checking for
     correctness in some fairly complicated code, so I'm putting it
     back in.

  2) The patch also changes the behavior of descriptors added via the
     control interface: previously, they were cached or not cached
     depending on their purpose.  Now, they're all cached.

     For compatibility, it's probably better to have the controller
     POSTDESC command take a cache=0/1 argument, and have the defaults
     mirror the old behavior.



-- 
Nick Mathewson

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20071013095016</emailId><senderName>Robert Hogan</senderName><senderEmail>robert@roberthogan.net</senderEmail><timestampReceived>2007-10-13 09:50:16-0400</timestampReceived><subject>Lock Control Port</subject><body>


This occurred to me this morning and I *think* it might be useful.

The dirty truth is that for the forseeable future many users will continue to 
leave authentication disabled in the interests of just getting things 
working, no matter how hard controllers try to force it down their throats 
and no matter how hard tor chides them for not enabling it.

While we're all still 'getting there', controllers could have the option of 
locking the control port if no auth mechanism is enabled, and even when it 
is. Given that users tend not to share installations and most run their 
controller concurrently with tor at all times this would be a useful fallback 
measure.

Patch below. Seems to work fine, though haven't tested it to death.


Index: src/or/control.c
===================================================================
--- src/or/control.c    (revision 11907)
+++ src/or/control.c    (working copy)
@@ -75,6 +75,8 @@
 static int authentication_cookie_is_set = 0;
 static char authentication_cookie[AUTHENTICATION_COOKIE_LEN];

+static int controlport_locked = 0;
+
 #define SHORT_NAMES 1
 #define LONG_NAMES 2
 #define ALL_NAMES (SHORT_NAMES|LONG_NAMES)
@@ -2553,6 +2555,13 @@
   tor_assert(conn-&gt;_base.state == CONTROL_CONN_STATE_OPEN ||
              conn-&gt;_base.state == CONTROL_CONN_STATE_NEEDAUTH);

+  if (conn-&gt;_base.state == CONTROL_CONN_STATE_NEEDAUTH &amp;&amp;
+      controlport_locked) {
+    connection_write_str_to_buf("514 Control Port Locked by Other User.\r\n", 
conn);
+    connection_mark_for_close(TO_CONN(conn));
+    return 0;
+  }
+
   if (!conn-&gt;incoming_cmd) {
     conn-&gt;incoming_cmd = tor_malloc(1024);
     conn-&gt;incoming_cmd_len = 1024;
@@ -2640,6 +2649,7 @@

   /* Quit is always valid. */
   if (!strcasecmp(conn-&gt;incoming_cmd, "QUIT")) {
+    controlport_locked = 0;
     connection_write_str_to_buf("250 closing connection\r\n", conn);
     connection_mark_for_close(TO_CONN(conn));
     return 0;
@@ -2711,6 +2721,12 @@
   } else if (!strcasecmp(conn-&gt;incoming_cmd, "PROTOCOLINFO")) {
     if (handle_control_protocolinfo(conn, data_len, args))
       return -1;
+  } else if (!strcasecmp(conn-&gt;incoming_cmd, "LOCK")) {
+    controlport_locked = 1;
+    connection_printf_to_buf(conn, "250 OK\r\n");
+  } else if (!strcasecmp(conn-&gt;incoming_cmd, "UNLOCK")) {
+    controlport_locked = 0;
+    connection_printf_to_buf(conn, "250 OK\r\n");
   } else {
     connection_printf_to_buf(conn, "510 Unrecognized command \"%s\"\r\n",
                              conn-&gt;incoming_cmd);
Index: doc/spec/control-spec.txt
===================================================================
--- doc/spec/control-spec.txt   (revision 11907)
+++ doc/spec/control-spec.txt   (working copy)
@@ -813,6 +813,22 @@

   [PROTOCOLINFO was not supported before Tor 0.2.0.5-alpha.]

+3.22. LOCK/UNLOCK
+
+  The syntax is:
+    "LOCK" CRLF
+    "UNLOCK" CRLF
+
+  The server reply format is:
+    "250 OK" CRLF
+
+  The "LOCK" command prevents anyone else from interacting with Tor through 
the
+  control port while the current session is open. Controllers should use this
+  command when Tor is not configured with an authentication mechanism by the 
user.
+  When this command is used other users will receive the message '514 Control 
Port
+  Locked by Other User' when they attempt to authenticate.
+  The "UNLOCK" command opens the control port to other users again.
+
 4. Replies

   Reply codes follow the same 3-character format as used by SMTP, with the


["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20071013202701</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-10-13 20:27:01-0400</timestampReceived><subject>Re: Lock Control Port</subject><body>

On Sat, Oct 13, 2007 at 10:50:16AM +0100, Robert Hogan wrote:
&gt; While we're all still 'getting there', controllers could have the option of 
&gt; locking the control port if no auth mechanism is enabled, and even when it 
&gt; is. Given that users tend not to share installations and most run their 
&gt; controller concurrently with tor at all times this would be a useful fallback 
&gt; measure.

Why not have your controller enable authentication when it connects and
doesn't like what it finds? If you want, you can then disable it when
you disconnect.

This approach would seem to have all the same properties of your
lock/unlock without any new commands or code.

--Roger

</body></email><email><emailId>20071010225018</emailId><senderName>Peter Palfrader</senderName><senderEmail>peter@palfrader.org</senderEmail><timestampReceived>2007-10-10 22:50:18-0400</timestampReceived><subject>Proposal: autonaming</subject><body>

Filename: xxx-autonaming.txt
Title: Naming authorities automatically create bindings
Version: $Revision$
Last-Modified: $Date$
Author: Peter Palfrader
Created: 2007-10-11
Status: Open

Overview:

  Tor's directory authorities can give certain servers a "Named" flag
  in the network-status entry, when they want to bind that nickname to
  that identity key. This allows clients to specify a nickname rather
  than an identity fingerprint and still be certain they're getting the
  "right" server.

  Authority operators name a server by adding their nickname and
  identity fingerprint to the 'approved-routers' file.  Historically
  being listed in the file was required for a router, at first for being
  listed in the directory at all, and later in order to be used by
  clients as a first or last hop of a circuit.

  Adding identities to the list of named routers so far has been a
  manual, time consuming, and boring job.  Given that and the fact that
  the Tor network works just fine without named routers the last
  authority to keep a current binding list stopped updating it well over
  half a year ago.

  Naming, if it were done, would serve a useful purpose however in that
  users can have a reasonable expectation that the exit server Bob they
  are using in their http://www.google.com.bob.exit/ URL is the same
  Bob every time.

Proposal:
  I propose that identity&lt;-&gt;name binding be completely automated:

  New bindings should be added after the router has been around for a
  bit and their name has not been used by other routers, similarly names
  that have not appeared on the network for a long time should be freed
  in case a new router wants to use it.

  The following rules are suggested:
  i) If a named router has not been online for half a year, the
     identity&lt;-&gt;name binding for that name is removed.  The nickname
     is free to be taken by other routers now.
  ii) If a router claims a certain nickname and
       a) has been on the network for at least two weeks, and
       b) that nickname is not yet linked to a different router, and
       c) no other router has wanted that nickname in the last month,
      a new binding should be created for this router and its desired
      nickname.

 This automaton does not necessarily need to live in the Tor code, it
 can do its job just as well when it's an external tool.

-- 
                           |  .''`.  ** Debian GNU/Linux **
      Peter Palfrader      | : :' :      The  universal
 http://www.palfrader.org/ | `. `'      Operating System
                           |   `-    http://www.debian.org/
</body></email><email><emailId>20071126023407</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-11-26 02:34:07-0400</timestampReceived><subject>Re: bridge and bridge authority proposal</subject><body>

On Sat, Nov 17, 2007 at 02:22:54PM -0800, Michael_google gmail_Gersten wrote:
&gt; A bridge is a Tor node, that talks to the rest of the tor network, and
&gt; acts as an entry guard. However, unlike normal tor nodes/entry guards,
&gt; there is no public list of all bridges; instead, you have to know a
&gt; bridge's IP address, or identity key. There are central servers that
&gt; can be queried for a key, and will return an IP address, but without
&gt; some privately passed information, there is no tor.

Right.

&gt; The intent of bridges is to act like an HTTPS: server -- the
&gt; communication between entry node and bridge user looks just like an
&gt; secure web page. The idea is to hide that you are using Tor. For this,
&gt; they act, by default, on port 443 where possible. If not, they
&gt; currently use 9001.

Right. (Actually, it's 443 on Windows and 9001 on other platforms
currently.)

&gt; If I understand that much, then my I suggest using 8000, or 8080, or
&gt; some other "user web server" port? 9001 is a normal tor port, and
&gt; easily blocked by someone trying to block tor.

I still think the long-term fix is described in Section 1.7 of
http://www.torproject.org/svn/trunk/doc/spec/proposals/125-bridges.txt

But you're right, the short-term fix should be to stop using such an
obvious port. In Vidalia, the default settings for relays are the same
whether it's a public relay or a bridge relay. Should we change Vidalia's
default ORPort on non-Windows platforms to 8080?

Thanks,
--Roger

</body></email><email><emailId>20071129124955</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-11-29 12:49:55-0400</timestampReceived><subject>Re: bridge and bridge authority proposal</subject><body>

On Sun, Nov 11, 2007 at 03:54:52PM -0500, Roger Dingledine wrote:
&gt; 1.2. Defining DirPort
&gt; 
&gt;   Bridges need to answer BEGIN_DIR requests, both so they can answer
&gt;   "/server/authority" questions ("what's your descriptor?") and so they
&gt;   can supply their bridge users with cached copies of all the various
&gt;   Tor network information.
&gt; 
&gt;   Right now (0.2.0.11-alpha) we require that bridges turn their DirPort on
&gt;   -- which means both that we answer BEGIN_DIR requests and that we fetch
&gt;   and cache directory information in an aggressive way like other servers.
&gt; 
&gt;   But:
&gt;   a) we don't enforce that DirPort is on, since it's not clear how to
&gt;   detect if the user meant to be a bridge. So it's easy to set up a bridge
&gt;   relay that silently refuses BEGIN_DIR requests and is thus useless.
&gt;   b) We don't actually care if they have an open or reachable DirPort. So
&gt;   at some point we should separate having an open DirPort from answering
&gt;   directory questions. Which leads to:
&gt;   c) We need to investigate if there are any anonymity worries with
&gt;   answering BEGIN_DIR requests when our DirPort is off. If there aren't,
&gt;   we should drop the DirPort requirement.
&gt; 
&gt;   I claim that we don't open any new attacks by answering BEGIN_DIR
&gt;   questions when DirPort is off: it's still a fine question to ask what
&gt;   partitioning attacks there are when you can query a Tor client about
&gt;   its current directory opinions, but these attacks already exist when
&gt;   DirPort is on.
&gt; 
&gt;   We need to answer this issue in 0.2.0.x.

On more thought, I think we should fix this by adding a new config option
that all bridges should set: "BridgeRelay 1"

When this is set, Tor automatically acts like a dir cache, whether or
not DirPort is set, and it automatically answers BEGIN_DIR questions
whether or not DirPort is set.

Being explicit about whether we mean to be a bridge relay will also come
in handy when we want to do other activities that bridges should do,
if any more instances like this come up.

(This still leaves issue "c" above unresolved. We should leave that for
0.2.1.x to solve, but we really ought to resolve it.)

I'll patch the proposal and the code, uhm, soon. :)

--Roger

</body></email><email><emailId>20071129125241</emailId><senderName>Peter Palfrader</senderName><senderEmail>peter@palfrader.org</senderEmail><timestampReceived>2007-11-29 12:52:41-0400</timestampReceived><subject>Re: bridge and bridge authority proposal</subject><body>

&gt; On more thought, I think we should fix this by adding a new config option
&gt; that all bridges should set: "BridgeRelay 1"
&gt; 
&gt; When this is set, Tor automatically acts like a dir cache, whether or
&gt; not DirPort is set, and it automatically answers BEGIN_DIR questions
&gt; whether or not DirPort is set.

Be careful about how we fetch the directory tho.  Else watching who
fetches server descriptors at the authorities becomes a good way to find
bridges.

Peter
-- 
                           |  .''`.  ** Debian GNU/Linux **
      Peter Palfrader      | : :' :      The  universal
 http://www.palfrader.org/ | `. `'      Operating System
                           |   `-    http://www.debian.org/
</body></email><email><emailId>20071004150913</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-10-04 15:09:13-0400</timestampReceived><subject>Proposal: Network status entries need a new Unnamed flag</subject><body>

Filename: xxx-unnamed-flag.txt
Title: Network status entries need a new Unnamed flag
Version: $Revision$
Last-Modified: $Date$
Author: Roger Dingledine
Created: 04-Oct-2007
Status: Open

Overview:

  Tor's directory authorities can give certain servers a "Named" flag
  in the network-status entry, when they want to bind that nickname to
  that identity key. This allows clients to specify a nickname rather
  than an identity fingerprint and still be certain they're getting the
  "right" server. As dir-spec.txt describes it,

    Name X is bound to identity Y if at least one binding directory lists
    it, and no directory binds X to some other Y'.

  In practice, clients can refer to servers by nickname whether they are
  Named or not; if they refer to nicknames that aren't Named, a complaint
  shows up in the log asking them to use the identity key in the future
  --- but it still works.

  The problem? Imagine a Tor server with nickname Bob. Bob and his
  identity fingerprint are registered in tor26's approved-routers
  file, but none of the other authorities registered him. Imagine
  there are several other unregistered servers also with nickname Bob
  ("the imposters").

  While Bob is online, all is well: a) tor26 gives a Named flag to
  the real one, and refuses to list the other ones; and b) the other
  authorities list the imposters but don't give them a Named flag. Clients
  who have all the network-statuses can compute which one is the real Bob.

  But when the real Bob disappears and his descriptor expires? tor26
  continues to refuse to list any of the imposters, and the other
  authorities continue to list the imposters. Clients don't have any
  idea that there exists a Named Bob, so they can ask for server Bob and
  get one of the imposters. (A warning will also appear in their log,
  but so what.)

The stopgap solution:

  tor26 should start accepting and listing the imposters, but it should
  assign them a new flag: "Unnamed". This would produce three cases from
  the client perspective:

  1) A unique Bob is listed as Named, and nobody lists that Bob as
  Unnamed. Clients can refer to Bob by nickname and be confident.

  2) Every Bob is listed by some authority as Unnamed. Clients asking
  for Bob should get a warning in the log and their request should fail
  ("no such router").

  3) At least one Bob is not listed by any authorities as Unnamed, but
  there is no unique Named Bob. In this case we do what we did before
  (currently "warn but allow it").

Problems not solved by this stopgap:

  If tor26 is the only authority that provides a binding for Bob, when
  tor26 goes offline we're back in our previous situation -- the imposters
  can be referenced with a mere ignorable warning in the client's log.

  If some other authority Names a different Bob, and tor26 goes offline,
  then that other Bob becomes the unique Named Bob.

  So be it. We should try to solve these one day, but there's no clear way
  to do it that doesn't destroy usability in other ways, and if we want
  to get the Unnamed flag into v3 network statuses we should add it soon.

Other benefits:

  This new flag will allow people to operate servers that happen to have
  the same nickname as somebody who registered their server two years ago
  and left soon after. Right now there are dozens of nicknames that are
  registered on all three binding directory authorities, yet haven't been
  running for years. While it's bad that these nicknames are effectively
  blacklisted from the network, the really bad part is that this logic
  is really unintuitive to prospective new server operators.

</body></email><email><emailId>20071004163604</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-10-04 16:36:04-0400</timestampReceived><subject>Re: Proposal: Network status entries need a new Unnamed flag</subject><body>


On Thu, Oct 04, 2007 at 11:09:13AM -0400, Roger Dingledine wrote:
&gt; Filename: xxx-unnamed-flag.txt
&gt; Title: Network status entries need a new Unnamed flag

Added as proposal 122.

--=20
Nick Mathewson

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20071009224419</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-10-09 22:44:19-0400</timestampReceived><subject>Re: Proposal: Network status entries need a new Unnamed flag</subject><body>

On Thu, Oct 04, 2007 at 11:09:13AM -0400, Roger Dingledine wrote:
&gt; The stopgap solution:
&gt; 
&gt;   tor26 should start accepting and listing the imposters, but it should
&gt;   assign them a new flag: "Unnamed". This would produce three cases from
&gt;   the client perspective:
&gt; 
&gt;   1) A unique Bob is listed as Named, and nobody lists that Bob as
&gt;   Unnamed. Clients can refer to Bob by nickname and be confident.
&gt; 
&gt;   2) Every Bob is listed by some authority as Unnamed. Clients asking
&gt;   for Bob should get a warning in the log and their request should fail
&gt;   ("no such router").
&gt; 
&gt;   3) At least one Bob is not listed by any authorities as Unnamed, but
&gt;   there is no unique Named Bob. In this case we do what we did before
&gt;   (currently "warn but allow it").

I brainstormed with weasel for a while, and we came up with the
following better explanation, which slightly changes the behavior:

PART ONE:

i) a router gets the Named flag in the v3 networkstatus if
  a) it's the only router with that nickname that has the Named flag
     out of all the votes, and
  b) no vote lists it as Unnamed
else,
ii) a router gets the Unnamed flag if
  a) some vote lists a different router with that nickname as Named, or
  b) at least one vote lists it as Unnamed, or
  c) there are other routers with the same nickname that are Unnamed
else,
iii) the router neither gets a Named nor an Unnamed flag.

(This whole proposal is meant only for v3 dir flags; we shouldn't try
to backport it to the v2 dir world.)

PART TWO:

Then client behavior is:

a) If there's a Bob with a Named flag, pick that one.
else b) If the Bobs don't have the Unnamed flag (notice that they should
either all have it, or none), pick one of them and warn.
else c) They all have the Unnamed flag -- no router found.

PART THREE:

Another point to notice is if tor26 names Bob(1), doesn't know about
Bob(2), but moria lists Bob(2). Then Bob(2) doesn't get an Unnamed flag
even if it should (and Bob(1) is not around).

Right now, in v2 dirs, the case where an authority doesn't know about
a server but the other authorities do know is rare. That's because
authorities periodically ask for other networkstatuses and then fetch
descriptors that are missing.

With v3, if that window occurs at the wrong time, it is extended for the
entire period. We could solve this by making the voting more complex,
but that doesn't seem worth it.


I'll update the proposal in svn to reflect these changes.

--Roger

</body></email><email><emailId>20071009230854</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-10-09 23:08:54-0400</timestampReceived><subject>Re: Proposal: Network status entries need a new Unnamed flag</subject><body>


On Tue, Oct 09, 2007 at 06:44:19PM -0400, Roger Dingledine wrote:
&gt; On Thu, Oct 04, 2007 at 11:09:13AM -0400, Roger Dingledine wrote:
&gt; &gt; The stopgap solution:
&gt; &gt; 
&gt; &gt;   tor26 should start accepting and listing the imposters, but it should
&gt; &gt;   assign them a new flag: "Unnamed". This would produce three cases from
&gt; &gt;   the client perspective:
&gt; &gt; 
&gt; &gt;   1) A unique Bob is listed as Named, and nobody lists that Bob as
&gt; &gt;   Unnamed. Clients can refer to Bob by nickname and be confident.
&gt; &gt; 
&gt; &gt;   2) Every Bob is listed by some authority as Unnamed. Clients asking
&gt; &gt;   for Bob should get a warning in the log and their request should fail
&gt; &gt;   ("no such router").
&gt; &gt; 
&gt; &gt;   3) At least one Bob is not listed by any authorities as Unnamed, but
&gt; &gt;   there is no unique Named Bob. In this case we do what we did before
&gt; &gt;   (currently "warn but allow it").
&gt; 
&gt; I brainstormed with weasel for a while, and we came up with the
&gt; following better explanation, which slightly changes the behavior:
&gt; 
&gt; PART ONE:
&gt; 
&gt; i) a router gets the Named flag in the v3 networkstatus if
&gt;   a) it's the only router with that nickname that has the Named flag
&gt;      out of all the votes, and
&gt;   b) no vote lists it as Unnamed
&gt; else,
&gt; ii) a router gets the Unnamed flag if
&gt;   a) some vote lists a different router with that nickname as Named, or
&gt;   b) at least one vote lists it as Unnamed, or
&gt;   c) there are other routers with the same nickname that are Unnamed
&gt; else,
&gt; iii) the router neither gets a Named nor an Unnamed flag.

This makes a lot more sense to me.

&gt; (This whole proposal is meant only for v3 dir flags; we shouldn't try
&gt; to backport it to the v2 dir world.)
&gt; 
&gt; PART TWO:
&gt; 
&gt; Then client behavior is:
&gt; 
&gt; a) If there's a Bob with a Named flag, pick that one.
&gt; else b) If the Bobs don't have the Unnamed flag (notice that they should
&gt; either all have it, or none), pick one of them and warn.
&gt; else c) They all have the Unnamed flag -- no router found.

Also agreed.

&gt; PART THREE:
&gt; 
&gt; Another point to notice is if tor26 names Bob(1), doesn't know about
&gt; Bob(2), but moria lists Bob(2). Then Bob(2) doesn't get an Unnamed flag
&gt; even if it should (and Bob(1) is not around).
&gt; 
&gt; Right now, in v2 dirs, the case where an authority doesn't know about
&gt; a server but the other authorities do know is rare. That's because
&gt; authorities periodically ask for other networkstatuses and then fetch
&gt; descriptors that are missing.
&gt; 
&gt; With v3, if that window occurs at the wrong time, it is extended for the
&gt; entire period. We could solve this by making the voting more complex,
&gt; but that doesn't seem worth it.
&gt; 
&gt; 
&gt; I'll update the proposal in svn to reflect these changes.

Okay.

Another thing to consider is that this means we need vote protocol
migration.  I'll spec that.  Do you think it needs a proposal?  The
basic problem is that, since Unnamed and Named are set differently
from other flags, existing authorities won't generate them properly,
and so old authorities and authorities that implement proposal 122
will generate different consensuses, and so no consensus will get all
the signatures.  The solution is for each authority to list in its
vote a list of "voting protocols" that it knows how to generate
consensuses with.  When generating the consensus, the authorities use
the highest-numbered protocol listed by at least 2/3 of the votes.

We could just write the code and upgrade the 2 current v3 authorities
simultaneously.  But IMO it's a good idea to get this solved now,
because if we need to add any new voting rules once the whole v3
directory system is fully deployed, we'll be in rather a bit of hurt.

yrs,
-- 
Nick Mathewson

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20071009235112</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-10-09 23:51:12-0400</timestampReceived><subject>Re: Proposal: Network status entries need a new Unnamed flag</subject><body>

On Tue, Oct 09, 2007 at 07:08:54PM -0400, Nick Mathewson wrote:
&gt; Another thing to consider is that this means we need vote protocol
&gt; migration.  I'll spec that.  Do you think it needs a proposal?

Only if think you might have gotten it wrong. ;)

&gt;  The
&gt; basic problem is that, since Unnamed and Named are set differently
&gt; from other flags, existing authorities won't generate them properly,
&gt; and so old authorities and authorities that implement proposal 122
&gt; will generate different consensuses, and so no consensus will get all
&gt; the signatures.  The solution is for each authority to list in its
&gt; vote a list of "voting protocols" that it knows how to generate
&gt; consensuses with.  When generating the consensus, the authorities use
&gt; the highest-numbered protocol listed by at least 2/3 of the votes.

Ok.

&gt; We could just write the code and upgrade the 2 current v3 authorities
&gt; simultaneously.  But IMO it's a good idea to get this solved now,
&gt; because if we need to add any new voting rules once the whole v3
&gt; directory system is fully deployed, we'll be in rather a bit of hurt.

Patching the two running v3 authorities for this particular issue,
and getting voting protocol versioning in place for the future, seem
orthogonal to me. Meaning: feel free to do them in whatever order
seems best.

Thanks,
--Roger

</body></email><email><emailId>20071012145540</emailId><senderName>Peter Palfrader</senderName><senderEmail>peter@palfrader.org</senderEmail><timestampReceived>2007-10-12 14:55:40-0400</timestampReceived><subject>Re: Proposal: Network status entries need a new Unnamed flag</subject><body>

On Tue, 09 Oct 2007, Roger Dingledine wrote:

&gt; (This whole proposal is meant only for v3 dir flags; we shouldn't try
&gt; to backport it to the v2 dir world.)

Can we still list the unnamed routers in the v2 status, even without an
unnamed flag?  Because if not and I enable auto-naming on tor26 I'll stop
listing about 150 routers for using names that are already taken.

See http://asteria.noreply.org/~weasel/tor-named-nicks

Peter
-- 
                           |  .''`.  ** Debian GNU/Linux **
      Peter Palfrader      | : :' :      The  universal
 http://www.palfrader.org/ | `. `'      Operating System
                           |   `-    http://www.debian.org/
</body></email><email><emailId>20071012164659</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-10-12 16:46:59-0400</timestampReceived><subject>Re: Proposal: Network status entries need a new Unnamed flag</subject><body>


On Fri, Oct 12, 2007 at 04:55:40PM +0200, Peter Palfrader wrote:
&gt; On Tue, 09 Oct 2007, Roger Dingledine wrote:
&gt; 
&gt; &gt; (This whole proposal is meant only for v3 dir flags; we shouldn't try
&gt; &gt; to backport it to the v2 dir world.)
&gt; 
&gt; Can we still list the unnamed routers in the v2 status, even without an
&gt; unnamed flag?  Because if not and I enable auto-naming on tor26 I'll stop
&gt; listing about 150 routers for using names that are already taken.

That shouldn't be a problem ; the v2 status is generated pretty
independently from the v3 consensus.  I think it's best to leave v2
directories more or less alone and reserve new features for the v3
directory system only.

-- 
Nick Mathewson

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20071017224854</emailId><senderName>Steven Murdoch</senderName><senderEmail>tor+steven.murdoch@cl.cam.ac.uk</senderEmail><timestampReceived>2007-10-17 22:48:54-0400</timestampReceived><subject>Comments on Proposal 105 -- handshake-revision</subject><body>

Nick asked me to comment on proposal 105, which is on a revision to
the Tor handshake to add versioning, clock-skew detection and MitM
resistance:
 http://tor.eff.org/svn/trunk/doc/spec/proposals/105-handshake-revision.txt

First two fairly irrelevant points:

Currently NumVersions is both a number of bytes and number of
versions. Would it be neater to change the definition to be just
number of bytes? Then, in the unlikely event we move to &gt;1 byte per
version, the appropriate substring can be decoded. Leaving it as
NumVersions would mean decoding until either the right number of
versions has been reached, or the end of field has been reached.

What do you think about specifying supported version ranges rather
than versions? This relaxes the 380 version limit, but that should
never be a limiting factor. A more important constraint is which
option you think will be easier to implement.

Now some that are less bikeshedy:

The triggering of expecting versions is based on certificate content,
but by the time 105 is implemented, we will not be doing client
certificates. How should this be rephrased? One option is that the
initiator is identified by ciphersuite, and the responder by
certificate content. Another is that the initiator is identified by
the fact that it didn't send a cert (as it was not asked).

If a MitM delays all NETINFO cells sent to a victim, for a really
long time, the receiver will think it is skewed. This isn't a huge
deal, since all that will happen is the user will get a warning, but
it's awkward. A recipient of a NETINFO cell knows that it was sent no
earlier than when the recipient sent its TLS nonce (since the MAC
key depends on that). A node can thus view with suspicion NETINFO cell
received long after it sent it's nonce. Can we get access to this
timestamp (or an adequate alternative) though?

I would suggest the proposal specify precisely the behaviour of a node
on receiving the addresses in the NETINFO cell. Currently it is vague.
I also worry about a host behind NAT. It will send out the internal IP
address in the NETINFO cell, so will not match the IP address that the
receiver sees. How would this case be handled?

Steven.

-- 
w: http://www.cl.cam.ac.uk/users/sjm217/
</body></email><email><emailId>20071018162758</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-10-18 16:27:58-0400</timestampReceived><subject>Re: Comments on Proposal 105 -- handshake-revision</subject><body>


On Wed, Oct 17, 2007 at 11:48:54PM +0100, Steven Murdoch wrote:
&gt; Nick asked me to comment on proposal 105, which is on a revision to
&gt; the Tor handshake to add versioning, clock-skew detection and MitM
&gt; resistance:
&gt;  http://tor.eff.org/svn/trunk/doc/spec/proposals/105-handshake-revision.txt
&gt; 
&gt; First two fairly irrelevant points:
&gt; 
&gt; Currently NumVersions is both a number of bytes and number of
&gt; versions. Would it be neater to change the definition to be just
&gt; number of bytes? Then, in the unlikely event we move to &gt;1 byte per
&gt; version, the appropriate substring can be decoded. Leaving it as
&gt; NumVersions would mean decoding until either the right number of
&gt; versions has been reached, or the end of field has been reached.

This seems quite sensible.

&gt; What do you think about specifying supported version ranges rather
&gt; than versions? This relaxes the 380 version limit, but that should
&gt; never be a limiting factor. A more important constraint is which
&gt; option you think will be easier to implement.

I think ranges would be trickier to implement, and not terribly
necessary.

So far, we're still at "v1" for the OR connection protocol, even after
4 years, and we're only now considering a move to "v2".  In fairness,
we've had backward-compatibility flags days once or twice in the early
days (once to make cells bigger, and once to fix a broken crypto
implementation) but other than that we've managed to do migrations
while keeping older Tor versions compatible -- often long after they
ceased to be secure or maintained.

IMO, as long as we don't treat this proposal as license to mint a new
version for things we could just as well do compatibly, we shouldn't
expect to see hundreds of versions, much less hundreds of
simultaneously implemented versions, for a very long time.

With that, I declare that bikeshed should be painted mauve.

&gt; Now some that are less bikeshedy:
&gt; 
&gt; The triggering of expecting versions is based on certificate content,
&gt; but by the time 105 is implemented, we will not be doing client
&gt; certificates. How should this be rephrased? One option is that the
&gt; initiator is identified by ciphersuite, and the responder by
&gt; certificate content.

Agreed.

&gt;                       Another is that the initiator is identified by
&gt; the fact that it didn't send a cert (as it was not asked).
&gt;
&gt; If a MitM delays all NETINFO cells sent to a victim, for a really
&gt; long time, the receiver will think it is skewed. This isn't a huge
&gt; deal, since all that will happen is the user will get a warning, but
&gt; it's awkward. A recipient of a NETINFO cell knows that it was sent no
&gt; earlier than when the recipient sent its TLS nonce (since the MAC
&gt; key depends on that). A node can thus view with suspicion NETINFO cell
&gt; received long after it sent it's nonce. Can we get access to this
&gt; timestamp (or an adequate alternative) though?

Oh, this _is_ an interesting bug, and thanks for mentioning it!

Here's a simpler approach that requires less mucking about in the TLS
state: we know (by specification) that the other party won't send us a
NETINFO until after they have received our VERSIONS cell.  Thus, we
can remember when we sent VERSIONS, and not trust the skew information
if the NETINFO cell arrives a long time after we send VERSIONS.

(FWIW, the point of this timestamp is to detect large skews on the
order of half-hours to months.  I'm not sure the attacker can delay
the cell so long without triggering connections to time-out entirely.)

&gt; I would suggest the proposal specify precisely the behaviour of a node
&gt; on receiving the addresses in the NETINFO cell. Currently it is vague.
&gt; I also worry about a host behind NAT. It will send out the internal IP
&gt; address in the NETINFO cell, so will not match the IP address that the
&gt; receiver sees. How would this case be handled?

Hmm.  On consideration, reporting the address of the interface that
the connection is arriving at is pretty useless, and potentially a
security problem.  (Some people think that knowing a computer's IP
address tells outsiders too much about one's internal network.)

Probably it would be better to have the netinfo contain:
    The other host's apparent address
    This OR's *published* address (or null if this host isn't an OR)

This way, we can achieve both goals of this feature:

  [1] we can use what other people report as our apparent address as a
      last-ditch attempt to guess our address (assuming that enough
      trustworthy people report the same thing)

  [2] We can notice MITMs by realizing that the address we extended to
      is not the official address of this OR.

Of course, for [2], this proposal doesn't play nicely with proposal
118.  I'll try to patch proposal 105 today in a way that fixes the
problems you note and that is also compatible with 118.

many thanks,
-- 
Nick Mathewson

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20071019095804</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-10-19 09:58:04-0400</timestampReceived><subject>Re: Comments on Proposal 105 -- handshake-revision</subject><body>

On Wed, Oct 17, 2007 at 11:48:54PM +0100, Steven Murdoch wrote:
&gt; I would suggest the proposal specify precisely the behaviour of a node
&gt; on receiving the addresses in the NETINFO cell. Currently it is vague.
&gt; I also worry about a host behind NAT. It will send out the internal IP
&gt; address in the NETINFO cell, so will not match the IP address that the
&gt; receiver sees. How would this case be handled?

It's been a while since we wrote that MITM part. I'm not sure I still
believe in it.

The primary vulnerability we worry about is due to the fact that Tor
combines multiple circuits inside the same TCP connection, and it assumes
it's got the right connection just based on the fellow on the other side
having the right key.

So the attack is that a malicious client somewhere guesses that there's no
connection yet between server1 and server2, builds a circuit to server1,
then asks server1 to extend the circuit to decoyIP:decoyPort specifying
the identity fingerprint of server2. Then decoyIP turns out to just
bounce traffic to server2. The handshake works, and everybody's happy
-- except the new Alice who comes along and asks server1 to extend her
circuit to server2, at which point server1 says "oh, I already have a
connection to server2, I'll just use that." (Alice also has problems if
she builds a circuit to server2 and asks it to extend to server1.)

One answer is this complex NETINFO cell that tells both sides who they're
actually talking to in an authenticated manner.

How about if we just remember the IP address we connected to (or the
IP address we got the connection from), and when somebody asks us to
extend to a given identity fingerprint and he specifies an IP:port that
doesn't currently have a connection open, then we open a new one. That
way we refuse to combine circuits that think they're going to different
places, but we're free to combine circuits that think they're going to
the same place.

We become vulnerable to an attacker who actually can redirect traffic
en route between server1 and server2, but we're in bad shape against
this attacker anyway.

This "you wanted server2, I see you got his IP address wrong, I'll do what
you meant instead of what you asked for" behavior is designed, if I recall
correctly, to tolerate servers on dynamic IP addresses, so even if you
have an old descriptor it still might work. It's also left-over from the
days of "server twins", where two servers in different locations shared
the same identity key. The design choice is 5 years old at this point,
and probably should have been taken out when we took out server twins.

(I don't know how our NETINFO cell is going to handle this situation any
better, because there's no easy way to distinguish between a malicious
neighbor with a similar IP address and a server that just got a new
lease.)

If we ever give servers the ability to advertise multiple IP addresses,
they should specify a "primary one", and clients should ask for this
primary one when sending an extend cell from one server to another
server. (I make the assumption that multiple advertised IP addresses
are helpful only to clients who are trying to get around some firewall.)
(I also make the assumption that IP address is all that matters -- if
the attacker shares the host computer and can "be" other ports on the
legitimate IP address, more power to him.)

Ok, the next stumbling block: what about those servers who advertise one
address yet bind to a different one for outbound connections? One option
for them would be to have them detect the address they actually use,
and write it in their descriptor. Then server1 can make an exception for
"well, you asked for server2's primary IP address, but I see I have a
connection to another one that server2 promised was acceptable too. You'll
be ok with that."

(If I'm not mistaken, we would need to do something like this for the
NETINFO approach too, since we'll have exactly the same problem, right?)

Ok, here's one advantage of the NETINFO approach, in the case of servers
that have multiple IP addresses: the NETINFO cell can communicate all
of these IP addresses. Otherwise we either divide the anonymity set
(in practice, there will be one TCP connection for circuits initiated by
server1 to server2, and a second TCP connection for circuits initiated by
server2 to server1), or we assume that server1 has a copy of server2's
descriptor so he can learn that both IP addresses are legit. (As a
hack, we could just declare that any IP address on the same /24 as the
official one is safe enough. This may cut down on the number of duplicate
connections enough that we're ok with what's left.) I'm guessing that
since we've been trying to maintain the "servers don't need to know about
the network" goal, the NETINFO cell approach will end up winning. Nick,
was this what you've been thinking all along, or did I just clarify some
of our assumptions?

--Roger

</body></email><email><emailId>20071020060216</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-10-20 06:02:16-0400</timestampReceived><subject>Re: Comments on Proposal 105 -- handshake-revision</subject><body>

On Thu, Oct 18, 2007 at 12:27:58PM -0400, Nick Mathewson wrote:
&gt; Hmm.  On consideration, reporting the address of the interface that
&gt; the connection is arriving at is pretty useless, and potentially a
&gt; security problem.  (Some people think that knowing a computer's IP
&gt; address tells outsiders too much about one's internal network.)
&gt; 
&gt; Probably it would be better to have the netinfo contain:
&gt;     The other host's apparent address
&gt;     This OR's *published* address (or null if this host isn't an OR)
&gt; 
&gt; This way, we can achieve both goals of this feature:
&gt; 
&gt;   [1] we can use what other people report as our apparent address as a
&gt;       last-ditch attempt to guess our address (assuming that enough
&gt;       trustworthy people report the same thing)
&gt; 
&gt;   [2] We can notice MITMs by realizing that the address we extended to
&gt;       is not the official address of this OR.
&gt; 
&gt; Of course, for [2], this proposal doesn't play nicely with proposal
&gt; 118.  I'll try to patch proposal 105 today in a way that fixes the
&gt; problems you note and that is also compatible with 118.

Here's a slight modification and some more details, based on my other
recent post in this thread:

The netinfo cell should contain:
a) The other host's apparent address -- in the case of the initiator,
it's the address we connected to; in the case of the recipient, it's
the address the connection is from.
b) A set of all IP addresses that are officially associated with the
server sending the netinfo cell.

When the connection initiator gets a netinfo cell, he makes sure that
the address he thought he connected to is among the set of IP addresses
in part b. When the connection recipient gets a netinfo cell, he makes
sure that the apparent IP address of the fellow on the other side is
one of the ones in part b. Notice that we're ignoring item a) above
in making these decisions.

And here's where it gets interesting: the current proposal 105 says that
if the IP address doesn't look right, we should close the connection
because we should suspect a mitm. But really, a) the circuit that caused
us to open that connection really did ask for that IP address, and b)
sometimes the IP address lists won't be perfect, and we should tolerate
this rather than mysteriously breaking. So rather than closing that
connection, we should mark it as not_to_primary_address and then treat
it as a normal connection -- so it will continue to work, but we won't
use it for any new circuits that want a "real" connection to that server.

Ok, after having written this, I notice that Nick snuck in a revision to
proposal 118 on Oct 9, though he didn't mention it on or-dev :)
http://archives.seul.org/or/cvs/Oct-2007/msg00103.html
This "suggested rule" appears to match my assumption in my previous post,
which was to be smart when server1 has a descriptor available for server2,
and otherwise be conservative and open a new connection. But doesn't
the NETINFO cell plan mean we don't need to look at (or rely on having)
descriptors at all?

And lest I sound like I've made up my mind: there are an increasing number
of design decisions that seem like they'll be a lot easier if we can
assume that most servers have descriptors of most other servers. It would
mean not needing NETINFO cells at all -- just find a descriptor signed
by the key that's on the other end of the connection, and compare the IP
address to the list of acceptable IP addresses in the descriptor. Maybe
it's time to admit that assumption before we add yet more complexity?

I am leaning toward "no, we'll never succeed at scaling if we make
design decisions that force every server to know about every server."
Anybody else have an opinion?

--Roger

</body></email><email><emailId>20071020182508</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-10-20 18:25:08-0400</timestampReceived><subject>Re: Comments on Proposal 105 -- handshake-revision</subject><body>


On Fri, Oct 19, 2007 at 05:58:04AM -0400, Roger Dingledine wrote:
 [...]
&gt; One answer is this complex NETINFO cell that tells both sides who they're
&gt; actually talking to in an authenticated manner.
&gt; 
&gt; How about if we just remember the IP address we connected to (or the
&gt; IP address we got the connection from), and when somebody asks us to
&gt; extend to a given identity fingerprint and he specifies an IP:port that
&gt; doesn't currently have a connection open, then we open a new one. That
&gt; way we refuse to combine circuits that think they're going to different
&gt; places, but we're free to combine circuits that think they're going to
&gt; the same place.

This approach would work, but it (as you note below) it's rather
over-conservative with respect to proposal 118 (multiple ORPorts).

&gt; We become vulnerable to an attacker who actually can redirect traffic
&gt; en route between server1 and server2, but we're in bad shape against
&gt; this attacker anyway.

Right.  That's not the attack we're trying to stop here.

&gt; This "you wanted server2, I see you got his IP address wrong, I'll do what
&gt; you meant instead of what you asked for" behavior is designed, if I recall
&gt; correctly, to tolerate servers on dynamic IP addresses, so even if you
&gt; have an old descriptor it still might work. It's also left-over from the
&gt; days of "server twins", where two servers in different locations shared
&gt; the same identity key. The design choice is 5 years old at this point,
&gt; and probably should have been taken out when we took out server
&gt; twins.

There was another reason to look up connections by ID besides "server
twins": it's not unheard of for a server to wind up with a network
configuration such that the TCP streams it opens seem to originate
from an IP address other than the IP address you use to connect to the
server.

[Ah.  You talk about this below.]

(Also, there's proposal 118, which you talk about below.)

 [...]
&gt; Ok, the next stumbling block: what about those servers who advertise one
&gt; address yet bind to a different one for outbound connections? One option
&gt; for them would be to have them detect the address they actually use,
&gt; and write it in their descriptor. Then server1 can make an exception for
&gt; "well, you asked for server2's primary IP address, but I see I have a
&gt; connection to another one that server2 promised was acceptable too. You'll
&gt; be ok with that."
&gt; 
&gt; (If I'm not mistaken, we would need to do something like this for the
&gt; NETINFO approach too, since we'll have exactly the same problem,
&gt; right?)

I believe so, but we've wanted to detect outgoing addresses for a
while, in order to make tordnsel work better.

&gt; Ok, here's one advantage of the NETINFO approach, in the case of servers
&gt; that have multiple IP addresses: the NETINFO cell can communicate all
&gt; of these IP addresses.

Right.

&gt;                          Otherwise we either divide the anonymity set
&gt; (in practice, there will be one TCP connection for circuits initiated by
&gt; server1 to server2, and a second TCP connection for circuits initiated by
&gt; server2 to server1), or we assume that server1 has a copy of server2's
&gt; descriptor so he can learn that both IP addresses are legit.  (As a
&gt; hack, we could just declare that any IP address on the same /24 as the
&gt; official one is safe enough. This may cut down on the number of duplicate
&gt; connections enough that we're ok with what's left.)

Ewww.  I don't like that hack at all.

&gt;    I'm guessing that
&gt; since we've been trying to maintain the "servers don't need to know about
&gt; the network" goal, the NETINFO cell approach will end up winning. Nick,
&gt; was this what you've been thinking all along, or did I just clarify some
&gt; of our assumptions?

Your email raises a lot of good points, and I'm not sure how many of
them you're wondering if I was "thinking all along".  Let me enumerate
a few things I do agree with:
  - I generally agree with the "list *all* the addresses we think we
    have in the NETINFO cell" approach.

  - I agree that the current policy of "use an existing OR connection
    if the ID matches" is too loose, and needs to be changed to avoid
    MITM.  The conservative fallback position of "use an existing OR
    connection if the ID *and* the IP match the requested ID and IP"
    however, runs into problems like those we outline above.

  - Right now, I think the right approach is probably something like
    "use an existing OR connection if the ID matches, and ANY of the
    following conditions hold:
       - The IP matches the requested IP.
       - We know that the IP we're using is canonical because it was
         listed in the NETINFO cell.
       - We know that the IP we're using is canonical because it was
         listed in the server descriptor."

    The implementation is pretty straightforward: give each OR
    connection a "canonical IP" bit, and set the bit whenever the IP
    in the NETINFO or the serverdesc implies that we're connected to
    an "official" address for the router.  Only extend a circuit over
    an existing connection if the ID and the IP match, or if the
    IDmatches and the IP is "canonical".

    In other words, we should default to doing the "paranoid" thing
    (match by ID and IP).  But since the "paranoid" thing partitions
    circuits and proliferates connections (this wasting sockets), we
    should use NETINFO *and* descriptors to notice when it is safe to
    do the less-paranoid thing (match by ID only).

  - You're right (in your other mail) that we shouldn't close a
    connection just for having a mismatched IP.  I must have been
    having a bad brain day when I said we should.

I think this is different from what I said in my last mail, and
different from what 105 says now, and different from 118 too.  It's a
lot closer to what you say in the mail you sent after this one.

peace,
-- 
Nick Mathewson

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20071012175324</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-10-12 17:53:24-0400</timestampReceived><subject>Re: Proposal: Network status entries need a new Unnamed flag</subject><body>

On Fri, Oct 12, 2007 at 12:46:59PM -0400, Nick Mathewson wrote:
&gt; &gt; &gt; (This whole proposal is meant only for v3 dir flags; we shouldn't try
&gt; &gt; &gt; to backport it to the v2 dir world.)
&gt; &gt; 
&gt; &gt; Can we still list the unnamed routers in the v2 status, even without an
&gt; &gt; unnamed flag?  Because if not and I enable auto-naming on tor26 I'll stop
&gt; &gt; listing about 150 routers for using names that are already taken.
&gt; 
&gt; That shouldn't be a problem ; the v2 status is generated pretty
&gt; independently from the v3 consensus.  I think it's best to leave v2
&gt; directories more or less alone and reserve new features for the v3
&gt; directory system only.

If Peter adds many lines to his approved-routers file (as he is suggesting
he'll do), then these will affect both v2 and v3 networkstatuses. If we
only have this Unnamed thing for v3, then the result is that Peter's v2
authority will stop listing about 15% of the network. This is bad.

Unless we add a notion of Naming that applies only to v3.

Hm.
--Roger

</body></email><email><emailId>20071018185747</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-10-18 18:57:47-0400</timestampReceived><subject>Re: Proposal: Network status entries need a new Unnamed flag</subject><body>


On Fri, Oct 12, 2007 at 01:53:24PM -0400, Roger Dingledine wrote:
&gt; On Fri, Oct 12, 2007 at 12:46:59PM -0400, Nick Mathewson wrote:
&gt; &gt; &gt; &gt; (This whole proposal is meant only for v3 dir flags; we shouldn't try
&gt; &gt; &gt; &gt; to backport it to the v2 dir world.)
&gt; &gt; &gt; 
&gt; &gt; &gt; Can we still list the unnamed routers in the v2 status, even without an
&gt; &gt; &gt; unnamed flag?  Because if not and I enable auto-naming on tor26 I'll stop
&gt; &gt; &gt; listing about 150 routers for using names that are already taken.
&gt; &gt; 
&gt; &gt; That shouldn't be a problem ; the v2 status is generated pretty
&gt; &gt; independently from the v3 consensus.  I think it's best to leave v2
&gt; &gt; directories more or less alone and reserve new features for the v3
&gt; &gt; directory system only.
&gt; 
&gt; If Peter adds many lines to his approved-routers file (as he is suggesting
&gt; he'll do), then these will affect both v2 and v3 networkstatuses. If we
&gt; only have this Unnamed thing for v3, then the result is that Peter's v2
&gt; authority will stop listing about 15% of the network. This is bad.
&gt; 
&gt; Unless we add a notion of Naming that applies only to v3.

Now I get it.  I've looked through the 0.1.2.x code, and as near as
I can tell, nothing bad will happen if the Unnamed servers are listed
in 0.1.2.x alongside a Named variant.  There _is_ a problem if the
Named one is missing: as now, clients will react to the nickname by
warning and using one of the unnamed servers.  But that's as bad as
current behavior IMO.

Peter: would you like to patch the results of this thread into
proposal 122, so I can get started implementing it?

yrs,
-- 
Nick Mathewson

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20071129142742</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-11-29 14:27:42-0400</timestampReceived><subject>Re: bridge and bridge authority proposal</subject><body>

On Thu, Nov 29, 2007 at 01:52:41PM +0100, Peter Palfrader wrote:
&gt; &gt; On more thought, I think we should fix this by adding a new config option
&gt; &gt; that all bridges should set: "BridgeRelay 1"
&gt; &gt; 
&gt; &gt; When this is set, Tor automatically acts like a dir cache, whether or
&gt; &gt; not DirPort is set, and it automatically answers BEGIN_DIR questions
&gt; &gt; whether or not DirPort is set.
&gt; 
&gt; Be careful about how we fetch the directory tho.  Else watching who
&gt; fetches server descriptors at the authorities becomes a good way to find
&gt; bridges.

Very good point.

This is an argument that Tors that have BridgeRelay enabled should use
dir caches for their updates (just like Tor clients do), and should use
the less aggressive dir update schedule (the one that Tor clients use,
not the one Tor relays use).

We could also take this opportunity to make Tors that have a DirPort
set but no ORPort set also use the caches and less aggressive schedule;
and to make Tors that have an ORPort and DirPort set but choose not to
advertise their DirPort (see decide_to_advertise_dirport() in router.c)
do that too. And Tors that haven't published their descriptor because
they haven't yet found themselves reachable. That would reduce load on
the directory authorities, especially as we grow.

But! There is a problem. See Section 1.4 of dir-spec.txt. There is a
set schedule for when authorities make the new consensus available,
when caches fetch it from the authorities, and when clients fetch it
from the caches. If bridge users are fetching from their bridges in the
same time slot that the bridges are fetching from the caches, then half
the time they'll do it in the wrong order.

So the follow-up question would be:
Can we further subdivide the interval when clients fetch the consensus,
so the "aggressive" clients fetch in the first half of that interval,
and the "subclients" fetch in the second half? Probably. As long as the
intervals are long enough.

We could also make it 3/4 and 1/4, for better fairness. But this still
raises the issue that over time we can distinguish a Tor client that
never asks in the last fraction of the interval. Does this mean that
*all* clients should fetch in only the first fraction of the interval,
to hide whether they're using this more aggressive schedule?

When we switch to directory guards, this will become less of an issue,
since the bridge will only be leaking to its directory guards whether
it's fetching the consensus on the aggressive schedule.

Should we instead have the bridge users lag behind by a whole interval?
That would imply having them use consensuses that are no longer valid.

As a last option, we could have bridges fetch a new consensus document
basically right as their current one is expiring. This would ensure that
the bridge has (with high probability, depending on clock skew) gotten
a new one, and it wouldn't cause much of a 'thundering herds' problem
so long as each bridge doesn't have that many simultaneous bridge users.

Finally, note that we're still not supporting any more levels of turtles
here besides the new one. That is, if we want to support people using
the bridge users as dir caches, we'd need to further subdivide that last
fraction of the interval, and so on for each new level of indirection.

--Roger

</body></email><email><emailId>20071120150417</emailId><senderName>Paul Syverson</senderName><senderEmail>syverson@itd.nrl.navy.mil</senderEmail><timestampReceived>2007-11-20 15:04:17-0400</timestampReceived><subject>Re: FEATURE IDEA: Hidden Directory Authorities</subject><body>

Hi Kyle,

Sorry swamped and crazy so can only give a partial answer. If you
are still unclear on something from me in a few weeks and I haven't
responded again, feel free to ping me again (directly, I don't
always catch something in any of the Tor mailing lists). Then iterate
that process a few weeks after that ;&gt;)

On Mon, Nov 19, 2007 at 12:29:53AM -0800, Kyle Williams wrote:
&gt; Any suggestions, questions, or comments are encouraged.
&gt; 
&gt; I know that Tor has the PrivateDir option, which uses an Onion Router
&gt; to make the request to the DA to retrieve updated cached-* documents.
&gt; However, this option will not
&gt; function without a pre-cached copy of the cached-routers documents
&gt; because it wouldn't know of an Onion Routers to tunnel the request
&gt; through.
&gt; Basically you need a pre-cached copy of cached-routers for PrivateDir
&gt; to work, right?
&gt; (Please correct me if I am wrong here.)
&gt; 
&gt; So the questions that entered my mind were:
&gt; * Could Directory Authorities use an .onion address instead of an IP
&gt; address if a pre-cached copy of cached-routers was distributed with
&gt; the initial download of Tor?
&gt; * Would this make the Directory Authorities more resistant to digital
&gt; &amp; physical attack?
&gt; * Are "guard" nodes[2] the same as "valet" nodes[1]?
&gt; The wording of "guard" nodes [2] sounds very similar to the concept of
&gt; "valet" nodes [1], but I'm not quite sure if these are the same.  Are
&gt; they?
&gt; 

No they're not the same. Guard nodes make it hard for someone to
identify you by just owning some small number of nodes and watching
you make connections over and over again until you use one of their
compromised nodes as a first hop. In [2] we were looking at using this
to attack hidden services and trying to see how far you could get
owning just one evil node in the network. But, as we noted if you own
more than one node, you can do the same thing to both ends of the
circuit to link source and destination. You can also do similar things
to play games with the choice of guard nodes (cf. "Low Resource
Routing Attacks Against Tor" in WPES'07).  Valet nodes do a bunch of
things. One is that they hide the introduction points from the
clients. Another is that they are part of making it much harder for
the introduction point to figure out the hidden service for which it's
an introduction point (I don't mean find the hidden service, I mean
hiding that going through that introduction point connects you to that
hidden service). BTW, the reference you should have had for valet
nodes is http://www.onion-router.net/Publications.html#valet-services
You seem to have inadvertently pointed at another publication.

&gt; Since the DAs would be the most logical place for an attacker to DoS
&gt; or attack, I was thinking that it would make sense if the DAs couldn't
&gt; be found physically or by IP.
&gt; To start a network, I was think of using 3 DAs with 8 nodes.  The
&gt; nodes would act as rendezvous points, introduction points, valet/guard
&gt; points, entry, middle, and exit nodes.
&gt; If the DAs .onion information and 8 startup nodes information was
&gt; pre-cached when Tor is download, would that be enough to keep the DA's
&gt; hidden?
&gt; 

Sorry, not sure I got this. Are you talking about directories of
hidden services or directories of Tor nodes. At the moment they
are in the same place, but there is no need for that to ultimately
stay true. I think there are mechanisms in place that make DoS attacks
on the directory infrastructure of Tor quite hard (redundancy, voting,
mirroring, etc.). The hidden service design that includes valet nodes
also includes hiding which directory has service lookup info for a
hidden service from those who don't know the .onion address already
and other protections too. Cf. also Karsten Loesing's work 
"Distributed Storage of Tor Hidden Service Descriptors" from PETS 2007
and 
http://www.torproject.org/svn/trunk/doc/spec/proposals/121-hidden-service-authentication.txt

&gt; Now the big question.  What type of attacks would this be prone to?
&gt; After reading [2], it became clear that someone could attack
&gt; Introduction Points to reveal the true location of the hidden service.
&gt;  But the 'valet' (or 'guard'?) node design model would significantly
&gt; help reduce the probability of this attack being successful.  So, if
&gt; the DA's are acting as a hidden service, in theory, Introduction and
&gt; Valet Points wouldn't be able to distinguish regular hidden services
&gt; from the DA's hidden service.
&gt; 

Right. That's the idea.

&gt; I know that by hiding the DA's, every downloaded package of Tor would
&gt; have to contain an up-to-date copy of the cached-routers.  Could a
&gt; "cached-onions" file be introduced into the design to make it clear
&gt; which are Onion Routers and which are Hidden Services?
&gt; 
&gt; This idea was something that been going through my mind the last few
&gt; weeks.  What do you think?
&gt; Paul, if you're reading this, I would really like to hear what you
&gt; think about this.
&gt; Any feedback from anyone is appreciated.
&gt; 

Above comments all I have time for right now. HTH.

aloha,
Paul
</body></email><email><emailId>20071016192425</emailId><senderName>Robert Hogan</senderName><senderEmail>robert@roberthogan.net</senderEmail><timestampReceived>2007-10-16 19:24:25-0400</timestampReceived><subject>One Typo, One Bug</subject><body>


One typo (PublishServerDescriptor) and one 'bug'.

Clearing the state of trusted_dir_servers (particularly 
has_accepted_server_desc) every time any sort of option is applied throws out 
the accuracy of 'getinfo status/good-server-descriptor'. Patch clears the 
state of trusted_dirs only when it's empty or actually being set by the 
config.




Index: src/or/config.c
===================================================================
--- src/or/config.c     (revision 11994)
+++ src/or/config.c     (working copy)
@@ -477,7 +477,7 @@
     "and servers." },
   { "ORListenAddress", "Bind to this address to listen for connections from "
     "clients and servers, instead of the default 0.0.0.0:ORPort." },
-  { "PublishServerDescriptors", "Set to \"\" to keep the server from "
+  { "PublishServerDescriptor", "Set to \"\" to keep the server from "
     "uploading info to the directory authorities." },
   /*{ "RedirectExit", "When an outgoing connection tries to connect to a "
    *"given address, redirect it to another address instead." },
@@ -963,8 +963,8 @@
   int running_tor = options-&gt;command == CMD_RUN_TOR;
   char *msg;

-  clear_trusted_dir_servers();
   if (options-&gt;DirServers) {
+    clear_trusted_dir_servers();
     for (cl = options-&gt;DirServers; cl; cl = cl-&gt;next) {
       if (parse_dir_server_line(cl-&gt;value, 0)&lt;0) {
         log_warn(LD_BUG,
@@ -973,7 +973,8 @@
       }
     }
   } else {
-    add_default_trusted_dirservers();
+    if (!router_get_trusted_dir_servers())
+      add_default_trusted_dirservers();
   }

   clear_bridge_list();

["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20071018183023</emailId><senderName>"Michael_google gmail_Gersten"</senderName><senderEmail>keybounce@gmail.com</senderEmail><timestampReceived>2007-10-18 18:30:23-0400</timestampReceived><subject>Where do nodes change from bandwidth limited to CPU limited?</subject><body>

We've had changes to Tor that should have improved the network's
capacity. I've noticed that my mother's computer (a middle-man node on
a cable modem) no longer runs at max bandwidth all the time.

Are the biggest nodes still CPU bound? Are moderate nodes still
bandwidth bound? At what point / range are nodes limited by CPU or
limited by bandwidth? Which one do we have more to play with, in
general?
</body></email><email><emailId>20071018192100</emailId><senderName>Peter Palfrader</senderName><senderEmail>peter@palfrader.org</senderEmail><timestampReceived>2007-10-18 19:21:00-0400</timestampReceived><subject>Re: Proposal: Network status entries need a new Unnamed flag</subject><body>

On Thu, 18 Oct 2007, Nick Mathewson wrote:
&gt; &gt; &gt; &gt; Can we still list the unnamed routers in the v2 status, even without an
&gt; &gt; &gt; &gt; unnamed flag?  Because if not and I enable auto-naming on tor26 I'll stop
&gt; &gt; &gt; &gt; listing about 150 routers for using names that are already taken.
&gt; Peter: would you like to patch the results of this thread into
&gt; proposal 122, so I can get started implementing it?

Like that?

Index: 122-unnamed-flag.txt
===================================================================
--- 122-unnamed-flag.txt	(revision 12024)
+++ 122-unnamed-flag.txt	(working copy)
@@ -105,8 +105,28 @@
   We need more naming authorities, possibly with some kind of auto-naming
   feature.  This is out-of-scope for this proposal -NM]
 
-4. Other benefits:
+4. Changes to the v2 directory
 
+  Previously v2 authorities that had a binding for a server named Bob did
+  not list any other server named Bob.  This will change too:
+
+  Version 2 authorities will start listing all routers they know about,
+  whether they conflict with a name-binding or not:  Servers for which
+  this authority has a binding will continue to be marked Named,
+  additionally all other servers of that will be listed without the
+  Named flag (i.e. there will be no Unnamed flag in v2 status documents).
+
+  Clients already should handle having a named Bob alongside unnamed
+  Bobs correctly, and having the unnamed Bobs in the status file even
+  without the named server is no worse than the curren status quo where
+  clients learn about those severs from other authorities.
+
+  The benefit of this is that an authority's opinion on a server like
+  Guard, Stable, Fast etc. can now be learned by clients even if that
+  specific authority has reserved that server's name for somebody else.
+
+5. Other benefits:
+
   This new flag will allow people to operate servers that happen to have
   the same nickname as somebody who registered their server two years ago
   and left soon after. Right now there are dozens of nicknames that are

-- 
                           |  .''`.  ** Debian GNU/Linux **
      Peter Palfrader      | : :' :      The  universal
 http://www.palfrader.org/ | `. `'      Operating System
                           |   `-    http://www.debian.org/
</body></email><email><emailId>20071020182948</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-10-20 18:29:48-0400</timestampReceived><subject>Re: Comments on Proposal 105 -- handshake-revision</subject><body>


On Sat, Oct 20, 2007 at 02:02:16AM -0400, Roger Dingledine wrote:
 [...]
&gt; Ok, after having written this, I notice that Nick snuck in a revision to
&gt; proposal 118 on Oct 9, though he didn't mention it on or-dev :)
&gt; http://archives.seul.org/or/cvs/Oct-2007/msg00103.html
&gt; This "suggested rule" appears to match my assumption in my previous post,
&gt; which was to be smart when server1 has a descriptor available for server2,
&gt; and otherwise be conservative and open a new connection. But doesn't
&gt; the NETINFO cell plan mean we don't need to look at (or rely on having)
&gt; descriptors at all?

Agreed.  IMO we should still look, but we don't need to rely on being
able to look.  (See other mail.)

&gt; And lest I sound like I've made up my mind: there are an increasing number
&gt; of design decisions that seem like they'll be a lot easier if we can
&gt; assume that most servers have descriptors of most other servers. It would
&gt; mean not needing NETINFO cells at all -- just find a descriptor signed
&gt; by the key that's on the other end of the connection, and compare the IP
&gt; address to the list of acceptable IP addresses in the descriptor. Maybe
&gt; it's time to admit that assumption before we add yet more complexity?
&gt; 
&gt; I am leaning toward "no, we'll never succeed at scaling if we make
&gt; design decisions that force every server to know about every server."
&gt; Anybody else have an opinion?

I too am leaning that way.  True, being scalable requires us to do
things that make our design decisions harder--but that doesn't mean we
can afford not to be scalable.  Back when we made the "all servers
know all servers always" assumption, circuit building could get
mysteriously unreliable, and we didn't have nearly as many servers
then as we do now.

yrs,
-- 
Nick Mathewson

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20071020194832</emailId><senderName>"Wilfred L. Guerin"</senderName><senderEmail>wilfredguerin@gmail.com</senderEmail><timestampReceived>2007-10-20 19:48:32-0400</timestampReceived><subject>Loops show DHS run Nodes, flood takeover</subject><body>

A brief cycle of loopbacks was run this past week and the models run against
public databases.

There is a huge influx of new nodes with slightly-above-average
characteristics over the last few weeks at most, all of which have close to
identical processing and bandwith characteristics abnormal to real
implementations.

Many of the highest correlations point at american DHS and USSS (cybercrime)
counterparts in close physical proximity as well as a large set of British
interpol spiders.

When the entire block is allocated to a specific client, it is only obvious
when they assign one ip of the range to the tor node on many hundred client
units using the public tor master list...

In short, someone has taken the que from the "spy nodes" issue of last month
and is attempting to flood the TOR mixer out of service.

This is a little more problematic than such things as https key negotiation
on the same wire, or million-bit encryption around a 56 or (much) less bit
key like we saw in anguilla a decade ago, since it explicitly authorizes
what is correlary to a denial of service attack against the operational
mechanisms of the TOR system as defined.

Has anyone further analysis of this problem?

Flooding out the media is IBB and BBC's job, but since it is heirchial and
structured from a single source, the MIM of google or mass media sources and
quarentine/isolation is not beyond their authority, but a public source
system that employs only donated elements should NOT be attacked in the same
manner. No mention of ISP dns registrations for update.windows...

Please advise

-Wilfred L. Guerin
WilfredGuerin@Gmail.com

[Attachment #3 (text/html)]

A brief cycle of loopbacks was run this past week and the models run against public \
databases.&lt;br&gt;&lt;br&gt;There is a huge influx of new nodes with slightly-above-average \
characteristics over the last few weeks at most, all of which have close to identical \
processing and bandwith characteristics abnormal to real implementations. \
&lt;br&gt;&lt;br&gt;Many of the highest correlations point at american DHS and USSS (cybercrime) \
counterparts in close physical proximity as well as a large set of British interpol \
spiders. &lt;br&gt;&lt;br&gt;When the entire block is allocated to a specific client, it is only \
obvious when they assign one ip of the range to the tor node on many hundred client \
units using the public tor master list...  &lt;br&gt;&lt;br&gt;In short, someone has taken the \
que from the "spy nodes" issue of last month and is attempting to flood the \
TOR mixer out of service.&lt;br&gt;&lt;br&gt;This is a little more problematic than such things \
as https key negotiation on the same wire, or million-bit encryption around a 56 or \
(much) less bit key like we saw in anguilla a decade ago, since it explicitly \
authorizes what is correlary to a denial of service attack against the operational \
mechanisms of the TOR system as defined. &lt;br&gt;&lt;br&gt;Has anyone further analysis of this \
problem?&lt;br&gt;&lt;br&gt;Flooding out the media is IBB and BBC's job, but since it is \
heirchial and structured from a single source, the MIM of google or mass media \
sources and quarentine/isolation is not beyond their authority, but a public source \
system that employs only donated elements should NOT be attacked in the same manner. \
No mention of ISP dns registrations for  update.windows...&lt;br&gt;&lt;br&gt;Please \
advise&lt;br&gt;&lt;br&gt;-Wilfred L. Guerin&lt;br&gt;&lt;a \
href="mailto:WilfredGuerin@Gmail.com"&gt;WilfredGuerin@Gmail.com&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;



</body></email><email><emailId>20070904180824</emailId><senderName>"Wilfred L. Guerin"</senderName><senderEmail>wilfredguerin@gmail.com</senderEmail><timestampReceived>2007-09-04 18:08:24-0400</timestampReceived><subject>ToR Protected Processing</subject><body>

Though I'm sure there has been much discussion on the appropriate methods of
implementing distributed data management and processing with TOR
capabilities, this specific target project has critical reasons for
protecting the autonomous data processing systems that handle specific
arbitrary data.

I propose this need for the protection of unwitting individuals who have
taken a picture and under no circumstance realized or knew that something in
the far far distance might be a restricted govt site or other "no pic"
target.

Please contact me directly with information on any project working on
grid-style distributed data containment and processing, especially VM
emulated and sandboxed models, and more modern implementations of
transparent loading and migration with physical region weighting. "
WilfredGuerin@Gmail.com"

The project of concern is intended for k-12 classroom curriculum in the
fields of using technology and imaging tools for practical applications. The
dominant protocol uses a conventional camera, large spheres or other balls,
and any computational system to generate 3d models of the environment.

In full scale, this project (now simplified to "Project BigBall.us")
implements a simple known-target identification model (large spheres) to
facilitate extrapolation of imaging data to 4d models.

The data and processing requirements are explicit, maximal imaging sources
to maximal storage and processing facilities.

A current model using various p2p and server-centric distribution and
management of both processing and data storage works suitably, however there
exists no consistent protocol or system definitions that make use of current
public-use techniques like the mess of current distributed processing
models.

The specific model of data and processing management is not of concern here,
the mechanism of protecting the arbitrary processing device and facilitating
scientific research without concern for rogue vulnerabilities must be
determined prior to public release.

We all know of the irony of preventing analogue-signal video tape from being
used at American infrastructure, and video from a cell phone is far more
useful against their concerns.

Our concern is very explicit: any 2 images for a distant horizon will not
each independently show the distinct object when said object's visual
profile is less than a pixle, yet the extrapolated correlational vector
between 2 images will give finite and distinguishable characteristics of the
target.

If said resulting data overlaps ... air in a flight path with nothing flying
(or worse, near-space earth) ... it could be assumed a liability for any
system involved in processing.

Moreso, even with known "do not show" sectors in 4d, the isolation of the
do-not-show requires the segregation of its signature from other
environmental characteristics; one can not determine that it sees something
until a separation is made between that which it sees and another that it
sees.

In order to strike voluntarily a target from imaging, beit someone's house
or a true liability, system must know what that target is and other
characteristics to facilitate removal. Other options are simply not
possible. (Proven)

My concern is simple.

Aside from diverse distributed data management and processing, there is
explicit need for protection mechanisms in this model.

If a student (k-12) wants a good 3d model of the park or beach, using all
available image sources is expected. Is the student liable for the flesh in
the image where the system stripped the growth characteristics of the tree
in the background out for the project and ignored the single-case (spurious)
structures? Moreso, does said student get expelled because an autonomous
machine polled imaging sources to extract relevant information and happened
to need to filter that which was unneeded?

In the expected dealings with the DHS NAO, NGIA(nima), etc, our analysis has
indicated that a waco-style religious institution is needed to protect the
region of any specific ball to force release of various media and data
collections, but protecting the excess of diverse machines, their owners,
entities associated, etc, from such stupid liability as a smoke stack on the
distant horizon requires further analysis.

I have proposed a derivative project called "Skunk Cabbage" (which always
smells good) that would facilitate VM/emu sandboxed scientific processing
environments on distributed machines, fully manage distributed loading and
processing with regional sectoriing using a consolidation of the current
psuedo-standards, and most importantly, COMPREHENSIVE SYSTEM AND CODE
INTEGRITY SUFFICIENT TO SUBSTANTIATE THE DISTINCTION BETWEEN AUTONOMOUS
SYSTEM AND HOST ENVIRONMENT.

Of course, maximal efficiency, but with no liability for the computation of
the distributed processes.

Please contact me directly with information on projects that are somewhat
related to these concerns.

Moreso, how does one best merge and optimize the various data transport
capabilities of any viable client system or host and still protect and
isolate the processes involved?

Such research and protocol creation should be desirable by all parties
requiring an isolated or protected computational and data storage
environment while using the power and resources of currently existing public
systems.

I look forward to any responses and a fast pursuit of a system suitable for
this task.

-Wilfred L. Guerin
WilfredGuerin@Gmail.com

[Attachment #3 (text/html)]

&lt;br&gt;Though I'm sure there has been much discussion on the appropriate methods of \
implementing distributed data management and processing with TOR capabilities, this \
specific target project has critical reasons for protecting the autonomous data \
processing systems that handle specific arbitrary data.  &lt;br&gt;&lt;br&gt;I propose this need \
for the protection of unwitting individuals who have taken a picture and under no \
circumstance realized or knew that something in the far far distance might be a \
restricted govt site or other "no pic" target. &lt;br&gt;&lt;br&gt;Please contact me \
directly with information on any project working on grid-style distributed data \
containment and processing, especially VM emulated and sandboxed models, and more \
modern implementations of transparent loading and migration with physical region \
weighting. " &lt;a \
href="mailto:WilfredGuerin@Gmail.com"&gt;WilfredGuerin@Gmail.com&lt;/a&gt;"&lt;br&gt;&lt;br&gt;The \
project of concern is intended for k-12 classroom curriculum in the fields of using \
technology and imaging tools for practical applications. The dominant protocol uses a \
conventional camera, large spheres or other balls, and any computational system to \
generate 3d models of the environment. &lt;br&gt;&lt;br&gt;In full scale, this project (now \
simplified to "Project BigBall.us") implements a simple known-target \
identification model (large spheres) to facilitate extrapolation of imaging data to \
4d models.&lt;br&gt;&lt;br&gt; The data and processing requirements are explicit, maximal imaging \
sources to maximal storage and processing facilities. &lt;br&gt;&lt;br&gt;A current model using \
various p2p and server-centric distribution and management of both processing and \
data storage works suitably, however there exists no consistent protocol or system \
definitions that make use of current public-use techniques like the mess of current \
distributed processing models. &lt;br&gt;&lt;br&gt;The specific model of data and processing \
management is not of concern here, the mechanism of protecting the arbitrary \
processing device and facilitating scientific research without concern for rogue \
vulnerabilities must be determined prior to public release. &lt;br&gt;&lt;br&gt;We all know of \
the irony of preventing analogue-signal video tape from being used at American \
infrastructure, and video from a cell phone is far more useful against their \
concerns. &lt;br&gt;&lt;br&gt;Our concern is very explicit: any 2 images for a distant horizon \
will not each independently show the distinct object when said object's visual \
profile is less than a pixle, yet the extrapolated correlational vector between 2 \
images will give finite and distinguishable characteristics of the target.  \
&lt;br&gt;&lt;br&gt;If said resulting data overlaps ... air in a flight path with nothing flying \
(or worse, near-space earth) ... it could be assumed a liability for any system \
involved in processing.&lt;br&gt;&lt;br&gt;Moreso, even with known "do not show" \
sectors in 4d, the isolation of the do-not-show requires the segregation of its \
signature from other environmental characteristics; one can not determine that it \
sees something until a separation is made between that which it sees and another that \
it sees. &lt;br&gt;&lt;br&gt;In order to strike voluntarily a target from imaging, beit \
someone's house or a true liability, system must know what that target is and \
other characteristics to facilitate removal. Other options are simply not possible. \
(Proven) &lt;br&gt;&lt;br&gt;My concern is simple.&lt;br&gt;&lt;br&gt;Aside from diverse distributed data \
management and processing, there is explicit need for protection mechanisms in this \
model.&lt;br&gt;&lt;br&gt;If a student (k-12) wants a good 3d model of the park or beach, using \
all available image sources is expected. Is the student liable for the flesh in the \
image where the system stripped the growth characteristics of the tree in the \
background out for the project and ignored the single-case (spurious) structures? \
Moreso, does said student get expelled because an autonomous machine polled imaging \
sources to extract relevant information and happened to need to filter that which was \
unneeded? &lt;br&gt;&lt;br&gt;In the expected dealings with the DHS NAO, NGIA(nima), etc, our \
analysis has indicated that a waco-style religious institution is needed to protect \
the region of any specific ball to force release of various media and data \
collections, but protecting the excess of diverse machines, their owners, entities \
associated, etc, from such stupid liability as a smoke stack on the distant horizon \
requires further analysis. &lt;br&gt;&lt;br&gt;I have proposed a derivative project called \
"Skunk Cabbage" (which always smells good) that would facilitate VM/emu \
sandboxed scientific processing environments on distributed machines, fully manage \
distributed loading and processing with regional sectoriing using a consolidation of \
the current psuedo-standards, and most importantly, COMPREHENSIVE SYSTEM AND CODE \
INTEGRITY SUFFICIENT TO SUBSTANTIATE THE DISTINCTION BETWEEN AUTONOMOUS SYSTEM AND \
HOST ENVIRONMENT. &lt;br&gt;&lt;br&gt;Of course, maximal efficiency, but with no liability for \
the computation of the distributed processes.&lt;br&gt;&lt;br&gt;Please contact me directly with \
information on projects that are somewhat related to these concerns.&lt;br&gt; &lt;br&gt;Moreso, \
how does one best merge and optimize the various data transport capabilities of any \
viable client system or host and still protect and isolate the processes \
involved?&lt;br&gt;&lt;br&gt;Such research and protocol creation should be desirable by all \
parties requiring an isolated or protected computational and data storage environment \
while using the power and resources of currently existing public systems. &lt;br&gt;&lt;br&gt;I \
look forward to any responses and a fast pursuit of a system suitable for this \
task.&lt;br&gt;&lt;br&gt;-Wilfred L. Guerin&lt;br&gt;&lt;a \
href="mailto:WilfredGuerin@Gmail.com"&gt;WilfredGuerin@Gmail.com&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;
 &lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;



</body></email><email><emailId>20070905233040</emailId><senderName>mrwigglet</senderName><senderEmail>mrwigglet@gmail.com</senderEmail><timestampReceived>2007-09-05 23:30:40-0400</timestampReceived><subject>Re: Prop 110 revisions</subject><body>

[Attachment #2 (multipart/alternative)]


Here are three revised patches for proposal 110.  I know that you all still
have to consider rolling out, other possible considerations, etc.  But I
figured I'd make the changes that Nick suggested so they could be
considered.  If there are still issues with these I'd like to know.  And if
it turns out that this would better be set up with the version checking
proposal that's cool too.  Just thought I'd send these along for
consideration (:

Thanks,

Nate



On 8/22/07, mrwigglet &lt;mrwigglet@gmail.com&gt; wrote:
&gt;
&gt; Sorry if this starts a new thread, I hadn't yet joined the or-dev list
&gt; so I couldn't just hit 'reply'.  Anyhow, I just have a few questions
&gt; so that I can hopefully get the patches right for this.  Question 1 is
&gt;
&gt; what exactly you guys want the behavior to be, either the way Nick
&gt; outlines it or the way it is in 'additional complexity'.  Second is
&gt; what the naming should be, RELAY_EARLY or something else.  Third question
&gt;
&gt; is about where to put the two fields.  Moving the counter for seen
&gt; extend cells to or_circuit_t is fine, but I'm not sure the other can
&gt; be moved to origin_circuit_t.  The reason is that the only place I
&gt;
&gt; can find that the CELL_RELAY type is set is in relay_send_command_from_edge
&gt; and the type of circuit in that function is circuit_t not origin_circuit_t.
&gt; So if you could let me know what way that should be handled that'd be great.
&gt;
&gt; Also, whether or not you guys think this should go along with another
&gt; proposal (105 or other).  Other than these few things I think I know
&gt; what is needed so hopefully we can work it all out.
&gt;
&gt; Thanks,
&gt;
&gt;
&gt; Nate
&gt;
&gt; On Tue, Aug 21, 2007 at 05:43:35PM -0400, Nick Mathewson wrote:
&gt; &gt; It looks like these patches introduces the RELAY_EXTEND
&gt; &gt; cell type as a server-accepted synonym for the RELAY cell type.
&gt; &gt; (RELAY_EXTEND is not my favorite name, since CELL_RELAY_EXTEND will
&gt;
&gt; &gt; get confused with RELAY_COMMAND_EXTEND in casual writing; Roger, maybe
&gt; &gt; we should change 110 to name the new type RELAY_EARLY or
&gt; &gt; RELAY_EXTEND_OK?  In the rest of this mail, I'll try to call it the
&gt;
&gt; &gt; "special" cell type.)
&gt;
&gt; I like RELAY_EARLY. It specifies how to treat the cell, rather than what
&gt; is meant to be in it, which might be handy later on.
&gt;
&gt; &gt;   I don't think that the behavior matches that described in 'phase
&gt;
&gt; &gt;   one' of the proposal: special cells are passed on with the RELAY
&gt; &gt;   type, not with their own type.
&gt;
&gt; Right. RELAY_EARLY cells need to be passed on as RELAY_EARLY cells,
&gt; and RELAY cells as RELAY cells.
&gt;
&gt;
&gt; &gt; The second patch mucks with some whitespace in circuitbuild.c, then
&gt; &gt; starts adding features so that clients will send as the special cell
&gt; &gt; type their first N relay cells on each circuit, where N is chosen
&gt;
&gt; &gt; uniformly at random between 5 and 10.
&gt; &gt;
&gt; &gt;   For this patch, I bet we could get the two uint16_ts that you've
&gt; &gt;   added to circuit_t down to a single field in origin_circuit_t (how
&gt; &gt;   many _more_ RELAY_EARLY cells will we originate?) and a single field
&gt;
&gt; &gt;   in or_circuit_t (how many _more_ cells will we accept before we
&gt; &gt;   accept stop accepting RELAY_EARLY cells)?  The fields can be
&gt; &gt;   uint8_t, since the limit is well under 255 in both cases.
&gt;
&gt;
&gt; Plausible.
&gt;
&gt; &gt; The third patch enforces the protocol by:
&gt; &gt;     A) Disallowing any RELAY_COMMAND_EXTEND cells without the special
&gt; &gt;        cell type, and
&gt; &gt;     B) Closing any circuit where too many cells of the special type
&gt;
&gt; &gt;        are sent.
&gt; &gt;
&gt; &gt;   Rule B is not quite right: the rule is not "You may send no more
&gt; &gt;   than X special cells;" the rule is "special cells may only occur as
&gt; &gt;   the first X cells on any circuit."  (See proposal 110, "Design"
&gt;
&gt; &gt;   section, last paragraph.)
&gt;
&gt; Right.
&gt;
&gt; But Nick, also see the 'additional complexity' section. It might be
&gt; smart for clients to send the first K of them as relay_early, but for
&gt; servers to enforce it by a "no more than K ever" rule. This could give us
&gt;
&gt; more flexibility if we want it later -- I don't think it increases the
&gt; damage that can be done via the infinite circuit attack, though sending
&gt; a relay_early cell later on would tell everybody in the circuit what
&gt;
&gt; you're up to.
&gt;
&gt; (If we opt for this approach, we may find that RELAY_EARLY is now a bad
&gt; name. Hm.)
&gt;
&gt; &gt; Here's a way that we could get the new protocol in faster.  It
&gt; &gt; requires that something like proposal 105 is implemented, so that part
&gt;
&gt; &gt; of negotiating a Tor connection is learning which connection protocol
&gt; &gt; version the other router supports.  Here goes:
&gt;
&gt; Actually, I had meant for us to be able to do phase 1 and phase 2 quite
&gt; close together (
&gt; e.g. both in the 0.2.0.x timeframe), and it doesn't depend
&gt; on proposal 105. Basically, Alice should use a RELAY_EARLY cell when
&gt; all the nodes in her path would understand it, and not otherwise. She
&gt; has descriptors for all of them, after all, so she's in a fine position
&gt;
&gt; to know when it will work.
&gt;
&gt; --Roger
&gt;
&gt;

[Attachment #5 (text/html)]

Here are three revised patches for proposal 110. I know that you all still have \
to consider rolling out, other possible considerations, etc. But I figured \
I'd make the changes that Nick suggested so they could be considered. If \
there are still issues with these I'd like to know. And if it turns out \
that this would better be set up with the version checking proposal that's cool \
too. Just thought I'd send these along for consideration (: \
&lt;br&gt;&lt;br&gt;Thanks,&lt;br&gt;&lt;br&gt;Nate&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;div&gt;&lt;span class="gmail_quote"&gt;On 8/22/07, \
&lt;b class="gmail_sendername"&gt;mrwigglet&lt;/b&gt; &lt;&lt;a \
href="mailto:mrwigglet@gmail.com"&gt;mrwigglet@gmail.com&lt;/a&gt;&gt; \
wrote:&lt;/span&gt;&lt;blockquote class="gmail_quote" style="border-left: 1px solid rgb(204, \
204, 204); margin: 0pt 0pt 0pt 0.8ex; padding-left: 1ex;"&gt; &lt;pre&gt;Sorry if this starts \
a new thread, I hadn't yet joined the &lt;span id="st" name="st" \
class="st"&gt;or&lt;/span&gt;-&lt;span id="st" name="st" class="st"&gt;dev&lt;/span&gt; list&lt;br&gt;so I \
couldn't just hit 'reply'.  Anyhow, I just have a few questions &lt;br&gt;so \
that I can hopefully get the patches right for this.  Question 1 is&lt;br&gt;&lt;br&gt;what \
exactly you guys want the behavior to be, either the way Nick&lt;br&gt;outlines it &lt;span \
id="st" name="st" class="st"&gt;or&lt;/span&gt; the way it is in 'additional \
complexity'.  Second is &lt;br&gt;what the naming should be, RELAY_EARLY &lt;span id="st" \
name="st" class="st"&gt;or&lt;/span&gt; something else.  Third question&lt;br&gt;&lt;br&gt;is about where \
to put the two fields.  Moving the counter for seen&lt;br&gt;extend cells to or_circuit_t \
is fine, but I'm not sure the other can &lt;br&gt;be moved to origin_circuit_t.  The \
reason is that the only place I &lt;br&gt; can find that the CELL_RELAY type is set is in \
relay_send_command_from_edge&lt;br&gt;and the type of circuit in that function is circuit_t \
not origin_circuit_t.&lt;br&gt;So if you could let me know what way that should be handled \
that'd be great. &lt;br&gt;&lt;br&gt;Also, whether &lt;span id="st" name="st" \
class="st"&gt;or&lt;/span&gt; not you guys think this should go along with another&lt;br&gt;proposal \
(105 &lt;span id="st" name="st" class="st"&gt;or&lt;/span&gt; other).  Other than these few \
things I think I know &lt;br&gt;what is needed so hopefully we can work it all \
out.&lt;br&gt;&lt;br&gt;Thanks,&lt;br&gt;&lt;br&gt; Nate&lt;br&gt;&lt;br&gt;On Tue, Aug 21, 2007 at 05:43:35PM -0400, \
Nick Mathewson wrote:&lt;br&gt;&gt; It looks like these patches introduces the \
RELAY_EXTEND&lt;br&gt;&gt; cell type as a server-accepted synonym for the RELAY cell \
type.&lt;br&gt;&gt; (RELAY_EXTEND is not my favorite name, since CELL_RELAY_EXTEND will \
&lt;br&gt;&lt;br&gt;&gt; get confused with RELAY_COMMAND_EXTEND in casual writing; Roger, \
maybe&lt;br&gt;&gt; we should change 110 to name the new type RELAY_EARLY &lt;span id="st" \
name="st" class="st"&gt;or&lt;/span&gt;&lt;br&gt;&gt; RELAY_EXTEND_OK?  In the rest of this mail, \
I'll try to call it the &lt;br&gt;&lt;br&gt;&gt; "special" cell type.)&lt;br&gt;&lt;br&gt;I \
like RELAY_EARLY. It specifies how to treat the cell, rather than what&lt;br&gt;is meant to \
be in it, which might be handy later on.&lt;br&gt;&lt;br&gt;&gt;   I don't think that the \
behavior matches that described in 'phase &lt;br&gt;&lt;br&gt;&gt;   one' of the \
proposal: special cells are passed on with the RELAY&lt;br&gt;&gt;   type, not with their \
own type.&lt;br&gt;&lt;br&gt;Right. RELAY_EARLY cells need to be passed on as RELAY_EARLY \
cells,&lt;br&gt;and RELAY cells as RELAY cells. &lt;br&gt;&lt;br&gt;&lt;br&gt;&gt; The second patch mucks \
with some whitespace in circuitbuild.c, then&lt;br&gt;&gt; starts adding features so that \
clients will send as the special cell&lt;br&gt;&gt; type their first N relay cells on each \
circuit, where N is chosen &lt;br&gt;&lt;br&gt;&gt; uniformly at random between 5 and 10.&lt;br&gt;&gt; \
&lt;br&gt;&gt;   For this patch, I bet we could get the two uint16_ts that \
you've&lt;br&gt;&gt;   added to circuit_t down to a single field in origin_circuit_t \
(how&lt;br&gt;&gt;   many _more_ RELAY_EARLY cells will we originate?) and a single field \
&lt;br&gt;&lt;br&gt;&gt;   in or_circuit_t (how many _more_ cells will we accept before \
we&lt;br&gt;&gt;   accept stop accepting RELAY_EARLY cells)?  The fields can be&lt;br&gt;&gt;   \
uint8_t, since the limit is well under 255 in both cases.&lt;br&gt; &lt;br&gt;
Plausible.&lt;br&gt;&lt;br&gt;&gt; The third patch enforces the protocol by:&lt;br&gt;&gt;     A) \
Disallowing any RELAY_COMMAND_EXTEND cells without the special&lt;br&gt;&gt;        cell \
type, and&lt;br&gt;&gt;     B) Closing any circuit where too many cells of the special type \
&lt;br&gt;&lt;br&gt;&gt;        are sent.&lt;br&gt;&gt; &lt;br&gt;&gt;   Rule B is not quite right: the rule \
is not "You may send no more&lt;br&gt;&gt;   than X special cells;" the rule is \
"special cells may only occur as&lt;br&gt;&gt;   the first X cells on any \
circuit."  (See proposal 110, "Design" &lt;br&gt;&lt;br&gt;&gt;   section, last \
paragraph.)&lt;br&gt;&lt;br&gt;Right.&lt;br&gt;&lt;br&gt;But Nick, also see the 'additional \
complexity' section. It might be&lt;br&gt;smart for clients to send the first K of them \
as relay_early, but for&lt;br&gt;servers to enforce it by a "no more than K ever" \
rule. This could give us &lt;br&gt;&lt;br&gt;more flexibility if we want it later -- I don't \
think it increases the&lt;br&gt;damage that can be done via the infinite circuit attack, \
though sending&lt;br&gt;a relay_early cell later on would tell everybody in the circuit \
what &lt;br&gt;&lt;br&gt;you're up to.&lt;br&gt;&lt;br&gt;(If we opt for this approach, we may find that \
RELAY_EARLY is now a bad&lt;br&gt;name. Hm.)&lt;br&gt;&lt;br&gt;&gt; Here's a way that we could get \
the new protocol in faster.  It&lt;br&gt;&gt; requires that something like proposal 105 is \
implemented, so that part &lt;br&gt;&lt;br&gt;&gt; of negotiating a Tor connection is learning \
which connection protocol&lt;br&gt;&gt; version the other router supports.  Here \
goes:&lt;br&gt;&lt;br&gt;Actually, I had meant for us to be able to do phase 1 and phase 2 \
quite&lt;br&gt;close together ( &lt;br&gt;e.g. both in the 0.2.0.x timeframe), and it doesn't \
depend&lt;br&gt;on proposal 105. Basically, Alice should use a RELAY_EARLY cell when&lt;br&gt;all \
the nodes in her path would understand it, and not otherwise. She&lt;br&gt;has descriptors \
for all of them, after all, so she's in a fine position &lt;br&gt;&lt;br&gt;to know when it \
will work.&lt;br&gt;&lt;br&gt;--Roger&lt;/pre&gt; &lt;/blockquote&gt;&lt;/div&gt;&lt;br&gt;


["tor_prop110_patch1.patch" (text/x-patch)]

diff -ru ../trunk/src/or/command.c trunk/src/or/command.c
--- ../trunk/src/or/command.c	2007-09-05 16:56:23.000000000 -0600
+++ trunk/src/or/command.c	2007-09-05 16:57:14.000000000 -0600
@@ -127,6 +127,11 @@
 #endif
       break;
     case CELL_RELAY:
+    /** Second part of patch 1 for proposal 110 NE 8-2007
+     * Handle new CELL_RELAY_EXTEND type here, distinction
+     * between the two is handled in a later revision. 
+     */
+    case CELL_RELAY_EARLY:
       ++stats_n_relay_cells_processed;
 #ifdef KEEP_TIMING_STATS
       ++num_relay;
diff -ru ../trunk/src/or/or.h trunk/src/or/or.h
--- ../trunk/src/or/or.h	2007-09-05 16:56:23.000000000 -0600
+++ trunk/src/or/or.h	2007-09-05 16:57:14.000000000 -0600
@@ -659,6 +659,11 @@
 #define CELL_DESTROY 4
 #define CELL_CREATE_FAST 5
 #define CELL_CREATED_FAST 6
+/**
+ * Part of possible patch for proposal 110 ** NE 8-2007
+ */
+#define CELL_RELAY_EARLY 7
+
 
 /** How long to test reachability before complaining to the user. */
 #define TIMEOUT_UNTIL_UNREACHABILITY_COMPLAINT (20*60)

["tor_prop110_patch2.patch" (text/x-patch)]

diff -ru ../torpatch1/trunk/AUTHORS trunk/AUTHORS
--- ../torpatch1/trunk/AUTHORS	2007-09-05 16:56:48.000000000 -0600
+++ trunk/AUTHORS	2007-09-05 16:59:04.000000000 -0600
@@ -24,7 +24,9 @@
 
 John Bashinski &lt;jbash@velvet.com&gt; contributed the initial rpm spec file.
 
-Christian Grothoff &lt;grothoff@cs.purdue.edu&gt; contributed better daemonizing
+Nathan Evans	&lt;nevans6@du.edu&gt; contributed patch implementing proposal 110
+
+Christian Grothoff &lt;christian@grothoff.org&gt; contributed better daemonizing
 behavior.
 
 Steven Hazel &lt;sah@thalassocracy.org&gt; made 'make install' do the right
--- ../torpatch1/trunk/src/or/circuitlist.c	2007-09-05 16:56:48.000000000 -0600
+++ trunk/src/or/circuitlist.c	2007-09-05 16:59:04.000000000 -0600
@@ -345,6 +345,10 @@
   circ-&gt;next_stream_id = crypto_rand_int(1&lt;&lt;16);
   circ-&gt;global_identifier = n_circuits_allocated++;
 
+  /** Part of patch 2 for proposal 110. Initialize &lt;b&gt;relay_early_num&lt;/b&gt;
+    * to random int between MIN_RELAY_EXTENDS and MAX_RELAY_EXTENDS  */
+  circ-&gt;relay_early_num = crypto_rand_int(MAX_RELAY_EXTENDS - MIN_RELAY_EXTENDS) + MIN_RELAY_EXTENDS;
+  
   init_circuit_base(TO_CIRCUIT(circ));
 
   return circ;
@@ -364,6 +368,10 @@
   if (p_conn)
     circuit_set_p_circid_orconn(circ, p_circ_id, p_conn);
 
+  /** Part of patch 2 for proposal 110. Initialize &lt;b&gt;relay_early_seen&lt;/b&gt;
+    * to 0 */
+  circ-&gt;relay_early_seen = 0;
+
   init_circuit_base(TO_CIRCUIT(circ));
 
   return circ;
diff -ru ../torpatch1/trunk/src/or/command.c trunk/src/or/command.c
--- ../torpatch1/trunk/src/or/command.c	2007-09-05 16:57:14.000000000 -0600
+++ trunk/src/or/command.c	2007-09-05 16:59:04.000000000 -0600
@@ -345,6 +345,12 @@
            direction==CELL_DIRECTION_OUT?"forward":"backward");
     circuit_mark_for_close(circ, -reason);
   }
+  
+  /** Part of patch 2 for proposal 110.  Increment this circuits
+  * number of extend cells seen.  */
+  if (cell-&gt;command == CELL_RELAY_EARLY)
+    TO_OR_CIRCUIT(circ)-&gt;relay_early_seen++;
+  
 }
 
 /** Process a 'destroy' &lt;b&gt;cell&lt;/b&gt; that just arrived from
diff -ru ../torpatch1/trunk/src/or/or.h trunk/src/or/or.h
--- ../torpatch1/trunk/src/or/or.h	2007-09-05 16:57:14.000000000 -0600
+++ trunk/src/or/or.h	2007-09-05 16:59:04.000000000 -0600
@@ -664,6 +664,14 @@
  */
 #define CELL_RELAY_EARLY 7
 
+/** Initial definition of the minimum number of extends
+ * to send, and the max to allow at each node.  Part of
+ * patch2 for proposal 110 NE 8-2007
+ * (Is this the right place for these?)
+ */
+#define MIN_RELAY_EXTENDS 5
+#define MAX_RELAY_EXTENDS 10
+
 
 /** How long to test reachability before complaining to the user. */
 #define TIMEOUT_UNTIL_UNREACHABILITY_COMPLAINT (20*60)
@@ -1676,6 +1684,7 @@
    * linked to an OR connection. */
   struct circuit_t *prev_active_on_n_conn;
   struct circuit_t *next; /**&lt; Next circuit in linked list of all circuits. */
+  
 } circuit_t;
 
 /** An origin_circuit_t holds data necessary to build and use a circuit.
@@ -1721,6 +1730,16 @@
   /** Quasi-global identifier for this circuit; used for control.c */
   /* XXXX NM This can get re-used after 2**32 circuits. */
   uint32_t global_identifier;
+  
+    /** Part of phase 2 for changes outlined in proposal 110. Add two new
+   *  variables &lt;b&gt;relay_early_num&lt;/b&gt; and &lt;b&gt;relay_early_seen&lt;/b&gt;.
+   *  The former will initially be set to a random value between 3 and 10
+   *  and decremented each time a relay_extend cell is sent.  The latter
+   *  will be used to keep track of relay_extend cells seen for a particular
+   *  circuit.  Once &lt;b&gt;relay_early_num&lt;/b&gt; reaches 0, no more extends will
+   *  be sent on this circuite.  Once &lt;b&gt;relay_early_seen&lt;/b&gt; reaches some
+   *  maximum (10?) the circuit will be discarded. NE 8-2007 */
+  uint8_t relay_early_num;
 
 } origin_circuit_t;
 
@@ -1787,6 +1806,16 @@
 
   /** True iff this circuit was made with a CREATE_FAST cell. */
   unsigned int is_first_hop : 1;
+  
+    /** Part of phase 2 for changes outlined in proposal 110. Add two new
+   *  variables &lt;b&gt;relay_early_num&lt;/b&gt; and &lt;b&gt;relay_early_seen&lt;/b&gt;.
+   *  The former will initially be set to a random value between 3 and 10
+   *  and decremented each time a relay_extend cell is sent.  The latter
+   *  will be used to keep track of relay_extend cells seen for a particular
+   *  circuit.  Once &lt;b&gt;relay_early_num&lt;/b&gt; reaches 0, no more extends will
+   *  be sent on this circuite.  Once &lt;b&gt;relay_early_seen&lt;/b&gt; reaches some
+   *  maximum (10?) the circuit will be discarded. NE 8-2007 */
+  uint8_t relay_early_seen;
 } or_circuit_t;
 
 /** Convert a circuit subtype to a circuit_t.*/
diff -ru ../torpatch1/trunk/src/or/relay.c trunk/src/or/relay.c
--- ../torpatch1/trunk/src/or/relay.c	2007-09-05 16:56:48.000000000 -0600
+++ trunk/src/or/relay.c	2007-09-05 17:02:19.000000000 -0600
@@ -481,7 +481,18 @@
   tor_assert(circ);
 
   memset(&amp;cell, 0, sizeof(cell_t));
-  cell.command = CELL_RELAY;
+    
+  /** Part of patch2 for proposal 110.  Check whether this node has sent the set
+   *  number of relay_early cells.  If so, send a regular relay cell instead. */
+  if (CIRCUIT_IS_ORIGIN(circ)) {
+    if (TO_ORIGIN_CIRCUIT(circ)-&gt;relay_early_num &gt; 0) {
+	  cell.command = CELL_RELAY_EARLY;
+	  TO_ORIGIN_CIRCUIT(circ)-&gt;relay_early_num--;
+	}
+	else
+	  cell.command = CELL_RELAY;
+  }
+  
   if (cpath_layer) {
     cell.circ_id = circ-&gt;n_circ_id;
     cell_direction = CELL_DIRECTION_OUT;

["tor_prop110_patch3.patch" (text/x-patch)]

diff -ru ../torpatch2/trunk/src/or/circuitbuild.c trunk/src/or/circuitbuild.c
--- ../torpatch2/trunk/src/or/circuitbuild.c	2007-09-05 16:59:04.000000000 -0600
+++ trunk/src/or/circuitbuild.c	2007-09-05 17:08:17.000000000 -0600
@@ -712,6 +712,14 @@
   char *onionskin;
   char *id_digest=NULL;
   
+  /** Part of patch 3 for proposal 110.  Make sure correct cell type is
+   * used when extend request is received. */
+  if (cell-&gt;command != CELL_RELAY_EARLY) {
+    log_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,
+           "Attempt to extend with incorrect cell type. Closing.");
+    return -1;
+  }
+  
   if (circ-&gt;n_conn) {
     log_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,
            "n_conn already set. Bug/attack. Closing.");
diff -ru ../torpatch2/trunk/src/or/relay.c trunk/src/or/relay.c
--- ../torpatch2/trunk/src/or/relay.c	2007-09-05 17:02:19.000000000 -0600
+++ trunk/src/or/relay.c	2007-09-05 17:08:17.000000000 -0600
@@ -234,6 +234,19 @@
                                   * we might kill the circ before we relay
                                   * the cells. */
 
+  /** Patch 3 for proposal 110, if too many extends have been seen on this
+  * circuit, end it! If the cell type is a regular relay cell, then set 
+  * &lt;b&gt;relay_early_seen&lt;/b&gt; higher than MAX_RELAY_EXTENDS so extending later
+  * is also disallowed NE 8-2007 */
+  if ((cell-&gt;command == CELL_RELAY_EARLY)&amp;&amp;(TO_OR_CIRCUIT(circ)-&gt;relay_early_seen &gt; \
MAX_RELAY_EXTENDS)) { +    log_fn(LOG_PROTOCOL_WARN,LD_PROTOCOL,
+           "Too many extends requested on this circuit, closing.");
+    return -END_CIRC_REASON_TORPROTOCOL;
+  }
+  else if ((cell-&gt;command == CELL_RELAY) &amp;&amp; (TO_OR_CIRCUIT(circ)-&gt;relay_early_seen &lt; \
MAX_RELAY_EXTENDS)) { +  	TO_OR_CIRCUIT(circ)-&gt;relay_early_seen = MAX_RELAY_EXTENDS + \
1; +  }
+
   append_cell_to_circuit_queue(circ, or_conn, cell, cell_direction);
   return 0;
 }



</body></email><email><emailId>20070906193236</emailId><senderName>"Wilfred L. Guerin"</senderName><senderEmail>wilfredguerin@gmail.com</senderEmail><timestampReceived>2007-09-06 19:32:36-0400</timestampReceived><subject>Re: Question on router to router communication</subject><body>

The initial design was intended to push as much data through any specific
wire or connection to provide additional cover for the trackability. There
was heated arguments about "cover noise" and constant loops being
established with continuous cyphers to eliminate entry-exit incident
tracking and provide for timed and buffered distribution. There are a lot of
ineffeciencies with this system as it currently stands, no less the use of a
single crypto method and lack of more diverse distribution models.

You can always run two services on a machine and loop to a similar
arrangement elsewhere, however it would be far more effective to use
multiple outgoing wires and multiple machines to facilitate intra-system
mixing prior to exit routes.

Remember, your https key negotiation goes on the same wire in a very
predictable manner right before your bank data does the same.

-Wilfred
Wilfred@Gmail.com

... I still find no published way to effectively protect intellectuals from
externally injected data or logistic liabilities.



On 9/6/07, Nick Mathewson &lt;nickm@freehaven.net&gt; wrote:
&gt;
&gt; On Wed, Sep 05, 2007 at 09:58:37AM -0700, Michael_google gmail_Gersten
&gt; wrote:
&gt; &gt; I've noticed that my tor configured as a client will only have one
&gt; &gt; outgoing TCP connection to an entry node, no matter how many circuits
&gt; &gt; Vidalia shows as going to that entry guard.
&gt; &gt;
&gt; &gt; I'm assuming that this continues on other router to router channels --
&gt; &gt; if there are three circuits that go from (for example) desync to
&gt; &gt; Tonga, there will only be one TCP connection.
&gt; &gt;
&gt; &gt; Is this necessary from a security standpoint? Tor can be sped up if
&gt; &gt; that "one channel per pair" restriction can be broken.
&gt;
&gt; Probably, yes?  Otherwise, it is trivial for an external attacker to
&gt; separate individual circuits and trace them more easily.  (It may be
&gt; possible to do this anyway with traffic analysis techniques, but also
&gt; maybe not.)
&gt;
&gt; For more information on the Tor design, you might want to check out
&gt; the design paper at http://tor.eff.org/doc/design-paper/tor-design.pdf .
&gt;
&gt; &gt; (Just like IP itself. A layer two connection between two nodes has (I
&gt; &gt; forget exactly) 8 channels, each of which can only have one
&gt; &gt; outstanding packet. Allowing Tor to have multiple channels between two
&gt; &gt; nodes will prevent a single stopped TCP from stopping all traffic
&gt; &gt; going that way.)
&gt;
&gt; Another long-term solution is possibly to switch to a UDP transport
&gt; between Tor servers (using DTLS in place of TLS) and then provide
&gt; reliability and ordering at a higher layer of the protocol.
&gt; Unfortunately, this is pretty hard, and we don't have a really solid
&gt; idea of how to do it best.
&gt;
&gt; yrs,
&gt; --
&gt; Nick Mathewson
&gt;
&gt;

[Attachment #3 (text/html)]

The initial design was intended to push as much data through any specific wire or \
connection to provide additional cover for the trackability. There was heated \
arguments about "cover noise" and constant loops being established with \
continuous cyphers to eliminate entry-exit incident tracking and provide for timed \
and buffered distribution. There are a lot of ineffeciencies with this system as it \
currently stands, no less the use of a single crypto method and lack of more diverse \
distribution models. &lt;br&gt;&lt;br&gt;You can always run two services on a machine and loop to \
a similar arrangement elsewhere, however it would be far more effective to use \
multiple outgoing wires and multiple machines to facilitate intra-system mixing prior \
to exit routes. &lt;br&gt;&lt;br&gt;Remember, your https key negotiation goes on the same wire in \
a very predictable manner right before your bank data does the \
same.&lt;br&gt;&lt;br&gt;-Wilfred&lt;br&gt;&lt;a \
                href="mailto:Wilfred@Gmail.com"&gt;Wilfred@Gmail.com&lt;/a&gt;&lt;br&gt;&lt;br&gt;
... I still find no published way to effectively protect intellectuals from \
externally injected data or logistic liabilities.&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;div&gt;&lt;span \
class="gmail_quote"&gt;On 9/6/07, &lt;b class="gmail_sendername"&gt;Nick Mathewson &lt;/b&gt; &lt;&lt;a \
href="mailto:nickm@freehaven.net"&gt;nickm@freehaven.net&lt;/a&gt;&gt; \
wrote:&lt;/span&gt;&lt;blockquote class="gmail_quote" style="border-left: 1px solid rgb(204, \
204, 204); margin: 0pt 0pt 0pt 0.8ex; padding-left: 1ex;"&gt;On Wed, Sep 05, 2007 at \
09:58:37AM -0700, Michael_google gmail_Gersten wrote: &lt;br&gt;&gt; I've noticed that \
my tor configured as a client will only have one&lt;br&gt;&gt; outgoing TCP connection to \
an entry node, no matter how many circuits&lt;br&gt;&gt; Vidalia shows as going to that \
entry guard.&lt;br&gt;&gt;&lt;br&gt; &gt; I'm assuming that this continues on other router to \
router channels --&lt;br&gt;&gt; if there are three circuits that go from (for example) \
desync to&lt;br&gt;&gt; Tonga, there will only be one TCP connection.&lt;br&gt;&gt;&lt;br&gt;&gt; Is \
this necessary from a security standpoint? Tor can be sped up if &lt;br&gt;&gt; that \
"one channel per pair" restriction can be broken.&lt;br&gt;&lt;br&gt;Probably, \
yes?Otherwise, it is trivial for an external attacker to&lt;br&gt;separate \
individual circuits and trace them more easily.(It may be &lt;br&gt;possible to \
do this anyway with traffic analysis techniques, but also&lt;br&gt;maybe not.)&lt;br&gt;&lt;br&gt;For \
more information on the Tor design, you might want to check out&lt;br&gt;the design paper \
at &lt;a href="http://tor.eff.org/doc/design-paper/tor-design.pdf"&gt; \
http://tor.eff.org/doc/design-paper/tor-design.pdf&lt;/a&gt; .&lt;br&gt;&lt;br&gt;&gt; (Just like IP \
itself. A layer two connection between two nodes has (I&lt;br&gt;&gt; forget exactly) 8 \
channels, each of which can only have one&lt;br&gt;&gt; outstanding packet. Allowing Tor to \
have multiple channels between two &lt;br&gt;&gt; nodes will prevent a single stopped TCP \
from stopping all traffic&lt;br&gt;&gt; going that way.)&lt;br&gt;&lt;br&gt;Another long-term solution \
is possibly to switch to a UDP transport&lt;br&gt;between Tor servers (using DTLS in place \
of TLS) and then provide &lt;br&gt;reliability and ordering at a higher layer of the \
protocol.&lt;br&gt;Unfortunately, this is pretty hard, and we don't have a really \
solid&lt;br&gt;idea of how to do it best.&lt;br&gt;&lt;br&gt;yrs,&lt;br&gt;--&lt;br&gt;Nick \
Mathewson&lt;br&gt;&lt;br&gt;&lt;/blockquote&gt; &lt;/div&gt;&lt;br&gt;



</body></email><email><emailId>20070908121914</emailId><senderName>"Christian Wilms"</senderName><senderEmail>christian.wilms@gmx.de</senderEmail><timestampReceived>2007-09-08 12:19:14-0400</timestampReceived><subject>Seminar Thesis on Hidden Service Performance</subject><body>

Hi everybody,

I wrote a seminar thesis concerning the performance of hidden services in
Tor. 

The thesis describes the way I performed the tests and the results, i.e. the
time it takes to receive the rendezvous descriptors, transfer times of most
cells and times to build circuits. I found a high variability in all steps
of establishing a hidden service, but also hints, where we can save some
time.

The paper can be found at the following location:
http://www.uni-bamberg.de/en/fakultaeten/wiai/faecher/informatik/lspi/bereic
h/research/software_projects/personalized-hidden-services/

My next step is to accelerate the whole process by implementing changes at
various points and to test those changes to prove the impact.

Comments are welcome!

Chris


</body></email><email><emailId>20070909164100</emailId><senderName>"Eric C"</senderName><senderEmail>soccerislander@gmail.com</senderEmail><timestampReceived>2007-09-09 16:41:00-0400</timestampReceived><subject>Setting up Private Tor Network with the real one</subject><body>

Hi all,

I emailed this question to or-talk but I think this might require some
changes to the code, so or-dev might be a better place. I know this
should never be done and should not be implemented in Tor, but I
wanted to do this for research purposes only. Thank you for any ideas
and help.

I have my own private Tor network (with 3 directory servers and some
Tor servers) running, and I wanted my Tor client to talk to both my
directory servers and the real hard-coded directory servers.

Right now, my private Tor network is completely separate from the real
Tor network. So, none of my directory servers or my Tor servers show
up in any of the hard-coded directory servers. Although that will be
much easier, I don't want my Tor servers to show up in the hard-coded
directory servers.

I have my Tor client and want to be able to choose between both my Tor
servers and the real Tor servers for building a circuit. However,
since my 3 directory servers and the 3 (I chose moria1, moria2, and
tor26) hard-coded directory servers don't agree on router descriptors
(since the two networks are disjoint), I am never able to establish
any circuit.

I tried to go through the source code to change the check so that even
if one directory server says it has the router descriptor for a Tor
server (call it A), and the other 5 don't have A, it will still use A
as a node in the circuit. However, that didn't work, most likely
because I didn't change the correct code or something else.

Any ideas about how to make this work will be much appreciated.

Thanks,

Eric
</body></email><email><emailId>20070915091253</emailId><senderName>Robert Hogan</senderName><senderEmail>robert@roberthogan.net</senderEmail><timestampReceived>2007-09-15 09:12:53-0400</timestampReceived><subject>Re: [or-cvs] r11434: Complete implementation of proposal 104: remove bandwidth hi (in tor/trunk: . d</subject><body>

On Friday 14 September 2007 20:24:49 Nick Mathewson wrote:
&gt; On Fri, Sep 14, 2007 at 07:16:39PM +0100, Robert Hogan wrote:
&gt; &gt; On Wednesday 12 September 2007 18:33:23 nickm@seul.org wrote:
&gt; &gt; &gt; Log:
&gt; &gt; &gt;  r14392@Kushana:  nickm | 2007-09-12 11:04:20 -0400
&gt; &gt; &gt;  Complete implementation of proposal 104: remove bandwidth history
&gt; &gt; &gt; lines from router descriptors.
&gt;
&gt; [Lines re-wrapped.]
&gt;
&gt; &gt; I recently completed a feature in tork that utilises the bandwidth
&gt; &gt; history. I dug a bit more into how i would use the 'extra-info'
&gt; &gt; option to retrieve the bandwidth history in future and have a couple
&gt; &gt; of notes/questions:
&gt; &gt;
&gt; &gt; There's currently no way of getting extra-info for just one
&gt; &gt; descriptor from the control interface. Tor either downloads
&gt; &gt; extra-info for all descriptors or none at all. What would be the
&gt; &gt; best way of making extra-info available on demand from the control
&gt; &gt; interface?
&gt;
&gt; Actually, it's probably best to not fetch the extra-info stuff for
&gt; clients at all.  Fetching on-demand is a risky feature, since it tells
&gt; the directories which servers you're interested in.  Are you sure this
&gt; is really something you need?
&gt;

Understood. I'll just make downloadextrainfo an across-the-board  option for 
those who want to see bandwidth history with server info.


</body></email><email><emailId>20070915195726</emailId><senderName>Robert Hogan</senderName><senderEmail>robert@roberthogan.net</senderEmail><timestampReceived>2007-09-15 19:57:26-0400</timestampReceived><subject>Re: [patch] server status getinfos</subject><body>


On Saturday 15 September 2007 19:37:21 Nick Mathewson wrote:
&gt;
&gt; Yes, but we need to think about backward compatibility!  Any program
&gt; which previously worked by looking for REACHABILITY_SUCCEEDED (which
&gt; has been shipped in the stable 0.1.2.x series) would break if we split
&gt; it like this.  It is not okay to change events around to break old
&gt; programs, when we can avoid this.
&gt;
&gt; There's a pretty easy fix.  How about if the events become:
&gt;
&gt;      "status/reachability-succeeded/or"
&gt;          0 or 1.
&gt;      "status/reachability-succeeded/dir"
&gt;          0 or 1
&gt;      "status/reachability-succeeded"
&gt;          "OR=" ("0"/"1") SP "DIR=" ("0"/"1") ?
&gt;
&gt; and the REACHABILITY_SUCCEEDED events remain as-is?  Unless you
&gt; object, I'll rewrite the patch to do this instead.
&gt;

The approach I've taken in using the events, which is probably the natural 
one, is to map from the action to a text (for display to the user) that may 
or may not be filled out with information from the arguments.Orport and 
dirport reachability are different enough for this approach to break down in 
the case of REACHABILITY_SUCCEEDED.

So if no-one is using the REACHABILITY_SUCCEEDED and CHECKING_REACHABILITY 
events at the moment (vidalia isn't AFAICT) it might be an opportunity to 
make the 'action' of the two events distinct and therefore easier to process. 

I can live with whichever approach you prefer but just thought I would clarify 
my reasons for suggesting the change.

["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20070917225705</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-09-17 22:57:05-0400</timestampReceived><subject>Re: DirPort and BandwidthRate</subject><body>

On Mon, Sep 17, 2007 at 11:39:51AM -0700, Michael_google gmail_Gersten wrote:
&gt; &gt; MaxAdvertisedBandwidth 20480
&gt; &gt; Whoops! Never updated that. (I'm normally on DSL; I'm on cable temporarily.)
&gt; &gt;
&gt; &gt; Nickname nsavaxBangKremvax
&gt; And as soon as I commented that line out, the dirport gets advertised.

weasel convinced me that this was a bug, so it is now fixed:
http://archives.seul.org/or/cvs/Sep-2007/msg00123.html

--Roger

</body></email><email><emailId>20070919124710</emailId><senderName>Paul Syverson</senderName><senderEmail>syverson@itd.nrl.navy.mil</senderEmail><timestampReceived>2007-09-19 12:47:10-0400</timestampReceived><subject>Re: Exit guards?</subject><body>

On Tue, Sep 18, 2007 at 10:12:45PM -0700, Michael_google gmail_Gersten wrote:
&gt; Thinking about the "evil exit node" issue, I'm wondering: Do we need
&gt; exit guards?
&gt; 
&gt; Entry guards aren't magical. Without entry guards, you will eventually
&gt; hit a path with both the entry and exit node under control of the
&gt; attacker, and your anonymity is lost.
&gt; 
&gt; Same idea for exit guards. Not magical. But now you have a chance that
&gt; your information won't be lost to a bad node, while without them you
&gt; will eventually hit a bad exit node.

A problem is that entry guards are subject to profiling, albeit
pseudonymous profiling by the middle node and, to some extent, others
watching the communication out of the entry guards.  We showed this
empirically in "Locating Hidden Servers" (the place where entry guards
for Tor were fist described). Lasse's experiments found the set of
entry guards for hidden services.  (Cf. also "Low-Resource Routing
Attacks Aganst Tor" by Bauer et al. for related but distinct issues
and explication and study of some of our attacks extended to ordinary
Tor circuits.)  In any case, this is perhaps not too bad if the exit is
honest.

Once we've added exit guards, the only element that is random per
circuit is the middle node, which can now profile both entries and
exits and their correlations. Hostile middle nodes can thus build
profiles and decide which nodes are worth further investigation/attack
in virtue of being part of interesting entry-exit pairs. Probably the
real answer is to just have relatively trusted whole paths, if you can
get them while maintaining sufficient anonymity and you can make sense
of adequate trust. For the general user this is probably not feasible,
and s/he will need to have entry or exit guards but not both, usually
entry guards since it is the client IP address that we more want to
protect. (But not always: imagine you are in a hotel room somewhere
for a day and you want to connect to a server at work or that you
own. In that case it is where you are headed that matters more.)
Hopefully I will have worked out much of this in a more rigorous
fashion before, well, too long.

aloha,
Paul
</body></email><email><emailId>20070914181639</emailId><senderName>Robert Hogan</senderName><senderEmail>robert@roberthogan.net</senderEmail><timestampReceived>2007-09-14 18:16:39-0400</timestampReceived><subject>Re: [or-cvs] r11434: Complete implementation of proposal 104: remove bandwidth hi (in tor/trunk: . d</subject><body>


On Wednesday 12 September 2007 18:33:23 nickm@seul.org wrote:
&gt; Log:
&gt;  r14392@Kushana:  nickm | 2007-09-12 11:04:20 -0400
&gt;  Complete implementation of proposal 104: remove bandwidth history lines
&gt; from router descriptors.
&gt;
&gt;

I recently completed a feature in tork that utilises the bandwidth history. I 
dug a bit more into how i would  use the 'extra-info' option to retrieve the 
bandwidth history in future and have a couple of notes/questions:

There's currently no way of getting extra-info for just one descriptor from 
the control interface. Tor either downloads extra-info for all descriptors or 
none at all. What would be the best way of making extra-info available on 
demand from the control interface?

Should tor download extra-info for a router if it receives a getinfo 
server/desc/fd/xxx for that router, in anticipation of a possible extra-info 
request?

Or would a setevents extra-info interface be better? If enabled, this would 
provide an asychronous extra-info message body for every server/desc/fd 
request received.

Also, there are a couple of typos in control.c, one of which prevents getinfo 
extra-info/digest from working.

Index: src/or/control.c
===================================================================
--- src/or/control.c    (revision 11439)
+++ src/or/control.c    (working copy)
@@ -1681,7 +1681,7 @@
   ITEM("desc/all-recent", dir,
        "All non-expired, non-superseded router descriptors."),
   ITEM("desc/all-recent-extrainfo-hack", dir, NULL), /* Hack. */
-  PREFIX("extrainfo/digest/", dir, "Extra-info documents by digest."),
+  PREFIX("extra-info/digest/", dir, "Extra-info documents by digest."),
   ITEM("ns/all", networkstatus,
        "Brief summary of router status (v2 directory format)"),
   PREFIX("ns/id/", networkstatus,
@@ -1689,7 +1689,7 @@
   PREFIX("ns/name/", networkstatus,
          "Brief summary of router status by nickname (v2 directory 
format)."),

-  PREFIX("unregisterd-servers-", dirserv_unregistered, NULL),
+  PREFIX("unregistered-servers-", dirserv_unregistered, NULL),
   ITEM("network-status", dir,
        "Brief summary of router status (v1 directory format)"),
   ITEM("circuit-status", events, "List of current circuits originating 
here."),


["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20070908183235</emailId><senderName>Robert Hogan</senderName><senderEmail>robert@roberthogan.net</senderEmail><timestampReceived>2007-09-08 18:32:35-0400</timestampReceived><subject>[patch] server status getinfos</subject><body>

[Attachment #2 (multipart/mixed)]


Adds getinfo:

    "status/good-server-descriptor"
    "status/or-reachability-succeeded"
    "status/dir-reachability-succeeded"

and splits out the REACHABILITY_SUCCEEDED event into:

OR_REACHABILITY_SUCCEEDED
DIR_REACHABILITY_SUCCEEDED

This makes sense because it maintains the one-to-one relationship between 
getinfo requests and status-events, getinfo reachability-succeeded would be 
too ambiguous to be useful, and makes writing controllers simpler because it 
is easier to identify the meaning of a status event by the 'action' of *all* 
status events rather than, in special cases, a combination of the action and 
one or more of the arguments.


["getinfos.diff" (text/x-diff)]

Index: src/or/control.c
===================================================================
--- src/or/control.c	(revision 11403)
+++ src/or/control.c	(working copy)
@@ -1590,6 +1590,12 @@
       *answer = tor_strdup(has_completed_circuit ? "1" : "0");
     } else if (!strcmp(question, "status/enough-dir-info")) {
       *answer = tor_strdup(router_have_minimum_dir_info() ? "1" : "0");
+    } else if (!strcmp(question, "status/good-server-descriptor")) {
+      *answer = tor_strdup(have_good_server_descriptor() ? "1" : "0");
+    } else if (!strcmp(question, "status/or-reachability-succeeded")) {
+      *answer = tor_strdup(check_whether_orport_reachable() ? "1" : "0");
+    } else if (!strcmp(question, "status/dir-reachability-succeeded")) {
+      *answer = tor_strdup(check_whether_dirport_reachable() ? "1" : "0");
     } else if (!strcmpstart(question, "status/version/")) {
       combined_version_status_t st;
       int is_server = server_mode(get_options());
Index: src/or/or.h
===================================================================
--- src/or/or.h	(revision 11403)
+++ src/or/or.h	(working copy)
@@ -2761,6 +2761,7 @@
 
 /********************************* directory.c ***************************/
 
+int have_good_server_descriptor(void);
 char *authority_type_to_string(authority_type_t auth);
 void directory_post_to_dirservers(uint8_t dir_purpose, uint8_t router_purpose,
                                   authority_type_t type, const char *payload,
Index: src/or/directory.c
===================================================================
--- src/or/directory.c	(revision 11403)
+++ src/or/directory.c	(working copy)
@@ -183,6 +183,25 @@
   return 0;
 }
 
+/** Return true iff all trusted directory servers have accepted our
+ * server descriptor. */
+int
+have_good_server_descriptor(void)
+{
+  int all_done = 1;
+  smartlist_t *servers;
+  servers = router_get_trusted_dir_servers();
+  SMARTLIST_FOREACH(servers, trusted_dir_server_t *, d, {
+    if ((d-&gt;type &amp; (V1_AUTHORITY|V2_AUTHORITY)) &amp;&amp;
+        !d-&gt;has_accepted_serverdesc) {
+      all_done = 0;
+      break;
+    }
+  });
+  return all_done;
+}
+
+
 /** Start a connection to every suitable directory authority, using
  * connection purpose 'purpose' and uploading the payload 'payload'
  * (length 'payload_len').  The purpose should be one of
@@ -1385,10 +1404,8 @@
   if (conn-&gt;_base.purpose == DIR_PURPOSE_UPLOAD_DIR) {
     switch (status_code) {
       case 200: {
-          int all_done = 1;
           trusted_dir_server_t *ds =
             router_get_trusteddirserver_by_digest(conn-&gt;identity_digest);
-          smartlist_t *servers;
           log_info(LD_GENERAL,"eof (status 200) after uploading server "
                    "descriptor: finished.");
           control_event_server_status(
@@ -1396,15 +1413,7 @@
                       conn-&gt;_base.address, conn-&gt;_base.port);
 
           ds-&gt;has_accepted_serverdesc = 1;
-          servers = router_get_trusted_dir_servers();
-          SMARTLIST_FOREACH(servers, trusted_dir_server_t *, d, {
-              if ((d-&gt;type &amp; (V1_AUTHORITY|V2_AUTHORITY)) &amp;&amp;
-                  !d-&gt;has_accepted_serverdesc) {
-                all_done = 0;
-                break;
-              }
-            });
-          if (all_done)
+          if (have_good_server_descriptor())
             control_event_server_status(LOG_NOTICE, "GOOD_SERVER_DESCRIPTOR");
         }
         break;
Index: src/or/router.c
===================================================================
--- src/or/router.c	(revision 11403)
+++ src/or/router.c	(working copy)
@@ -649,7 +649,7 @@
     if (!me)
       return;
     control_event_server_status(LOG_NOTICE,
-                                "REACHABILITY_SUCCEEDED ORADDRESS=%s:%d",
+                                "OR_REACHABILITY_SUCCEEDED ORADDRESS=%s:%d",
                                 me-&gt;address, me-&gt;dir_port);
   }
 }
@@ -667,7 +667,7 @@
     if (!me)
       return;
     control_event_server_status(LOG_NOTICE,
-                                "REACHABILITY_SUCCEEDED DIRADDRESS=%s:%d",
+                                "DIR_REACHABILITY_SUCCEEDED_DIR DIRADDRESS=%s:%d",
                                 me-&gt;address, me-&gt;dir_port);
   }
 }
Index: doc/spec/control-spec.txt
===================================================================
--- doc/spec/control-spec.txt	(revision 11403)
+++ doc/spec/control-spec.txt	(working copy)
@@ -524,6 +524,9 @@
 
     "status/circuit-established"
     "status/enough-dir-info"
+    "status/good-server-descriptor"
+    "status/or-reachability-succeeded"
+    "status/dir-reachability-succeeded"
     "status/..."
       These provide the current internal Tor values for various Tor
       states. See Section 4.1.10 for explanations. (Only a few of the
@@ -1318,11 +1321,14 @@
        {This event could effect the controller's idea of server status, but
        the controller should not interrupt the user to tell them so.}
 
-     REACHABILITY_SUCCEEDED
+     OR_REACHABILITY_SUCCEEDED
      "ORADDRESS=IP:port"
+       We successfully verified the reachability of our external OR port.
+
+     DIR_REACHABILITY_SUCCEEDED
      "DIRADDRESS=IP:port"
-       We successfully verified the reachability of our external OR port or
-       directory port.
+       We successfully verified the reachability of our external directory
+       port.
 
        {This event could effect the controller's idea of server status, but
        the controller should not interrupt the user to tell them so.}

["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20070917163603</emailId><senderName>"Michael_google gmail_Gersten"</senderName><senderEmail>keybounce@gmail.com</senderEmail><timestampReceived>2007-09-17 16:36:03-0400</timestampReceived><subject>DirPort and BandwidthRate</subject><body>

My log shows:
Sep 17 09:32:44.918 [notice] Not advertising DirPort (Reason:
BandwidthRate under 50KB)
Sep 17 09:32:55.968 [notice] Self-testing indicates your ORPort is
reachable from the outside. Excellent. Publishing server descriptor.

Sep 17 09:33:03.643 [notice] Performing bandwidth self-test...done.


My torrc says:
BandwidthRate  51 kb
BandwidthBurst 51 kb

Since the bandwidth self test hasn't been done at the "not
advertising" line, and my torrc states that the bandwidth is enough,
why isn't this working?
</body></email><email><emailId>20070917171125</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-09-17 17:11:25-0400</timestampReceived><subject>Re: DirPort and BandwidthRate</subject><body>


On Mon, Sep 17, 2007 at 09:36:03AM -0700, Michael_google gmail_Gersten wrote:
&gt; My log shows:
&gt; Sep 17 09:32:44.918 [notice] Not advertising DirPort (Reason:
&gt; BandwidthRate under 50KB)
&gt; Sep 17 09:32:55.968 [notice] Self-testing indicates your ORPort is
&gt; reachable from the outside. Excellent. Publishing server descriptor.
&gt; 
&gt; Sep 17 09:33:03.643 [notice] Performing bandwidth self-test...done.
&gt; 
&gt; 
&gt; My torrc says:
&gt; BandwidthRate  51 kb
&gt; BandwidthBurst 51 kb
&gt; 
&gt; Since the bandwidth self test hasn't been done at the "not
&gt; advertising" line, and my torrc states that the bandwidth is enough,
&gt; why isn't this working?

Strange!  What version of Tor is this?

-- 
Nick Mathewson

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070917171835</emailId><senderName>"Michael_google gmail_Gersten"</senderName><senderEmail>keybounce@gmail.com</senderEmail><timestampReceived>2007-09-17 17:18:35-0400</timestampReceived><subject>Re: DirPort and BandwidthRate</subject><body>

On 9/17/07, Nick Mathewson &lt;nickm@freehaven.net&gt; wrote:
&gt; On Mon, Sep 17, 2007 at 09:36:03AM -0700, Michael_google gmail_Gersten wrote:
&gt; &gt; My log shows:
&gt; &gt; Sep 17 09:32:44.918 [notice] Not advertising DirPort (Reason:
&gt; &gt; BandwidthRate under 50KB)
&gt; &gt; Sep 17 09:32:55.968 [notice] Self-testing indicates your ORPort is
&gt; &gt; reachable from the outside. Excellent. Publishing server descriptor.
&gt; &gt;
&gt; &gt; Sep 17 09:33:03.643 [notice] Performing bandwidth self-test...done.
&gt; &gt;
&gt; &gt;
&gt; &gt; My torrc says:
&gt; &gt; BandwidthRate  51 kb
&gt; &gt; BandwidthBurst 51 kb
&gt; &gt;
&gt; &gt; Since the bandwidth self test hasn't been done at the "not
&gt; &gt; advertising" line, and my torrc states that the bandwidth is enough,
&gt; &gt; why isn't this working?
&gt;
&gt; Strange!  What version of Tor is this?
&gt;
&gt; --
&gt; Nick Mathewson

Sep 17 09:31:04.585 [notice] Tor v0.1.2.16. This is experimental
software. Do not rely on it for strong anonymity.

Hmm... I thought I was running the 2. series.
</body></email><email><emailId>20070917183140</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-09-17 18:31:40-0400</timestampReceived><subject>Re: DirPort and BandwidthRate</subject><body>

On Mon, Sep 17, 2007 at 10:18:35AM -0700, Michael_google gmail_Gersten wrote:
&gt; &gt; &gt; My log shows:
&gt; &gt; &gt; Sep 17 09:32:44.918 [notice] Not advertising DirPort (Reason:
&gt; &gt; &gt; BandwidthRate under 50KB)
&gt; &gt; &gt; Sep 17 09:32:55.968 [notice] Self-testing indicates your ORPort is
&gt; &gt; &gt; reachable from the outside. Excellent. Publishing server descriptor.
&gt; &gt; &gt;
&gt; &gt; &gt; Sep 17 09:33:03.643 [notice] Performing bandwidth self-test...done.
&gt; &gt; &gt;
&gt; &gt; &gt;
&gt; &gt; &gt; My torrc says:
&gt; &gt; &gt; BandwidthRate  51 kb
&gt; &gt; &gt; BandwidthBurst 51 kb
&gt; &gt; &gt;
&gt; &gt; &gt; Since the bandwidth self test hasn't been done at the "not
&gt; &gt; &gt; advertising" line, and my torrc states that the bandwidth is enough,
&gt; &gt; &gt; why isn't this working?
&gt;
&gt; Sep 17 09:31:04.585 [notice] Tor v0.1.2.16. This is experimental
&gt; software. Do not rely on it for strong anonymity.
&gt; 
&gt; Hmm... I thought I was running the 2. series.

Hm. If you had BandwidthRate set to 50KB, I would have an explanation:
http://archives.seul.org/or/cvs/Feb-2007/msg00032.html

But for 51KB, I don't have a good answer. Perhaps you have another line
in your torrc somewhere, like MaxAdvertisedBandwidth?

In any case, which nickname are you, so we can look at it more carefully?

--Roger

</body></email><email><emailId>20070917183819</emailId><senderName>"Michael_google gmail_Gersten"</senderName><senderEmail>keybounce@gmail.com</senderEmail><timestampReceived>2007-09-17 18:38:19-0400</timestampReceived><subject>Re: DirPort and BandwidthRate</subject><body>

On 9/17/07, Roger Dingledine &lt;arma@mit.edu&gt; wrote:
&gt; On Mon, Sep 17, 2007 at 10:18:35AM -0700, Michael_google gmail_Gersten wrote:
&gt; &gt; &gt; &gt; My log shows:
&gt; &gt; &gt; &gt; Sep 17 09:32:44.918 [notice] Not advertising DirPort (Reason:
&gt; &gt; &gt; &gt; BandwidthRate under 50KB)
&gt; &gt; &gt; &gt; Sep 17 09:32:55.968 [notice] Self-testing indicates your ORPort is
&gt; &gt; &gt; &gt; reachable from the outside. Excellent. Publishing server descriptor.
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; Sep 17 09:33:03.643 [notice] Performing bandwidth self-test...done.
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; My torrc says:
&gt; &gt; &gt; &gt; BandwidthRate  51 kb
&gt; &gt; &gt; &gt; BandwidthBurst 51 kb
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; Since the bandwidth self test hasn't been done at the "not
&gt; &gt; &gt; &gt; advertising" line, and my torrc states that the bandwidth is enough,
&gt; &gt; &gt; &gt; why isn't this working?
&gt; &gt;
&gt; &gt; Sep 17 09:31:04.585 [notice] Tor v0.1.2.16. This is experimental
&gt; &gt; software. Do not rely on it for strong anonymity.
&gt; &gt;
&gt; &gt; Hmm... I thought I was running the 2. series.
&gt;
&gt; Hm. If you had BandwidthRate set to 50KB, I would have an explanation:
&gt; http://archives.seul.org/or/cvs/Feb-2007/msg00032.html
&gt;
&gt; But for 51KB, I don't have a good answer. Perhaps you have another line
&gt; in your torrc somewhere, like MaxAdvertisedBandwidth?
&gt;
&gt; In any case, which nickname are you, so we can look at it more carefully?
&gt;
&gt; --Roger

MaxAdvertisedBandwidth 20480
Whoops! Never updated that. (I'm normally on DSL; I'm on cable temporarily.)

Nickname nsavaxBangKremvax
</body></email><email><emailId>20070917183951</emailId><senderName>"Michael_google gmail_Gersten"</senderName><senderEmail>keybounce@gmail.com</senderEmail><timestampReceived>2007-09-17 18:39:51-0400</timestampReceived><subject>Re: DirPort and BandwidthRate</subject><body>

&gt; MaxAdvertisedBandwidth 20480
&gt; Whoops! Never updated that. (I'm normally on DSL; I'm on cable temporarily.)
&gt;
&gt; Nickname nsavaxBangKremvax
And as soon as I commented that line out, the dirport gets advertised.
</body></email><email><emailId>20070915183721</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-09-15 18:37:21-0400</timestampReceived><subject>Re: [patch] server status getinfos</subject><body>


On Sat, Sep 08, 2007 at 07:32:35PM +0100, Robert Hogan wrote:
&gt; 
&gt; Adds getinfo:
&gt; 
&gt;     "status/good-server-descriptor"
&gt;     "status/or-reachability-succeeded"
&gt;     "status/dir-reachability-succeeded"

This part is good.

&gt; and splits out the REACHABILITY_SUCCEEDED event into:
&gt; 
&gt; OR_REACHABILITY_SUCCEEDED
&gt; DIR_REACHABILITY_SUCCEEDED

&gt; 
&gt; This makes sense because it maintains the one-to-one relationship between 
&gt; getinfo requests and status-events, getinfo reachability-succeeded would be 
&gt; too ambiguous to be useful, and makes writing controllers simpler because it 
&gt; is easier to identify the meaning of a status event by the 'action' of *all* 
&gt; status events rather than, in special cases, a combination of the action and 
&gt; one or more of the arguments.

Yes, but we need to think about backward compatibility!  Any program
which previously worked by looking for REACHABILITY_SUCCEEDED (which
has been shipped in the stable 0.1.2.x series) would break if we split
it like this.  It is not okay to change events around to break old
programs, when we can avoid this.

There's a pretty easy fix.  How about if the events become:

     "status/reachability-succeeded/or"
         0 or 1.
     "status/reachability-succeeded/dir"
         0 or 1
     "status/reachability-succeeded"
         "OR=" ("0"/"1") SP "DIR=" ("0"/"1") ?

and the REACHABILITY_SUCCEEDED events remain as-is?  Unless you
object, I'll rewrite the patch to do this instead.

yrs,
-- 
Nick Mathewson

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070919051245</emailId><senderName>"Michael_google gmail_Gersten"</senderName><senderEmail>keybounce@gmail.com</senderEmail><timestampReceived>2007-09-19 05:12:45-0400</timestampReceived><subject>Exit guards?</subject><body>

Thinking about the "evil exit node" issue, I'm wondering: Do we need
exit guards?

Entry guards aren't magical. Without entry guards, you will eventually
hit a path with both the entry and exit node under control of the
attacker, and your anonymity is lost.

Same idea for exit guards. Not magical. But now you have a chance that
your information won't be lost to a bad node, while without them you
will eventually hit a bad exit node.
</body></email><email><emailId>20070914192449</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-09-14 19:24:49-0400</timestampReceived><subject>Re: [or-cvs] r11434: Complete implementation of proposal 104: remove bandwidth hi (in tor/trunk: . d</subject><body>


On Fri, Sep 14, 2007 at 07:16:39PM +0100, Robert Hogan wrote:
&gt; On Wednesday 12 September 2007 18:33:23 nickm@seul.org wrote:
&gt; &gt; Log:
&gt; &gt;  r14392@Kushana:  nickm | 2007-09-12 11:04:20 -0400
&gt; &gt;  Complete implementation of proposal 104: remove bandwidth history lines
&gt; &gt; from router descriptors.
&gt; &gt;
&gt; &gt;

[Lines re-wrapped.]

&gt; 
&gt; I recently completed a feature in tork that utilises the bandwidth
&gt; history. I dug a bit more into how i would use the 'extra-info'
&gt; option to retrieve the bandwidth history in future and have a couple
&gt; of notes/questions:
&gt;
&gt; There's currently no way of getting extra-info for just one
&gt; descriptor from the control interface. Tor either downloads
&gt; extra-info for all descriptors or none at all. What would be the
&gt; best way of making extra-info available on demand from the control
&gt; interface?

Actually, it's probably best to not fetch the extra-info stuff for
clients at all.  Fetching on-demand is a risky feature, since it tells
the directories which servers you're interested in.  Are you sure this
is really something you need?

&gt; Should tor download extra-info for a router if it receives a getinfo
&gt; server/desc/fd/xxx for that router, in anticipation of a possible
&gt; extra-info request?

Probably not; see above.

&gt; Or would a setevents extra-info interface be better? If enabled,
&gt; this would provide an asychronous extra-info message body for every
&gt; server/desc/fd request received.
&gt;
&gt; Also, there are a couple of typos in control.c, one of which
&gt; prevents getinfo extra-info/digest from working.
&gt; 

Will apply, thanks.



-- 
Nick Mathewson

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070919172533</emailId><senderName>"Michael_google gmail_Gersten"</senderName><senderEmail>keybounce@gmail.com</senderEmail><timestampReceived>2007-09-19 17:25:33-0400</timestampReceived><subject>Privoxy bundle: configuration</subject><body>

I just upgraded the tor/privoxy bundle on my Mac Os 10.4 to .17

The config file supplied is old, not the current privoxy config.
Worse, I have a lot of customized .forward lines in mine, all of which
want to be wiped.

There are two issues here. First, the default action is to replace the
users config with a stock one. No place for customizations to be
saved. No "Only install a config if there isn't one already".

The second issue: Privoxy needs an "Include" directive, so that users
can have their customizations included even when the stock file is
updated with a new version.
</body></email><email><emailId>20070919181440</emailId><senderName></senderName><senderEmail>phobos</senderEmail><timestampReceived>2007-09-19 18:14:40-0400</timestampReceived><subject>Re: Privoxy bundle: configuration</subject><body>

On Wed, Sep 19, 2007 at 10:25:33AM -0700, keybounce@gmail.com wrote 0.6K bytes in 13 lines about:
: I just upgraded the tor/privoxy bundle on my Mac Os 10.4 to .17
: The config file supplied is old, not the current privoxy config.
: Worse, I have a lot of customized .forward lines in mine, all of which
: want to be wiped.

This is odd to me.  The PreFlight script makes a tarball of all your
configs, and puts it in /tmp/TorSavedMe.tar.gz while the install runs.
The PostFlight script extracts TorSavedMe.tar.gz to put back the custom
configs.

The scripts are
https://tor-svn.freehaven.net/svn/tor/branches/tor-0_1_2-patches/contrib/osx/TorPreFlight
and
https://tor-svn.freehaven.net/svn/tor/branches/tor-0_1_2-patches/contrib/osx/TorPostflight

What files were overwritten? We specifically back up $PRIVOXYPATH/config
$PRIVOXYPATH/user.action, if there is another we should be saving
through the upgrade/install, let me know.

-- 
Andrew
</body></email><email><emailId>20070926142029</emailId><senderName>Karsten Loesing</senderName><senderEmail>karsten.loesing@gmx.net</senderEmail><timestampReceived>2007-09-26 14:20:29-0400</timestampReceived><subject>Proposal: Hidden Service Authentication</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Hi everyone,

we would like to propose an extension of Tor hidden services towards
providing authentication. This includes authentication at the hidden
service and at introduction points, both either via password or
public-key authentication.

This gives us the new security property of access control, improves
hiding service activity from unauthorized clients, and reduces traffic
by dropping false requests as soon as possible.

Comments are welcome! :)

- --Tobias, Thomas, Karsten, Ferdinand, and Christoph
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFG+mqt0M+WPffBEmURAjNyAKCyox0rlBwiygrNtI7PU2JrPQX/xgCfW3QK
V91+U7PrgcW+cIJYvUrt+BE=
=LyG0
-----END PGP SIGNATURE-----

["hidden-service-authentication.txt" (text/plain)]

Filename: 121-hidden-service-authentication.txt
Title: Hidden Service Authentication
Version: $LastChangedRevision: 469 $
Last-Modified: $LastChangedDate: 2007-09-26 14:16:52 +0200 (Mi, 26 Sep 2007) $
Author: Tobias Kamm, Thomas Lauterbach, Karsten Loesing, Ferdinand Rieger,
        Christoph Weingarten
Created: 10-Sep-2007
Status: Open

Change history:

  26-Sep-2007  Initial proposal for or-dev

Overview:

  This proposal deals with some possibilities to implement authentication
  for restricted access to hidden services. This way we try to increase the
  security level for the service provider (Bob) by giving him the ability
  to exclude non-authorized users from using his service. It is based on
  proposal 114-distributed-storage but is better suited for a fine grained
  way of authentication, because it is less resource-consuming. Whenever we
  refer to service descriptors and cell formats, we are talking about the
  definitions found in 114-distributed-storage unless otherwise stated.

  We discuss password and public-key authentication for the Onion Proxy
  (OP) of Bob's hidden service (HS). Furthermore a challenge-response
  authentication mechanism is introduced at the introduction point.

  These modifications aim at:
   - increasing the security of hidden services by limiting access only to
     authorized users (specification see details) and
   - reducing the traffic in the network by rejecting unauthorized access
     requests earlier.

Motivation:

  The currently used implementation of hidden services does not provide any
  kind of authentication. The v2 implementation adds an authentication
  mechanism at the directory server. Security can be further improved by
  adding two more authentication authorities at the introduction point
  (IPo) and the OP.

  Although the service descriptors are already designed to carry
  authentication information the existing fields are not used so far.
  Moreover one can find a couple of notes at the specification of cell
  formats (rend-spec) which point at adding authentication information but
  no fields are specified yet. It would be preferable to extend the Tor
  network with authentication features to offer a solution for all
  services. This would also provide means to authorize access to services
  that currently do not support authentication mechanisms. Moreover, Bob's
  authentication administration for all services could be performed
  centralized in the Tor application, and the implementation overhead for
  developers would be significantly reduced. Another benefit would be the
  reduced traffic by checking authentication data and dropping unauthorized
  requests as soon as possible. For example unauthorized requests could
  already be discarded at the introduction points.

  In addition to that, our implementation is able to hide the service from
  users, who still have access to the secret cookie (see
  114-distributed-storage) but should no longer be authorized. Bob can now
  not only hide his location, but also to a certain degree his presence
  towards unauthorized clients given that none of his IPo's are corrupted.

Details:

  /1/ Client authentication at the hidden service

  In proposal 114 a client (Alice) who has a valid secret cookie, which may
  be considered as a form of authentication, and a service ID is able to
  connect to Bob if he is online. He can not distinguish between Alice
  being intentionally authorized by himself or being an attacker.
  Integrating authentication in Tor HS will ensure Bob that Alice is only
  able to use the service if she is authorized by him.    

  Authentication data will be transmitted via the RELAY_INTRODUCE1 cell
  from Alice to Bob that is forwarded by the IPo. For this message several
  format versions are specified in the rend-spec in section 1.8. We will
  use the format version 3. This specification already contains the fields
  "AUTHT" (to specify the authentication method), "AUTHL" (length of the
  authentication data), and "AUTHD" (the authentication data) that will be
  used to store authentication data. Since these fields are encrypted with
  the service's public key, sniffing attacks will fail. Bob will only build
  the circuit to the rendezvous point if the provided authentication data
  is valid, otherwise he will drop the cell. This will improve security due
  to preventing communication between Bob and Alice if she is an attacker.
  As a positive side effect it reduces network traffic because it avoids
  Bob from building unnecessary circuits to the rendezvous points.
  Authentication at the HS should be the last gatekeeper and the number of
  cases in which a client successfully passes the introduction point, but
  fails at the HS should be almost zero. Therefore it is very important to
  perform fine-grained access control already at the IPo (but without
  relying on it).

  The first authentication mechanism that will be supported is password
  (symmetric secret) authentication. "AUTHT" is set to "1" for this
  authentication method while the "AUTHL" field is set to "20", the length
  of the SHA-1 digest of the password.

  (1) Alice creates a password x and sends the password digest h(x) to Bob
      out of band.
  (2) Alice sends h(x) to Bob, encrypted with Bob's fresh service key (not
      subject to this proposal, see proposal 114).
  (3) Bob decrypts Alice's message using his private service key (see
      proposal 114) and compares the contained h(x) with what he knows what
      Alice's password digest h(x) should be.

  This kind of authentication is well-known. It has the known disadvantage
  of weak passwords that are vulnerable to dictionary or brute-force
  attacks. Nevertheless it seems to be an appropriate solution since safe
  passwords can be randomly generated by Tor. Cracking methods that rely on
  guessing passwords should not be effective in the constantly changing
  network infrastructure. A usability advantage is that this method is easy
  to perform even for unexperienced users. The authenticationdata will be
  the SHA-1 secure hash (see tor-spec) of the shared secret (password).

  The premise to use password authentication is that Bob must send the
  password to Alice outside Tor. If at the same time the secret cookie is
  transmitted and the message is intercepted the attacker can gain access
  to the service. Therefore, a secure way to exchange this information must
  be established.

  The second authentication mechanism is public-key authentication. The
  well-known RSA implementation will be used as cipher (see tor-spec). 
  Authentication data will be the hash of the rendezvous cookie, signed
  with the private key (SK).

  When Alice wants to use this authentication method she sets "AUTHT" to
  "2" and "AUTHL" to "128" which is the size of the encrypted data. Since
  the rendezvous cookie changes each time Alice connects, replay attacks
  can be easily prevented.

  (1) Alice creates a private key e and sends the corresponding public key
      d to Bob out of band.
  (2) Alice generates a random rendezvous cookie r, computes PKSign(e, r),
      encrypts it with Bob's fresh service key (see proposal 114), and
      sends the result to Bob.
  (3) Bob decrypts Alice's message using his private service key (see
      proposal 114) and verifies PKSign(e, r) with d.

  The premise for public-key authentication is that Alice must send the
  generated public key to Bob outside Tor. If an attacker is able to swap
  that key, the attacker could perform a man-in-the-middle attack, if he
  managed to serve as an IPo for Bob. Therefore a secure exchange channel
  must be established.

  Depending on what authentication data Bob knows from Alice (password
  and/or public key, or other data that is added later) there are several
  choices for Alice to authenticate to the service.

  After validating the provided "AUTHD" Bob builds a circuit to the
  rendezvous point and starts interacting with Alice. If Bob cannot
  identify the client he must refuse the request by not connecting to the
  rendezvous point.

  It will also still be possible to establish v2 hidden services without
  authentication. Therefore the "AUTHT" field must be set to "0". "AUTHL"
  and "AUTHD" are not provided by the client in that case.

  /2/ Client authentication at the introduction point 	

  In addition to authentication at the HS OP, the IPo should be able to
  detect and abandon all unauthorized requests. This would help to raise
  the level of privacy and therefore also the level of security for Bob by
  better hiding his online activity from unauthorized users. Especially if
  Alice still has access to the secret cookie. This can be the case if she
  had access to the service earlier, but is no longer authorized or the
  directory is outdated. Another advantage of this additional "gate keeper"
  would be reduced traffic in the network, because unauthorized requests
  could already be detected and declined at the IPo.

  It is important to notice that the IPo may not be trustworthy, and
  therefore can not replace authentication at the HS OP itself. Nor should
  the IPo get hold of critical authentication information (because it could
  try to access the service itself).

  A challenge-response authentication protocol is used to address these
  issues. This means that a challenge is needed to be solved by Alice to
  get forwarded to Bob by the IPo.

  Two types of authentication are supported and need to be preconfigured by
  Bob when creating the service: password and public-key authentication.
  Again it is up to Alice what kind of authentication mechanism she wants
  to use, given that Bob knows both her password and her public key.

  If Alice uses a password to authenticate herself at the IPo, the
  authentication is based on a symmetric challenge-response authentication 
  protocol. In this case the challenge for Alice is to send h(x|y) where x
  is a user-specific password, which should be different from the password
  needed for authentication at the hidden service and y is a randomly
  generated value. Alice gets hold of her password out of band.

  With the initial RELAY_ESTABLISH_INTRO cell, the IPo gets a list of
  h(x|y)'s which it stores locally. Upon a request of Alice it compares her
  provided authentication data with the list entries. If there is a
  matching entry in its list, Alice's request is valid and can be forwarded
  to Bob. To generate the hash, Alice needs to know the password (which she
  will get out of band) and the random value y. This value is contained in
  the cookie-encrypted part of the hidden service descriptor which Alice
  can retrieve from the directory using her secret cookie.

  (1) Alice creates a password x and sends the password digest h(x) to Bob
      out of band.
  (2) Bob creates a random value y, computes h(h(x)|y), and sends the
      result to the introduction point.
  (3) Bob encrypts y with a secret cookie (see proposal 114) and writes it
      to a rendezvous service descriptor.
  (4) Alice fetches Bob's rendezvous service descriptor, decrypts y using
      the secret cookie (see proposal 114), computes h(h(x)|y), encrypts
      it with the public key of the introduction point, and sends it to
      that introduction point.
  (5) The introduction point decrypts h(h(x)|y) from Alice's message and
      compares it to the value it knows from Bob (from step 2).

  If Alice wants to use public-key authentication to authenticate herself
  at Bob's HS, the challenge-response authentication protocol is slightly
  different.

  The IPo's are provided with a list of random value hashes h(r) with an
  entry for each user via the RELAY_ESTABLISH_INTRO cell. For public-key
  authentication Alice uses an RSA public/private-key pair (as specified in
  tor-spec). The public key is made known to Bob out of band. The IPo's
  will now be sent a new ESTABLISH_INTRO cell with an additional random
  value hash for Alice and a new descriptor is uploaded to the responsible
  directories. The public-key authentication part of the service descriptor
  holds a blank separated list of key-value pairs with one pair for every
  authorized user. The hash of the public key of a user serves as a key,
  while the PK-encrypted r represents the value. Authorized users can now
  find their respective key-value pair and decrypt the value of h(r). This
  result serves as an authorization token at the IPo in the same way as
  with password authentication. The IPo does not know which authentication
  method was used since the tokens always have the same format.

  (1) Alice creates a private key e and sends the corresponding public key
      d to Bob out of band.
  (2) Bob creates a random value y and sends it to the introduction point.
  (3) Bob computes PKEncrypt(d, y), encrypts the result with a secret
      cookie (see proposal 114), and writes it to a rendezvous service
      descriptor.
  (4) Alice fetches Bob's rendezvous service descriptor, decrypts
      PKEncrypt(d, y) using the secret cookie (see proposal 114), decrypts
      y from it using her private key e, and sends it to the introduction
      point.
  (5) The introduction point compares y with the value it knows from Bob
      (from step 2).

  To remove a user from a group, Bob needs to update the random value list
  at the IPo's.

  The changes needed in Tor to realize these two challenge-response
  variations affect the RELAY_ESTABLISH_INTRO and RELAY_INTRODUCE1 relay
  cells, the service descriptor and the code parts in Tor where these cells
  and the descriptor are handled.

  The RELAY_ESTABLISH_INTRO cell is now structured as follows:

  V      Format byte: set to 255             [1 octet]
  V      Version byte: set to 2              [1 octet]
  KL     Key length                         [2 octets]
  PK     Bob's public key                  [KL octets]
  HS     Hash of session info              [20 octets]
  AUTHT  The auth type that is supported     [1 octet]
  AUTHL  Length of auth data                [2 octets]
  AUTHD  Auth data                          [variable]
  SIG    Signature of above information     [variable]

  "AUTHT" is set to "1" for password/public-key authentication.
  "AUTHD" is a list of 20 octet long challenges for clients.

  The service descriptor as specified in 114-distributed-storage is used in
  our implementation.

  For password authentication "authentication" auth-type is set to "1" and
  auth-data contains the 20 octets long string used by clients to construct
  the response to the challenge for authentication at the IPo.

  When using public-key authentication the auth-type is set to "2" and
  auth-data holds a list of 148 octets long blank separated values. The
  first 20 octets of each value is the hash of the public key of a certain
  client and used by Alice to determine her entry in the list. The
  remaining 128 octets contain the PK-encrypted token needed to
  authenticate to the IPo.

  The part of the RELAY_INTRODUCE1 cell that can be read by the IPo has the
  following fields added:

  AUTHT  The auth type that is supported   [1 octet]
  AUTHL  Length of auth data               [1 octets]
  AUTHD  Auth data                         [variable]

  The AUTHT and AUTHL fields are provided to allow extensions of the
  protocol. Currently, we set AUTHT to 1 for password/public-key
  authentication and AUTHL to 20 for the length of the authorization token.

Security implications:

  In addition to the security features proposed in 114-distributed-storage
  a new way of authentication is added at the OP of Bob. Moreover, the
  authentication at the IPo's is improved to support a fine-grained access
  control. Corrupted IPo's may easily bypass this authentication, but given
  the case that the majority of IPo's is acting as expected we still
  consider this feature as being useful.

  Bob can now decide whether he wants to allow Alice to use his services or
  not. This gives him the possibility to offer his services only to known
  and trusted users that need to identify by a password or by signing their
  messages. The anonymity of the client towards the service provider is
  thereby reduced to pseudonymity.

  Changing of access rights now involves all three authorization authorities
  depending on what changes should be made:

    - The user configures his changes at the local OP. Therefore he can
      edit the cookie files that were extended to support multiple users.
      Moreover he can edit the new user files that were added to specify
      authentication information for every user.

    - Whenever local changes occur, this information needs to be either
      passed to the responsible IPo's, the directory servers, or both
      depending on the authorization method and operation used. It is
      important to have consistent authorization results at all authorities
      at the same time, to create a trustworthy system with good user
      acceptance. As these reconfigurations always follow local changes
      they can be done automatically by the new Tor implementation and
      therefore no user interaction is needed.

    - The secret cookies proposed in 114-distributed-storage are used for
      group management in our implementation as their use would be far to
      costly for a user-based authorization. That is because right now one
      descriptor is generated and uploaded for every secret cookie. Changes
      in this configuration should therefore be rare (maybe never) and only
      a few groups should exist. Provided that this is the case the costs
      for changes seem acceptable. As there is currently no possibility to
      make a directory remove the descriptor for a group an updated
      descriptor without any IPo should be uploaded to the directory
      servers.

  Local changes to access rights can now be done faster than by changing
  service descriptors which reduces the directory server load and network
  traffic. Still every configuration change remains costly and users should
  carefully choose how detailed the access right configuration should be.

  Attacking clients now need to bypass two more authentication steps to
  reach the service implementation. Compared to the current state it is
  more likely that attackers can be stopped even before they are able to
  contact Bob's OP. We expect that the possibility of an attack is thereby
  significantly reduced. Another positive side effect is that network
  traffic and router load is reduced by discarding unauthorized cells which
  should lower the effectiveness of denial of service attacks.

Compatibility:

  When using our authentication for hidden services the implementation of
  IPo's needs to be extended. Therefore we use version information provided
  in router descriptors to be sure that we only send modified
  RELAY_ESTABLISH_INTRO cells to routers that can handle them. Clients of
  v2 hidden services will have to update their Tor installation if they
  want to be able to use the service.


["hidden-service-authentication.txt.sig" (application/octet-stream)]

</body></email><email><emailId>20070927154116</emailId><senderName>Johannes Renner</senderName><senderEmail>hannesrenner@gmx.de</senderEmail><timestampReceived>2007-09-27 15:41:16-0400</timestampReceived><subject>Master's Thesis: Performance-Improved Onion Routing</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Hello everybody!

I recently finished my diploma/master's thesis about improving the
performance of Tor by modifying the methods that are used to select
nodes. The title of my thesis is "Development and Evaluation of
Path Selection Algorithms for Performance-Improved Onion Routing".

New techniques of measuring performance in the Tor network are
proposed, as well as methods of path selection that are based on
the results of such measurings. Further, an implementation of the
proposed techniques is presented. Included evaluations cover the
performance that is reached on average, but also the degree of
anonymity that is achieved when employing different methods of
path selection.

I decided not to publish a download-link, since eventually a
summarizing paper will be written and published that concentrates
on the most interesting aspects (and will not require the reader
to read &gt;100 pages). This naturally will take some time, so for
anybody who is interested in my work I am willing to provide a
pdf of my thesis, if you simply draw me a line.

For now, I would like to thank all people on this list who helped
me with my work and during GSoC!

Greetings,
Johannes
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFG+88c1TFW0/n+aNgRAsIGAJ9Tn0G29xGYGi06CybrXf/b3HT4pQCfd60U
V3HV4953C60zudMCDvs9rJk=
=AW3D
-----END PGP SIGNATURE-----
</body></email><email><emailId>20070927234611</emailId><senderName>"Michael_google gmail_Gersten"</senderName><senderEmail>keybounce@gmail.com</senderEmail><timestampReceived>2007-09-27 23:46:11-0400</timestampReceived><subject>Tor crash</subject><body>

I had a server crash today.

I first shut down the Or-port, to try to let all connections close.
When it was time to actually say "Time to stop", I re-enabled the
Or-port, and then sent a sigint. (If I send sigint without first
re-enabling the or-port, Tor assumes that it should stop immediately,
without notifying the clients).

Tor crashed about a minute later. I don't know if it was related or not.
This is 1.2.17

Note: Even 50 minutes after closing my or port, I was still almost at
full bandwidth (I had just started to see a drop below full).

Sep 27 15:32:57 stbmac Tor[23808]: Received reload signal (hup).
Reloading config.\n
Sep 27 15:32:57 stbmac Tor[23808]: Closing no-longer-configured OR
listener on 0.0.0.0:9001\n
Sep 27 15:32:57 stbmac Tor[23808]: Closing old OR listener on 0.0.0.0:9001\n
Sep 27 16:22:59 stbmac Tor[23808]: Received reload signal (hup).
Reloading config.\n
Sep 27 16:22:59 stbmac Tor[23808]: Opening OR listener on 0.0.0.0:9001\n
Sep 27 16:23:00 stbmac Tor[23808]: Your Tor server's identity key
fingerprint is 'nsavaxBangKremvax 11E5 D291 5CE9 89C9 F258 1BEC A49A
127D 7022 AC15'\n
Sep 27 16:23:00 stbmac Tor[23808]: Now checking whether ORPort
76.175.149.74:9001 and DirPort 76.175.149.74:9030 are reachable...
(this may take up to 20 minutes -- look for log messages indicating
success)\n
Sep 27 16:23:07 stbmac Tor[23808]: Interrupt: will shut down in 240
seconds. Interrupt again to exit now.\n
Sep 27 16:24:10 stbmac Tor[23808]: Resolved "img9.imagepile.net" which
was already resolved; ignoring\n
Sep 27 16:24:10 stbmac Tor[23808]: eventdns: Nameserver
118.119.103.108 is back up\n
Sep 27 16:24:12 stbmac crashdump[25690]: tor crashed
Sep 27 16:24:12 stbmac crashdump[25690]: crash report written to:
/Users/Michael/Library/Logs/CrashReporter/tor.crash.log
</body></email><email><emailId>20070928143140</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-09-28 14:31:40-0400</timestampReceived><subject>Re: Tor crash</subject><body>


On Thu, Sep 27, 2007 at 04:46:11PM -0700, Michael_google gmail_Gersten wrote:
&gt; I had a server crash today.
&gt; 
&gt; I first shut down the Or-port, to try to let all connections close.
&gt; When it was time to actually say "Time to stop", I re-enabled the
&gt; Or-port, and then sent a sigint. (If I send sigint without first
&gt; re-enabling the or-port, Tor assumes that it should stop immediately,
&gt; without notifying the clients).
&gt; 
&gt; Tor crashed about a minute later. I don't know if it was related or not.
&gt; This is 1.2.17

Interesting!  Is this reproducible?

&gt; Note: Even 50 minutes after closing my or port, I was still almost at
&gt; full bandwidth (I had just started to see a drop below full).

Most strange.  I'm wondering whether your server was accepting new
circuits (which would be wrong) or whether all this bandwidth was in
old circuits (which would be unlikely).

Oh!  By any chance is your ORListenAddress set in your torrc?  The
code in server_mode in router.c is:

  int
  server_mode(or_options_t *options)
  {
    if (options-&gt;ClientOnly) return 0;
    return (options-&gt;ORPort != 0 || options-&gt;ORListenAddress);
  }

This could be problematical.  Roger: is this really what we want to
do?

&gt; Sep 27 15:32:57 stbmac Tor[23808]: Received reload signal (hup).
&gt; Reloading config.\n
&gt; Sep 27 15:32:57 stbmac Tor[23808]: Closing no-longer-configured OR
&gt; listener on 0.0.0.0:9001\n
&gt; Sep 27 15:32:57 stbmac Tor[23808]: Closing old OR listener on 0.0.0.0:9001\n
&gt; Sep 27 16:22:59 stbmac Tor[23808]: Received reload signal (hup).
&gt; Reloading config.\n
&gt; Sep 27 16:22:59 stbmac Tor[23808]: Opening OR listener on 0.0.0.0:9001\n
&gt; Sep 27 16:23:00 stbmac Tor[23808]: Your Tor server's identity key
&gt; fingerprint is 'nsavaxBangKremvax 11E5 D291 5CE9 89C9 F258 1BEC A49A
&gt; 127D 7022 AC15'\n
&gt; Sep 27 16:23:00 stbmac Tor[23808]: Now checking whether ORPort
&gt; 76.175.149.74:9001 and DirPort 76.175.149.74:9030 are reachable...
&gt; (this may take up to 20 minutes -- look for log messages indicating
&gt; success)\n
&gt; Sep 27 16:23:07 stbmac Tor[23808]: Interrupt: will shut down in 240
&gt; seconds. Interrupt again to exit now.\n
&gt; Sep 27 16:24:10 stbmac Tor[23808]: Resolved "img9.imagepile.net" which
&gt; was already resolved; ignoring\n
&gt; Sep 27 16:24:10 stbmac Tor[23808]: eventdns: Nameserver
&gt; 118.119.103.108 is back up\n
&gt; Sep 27 16:24:12 stbmac crashdump[25690]: tor crashed
&gt; Sep 27 16:24:12 stbmac crashdump[25690]: crash report written to:
&gt; /Users/Michael/Library/Logs/CrashReporter/tor.crash.log

Did you get a core?  Was there anything useful in tor.crash.log?
There's nothing in the log above that indicates where the crash might
have come from.

yrs,
-- 
Nick Mathewson

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070928121952</emailId><senderName>Alex Bihlmaier</senderName><senderEmail>thalunil@kallisti.de</senderEmail><timestampReceived>2007-09-28 12:19:52-0400</timestampReceived><subject>Re: Master's Thesis: Performance-Improved Onion Routing</subject><body>


### Johannes Renner schrieb am 27. Sep (Do):

&gt; -----BEGIN PGP SIGNED MESSAGE-----
&gt; Hash: SHA1
&gt; 
&gt; Hello everybody!
&gt; 
&gt; I recently finished my diploma/master's thesis about improving the
&gt; performance of Tor by modifying the methods that are used to select
&gt; nodes. The title of my thesis is "Development and Evaluation of
&gt; Path Selection Algorithms for Performance-Improved Onion Routing".
&gt; 
&gt; New techniques of measuring performance in the Tor network are
&gt; proposed, as well as methods of path selection that are based on
&gt; the results of such measurings. Further, an implementation of the
&gt; proposed techniques is presented. Included evaluations cover the
&gt; performance that is reached on average, but also the degree of
&gt; anonymity that is achieved when employing different methods of
&gt; path selection.
&gt; 
&gt; I decided not to publish a download-link, since eventually a
&gt; summarizing paper will be written and published that concentrates
&gt; on the most interesting aspects (and will not require the reader
&gt; to read &gt;100 pages). This naturally will take some time, so for
&gt; anybody who is interested in my work I am willing to provide a
&gt; pdf of my thesis, if you simply draw me a line.

Hiya Johannes,
 I am pretty interested in digging through you master thesis.
 So if you want to send me a link, I would appreciate that.


All the best,
 thal
-- 
        Alex Bihlmaier &lt;thalunil@kallisti.de&gt;, GPG KeyID: 0x1097029B
                     Jabber: thalunil@jabber.ccc.de
	                 Phone: +49 2227 9090075

["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20070928142421</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-09-28 14:24:21-0400</timestampReceived><subject>Re: Master's Thesis: Performance-Improved Onion Routing</subject><body>


On Thu, Sep 27, 2007 at 05:41:16PM +0200, Johannes Renner wrote:
&gt; -----BEGIN PGP SIGNED MESSAGE-----
&gt; Hash: SHA1
&gt; 
&gt; Hello everybody!
&gt; 
&gt; I recently finished my diploma/master's thesis about improving the
&gt; performance of Tor by modifying the methods that are used to select
&gt; nodes. The title of my thesis is "Development and Evaluation of
&gt; Path Selection Algorithms for Performance-Improved Onion Routing".

Hi, Jonannes!  Could you send me a copy as well?

&gt; 
&gt; New techniques of measuring performance in the Tor network are
&gt; proposed, as well as methods of path selection that are based on
&gt; the results of such measurings. Further, an implementation of the
&gt; proposed techniques is presented. Included evaluations cover the
&gt; performance that is reached on average, but also the degree of
&gt; anonymity that is achieved when employing different methods of
&gt; path selection.

This part is particularly interesting to me.  What are you using as
your anonymity measure?

-- 
Nick Mathewson

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070928143634</emailId><senderName>Paul Syverson</senderName><senderEmail>syverson@itd.nrl.navy.mil</senderEmail><timestampReceived>2007-09-28 14:36:34-0400</timestampReceived><subject>Re: Master's Thesis: Performance-Improved Onion Routing</subject><body>

Hi Jonnanes,

Please repeat all of Nick's sentences as if from me: i.e., please send
me a copy. I am quite interested in anonymity evaluation according to
path selection (as well as performance improvements therefrom), and
what is your metric?  N.B. If you think about it, (other than the
parenthetical remark prior to this one) this is not the top post it
appears to be.

-Paul



On Fri, Sep 28, 2007 at 10:24:21AM -0400, Nick Mathewson wrote:
&gt; On Thu, Sep 27, 2007 at 05:41:16PM +0200, Johannes Renner wrote:
&gt; &gt; -----BEGIN PGP SIGNED MESSAGE-----
&gt; &gt; Hash: SHA1
&gt; &gt; 
&gt; &gt; Hello everybody!
&gt; &gt; 
&gt; &gt; I recently finished my diploma/master's thesis about improving the
&gt; &gt; performance of Tor by modifying the methods that are used to select
&gt; &gt; nodes. The title of my thesis is "Development and Evaluation of
&gt; &gt; Path Selection Algorithms for Performance-Improved Onion Routing".
&gt; 
&gt; Hi, Jonannes!  Could you send me a copy as well?
&gt; 
&gt; &gt; 
&gt; &gt; New techniques of measuring performance in the Tor network are
&gt; &gt; proposed, as well as methods of path selection that are based on
&gt; &gt; the results of such measurings. Further, an implementation of the
&gt; &gt; proposed techniques is presented. Included evaluations cover the
&gt; &gt; performance that is reached on average, but also the degree of
&gt; &gt; anonymity that is achieved when employing different methods of
&gt; &gt; path selection.
&gt; 
&gt; This part is particularly interesting to me.  What are you using as
&gt; your anonymity measure?
&gt; 
&gt; -- 
&gt; Nick Mathewson


</body></email><email><emailId>20070928155652</emailId><senderName>Johannes Renner</senderName><senderEmail>hannesrenner@gmx.de</senderEmail><timestampReceived>2007-09-28 15:56:52-0400</timestampReceived><subject>Re: Master's Thesis: Performance-Improved Onion Routing</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Nick Mathewson wrote:
&gt;&gt; proposed techniques is presented. Included evaluations cover the
&gt;&gt; performance that is reached on average, but also the degree of
&gt;&gt; anonymity that is achieved when employing different methods of
&gt;&gt; path selection.
&gt;
&gt; What are you using as your anonymity measure?

[Answering here since it seems to be interesting]

To measure a "degree of anonymity", a certain method of path
selection can provide, I do the following:

I generate a (preferably big) amount of paths, without actually
creating any circuit. This list of paths can then be evaluated
regarding the occurrences of specific nodes on the single
positions of the paths. So, as a first metric I simply count the
total number of different nodes that is chosen on the single
positions of the paths. The higher the single numbers for
entry/middle/exit positions, the more anonymity there is.

I know, this metric does not consider that some methods choose
some nodes with a higher probability (means more often) than
others. Therefore, I work towards the conditional probability
that a specific entry node is chosen, given the IP of an exit
node and vice-versa (according to an advice from Mike Perry).
This means, instead of counting the occurrences of single nodes,
I count the total number of different combinations of entry and
exit nodes (EE-combinations). Intuitively, the more different
EE-combinations there are in a sample of n paths, the better the
achieved anonymity.

Further, I calculate the entropy regarding the probabilities of
the different EE-combinations, and from this, a bounded degree
of anonymity 'd'. This is done using the maximum entropy that is
calculated from a sample of size n, where no two paths have the
same EE-combination (which means d=1, iff all of the generated
paths show different EE-combinations). This way it is easy to
compare different methods of path selection regarding the
achieved anonymity by generating samples of the same size. From
these samples, 'd' is calculated and the results can be compared.
For my thesis I generated samples of 100.000 paths (only), so it
will be interesting to increase n to maybe 1.000.000 and repeat
the experiment.

Note, that I only had limited time for writing my thesis, and
the anonymity evaluation was not the most important aspect in
it (even if it is maybe the most interesting). So, all of this
surely offers room for improvements, please send me your ideas!

Have a nice weekend,
Johannes
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFG/SRE1TFW0/n+aNgRAsWeAJsEDErLkwO53/gW+Mq9JB30vA428wCghKF9
Ro1gxrrLjQeib0/KyH4wgjo=
=kLdW
-----END PGP SIGNATURE-----
</body></email><email><emailId>20070926145320</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-09-26 14:53:20-0400</timestampReceived><subject>Re: Proposal: Hidden Service Authentication</subject><body>


On Wed, Sep 26, 2007 at 04:20:29PM +0200, Karsten Loesing wrote:
&gt; -----BEGIN PGP SIGNED MESSAGE-----
&gt; Hash: SHA1
&gt; 
&gt; Hi everyone,
&gt; 
&gt; we would like to propose an extension of Tor hidden services towards
&gt; providing authentication. This includes authentication at the hidden
&gt; service and at introduction points, both either via password or
&gt; public-key authentication.

Added to https://tor.eff.org/svn/trunk/doc/spec/proposals/ as proposal 121.

-- 
Nick Mathewson

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070926193336</emailId><senderName>Robert Hogan</senderName><senderEmail>robert@roberthogan.net</senderEmail><timestampReceived>2007-09-26 19:33:36-0400</timestampReceived><subject>Re: Proposal: Hidden Service Authentication</subject><body>

On Wednesday 26 September 2007 15:20:29 Karsten Loesing wrote:
&gt; Hi everyone,
&gt;
&gt; we would like to propose an extension of Tor hidden services towards
&gt; providing authentication. This includes authentication at the hidden
&gt; service and at introduction points, both either via password or
&gt; public-key authentication.
&gt;
&gt; This gives us the new security property of access control, improves
&gt; hiding service activity from unauthorized clients, and reduces traffic
&gt; by dropping false requests as soon as possible.
&gt;
&gt; Comments are welcome! :)
&gt;
&gt; --Tobias, Thomas, Karsten, Ferdinand, and Christoph

I think I can see how tor might manage all this stuff in a fairly transparent 
way but it would be useful to be explicit about what input tor needs from the 
user during the authentication and when/how it should be gathered.

For example, it's not clear to me how (or even if) the tor client gathers the 
password  from the user when connecting to a specific hidden service. Does 
the user specify it in their torrc for that hidden service?


-- 

Browse Anonymously Anywhere	- http://anonymityanywhere.com
TorK	- KDE Anonymity Manager	- http://tork.sf.net
KlamAV	- KDE Anti-Virus 	- http://www.klamav.net

</body></email><email><emailId>20070919182510</emailId><senderName>"Michael_google gmail_Gersten"</senderName><senderEmail>keybounce@gmail.com</senderEmail><timestampReceived>2007-09-19 18:25:10-0400</timestampReceived><subject>Re: Privoxy bundle: configuration</subject><body>

&gt; : I just upgraded the tor/privoxy bundle on my Mac Os 10.4 to .17
&gt; : The config file supplied is old, not the current privoxy config.
&gt; : Worse, I have a lot of customized .forward lines in mine, all of which
&gt; : want to be wiped.
&gt;
&gt; This is odd to me.  The PreFlight script makes a tarball of all your
&gt; configs, and puts it in /tmp/TorSavedMe.tar.gz while the install runs.
&gt; The PostFlight script extracts TorSavedMe.tar.gz to put back the custom
&gt; configs.
&gt;
&gt; The scripts are
&gt; https://tor-svn.freehaven.net/svn/tor/branches/tor-0_1_2-patches/contrib/osx/TorPreFlight
&gt; and
&gt; https://tor-svn.freehaven.net/svn/tor/branches/tor-0_1_2-patches/contrib/osx/TorPostflight
&gt;
&gt; What files were overwritten? We specifically back up $PRIVOXYPATH/config
&gt; $PRIVOXYPATH/user.action, if there is another we should be saving
&gt; through the upgrade/install, let me know.
&gt;
&gt; --
&gt; Andrew

The file /Library/Privoxy/config was overwritten with a stock config
for privoxy 3.0.x. The one I'm using was modified from the stock for
3.0.6.

I upgraded this morning:

Sep 19 10:12:37 stbmac Tor[2140]: Please upgrade! This version of Tor
(0.1.2.16) is obsolete, according to 3/3 version-listing network
statuses. Versions recommended by at least 1 authority are: 0.1.2.17,
0.2.0.6-alpha\n
Sep 19 10:12:37 stbmac Tor[2140]: We now have enough directory
information to build circuits.\n
Sep 19 10:12:40 stbmac Tor[2140]: Interrupt: will shut down in 240
seconds. Interrupt again to exit now.\n
Sep 19 10:12:41 stbmac Tor[2140]: Tor has successfully opened a
circuit. Looks like client functionality is working.\n
Sep 19 10:12:41 stbmac Tor[2140]: Now checking whether ORPort
76.173.217.193:9001 and DirPort 76.173.217.193:9030 are reachable...
(this may take up to 20 minutes -- look for log messages indicating
success)\n
Sep 19 10:12:42 stbmac Tor[2140]: Sigint received a second time; exiting now.\n
Sep 19 10:14:53 stbmac sudo:     root : TTY=unknown ; PWD=/ ;
USER=root ; COMMAND=/bin/kill 1908
Sep 19 10:14:53 stbmac sudo:     root : TTY=unknown ;
PWD=/Library/Privoxy ; USER=root ; COMMAND=/Library/Privoxy/privoxy
--pidfile /var/run/privoxy.pid config
Sep 19 10:14:55 stbmac sudo:     root : TTY=unknown ; PWD=/ ;
USER=root ; COMMAND=/bin/kill 2261
Sep 19 10:14:55 stbmac sudo:     root : TTY=unknown ;
PWD=/Library/Privoxy ; USER=root ; COMMAND=/Library/Privoxy/privoxy
--pidfile /var/run/privoxy.pid config
Sep 19 10:15:51 stbmac Tor[2318]: Detected state file from old version
'Tor 0.1.2.16'. Choosing new entry guards for you.\n

(That double restart of privoxy came because I first re-installed .16
by mistake, and second installed .17 correctly)

Looking in /tmp:

stbmac:/Library/Privoxy Michael$ ls -lt /tmp/
total 344
  4 -rw-------   1 Michael   wheel      36 Sep 19 11:19 objc_sharing_ppc_501
332 -rw-r--r--   1 Michael   wheel  339264 Sep 19 11:00 ntp.log
  4 -rw-------   1 nobody    wheel      24 Sep 19 10:14
objc_sharing_ppc_4294967294
  4 -rw-------   1 security  wheel      24 Sep 19 10:14 objc_sharing_ppc_92
  0 -rw-r--r--   1 security  wheel       0 Sep 19 09:03 cs_cache_lock_92

Nothing else. (I rebooted this morning, so /tmp is clean.)
</body></email><email><emailId>20070920031747</emailId><senderName></senderName><senderEmail>phobos</senderEmail><timestampReceived>2007-09-20 03:17:47-0400</timestampReceived><subject>Re: Privoxy bundle: configuration</subject><body>

On Wed, Sep 19, 2007 at 11:25:10AM -0700, keybounce@gmail.com wrote 3.1K bytes in 71 lines about:
: &gt; What files were overwritten? We specifically back up $PRIVOXYPATH/config
: &gt; $PRIVOXYPATH/user.action, if there is another we should be saving
: &gt; through the upgrade/install, let me know.

As was pointed out to me today, this is a classic security issue.  I'll
address it this week with mktemp, hopefully in time for the next alpha.


: The file /Library/Privoxy/config was overwritten with a stock config
: for privoxy 3.0.x. The one I'm using was modified from the stock for
: 3.0.6.

Well, you could always uncheck "upgrade privoxy" since the version
hasn't changed in a year, and isn't likely to change going forward.

: Looking in /tmp:

Right, the postflight removes the file if the install is successful.

I've tested this twice and in both cases, my original config was put
back, rather than the stock config.  

I'll poke some more.

-- 
Andrew
</body></email><email><emailId>20070927160830</emailId><senderName>Karsten Loesing</senderName><senderEmail>karsten.loesing@gmx.net</senderEmail><timestampReceived>2007-09-27 16:08:30-0400</timestampReceived><subject>Re: Proposal: Hidden Service Authentication</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Hi Robert,

&gt; I think I can see how tor might manage all this stuff in a fairly
&gt; transparent way but it would be useful to be explicit about what
&gt; input tor needs from the user during the authentication and when/how
&gt; it should be gathered.
&gt; 
&gt; For example, it's not clear to me how (or even if) the tor client
&gt; gathers the password  from the user when connecting to a specific
&gt; hidden service. Does the user specify it in their torrc for that
&gt; hidden service?

Thank you for your comment! You mention an important point with regard
to usability!

But there are two reasons why we did not include that into our proposal:

1. It is not part of the Tor protocol, but an implementation issue of
the Tor software. Thus, it should be left to the programmer of a Tor
node to decide how keys and configurations are stored.

2. We did not make a final decision on how to include it in the Tor
software.

We wrote down a draft version of the necessary configuration files on
both, hidden service and client side. But these formats have not been
implemented and are subject to change!

On hidden-service side there is a single file (e.g. "authentication") in
the hidden service directory, containing:

  SecretCookieName [unique cookie name]
  SecretCookieKey [password]

  User [user name]
  IntroductionPointAuthentication [password]
  HiddenServiceAuthentication [password]
  PublicKeyAuthentication
  -----BEGIN RSA PUBLIC KEY-----
  [base64 encoded public RSA key]
  -----END RSA PUBLIC KEY-----

The names for secret cookies and users are merely used for display
purposes in a GUI. There may be one or more secret cookie blocks, each
followed by one or more user blocks. For each user there needs to be
specified at least one password or public key.

On client side there is a single file for each hidden service to be
accessed. Its file name is a user-defined alias of 1 to 15 characters,
e.g. "bobsservice", that the user later provides as onion URL, e.g.
"bobsservice.onion". It is stored in a subdirectory of Tor's working
directory. It contains:

  HiddenServiceID [service id]
  SecretCookieKey [password]
  IntroductionPointAuthentication [password]
  HiddenServiceAuthentication [password]
  PublicKeyAuthentication
  -----BEGIN RSA PRIVATE KEY-----
  [base64 encoded private RSA key]
  -----END RSA PRIVATE KEY-----

When accessing an onion address using such an alias, Tor looks up, if
there is a file containing authentication data and performs
authentication instead of directly trying to connect to the hidden service.

As an alternative we discussed to write all authentication data to the
onion address, like:

&lt;intro-auth&gt;.&lt;hid-serv-auth&gt;.&lt;secret-cookie&gt;.&lt;hid-serv-id&gt;.onion

This is just a first draft. If you have any suggestions on how to
improve it, please tell us! We are not _using_ hidden services regularly
(shame on us...), so we don't know exactly what would be best from a
usability perspective!

Thanks!
- --Tobias, Thomas, Karsten, Ferdinand, and Christoph
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFG+9V+0M+WPffBEmURAm2RAJ9TweGibY5I99H8A/y8YrAClVJwJwCfXaAq
5qCAeqv+HDdQ8eTAmwww5Ao=
=vyvB
-----END PGP SIGNATURE-----
</body></email><email><emailId>20070928195823</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-09-28 19:58:23-0400</timestampReceived><subject>Does your Tor controller use "setrouterpurpose"?</subject><body>

Hi folks,

Nick has been working on keeping track of descriptor purposes in the
on-disk descriptor cache. Long ago, we added a controller command
"setrouterpurpose" that lets you assign a new router purpose (e.g.
"general-purpose", "for the controller's use only", etc) to a given
descriptor. Around the same time, we also added a new option to the
"postdescriptor" controller command that let you specify PURPOSE=%s
at the same point that you tell Tor about a new descriptor.

For details, see Sec 3.12 and 3.14 of
https://tor.eff.org/svn/trunk/doc/spec/control-spec.txt

We plan to disable the "setrouterpurpose" command, because it makes
things really messy to then have two copies of the descriptor around
(one with the old purpose, one with the new), and we don't see any
critical uses for it.

If your controller relies on this feature, please let us know rsn!

--Roger

</body></email><email><emailId>20070929130209</emailId><senderName>Robert Hogan</senderName><senderEmail>robert@roberthogan.net</senderEmail><timestampReceived>2007-09-29 13:02:09-0400</timestampReceived><subject>Turning off a server</subject><body>


AFAICS there's no way of turning off a server immediately, without actually 
killing the tor process.

What I mean by this is some controller command(s) that:

- Closes all the server's ORCONNs immediately
- Sends a suicide descriptor to the authdirs.

The use-case is the general user who runs a relay most of the time but 
occasionally wants to toggle it off without disripting general use. The 
ability to close orconns may have other uses from the controller interface, 
e.g. for research controllers.

If it seems like a good idea I can do up a patch.

-- 

Browse Anonymously Anywhere	- http://anonymityanywhere.com
TorK	- KDE Anonymity Manager	- http://tork.sf.net
KlamAV	- KDE Anti-Virus 	- http://www.klamav.net


["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20070929164302</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-09-29 16:43:02-0400</timestampReceived><subject>Re: Master's Thesis: Performance-Improved Onion Routing</subject><body>


On Fri, Sep 28, 2007 at 05:56:52PM +0200, Johannes Renner wrote:
&gt; -----BEGIN PGP SIGNED MESSAGE-----
&gt; Hash: SHA1
&gt; 
&gt; Nick Mathewson wrote:
&gt; &gt;&gt; proposed techniques is presented. Included evaluations cover the
&gt; &gt;&gt; performance that is reached on average, but also the degree of
&gt; &gt;&gt; anonymity that is achieved when employing different methods of
&gt; &gt;&gt; path selection.
&gt; &gt;
&gt; &gt; What are you using as your anonymity measure?
&gt; 
&gt; [Answering here since it seems to be interesting]
&gt; 
&gt; To measure a "degree of anonymity", a certain method of path
&gt; selection can provide, I do the following:
&gt; 
&gt; I generate a (preferably big) amount of paths, without actually
&gt; creating any circuit. This list of paths can then be evaluated
&gt; regarding the occurrences of specific nodes on the single
&gt; positions of the paths. So, as a first metric I simply count the
&gt; total number of different nodes that is chosen on the single
&gt; positions of the paths. The higher the single numbers for
&gt; entry/middle/exit positions, the more anonymity there is.

This seems pretty weird; it implies that an adversary can increase
people's anonymity by signing up more nodes.  (Since the more nodes on
the network, the more possible nodes will appear in entry/middle/exit
positions.)

&gt; I know, this metric does not consider that some methods choose
&gt; some nodes with a higher probability (means more often) than
&gt; others. Therefore, I work towards the conditional probability
&gt; that a specific entry node is chosen, given the IP of an exit
&gt; node and vice-versa (according to an advice from Mike Perry).

This is a bit more reasonable, though it probably makes more sense to
look at conditional entropy of entry node given exit node and/or
target IP... or perhaps additional information gained about entry
nodes given knowledge of the exit node or destination?  (If entry
nodes are chosen dependent on the client's current location, we want
to look at additional info gained about client location too.)

 [I see below that you *do* go for entropy.  Cool.]

Also, if we're worried about the attacker being the exit, we need to
look at additional info gained given knowledge of the exit _and_
middle nodes:  if you're the exit node, you not only know where you
are, but you also know the previous node in the circuit.

In any case, that's a decent measure of the attack where the adversary
observes some nodes in the circuit and tries to infer the rest.  But
there are other attacks, and so there there are other measures that
count too!  These include:

  - Given a fraction of nodes compromised by an adversary, what is the
    probability that a given path will have first and last node
    compromised?

  - Given a fraction of nodes compromised by an adversary, and
    assuming guard nodes are in use, what is the probability that
    adversary can be first and last node for a sample of
    paths?  (This is important if what you're worried about is
    statistical sampling.)

&gt; This means, instead of counting the occurrences of single nodes,
&gt; I count the total number of different combinations of entry and
&gt; exit nodes (EE-combinations). Intuitively, the more different
&gt; EE-combinations there are in a sample of n paths, the better the
&gt; achieved anonymity.

This doesn't take into account knowledge of the middle node that the
attacker gets by being the exit.

&gt; Further, I calculate the entropy regarding the probabilities of
&gt; the different EE-combinations, and from this, a bounded degree
&gt; of anonymity 'd'. This is done using the maximum entropy that is
&gt; calculated from a sample of size n, where no two paths have the
&gt; same EE-combination (which means d=1, iff all of the generated
&gt; paths show different EE-combinations). This way it is easy to
&gt; compare different methods of path selection regarding the
&gt; achieved anonymity by generating samples of the same size. From
&gt; these samples, 'd' is calculated and the results can be compared.
&gt; For my thesis I generated samples of 100.000 paths (only), so it
&gt; will be interesting to increase n to maybe 1.000.000 and repeat
&gt; the experiment.

 [THis looks interesting; I think I should read the relevant bits of
 the thesis for details and think about it more.]
 
&gt; Note, that I only had limited time for writing my thesis, and
&gt; the anonymity evaluation was not the most important aspect in
&gt; it (even if it is maybe the most interesting). So, all of this
&gt; surely offers room for improvements, please send me your ideas!

My main idea is this: too many papers decide to characterize some
measure as "anonymity" when that measure only reflects the difficulty
of one possible attack among many.  This is indeed a valuable
contribution to research, since resisting more attacks is quite
worthwhile... but it's possible to resist one attack at the expense of
becoming weaker to another.  Thus, it's important to look at many
different measures and consider the effects of design choices on all
the significant attacks that effect your system.

For all I know, you do this in your thesis; I should check it out in
more detail.

anyways, thanks again for your work!  I have the copy of your thesis
that you sent, and I look forward to reading it.

yrs,
-- 
Nick Mathewson

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070930015151</emailId><senderName>"Michael_google gmail_Gersten"</senderName><senderEmail>keybounce@gmail.com</senderEmail><timestampReceived>2007-09-30 01:51:51-0400</timestampReceived><subject>Re: Tor crash</subject><body>

&gt; Interesting!  Is this reproducible?
Don't know yet.

&gt; Oh!  By any chance is your ORListenAddress set in your torrc?
Nope

&gt; Did you get a core?  Was there anything useful in tor.crash.log?
No core.
Here's the crash log:


Host Name:      stbmac
Date/Time:      2007-09-27 16:24:10.933 -0700
OS Version:     10.4.10 (Build 8R218)
Report Version: 4

Command: tor
Path:    /Library/Tor/tor
Parent:  bash [389]

Version: ??? (???)

PID:    23808
Thread: 0

Exception:  EXC_BAD_ACCESS (0x0001)
Codes:      KERN_INVALID_ADDRESS (0x0001) at 0xca5ad9b6

Thread 0 Crashed:
0   tor                 0x00087c04 event_del + 44 (event.c:697)
1   tor                 0x0006cdd4 nameserver_up + 84 (eventdns.c:533)
2   tor                 0x0006cee0 reply_callback + 112 (eventdns.c:648)
3   tor                 0x0006fc6c reply_handle + 684 (eventdns.c:740)
4   tor                 0x000714cc nameserver_ready_callback + 1564
(eventdns.c:925)
5   tor                 0x00087364 event_process_active + 240 (event.c:332)
6   tor                 0x00087634 event_base_loop + 340 (event.c:448)
7   tor                 0x000874cc event_loop + 40 (event.c:382)
8   tor                 0x000873d0 event_dispatch + 20 (event.c:346)
9   tor                 0x0004b8b0 tor_main + 656 (main.c:1270)
10  tor                 0x0000277c _start + 760
11  tor                 0x00002480 start + 48

Thread 1:
0   libSystem.B.dylib   0x90023c60 recvfrom + 12
1   tor                 0x000350c4 cpuworker_main + 148 (cpuworker.c:254)
2   tor                 0x0007800c tor_pthread_helper_fn + 76 (compat.c:1016)
3   libSystem.B.dylib   0x9002bd08 _pthread_body + 96

Thread 0 crashed with PPC Thread State 64:
  srr0: 0x0000000000087c04 srr1: 0x000000000000d030
    vrsave: 0x0000000000000000
    cr: 0x24000228          xer: 0x0000000000000004   lr:
0x0000000000087bec  ctr: 0x00000000900015c8
    r0: 0x000000000006cdd4   r1: 0x00000000bfffed90   r2:
0x00000000a0001fac   r3: 0x00000000ffffffff
    r4: 0x0000000000000000   r5: 0x000000000000004d   r6:
0x00000000ffffffff   r7: 0x000000000000004d
    r8: 0x0000000000000889   r9: 0x0000000000000000  r10:
0x0000000000000005  r11: 0x00000000a0006208
   r12: 0x00000000900015c8  r13: 0x000000000000002e  r14:
0x0000000000000005  r15: 0x0000000000000094
   r16: 0x00000000bfffef80  r17: 0x00000000bffff088  r18:
0x00000000bffff08c  r19: 0x0000000000000004
   r20: 0x0000000000000094  r21: 0x000000000296bc00  r22:
0x0000000000000074  r23: 0x00000000bffff080
   r24: 0x0000000000000001  r25: 0x0000000000000001  r26:
0x0000000000008180  r27: 0x0000000000000000
   r28: 0x0000000002b1a100  r29: 0x0000000002b1a16c  r30:
0x00000000ca5ad9b6  r31: 0x0000000000087bec

Binary Images Description:
    0x1000 -    0xb1fff tor     /Library/Tor/tor
0x8fe00000 - 0x8fe52fff dyld 46.12      /usr/lib/dyld
0x90000000 - 0x901bcfff libSystem.B.dylib       /usr/lib/libSystem.B.dylib
0x90214000 - 0x90219fff libmathCommon.A.dylib
/usr/lib/system/libmathCommon.A.dylib
0x91110000 - 0x9111efff libz.1.dylib    /usr/lib/libz.1.dylib
0x91a1a000 - 0x91ae1fff libcrypto.0.9.7.dylib   /usr/lib/libcrypto.0.9.7.dylib
0x9504c000 - 0x9507bfff libssl.0.9.7.dylib      /usr/lib/libssl.0.9.7.dylib
</body></email><email><emailId>20070801092105</emailId><senderName>Jens Kubieziel</senderName><senderEmail>maillist@kubieziel.de</senderEmail><timestampReceived>2007-08-01 09:21:05-0400</timestampReceived><subject>[PATCH] Mention svn instead of cvs</subject><body>

[Attachment #2 (multipart/mixed)]


Hi,

INSTALL mentions cvs, but we changed to svn.

Besten Gru

-- 
Jens Kubieziel                                   http://www.kubieziel.de
Um eine Einkommensteuererklrung abgeben zu knnen, muss man ein
Philosoph sein. Fr einen Mathematiker ist es zu schwierig. Albert Einstein

["INSTALL.diff" (text/x-diff)]

Index: INSTALL
===================================================================
--- INSTALL	(Revision 11009)
+++ INSTALL	(Arbeitskopie)
@@ -2,7 +2,7 @@
 Most users should simply follow the directions at
 http://tor.eff.org/docs/tor-doc-unix
 
-If you got the source from cvs, run "./autogen.sh", which will run the
+If you got the source from svn, run "./autogen.sh", which will run the
 various auto* programs and then run ./configure for you. From there,
 refer to the above instructions.
 

["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20070801190408</emailId><senderName>"Michael_google gmail_Gersten"</senderName><senderEmail>keybounce@gmail.com</senderEmail><timestampReceived>2007-08-01 19:04:08-0400</timestampReceived><subject>Re: Correct formulas for exit weights [was Re: Exit Balancing Patch]</subject><body>

&gt; Tor uses four hop paths when you use the .exit notation

Why?

If I have a .exit node, why not choose a length 2 path normally, and
then add my specified exit node?

(Serious question. Is there a privacy issue I don't know about? Is
there some fairness concern? Do things become too traceable?)
</body></email><email><emailId>20070814205339</emailId><senderName></senderName><senderEmail>phobos</senderEmail><timestampReceived>2007-08-14 20:53:39-0400</timestampReceived><subject>Re: bug in uninstaller</subject><body>

On Thu, Aug 09, 2007 at 10:43:31PM +0200, vikingserver@gmail.com wrote 0.9K bytes in 21 lines about:
: I recently uninstalled the tor bundle, in order to install the new tor0204.
: Normally i just install the bundle on top of the previous installation,
: but this time I did like you normally should when you have upgraded a
: program for more than 30 times and the default folder has changed...

The default folder hasn't changed, at least from the packages.  It's
still /Library/Tor/.

: I uninstalled, and whoops suddenly my torrc, fingerprint, secret key and
: all disappeared!

Right, this is by design.  The uninstaller is designed to wipe Tor and
traces from the system.

: Please urgently change the uninstaller so that it leaves the settings!!!

I believe this has been discussed previously.  People fell into two
camps; one insisted on the user making backups; and, the other wanted an option to the
uninstaller for removing user data (torrc, fingerprint, etc).  We left
it as is.  I'd rather add a warning to uninstall.txt or something
similar.  Or add an option to backup changed files to a tarball
somewhere.  Thoughts?

: If you want the option to remove all settings, you could leave the user
: a choice. Please fix this. Maybe you also should announce it on the
: or-talk or announce list. As you have changed the default folder, others

What do you think the default folder was previously?

-- 
Andrew
</body></email><email><emailId>20070815130829</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-08-15 13:08:29-0400</timestampReceived><subject>Re: constructing circuits using control port</subject><body>

On Wed, Aug 15, 2007 at 04:02:43AM -0400, Andrew wrote:
&gt; &gt; A) Put the setevents earlier, in case you're missing some answers
&gt; &gt; in between your EXTENDCIRCUIT and your SETEVENTS.
&gt; 
&gt; I've done this, and also added the EXTENDED keyword to get more
&gt; information, at Mike Perry's advice.  It's helped narrow the scope of
&gt; the problem down to a few distinct classes of errors.  Recreating the
&gt; above situation, I get a more useful message from the socket:
&gt; C 20070815020009: EXTENDCIRCUIT 0 [fingerprintscrubbed],[fingerprintscrubbed]
&gt; S 20070815020009: 250 EXTENDED 22
&gt; S 20070815020009: 650 CIRC 22 LAUNCHED
&gt; S 20070815020009: 650 CIRC 22 FAILED REASON=OR_CONN_CLOSED

The first hop you picked was not reachable (or was not up).

&gt; &gt; B) What do your Tor logs say?
&gt; 
&gt; In the above example at INFO level, all I get is this:
&gt; Aug 15 02:00:09.185 [info] handle_control_authenticate():
&gt; Authenticated control connection (9)
&gt; Aug 15 02:00:09.317 [info] circuit_n_conn_done(): or_conn failed. Closing circ.

Yep.

&gt; &gt; C) Which nodes are you trying? Are they running, etc?
&gt; 
&gt; I'm getting a list of nodes using
&gt; 
&gt; GETINFO desc/all-recent
&gt; 
&gt; And choosing random paths with acceptable exit policies from the
&gt; output.  I was working from the assumption that this provides a list
&gt; of routers that are all currently usable...maybe my problem is in this
&gt; thinking?

Correct. You would want to getinfo ns/all too and cross-correlate.

But really, you just want to use Torflow as Mike says.

--Roger

</body></email><email><emailId>20070822163256</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-08-22 16:32:56-0400</timestampReceived><subject>Re: Research Ideas</subject><body>

On Wed, Aug 22, 2007 at 11:25:28AM -0500, Josh McFarlane wrote:
&gt; I'm looking for a topic for my undergraduate honors thesis and want to
&gt; do something relating to Tor. At first I thought about looking into
&gt; finding a solution to transporting IP traffic instead of just TCP
&gt; traffic, but that may be too large of a topic for me to cover in the
&gt; two semesters I have to complete it.
&gt; 
&gt; Anyone have any possible Tor-related topics they'd like to see some
&gt; research done on? I'm all open ears, just keep in mind I'm only an
&gt; undergraduate.

http://tor.eff.org/volunteer#Research has some good questions on it.

For background, I'd suggest reading some of the papers on
http://freehaven.net/anonbib/
(We've put boxes around the ones that are influential to us and/or
really relevant.)

Welcome! :)

--Roger

</body></email><email><emailId>20070824012436</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-08-24 01:24:36-0400</timestampReceived><subject>Re: Patches (maybe) for proposal 110</subject><body>


On Wed, Aug 22, 2007 at 03:31:01AM -0400, Roger Dingledine wrote:
&gt; On Tue, Aug 21, 2007 at 05:43:35PM -0400, Nick Mathewson wrote:
 [...]
&gt; &gt; The third patch enforces the protocol by:
&gt; &gt;     A) Disallowing any RELAY_COMMAND_EXTEND cells without the special
&gt; &gt;        cell type, and
&gt; &gt;     B) Closing any circuit where too many cells of the special type
&gt; &gt;        are sent.
&gt; &gt; 
&gt; &gt;   Rule B is not quite right: the rule is not "You may send no more
&gt; &gt;   than X special cells;" the rule is "special cells may only occur as
&gt; &gt;   the first X cells on any circuit."  (See proposal 110, "Design"
&gt; &gt;   section, last paragraph.)
&gt; 
&gt; Right.
&gt; 
&gt; But Nick, also see the 'additional complexity' section. It might be
&gt; smart for clients to send the first K of them as relay_early, but for
&gt; servers to enforce it by a "no more than K ever" rule. This could give us
&gt; more flexibility if we want it later -- I don't think it increases the
&gt; damage that can be done via the infinite circuit attack, though sending
&gt; a relay_early cell later on would tell everybody in the circuit what
&gt; you're up to.
&gt; 
&gt; (If we opt for this approach, we may find that RELAY_EARLY is now a bad
&gt; name. Hm.)

Right.  Personally, I'm not convinced that this is actually something
we'll want to do down the road, but I don't immediately see any way it
can hurt.

Other names: RELAY_COSTLY? RELAY_LIMITED?  RELAY_CAN_BE_EXTEND?
RELAY_HEAVY?

&gt; 
&gt; &gt; Here's a way that we could get the new protocol in faster.  It
&gt; &gt; requires that something like proposal 105 is implemented, so that part
&gt; &gt; of negotiating a Tor connection is learning which connection protocol
&gt; &gt; version the other router supports.  Here goes:
&gt; 
&gt; Actually, I had meant for us to be able to do phase 1 and phase 2 quite
&gt; close together (e.g. both in the 0.2.0.x timeframe), and it doesn't depend
&gt; on proposal 105. Basically, Alice should use a RELAY_EARLY cell when
&gt; all the nodes in her path would understand it, and not otherwise. She
&gt; has descriptors for all of them, after all, so she's in a fine position
&gt; to know when it will work.

The problem is that this tells an attacker running a node whether the
other nodes in Alice's path are or are not among those that have
upgraded to support RELAY_EARLY.  If the number of nodes that supports
R_E is small, then an exit can narrow down Alice's entry pretty easily
by noticing that it has just gotten an R_E cell.  Worse, if the number
of nodes that _don't_ support R_E is small, than an exit can narrow
down Alice's entry by noticing that it has just gotten a _regular_
relay cell.

Sure, 105 has a bit of complexity.  But we need it anyway for other
stuff, and we might as well use it to let us do 110 a little more
securely.

Thoughts?
-- 
Nick Mathewson

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070824032312</emailId><senderName>mrwigglet</senderName><senderEmail>mrwigglet@gmail.com</senderEmail><timestampReceived>2007-08-24 03:23:12-0400</timestampReceived><subject>Re: Prop 110 revisions</subject><body>

That's how I was thinking of doing it also, but I'm content to wait for
however everybody thinks it should all be done.  Meanwhile, I've got the
patches with the minor issues ready and am willing to go along with however
you all want it done, be that with prop 105 changes or other!

Thanks,

Nate

On 8/23/07, Christian Grothoff &lt;christian@grothoff.org&gt; wrote:
&gt;
&gt; On Thursday 23 August 2007 19:31, Nick Mathewson wrote:
&gt; &gt; &gt;  Third question
&gt; &gt; &gt; is about where to put the two fields.  Moving the counter for seen
&gt; &gt; &gt; extend cells to or_circuit_t is fine, but I'm not sure the other can
&gt; &gt; &gt; be moved to origin_circuit_t.  The reason is that the only place I
&gt; &gt; &gt; can find that the CELL_RELAY type is set is in
&gt; &gt; &gt; relay_send_command_from_edge and the type of circuit in that function
&gt; is
&gt; &gt; &gt; circuit_t not
&gt; &gt; &gt; origin_circuit_t.
&gt; &gt;
&gt; &gt; This will probably depend on which implementation we wind up doing.
&gt; &gt; If RELAY_EXTEND cells only originate from the client, then the counter
&gt; &gt; can go into origin_circuit_t, since every client circuit is an
&gt; &gt; origin_circuit_t.  If other nodes in the circuit decide to sometimes
&gt; &gt; originate RELAY_EXTEND cells (as they do in the migration phase in my
&gt; &gt; half-backed idea in my last email in this thread), then everybody
&gt; &gt; needs a count.
&gt;
&gt; How about this: if a peer (starting at patch level 2) receives a normal,
&gt; non-RELAY_EXTEND cell and its counter of # relay-extend-cells received is
&gt; still &lt; MAX, it just converts the cell type (and decrements the
&gt; EXTEND-received counter).  Yes, this will prevent the initiator from
&gt; sending
&gt; RELAY-EXTEND cells after the first 10, but no harm done there (and would
&gt; be
&gt; as in Proposal 110 anyway).  As for anonymity sets, just having a single
&gt; patch-level 2 peer on the path would result in the exit-level seeing
&gt; RELAY_EXTEND, so your anonymity sets are preserved.   In essence, we use
&gt; the
&gt; same counter that we use to reject RELAY_EXTEND to automatically convert
&gt; to
&gt; RELAY_EXTEND.  I think if we do this, we can get away with just a single
&gt; counter.
&gt;
&gt; I think this is either what you were proposing or at least an equally
&gt; effective alternative ;-).
&gt;
&gt; &gt; Cool!  Sorry for the indecisiveness here; I really wish we had this
&gt; &gt; all designed well ahead of time. :/
&gt;
&gt; No problem, these things need to be considered thoroughly.
&gt;
&gt; Cheers!
&gt;
&gt; Christian
&gt;

[Attachment #3 (text/html)]

That's how I was thinking of doing it also, but I'm content to wait for \
however everybody thinks it should all be done. Meanwhile, I've got the \
patches with the minor issues ready and am willing to go along with however you all \
want it done, be that with prop 105 changes or other! \
&lt;br&gt;&lt;br&gt;Thanks,&lt;br&gt;&lt;br&gt;Nate&lt;br&gt;&lt;br&gt;&lt;div&gt;&lt;span class="gmail_quote"&gt;On 8/23/07, &lt;b \
class="gmail_sendername"&gt;Christian Grothoff&lt;/b&gt; &lt;&lt;a \
href="mailto:christian@grothoff.org"&gt;christian@grothoff.org&lt;/a&gt;&gt; \
wrote:&lt;/span&gt;&lt;blockquote class="gmail_quote" style="border-left: 1px solid rgb(204, \
204, 204); margin: 0pt 0pt 0pt 0.8ex; padding-left: 1ex;"&gt; On Thursday 23 August 2007 \
19:31, Nick Mathewson wrote:&lt;br&gt;&gt; &gt;Third question&lt;br&gt;&gt; &gt; is \
about where to put the two fields.Moving the counter for seen&lt;br&gt;&gt; \
&gt; extend cells to or_circuit_t is fine, but I'm not sure the other can \
&lt;br&gt;&gt; &gt; be moved to origin_circuit_t.The reason is that the only \
place I&lt;br&gt;&gt; &gt; can find that the CELL_RELAY type is set is in&lt;br&gt;&gt; &gt; \
relay_send_command_from_edge and the type of circuit in that function is &lt;br&gt;&gt; \
&gt; circuit_t not&lt;br&gt;&gt; &gt; origin_circuit_t.&lt;br&gt;&gt;&lt;br&gt;&gt; This will probably \
depend on which implementation we wind up doing.&lt;br&gt;&gt; If RELAY_EXTEND cells only \
originate from the client, then the counter &lt;br&gt;&gt; can go into origin_circuit_t, \
since every client circuit is an&lt;br&gt;&gt; origin_circuit_t.If other nodes \
in the circuit decide to sometimes&lt;br&gt;&gt; originate RELAY_EXTEND cells (as they do \
in the migration phase in my &lt;br&gt;&gt; half-backed idea in my last email in this \
thread), then everybody&lt;br&gt;&gt; needs a count.&lt;br&gt;&lt;br&gt;How about this: if a peer \
(starting at patch level 2) receives a normal,&lt;br&gt;non-RELAY_EXTEND cell and its \
counter of # relay-extend-cells received is &lt;br&gt;still &lt; MAX, it just converts the \
cell type (and decrements the&lt;br&gt;EXTEND-received counter).Yes, this will \
prevent the initiator from sending&lt;br&gt;RELAY-EXTEND cells after the first 10, but no \
harm done there (and would be &lt;br&gt;as in Proposal 110 anyway).As for \
anonymity sets, just having a single&lt;br&gt;patch-level 2 peer on the path would result \
in the exit-level seeing&lt;br&gt;RELAY_EXTEND, so your anonymity sets are \
preserved. In essence, we use the &lt;br&gt;same counter that we use to reject \
RELAY_EXTEND to automatically convert to&lt;br&gt;RELAY_EXTEND.I think if we do \
this, we can get away with just a single&lt;br&gt;counter.&lt;br&gt;&lt;br&gt;I think this is either \
what you were proposing or at least an equally &lt;br&gt;effective alternative \
;-).&lt;br&gt;&lt;br&gt;&gt; Cool!Sorry for the indecisiveness here; I really wish we \
had this&lt;br&gt;&gt; all designed well ahead of time. :/&lt;br&gt;&lt;br&gt;No problem, these things \
need to be considered thoroughly.&lt;br&gt; \
&lt;br&gt;Cheers!&lt;br&gt;&lt;br&gt;Christian&lt;br&gt;&lt;/blockquote&gt;&lt;/div&gt;&lt;br&gt;



</body></email><email><emailId>20070824121711</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-08-24 12:17:11-0400</timestampReceived><subject>Re: Proposal: New PROTOCOLINFO command for controllers</subject><body>


On Fri, Aug 24, 2007 at 02:00:27AM -0400, Roger Dingledine wrote:
&gt; On Tue, Aug 14, 2007 at 02:29:41PM -0400, Nick Mathewson wrote:
&gt; &gt; &gt;   Here we describe how to help controllers locate the cookie
&gt; &gt; &gt;   authentication file when authenticating to Tor, so we can a) require
&gt; &gt; &gt;   authentication by default for Tor controllers and b) still keep
&gt; &gt; &gt;   things usable.
&gt; &gt; 
&gt; &gt; Also, this is an extensible, general-purpose mechanism that
&gt; &gt; controllers use to learn what kind of authentication is
&gt; &gt; needed/protocol is spoken before authenticating.
&gt; 
&gt; Matt has pointed out that right now Tor doesn't let you configure both
&gt; CookieAuthentication and HashedControlPassword. I can't think of a
&gt; reason for this -- it seems to me that if both are configured, then Tor
&gt; should allow auth by either approach. Maybe in situations with multiple
&gt; controllers, some of them would find reading a cookie file easier,
&gt; and some would find remembering a password easier. We should let that
&gt; happen; let me know if you see a reason not to. Nick also spoke of
&gt; allowing multiple HashedControlPassword lines, and thus supporting
&gt; several passwords (any of which will work).

This seems like a fine idea to me, and I don't see any reason not to
do it.

&gt; 
&gt; The next observation was that it's a bit hard for Tor to know *how* you're
&gt; attempting to authenticate to it. Right now it looks at the argument to
&gt; AUTHENTICATE, and if the first character is hex then it thinks you're
&gt; trying a password, and if it's a quote then it thinks you're trying a
&gt; cookie, and if it's empty it thinks you're trying a null
&gt; authenticate.
&gt; 
&gt; &gt; &gt;   AuthMethod =
&gt; &gt; &gt;     "NULL"           / ; No authentication is required
&gt; &gt; &gt;     "HASHEDPASSWORD" / ; A controller must supply the original password
&gt; &gt; &gt;     "COOKIE"         / ; A controller must supply the contents of a cookie
&gt; 
&gt; I suggest the AUTHENTICATE line should also allow you to say
&gt; HASHEDPASSWORD=foo or COOKIE="bar" as arguments. This will let us one day
&gt; add another type of auth that can't be distinguished just by the encoding
&gt; of its argument. I guess for completeness we might accept NULL= as well.
&gt; Since the current Tors won't accept the new more explicit approach,
&gt; controllers should only use it when the protocolinfo response indicates
&gt; a new enough Tor version.
&gt; 
&gt; Plausible?

This may be silly, but I was planning on just testing the provided
password against every configured authentication method, in order.
First, if we have a cookie, see if they gave us the cookie.  Then, for
each hashedpassword, hash the provided password with the same salt and
see whether it matches. Finally, if 'null' is set, then accept an
empty password.

reasonable?
-- 
Nick Mathewson

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070825005926</emailId><senderName>coderman</senderName><senderEmail>coderman@gmail.com</senderEmail><timestampReceived>2007-08-25 00:59:26-0400</timestampReceived><subject>Re: Server node stalls on unsuccessful socks listener change</subject><body>

On 8/21/07, coderman &lt;coderman@gmail.com&gt; wrote:
&gt; ...
&gt; this appears to be a linux'ism and applies only when going from an
&gt; unspecified bind (0.0.0.0) to a specified bind to an address on the
&gt; host.  changing specified bind addresses works as expected.

two issues here, one that i completely overlooked (thanks tup!)

the linux'ism described above may or may not be a problem.  there is a
bigger issue affecting all platforms first:

when reloading the config (ala SIGHUP or control port), the Tor
process tries to apply the various settings in an "undoable" fashion,
such that if the configuration fails, it reverts to its previous
state.  that is, set_options tries options_act_reversible which calls
retry_all_listeners which calls retry_listeners for each type with a
replaced_conns passed.

this results in behavior where a listening socket bound to 0.0.0.0 is
open at the same time tor tries to bind to a specified address, like
127.0.0.1, which obviously fails.  this doesn't cause a problem when
you start with a specified address because multiple specified
addresses can be bound to the same port since Tor is using
SO_REUSEADDR.

question for the Tor devs:

two possible ways to resolve this:
1. check for a change from unspecified to specified address in any of
the settings and disallow it.  (this should generate a warning in the
options_transition_allowed() checks)

2. modify retry_listeners so that when a listen port is previously
bound to 0.0.0.0 it does the following:
a. close the existing port immediately, instead of adding it to the
replace queue.
b. add this 0.0.0.0:port to an "undo" list in case subsequent changes fail.
c. bind to the new address:port and return success, or
d. close the attempted socket which caused a failed bind, and re-open
the previous 0.0.0.0:port socket so undo behavior is preserved.

i'd really like to be able to modify a running instance to change from
unspecified to specified binds without a restart.  this bit me once
already, and i think it is worth pursuing unless too complicated to
implement.

last caveat: the linux'ism still may be a problem.  the apparent
workaround for this is a small delay before rebinding.  the fix above
would at least correct the behavior on most platforms, leaving loonix
to be dealt with if needed.

best regards,
</body></email><email><emailId>20070828180102</emailId><senderName>Robert Hogan</senderName><senderEmail>robert@roberthogan.net</senderEmail><timestampReceived>2007-08-28 18:01:02-0400</timestampReceived><subject>Re: vidalia and new firewall config</subject><body>


On Tuesday 28 August 2007 10:53:24 Christian Grothoff wrote:
&gt; On Tuesday 28 August 2007 03:34, Roger Dingledine wrote:
&gt; &gt; &gt; Choosing 443 makes this hard to implement because Tor has to be started
&gt; &gt; &gt; as root to bind to it.  Would it be as well to suggest a popular
&gt; &gt; &gt; high-numbered port such as 8080?
&gt; &gt;
&gt; &gt; Good point. I guess in Windows-land it should be 443, but in Unix-land
&gt; &gt; it shouldn't be. Is 8080 popular? What are other good choices that won't
&gt; &gt; stand out too much?
&gt;
&gt; I disagree a bit here.  It is pretty easy to use iptables &amp; friends to map
&gt; the external port 443 to any other internal port.  I've been using this in
&gt; GNUnet -- the http transport advertises the public port 80 and internally
&gt; uses a different port.  The user than adds a rule to the firewall
&gt; configuration, something like:
&gt;
&gt; # iptables -t nat -A PREROUTING -p tcp -m tcp --dport 80 -j
&gt; REDIRECT --to-ports 8080
&gt;

Yes, but I think Tor will try to bind to the address that you want to 
advertise - which is the problem.

8080 is used by coral cache and many others, including open proxies. Maybe  
censors firewall it as a rule for just that reason.


-- 

Browse Anonymously Anywhere	- http://anonymityanywhere.com
TorK	- KDE Anonymity Manager	- http://tork.sf.net
KlamAV	- KDE Anti-Virus 	- http://www.klamav.net


["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20070814171823</emailId><senderName>Andrew</senderName><senderEmail>andrewmv@pobox.com</senderEmail><timestampReceived>2007-08-14 17:18:23-0400</timestampReceived><subject>constructing circuits using control port</subject><body>

I'm developing a tool that attempts to set up Tor circuits through
predetermined exit nodes via Tor's control port, but I've been having
only intermittent luck at getting the circuits to open.

The basic process that I'm using is to pick two or three nodes at
random from the list of ORs known to the client, checking to make sure
the would-be exit node has an acceptable policy, and then building the
appropriate circuit using the EXTENDCIRCUIT command and a list of
fingerprints.  Most (but not all) of the time, however, the circuit
fails immediately without explanation and without ever reaching the
BUILT state.

Here's an example of my control socket transcript:

C 20070804034544: AUTHENTICATE
S 20070804034544: 250 OK
C 20070804034544: EXTENDCIRCUIT 0 [fingerprintscrubbed],[fingerprintscrubbed]
S 20070804034545: 250 EXTENDED 116
C 20070804034545: SETEVENTS STREAM CIRC
S 20070804034545: 250 OK
S 20070804034545: 650 CIRC 116 FAILED

Is there anything wrong with my approach?
</body></email><email><emailId>20070814173523</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-08-14 17:35:23-0400</timestampReceived><subject>Re: constructing circuits using control port</subject><body>

On Tue, Aug 14, 2007 at 01:18:23PM -0400, Andrew wrote:
&gt; Here's an example of my control socket transcript:
&gt; 
&gt; C 20070804034544: AUTHENTICATE
&gt; S 20070804034544: 250 OK
&gt; C 20070804034544: EXTENDCIRCUIT 0 [fingerprintscrubbed],[fingerprintscrubbed]
&gt; S 20070804034545: 250 EXTENDED 116
&gt; C 20070804034545: SETEVENTS STREAM CIRC
&gt; S 20070804034545: 250 OK
&gt; S 20070804034545: 650 CIRC 116 FAILED
&gt; 
&gt; Is there anything wrong with my approach?

A) Put the setevents earlier, in case you're missing some answers
in between your EXTENDCIRCUIT and your SETEVENTS.

B) What do your Tor logs say?

C) Which nodes are you trying? Are they running, etc?

--Roger

</body></email><email><emailId>20070815031441</emailId><senderName>Mike Perry</senderName><senderEmail>mikeperry@fscked.org</senderEmail><timestampReceived>2007-08-15 03:14:41-0400</timestampReceived><subject>Re: constructing circuits using control port</subject><body>


Thus spake Andrew (andrewmv@pobox.com):

&gt; Here's an example of my control socket transcript:
&gt; 
&gt; C 20070804034544: AUTHENTICATE
&gt; S 20070804034544: 250 OK
&gt; C 20070804034544: EXTENDCIRCUIT 0 [fingerprintscrubbed],[fingerprintscrubbed]
&gt; S 20070804034545: 250 EXTENDED 116
&gt; C 20070804034545: SETEVENTS STREAM CIRC
&gt; S 20070804034545: 250 OK
&gt; S 20070804034545: 650 CIRC 116 FAILED
&gt; 
&gt; Is there anything wrong with my approach?

You should probably do SETEVENTS EXTENDED CIRC STREAM to get more info
on circuit failure reasons (most common reasons are timeouts and node
connections breaking down due to load balancing issues).


You should also look at TorFlow before you reinvent the wheel :)

http://tor.eff.org/svn/torflow/

or if you have SVN: 

svn co https://tor-svn.freehaven.net/svn/torflow/trunk torflow

It has tons of useful python classes for building custom circuits and
augmenting path selection. The README is a little sparse, but the code
is well organized and legible.



-- 
Mike Perry
Mad Computer Scientist
fscked.org evil labs

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070815080243</emailId><senderName>Andrew</senderName><senderEmail>andrewmv@pobox.com</senderEmail><timestampReceived>2007-08-15 08:02:43-0400</timestampReceived><subject>Re: constructing circuits using control port</subject><body>

On 8/14/07, Roger Dingledine &lt;arma@mit.edu&gt; wrote:
&gt; On Tue, Aug 14, 2007 at 01:18:23PM -0400, Andrew wrote:
&gt; &gt; Here's an example of my control socket transcript:
&gt; &gt;
&gt; &gt; C 20070804034544: AUTHENTICATE
&gt; &gt; S 20070804034544: 250 OK
&gt; &gt; C 20070804034544: EXTENDCIRCUIT 0 [fingerprintscrubbed],[fingerprintscrubbed]
&gt; &gt; S 20070804034545: 250 EXTENDED 116
&gt; &gt; C 20070804034545: SETEVENTS STREAM CIRC
&gt; &gt; S 20070804034545: 250 OK
&gt; &gt; S 20070804034545: 650 CIRC 116 FAILED
&gt; &gt;
&gt; &gt; Is there anything wrong with my approach?
&gt;
&gt; A) Put the setevents earlier, in case you're missing some answers
&gt; in between your EXTENDCIRCUIT and your SETEVENTS.

I've done this, and also added the EXTENDED keyword to get more
information, at Mike Perry's advice.  It's helped narrow the scope of
the problem down to a few distinct classes of errors.  Recreating the
above situation, I get a more useful message from the socket:
C 20070815020009: EXTENDCIRCUIT 0 [fingerprintscrubbed],[fingerprintscrubbed]
S 20070815020009: 250 EXTENDED 22
S 20070815020009: 650 CIRC 22 LAUNCHED
S 20070815020009: 650 CIRC 22 FAILED REASON=OR_CONN_CLOSED

&gt; B) What do your Tor logs say?

In the above example at INFO level, all I get is this:
Aug 15 02:00:09.185 [info] handle_control_authenticate():
Authenticated control connection (9)
Aug 15 02:00:09.317 [info] circuit_n_conn_done(): or_conn failed. Closing circ.


&gt; C) Which nodes are you trying? Are they running, etc?

I'm getting a list of nodes using

GETINFO desc/all-recent

And choosing random paths with acceptable exit policies from the
output.  I was working from the assumption that this provides a list
of routers that are all currently usable...maybe my problem is in this
thinking?

-Andrew
</body></email><email><emailId>20070815081011</emailId><senderName>Andrew</senderName><senderEmail>andrewmv@pobox.com</senderEmail><timestampReceived>2007-08-15 08:10:11-0400</timestampReceived><subject>Re: constructing circuits using control port</subject><body>

On 8/14/07, Mike Perry &lt;mikeperry@fscked.org&gt; wrote:
&gt; You should also look at TorFlow before you reinvent the wheel :)
&gt;
&gt; http://tor.eff.org/svn/torflow/
&gt;
&gt; or if you have SVN:
&gt;
&gt; svn co https://tor-svn.freehaven.net/svn/torflow/trunk torflow
&gt;
&gt; It has tons of useful python classes for building custom circuits and
&gt; augmenting path selection. The README is a little sparse, but the code
&gt; is well organized and legible.
&gt; --
&gt; Mike Perry
&gt; Mad Computer Scientist
&gt; fscked.org evil labs
&gt;

This actually overlaps my needs pretty closely...thanks for pointing
this out :).  My real solution may be to refocus my project on working
with and possibly extending this toolkit.

-Andrew
</body></email><email><emailId>20070830103643</emailId><senderName>Christian King</senderName><senderEmail>urzumph@gmail.com</senderEmail><timestampReceived>2007-08-30 10:36:43-0400</timestampReceived><subject>Problems compiling Tor with an altered libevent.</subject><body>

So for those of you who don't know me, I'm a SoC student working on the
Windows Networking side of Tor. As part of my project I have made some
fairly extensive alterations to libevent (with more to come) and now I
am trying to link my altered libevent with Tor.

So, here is what I have done so far:
In my altered libevent dir (available at
https://tor-svn.freehaven.net/svn/libevent-urz/trunk), I execute
aclocal &amp;&amp; autoheader &amp;&amp; autoconf &amp;&amp; automake --add-missing --copy
./configure --enable-static --disable-shared
make clean
make
make install

(note the --enable-static and --disable-shared are as per the mingw32
compile guide)

Now, the correct event.h header appears to be installed properly because
it appears in /usr/local/include/event.h (under mingw, which corresponds
to C:\msys\1.0\local\include\event.h) Now, in a directory containing the
latest SVN trunk of Tor (r11315 at the time of writing) I execute the
commands:

aclocal &amp;&amp; autoheader &amp;&amp; autoconf &amp;&amp; automake --add-missing --copy
./configure --enable-static --disable-shared

and configure fails with:
checking for libevent directory...
./configure: test: !=: unary operator expected
checking whether we need extra options to link libevent... configure:
error: Found linkable libevent in , but it does not seem to run, even
with -R. Maybe specify another using --with-libevent-dir}

I have also tried running ./configure --enable-static --disable-shared
--with-libevent-dir=/usr/local/include but this does not change the results.

From reading config.log, this excerpt from config.log seems relevant:

configure: program exited with status 1
configure: failed program was:
| /* confdefs.h.  */
|
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE "tor"
| #define VERSION "0.2.0.6-alpha-dev"
| #define ENABLE_CELL_POOL 1
| #define ENABLE_THREADS 1
| #define MS_WINDOWS 1
| #define HAVE_GETTIMEOFDAY 1
| #define HAVE_FTIME 1
| #define HAVE_STRTOULL 1
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define u_int64_t unsigned long long
| #define u_int32_t unsigned long
| #define u_int16_t unsigned short
| #define u_int8_t unsigned char
| /* end confdefs.h.  */
| void exit(int); void *event_init(void);
| int
| main ()
| {
| event_init(); exit(0);
|   ;
|   return 0;
| }
configure:5499: error: Found linkable libevent in , but it does not seem
to run, even with -R. Maybe specify another using --with-libevent-dir}

Now, if I do all the libevent steps as above in a directory with
standard libevent 1.3b and then configure tor, configure finishes
successfully.

So does anyone have any thoughts as to what is going on?
If you need more information I will be happy to provide whatever I can.

Thanks
Christian
</body></email><email><emailId>20070830142358</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-08-30 14:23:58-0400</timestampReceived><subject>Re: Extra information regarding my compilation issue</subject><body>


On Thu, Aug 30, 2007 at 08:39:21PM +1000, Christian King wrote:

&gt; Here is the complete config.log as you suggested. Since the config.log
&gt; lines reference the generated configure script, I have included that for
&gt; you as well. Let me know if you need anything else.
&gt; 
&gt; Christian

Here's the trouble:

&gt; In file included from conftest.c:35:
&gt; C:/msys/1.0/local/include/event.h:34:20: config.h: No such file or directory
&gt; C:/msys/1.0/local/include/event.h:35:30: compat/sys/queue.h: No such file or directory
&gt; In file included from conftest.c:35:
&gt; C:/msys/1.0/local/include/event.h:378: warning: no semicolon at end of struct or union
&gt; C:/msys/1.0/local/include/event.h:378: error: syntax error before "list_elem"
&gt; C:/msys/1.0/local/include/event.h:381: error: syntax error before '}' token
&gt; configure:5274: $? = 1

It seems, for whatever reason, that autoconf can't actually build with
the event.h header you have.  It seems to be including both config.h
and compat/sys/queue.h, neither of which is installed.  (Neither of
these is included by standard libevent.)  Also, there are some syntax
errors.

To fix this, I'd check out what recent versions of libevent do with
event.h.

I'm still not sure what causes the autoconf bug though.  The configure
script should complain about this.

yrs,
-- 
Nick Mathewson

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070830150916</emailId><senderName>Peter Palfrader</senderName><senderEmail>peter@palfrader.org</senderEmail><timestampReceived>2007-08-30 15:09:16-0400</timestampReceived><subject>Re: Proposal: Suicide descriptors when Tor servers stop</subject><body>

On Fri, 24 Aug 2007, Roger Dingledine wrote:

&gt; &gt; The usual approach on IRC networks is to perform some checks on connect,
&gt; &gt; and if the check is positive to set a temporary KLINE that lasts from
&gt; &gt; days to weeks.  If that client ever connects again the check isn't
&gt; &gt; repeated, the configured KLINE matches immediately and rejects the
&gt; &gt; client.
&gt; 
&gt; Would it be plausible to encourage these IRC networks (at least, the
&gt; friendly ones who know about tordnsel) to make the klines that they add
&gt; in response to the tordnsel last for a shorter time period?

Freenode probably.  I don't know about the others, but I guess it's
rather unlikely.

Peter
-- 
                           |  .''`.  ** Debian GNU/Linux **
      Peter Palfrader      | : :' :      The  universal
 http://www.palfrader.org/ | `. `'      Operating System
                           |   `-    http://www.debian.org/
</body></email><email><emailId>20070822162528</emailId><senderName>"Josh McFarlane"</senderName><senderEmail>josh.mcfarlane@gmail.com</senderEmail><timestampReceived>2007-08-22 16:25:28-0400</timestampReceived><subject>Research Ideas</subject><body>

I'm looking for a topic for my undergraduate honors thesis and want to
do something relating to Tor. At first I thought about looking into
finding a solution to transporting IP traffic instead of just TCP
traffic, but that may be too large of a topic for me to cover in the
two semesters I have to complete it.

Anyone have any possible Tor-related topics they'd like to see some
research done on? I'm all open ears, just keep in mind I'm only an
undergraduate.

-- 
Thanks,
Josh McFarlane
http://www.joshmcfarlane.com
</body></email><email><emailId>20070821214335</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-08-21 21:43:35-0400</timestampReceived><subject>Re: Patches (maybe) for proposal 110</subject><body>


[I'm moving this conversation onto or-dev with Nathan's permission, so
that other people can get into the design discussion.]

On Wed, Aug 15, 2007 at 04:25:31PM -0600, mrwigglet wrote:
&gt; Here are a set of patches with a possible implementation of proposal 110.
&gt; I'd like to know if this is what the outline was recommending.  I've tested
&gt; this on a tor network with ~10 routers ~3 dirservers and of course the first
&gt; two patches are compatible with the current tor versions, patch 3 is the
&gt; only one that enforces the protocol change.  Let me know if these are close
&gt; to what they should be, if not let me know how to change/improve/fix them.
&gt; 
&gt; Thanks!
&gt; 
&gt; Nathan Evans

Hi, Nathan, and thanks for the work!  I want to see more discussion on
the proposal itself before we move on this, but the basic idea seems
sane.

It looks like the first of these patches introduces the RELAY_EXTEND
cell type as a server-accepted synonym for the RELAY cell type.
(RELAY_EXTEND is not my favorite name, since CELL_RELAY_EXTEND will
get confused with RELAY_COMMAND_EXTEND in casual writing; Roger, maybe
we should change 110 to name the new type RELAY_EARLY or
RELAY_EXTEND_OK?  In the rest of this mail, I'll try to call it the
"special" cell type.)

  This patch makes sense other than the naming stuff, which wasn't
  your idea, so it's not your fault.

  I don't think that the behavior matches that described in 'phase
  one' of the proposal: special cells are passed on with the RELAY
  type, not with their own type.

The second patch mucks with some whitespace in circuitbuild.c, then
starts adding features so that clients will send as the special cell
type their first N relay cells on each circuit, where N is chosen
uniformly at random between 5 and 10.

  For this patch, I bet we could get the two uint16_ts that you've
  added to circuit_t down to a single field in origin_circuit_t (how
  many _more_ RELAY_EARLY cells will we originate?) and a single field
  in or_circuit_t (how many _more_ cells will we accept before we
  accept stop accepting RELAY_EARLY cells)?  The fields can be
  uint8_t, since the limit is well under 255 in both cases.

The third patch enforces the protocol by:
    A) Disallowing any RELAY_COMMAND_EXTEND cells without the special
       cell type, and
    B) Closing any circuit where too many cells of the special type
       are sent.

  Rule B is not quite right: the rule is not "You may send no more
  than X special cells;" the rule is "special cells may only occur as
  the first X cells on any circuit."  (See proposal 110, "Design"
  section, last paragraph.)

  Also, I think that despite what 110 says, we could add rule B in
  phase 1.

Other design issues on the proposal: It makes me a little nervous that
we can't actually do phase 2 until _first_ all of the servers that
don't support phase 1 are obsolete, and _then_ we can't do phase 3
until all the servers that support phase 2 are obsolete.  Thus, we'll
need two obsolescence before we could actually deploy this thing, and
old versions seem to get obsoleted only after 9-18 months or so.

Here's a way that we could get the new protocol in faster.  It
requires that something like proposal 105 is implemented, so that part
of negotiating a Tor connection is learning which connection protocol
version the other router supports.  Here goes:

    Phase 1: Add a v2 router protocol, to include RELAY_EARLY cells.

      When (as a client) we negotiate a v2 connection, send our first
      X cells as RELAY_EARLY cells.

      When we (as a server) receive a RELAY_EARLY cell on a v2
      connection, and we are sending it to another server with whom we
      have a v2 connection, then leave it as a RELAY_EARLY cell.  When
      we are sending it to another server with whom we have a v1
      connection, send it as a RELAY cell.

      When we (as a server) get a new circuit on a v1 connection,
      relay the first X cells as RELAY_EARLY cells.

    Phase 2:
      Eventually, stop accepting v1 connections.  Now, the proposal
      110 rules will be enforced.

This variant requires only one obsolescence.  Does it sound like a
good first cut?  Does it leak more or less information about client
operations and paths than the version currently in 110?  Shall I add
it to the proposal?  Is the dependency on proposal 105 acceptable?

yrs,
-- 
Nick Mathewson

----- End forwarded message -----

-- 
Nick Mathewson

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070822073101</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-08-22 07:31:01-0400</timestampReceived><subject>Re: Patches (maybe) for proposal 110</subject><body>

On Tue, Aug 21, 2007 at 05:43:35PM -0400, Nick Mathewson wrote:
&gt; It looks like the first of these patches introduces the RELAY_EXTEND
&gt; cell type as a server-accepted synonym for the RELAY cell type.
&gt; (RELAY_EXTEND is not my favorite name, since CELL_RELAY_EXTEND will
&gt; get confused with RELAY_COMMAND_EXTEND in casual writing; Roger, maybe
&gt; we should change 110 to name the new type RELAY_EARLY or
&gt; RELAY_EXTEND_OK?  In the rest of this mail, I'll try to call it the
&gt; "special" cell type.)

I like RELAY_EARLY. It specifies how to treat the cell, rather than what
is meant to be in it, which might be handy later on.

&gt;   I don't think that the behavior matches that described in 'phase
&gt;   one' of the proposal: special cells are passed on with the RELAY
&gt;   type, not with their own type.

Right. RELAY_EARLY cells need to be passed on as RELAY_EARLY cells,
and RELAY cells as RELAY cells.

&gt; The second patch mucks with some whitespace in circuitbuild.c, then
&gt; starts adding features so that clients will send as the special cell
&gt; type their first N relay cells on each circuit, where N is chosen
&gt; uniformly at random between 5 and 10.
&gt; 
&gt;   For this patch, I bet we could get the two uint16_ts that you've
&gt;   added to circuit_t down to a single field in origin_circuit_t (how
&gt;   many _more_ RELAY_EARLY cells will we originate?) and a single field
&gt;   in or_circuit_t (how many _more_ cells will we accept before we
&gt;   accept stop accepting RELAY_EARLY cells)?  The fields can be
&gt;   uint8_t, since the limit is well under 255 in both cases.

Plausible.

&gt; The third patch enforces the protocol by:
&gt;     A) Disallowing any RELAY_COMMAND_EXTEND cells without the special
&gt;        cell type, and
&gt;     B) Closing any circuit where too many cells of the special type
&gt;        are sent.
&gt; 
&gt;   Rule B is not quite right: the rule is not "You may send no more
&gt;   than X special cells;" the rule is "special cells may only occur as
&gt;   the first X cells on any circuit."  (See proposal 110, "Design"
&gt;   section, last paragraph.)

Right.

But Nick, also see the 'additional complexity' section. It might be
smart for clients to send the first K of them as relay_early, but for
servers to enforce it by a "no more than K ever" rule. This could give us
more flexibility if we want it later -- I don't think it increases the
damage that can be done via the infinite circuit attack, though sending
a relay_early cell later on would tell everybody in the circuit what
you're up to.

(If we opt for this approach, we may find that RELAY_EARLY is now a bad
name. Hm.)

&gt; Here's a way that we could get the new protocol in faster.  It
&gt; requires that something like proposal 105 is implemented, so that part
&gt; of negotiating a Tor connection is learning which connection protocol
&gt; version the other router supports.  Here goes:

Actually, I had meant for us to be able to do phase 1 and phase 2 quite
close together (e.g. both in the 0.2.0.x timeframe), and it doesn't depend
on proposal 105. Basically, Alice should use a RELAY_EARLY cell when
all the nodes in her path would understand it, and not otherwise. She
has descriptors for all of them, after all, so she's in a fine position
to know when it will work.

--Roger

</body></email><email><emailId>20070823021702</emailId><senderName>mrwigglet</senderName><senderEmail>mrwigglet@gmail.com</senderEmail><timestampReceived>2007-08-23 02:17:02-0400</timestampReceived><subject>Prop 110 revisions</subject><body>

Sorry if this starts a new thread, I hadn't yet joined the or-dev list
so I couldn't just hit 'reply'.  Anyhow, I just have a few questions
so that I can hopefully get the patches right for this.  Question 1 is
what exactly you guys want the behavior to be, either the way Nick
outlines it or the way it is in 'additional complexity'.  Second is
what the naming should be, RELAY_EARLY or something else.  Third question
is about where to put the two fields.  Moving the counter for seen
extend cells to or_circuit_t is fine, but I'm not sure the other can
be moved to origin_circuit_t.  The reason is that the only place I
can find that the CELL_RELAY type is set is in relay_send_command_from_edge
and the type of circuit in that function is circuit_t not origin_circuit_t.
So if you could let me know what way that should be handled that'd be great.
Also, whether or not you guys think this should go along with another
proposal (105 or other).  Other than these few things I think I know
what is needed so hopefully we can work it all out.

Thanks,

Nate

On Tue, Aug 21, 2007 at 05:43:35PM -0400, Nick Mathewson wrote:
&gt; It looks like these patches introduces the RELAY_EXTEND
&gt; cell type as a server-accepted synonym for the RELAY cell type.
&gt; (RELAY_EXTEND is not my favorite name, since CELL_RELAY_EXTEND will
&gt; get confused with RELAY_COMMAND_EXTEND in casual writing; Roger, maybe
&gt; we should change 110 to name the new type RELAY_EARLY or
&gt; RELAY_EXTEND_OK?  In the rest of this mail, I'll try to call it the
&gt; "special" cell type.)

I like RELAY_EARLY. It specifies how to treat the cell, rather than what
is meant to be in it, which might be handy later on.

&gt;   I don't think that the behavior matches that described in 'phase
&gt;   one' of the proposal: special cells are passed on with the RELAY
&gt;   type, not with their own type.

Right. RELAY_EARLY cells need to be passed on as RELAY_EARLY cells,
and RELAY cells as RELAY cells.

&gt; The second patch mucks with some whitespace in circuitbuild.c, then
&gt; starts adding features so that clients will send as the special cell
&gt; type their first N relay cells on each circuit, where N is chosen
&gt; uniformly at random between 5 and 10.
&gt;
&gt;   For this patch, I bet we could get the two uint16_ts that you've
&gt;   added to circuit_t down to a single field in origin_circuit_t (how
&gt;   many _more_ RELAY_EARLY cells will we originate?) and a single field
&gt;   in or_circuit_t (how many _more_ cells will we accept before we
&gt;   accept stop accepting RELAY_EARLY cells)?  The fields can be
&gt;   uint8_t, since the limit is well under 255 in both cases.

Plausible.

&gt; The third patch enforces the protocol by:
&gt;     A) Disallowing any RELAY_COMMAND_EXTEND cells without the special
&gt;        cell type, and
&gt;     B) Closing any circuit where too many cells of the special type
&gt;        are sent.
&gt;
&gt;   Rule B is not quite right: the rule is not "You may send no more
&gt;   than X special cells;" the rule is "special cells may only occur as
&gt;   the first X cells on any circuit."  (See proposal 110, "Design"
&gt;   section, last paragraph.)

Right.

But Nick, also see the 'additional complexity' section. It might be
smart for clients to send the first K of them as relay_early, but for
servers to enforce it by a "no more than K ever" rule. This could give us
more flexibility if we want it later -- I don't think it increases the
damage that can be done via the infinite circuit attack, though sending
a relay_early cell later on would tell everybody in the circuit what
you're up to.

(If we opt for this approach, we may find that RELAY_EARLY is now a bad
name. Hm.)

&gt; Here's a way that we could get the new protocol in faster.  It
&gt; requires that something like proposal 105 is implemented, so that part
&gt; of negotiating a Tor connection is learning which connection protocol
&gt; version the other router supports.  Here goes:

Actually, I had meant for us to be able to do phase 1 and phase 2 quite
close together (e.g. both in the 0.2.0.x timeframe), and it doesn't depend
on proposal 105. Basically, Alice should use a RELAY_EARLY cell when
all the nodes in her path would understand it, and not otherwise. She
has descriptors for all of them, after all, so she's in a fine position
to know when it will work.

--Roger

[Attachment #3 (text/html)]

&lt;pre&gt;Sorry if this starts a new thread, I hadn't yet joined the or-dev list&lt;br&gt;so \
I couldn't just hit 'reply'.  Anyhow, I just have a few questions&lt;br&gt;so \
that I can hopefully get the patches right for this.  Question 1 is &lt;br&gt;what exactly \
you guys want the behavior to be, either the way Nick&lt;br&gt;outlines it or the way it is \
in 'additional complexity'.  Second is&lt;br&gt;what the naming should be, \
RELAY_EARLY or something else.  Third question &lt;br&gt;is about where to put the two \
fields.  Moving the counter for seen&lt;br&gt;extend cells to or_circuit_t is fine, but \
I'm not sure the other can&lt;br&gt;be moved to origin_circuit_t.  The reason is that \
the only place I &lt;br&gt; can find that the CELL_RELAY type is set is in \
relay_send_command_from_edge&lt;br&gt;and the type of circuit in that function is circuit_t \
not origin_circuit_t.&lt;br&gt;So if you could let me know what way that should be handled \
that'd be great. &lt;br&gt;Also, whether or not you guys think this should go along \
with another&lt;br&gt;proposal (105 or other).  Other than these few things I think I \
know&lt;br&gt;what is needed so hopefully we can work it all out.&lt;br&gt;&lt;br&gt;Thanks,&lt;br&gt;&lt;br&gt; \
Nate&lt;br&gt;&lt;br&gt;On Tue, Aug 21, 2007 at 05:43:35PM -0400, Nick Mathewson wrote:&lt;br&gt;&gt; \
It looks like these patches introduces the RELAY_EXTEND&lt;br&gt;&gt; cell type as a \
server-accepted synonym for the RELAY cell type.&lt;br&gt;&gt; (RELAY_EXTEND is not my \
favorite name, since CELL_RELAY_EXTEND will &lt;br&gt;&gt; get confused with \
RELAY_COMMAND_EXTEND in casual writing; Roger, maybe&lt;br&gt;&gt; we should change 110 to \
name the new type RELAY_EARLY or&lt;br&gt;&gt; RELAY_EXTEND_OK?  In the rest of this mail, \
I'll try to call it the &lt;br&gt;&gt; "special" cell type.)&lt;br&gt;&lt;br&gt;I like \
RELAY_EARLY. It specifies how to treat the cell, rather than what&lt;br&gt;is meant to be \
in it, which might be handy later on.&lt;br&gt;&lt;br&gt;&gt;   I don't think that the \
behavior matches that described in 'phase &lt;br&gt;&gt;   one' of the proposal: \
special cells are passed on with the RELAY&lt;br&gt;&gt;   type, not with their own \
type.&lt;br&gt;&lt;br&gt;Right. RELAY_EARLY cells need to be passed on as RELAY_EARLY \
cells,&lt;br&gt;and RELAY cells as RELAY cells. &lt;br&gt;&lt;br&gt;&gt; The second patch mucks with \
some whitespace in circuitbuild.c, then&lt;br&gt;&gt; starts adding features so that \
clients will send as the special cell&lt;br&gt;&gt; type their first N relay cells on each \
circuit, where N is chosen &lt;br&gt;&gt; uniformly at random between 5 and 10.&lt;br&gt;&gt; \
&lt;br&gt;&gt;   For this patch, I bet we could get the two uint16_ts that \
you've&lt;br&gt;&gt;   added to circuit_t down to a single field in origin_circuit_t \
(how&lt;br&gt;&gt;   many _more_ RELAY_EARLY cells will we originate?) and a single field \
&lt;br&gt;&gt;   in or_circuit_t (how many _more_ cells will we accept before we&lt;br&gt;&gt;   \
accept stop accepting RELAY_EARLY cells)?  The fields can be&lt;br&gt;&gt;   uint8_t, since \
the limit is well under 255 in both cases.&lt;br&gt;&lt;br&gt; Plausible.&lt;br&gt;&lt;br&gt;&gt; The third \
patch enforces the protocol by:&lt;br&gt;&gt;     A) Disallowing any RELAY_COMMAND_EXTEND \
cells without the special&lt;br&gt;&gt;        cell type, and&lt;br&gt;&gt;     B) Closing any \
circuit where too many cells of the special type &lt;br&gt;&gt;        are sent.&lt;br&gt;&gt; \
&lt;br&gt;&gt;   Rule B is not quite right: the rule is not "You may send no \
more&lt;br&gt;&gt;   than X special cells;" the rule is "special cells may only \
occur as&lt;br&gt;&gt;   the first X cells on any circuit."  (See proposal 110, \
"Design" &lt;br&gt;&gt;   section, last paragraph.)&lt;br&gt;&lt;br&gt;Right.&lt;br&gt;&lt;br&gt;But \
Nick, also see the 'additional complexity' section. It might be&lt;br&gt;smart for \
clients to send the first K of them as relay_early, but for&lt;br&gt;servers to enforce it \
by a "no more than K ever" rule. This could give us &lt;br&gt;more flexibility if \
we want it later -- I don't think it increases the&lt;br&gt;damage that can be done via \
the infinite circuit attack, though sending&lt;br&gt;a relay_early cell later on would tell \
everybody in the circuit what &lt;br&gt;you're up to.&lt;br&gt;&lt;br&gt;(If we opt for this \
approach, we may find that RELAY_EARLY is now a bad&lt;br&gt;name. Hm.)&lt;br&gt;&lt;br&gt;&gt; \
Here's a way that we could get the new protocol in faster.  It&lt;br&gt;&gt; requires \
that something like proposal 105 is implemented, so that part &lt;br&gt;&gt; of negotiating \
a Tor connection is learning which connection protocol&lt;br&gt;&gt; version the other \
router supports.  Here goes:&lt;br&gt;&lt;br&gt;Actually, I had meant for us to be able to do \
phase 1 and phase 2 quite&lt;br&gt;close together ( e.g. both in the 0.2.0.x timeframe), \
and it doesn't depend&lt;br&gt;on proposal 105. Basically, Alice should use a \
RELAY_EARLY cell when&lt;br&gt;all the nodes in her path would understand it, and not \
otherwise. She&lt;br&gt;has descriptors for all of them, after all, so she's in a fine \
position &lt;br&gt;to know when it will work.&lt;br&gt;&lt;br&gt;--Roger&lt;/pre&gt;



</body></email><email><emailId>20070824013113</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-08-24 01:31:13-0400</timestampReceived><subject>Re: Prop 110 revisions</subject><body>


On Wed, Aug 22, 2007 at 08:17:02PM -0600, mrwigglet wrote:
&gt; Sorry if this starts a new thread, I hadn't yet joined the or-dev list
&gt; so I couldn't just hit 'reply'.  Anyhow, I just have a few questions
&gt; so that I can hopefully get the patches right for this.  Question 1 is
&gt; what exactly you guys want the behavior to be, either the way Nick
&gt; outlines it or the way it is in 'additional complexity'.

I don't think we've actually decided for sure yet; we'll probably
argue for a while and choose something. :)

&gt;  Second is
&gt; what the naming should be, RELAY_EARLY or something else.

Ditto.

&gt;  Third question
&gt; is about where to put the two fields.  Moving the counter for seen
&gt; extend cells to or_circuit_t is fine, but I'm not sure the other can
&gt; be moved to origin_circuit_t.  The reason is that the only place I
&gt; can find that the CELL_RELAY type is set is in relay_send_command_from_edge
&gt; and the type of circuit in that function is circuit_t not
&gt; origin_circuit_t.

This will probably depend on which implementation we wind up doing.
If RELAY_EXTEND cells only originate from the client, then the counter
can go into origin_circuit_t, since every client circuit is an
origin_circuit_t.  If other nodes in the circuit decide to sometimes
originate RELAY_EXTEND cells (as they do in the migration phase in my
half-backed idea in my last email in this thread), then everybody
needs a count.

As for implementation.  Every origin_circuit_t is also a circuit_t;
use the CIRCUIT_IS_ORIGIN() macro to test whether a circuit_t is an
origin_circuit_t, and use TO_ORIGIN_CIRCUIT() to convert a circuit_t
into an origin_circuit_t.  When sending a command from the client
side, you would check and maybe send a RELAY_EXTEND.  When sending a
command from the exit side of a circuit, you would never send a
RELAY_EXTEND, since they aren't supposed to travel in that direction.

&gt; So if you could let me know what way that should be handled that'd be great.
&gt; Also, whether or not you guys think this should go along with another
&gt; proposal (105 or other).  Other than these few things I think I know
&gt; what is needed so hopefully we can work it all out.
&gt; 

Cool!  Sorry for the indecisiveness here; I really wish we had this
all designed well ahead of time. :/

peace,
-- 
Nick Mathewson

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070814173044</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-08-14 17:30:44-0400</timestampReceived><subject>Proposal: New PROTOCOLINFO command for controllers</subject><body>

Filename: 1xx-protocolinfo-on-controlport.txt
Title: New PROTOCOLINFO command for controllers
Version:
Last-Modified:
Author: Roger Dingledine
Created: 14-Aug-2007
Status: Open

Overview:

  Here we describe how to help controllers locate the cookie
  authentication file when authenticating to Tor, so we can a) require
  authentication by default for Tor controllers and b) still keep
  things usable.

The Problem:

  When we first added the controller protocol, we wanted to make it
  easy for people to play with it, so by default we didn't require any
  authentication from controller programs. We allowed requests only from
  localhost as a stopgap measure for security.

  Due to an increasing number of vulnerabilities based on this approach,
  it's time to add authentication in default configurations.

  We have a number of goals:
  - We want the default Vidalia bundles to transparently work. That
    means we don't want the users to have to type in or know a password.
  - We want to allow multiple controller applications to connect to the
    control port. So if Vidalia is launching Tor, it can't just keep the
    secrets to itself.

  Right now there are three authentication approaches supported
  by the control protocol: NULL, CookieAuthentication, and
  HashedControlPassword. See Sec 5.1 in control-spec.txt for details.

  There are a couple of challenges here. The first is: if the controller
  launches Tor, how should we teach Tor what authentication approach
  it should require, and the secret that goes along with it? Next is:
  how should this work when the controller attaches to an existing Tor,
  rather than launching Tor itself?

  Cookie authentication seems most amenable to letting multiple controller
  applications interact with Tor. But that brings in yet another question:
  how does the controller guess where to look for the cookie file,
  without first knowing what DataDirectory Tor it using?

Design:

  We should add a new controller command PROTOCOLINFO that can be sent
  as a valid first command (the others being AUTHENTICATE and QUIT). If
  PROTOCOLINFO is sent as the first command, the second command must be
  either a successful AUTHENTICATE or a QUIT.



Spec:

  C: PROTOCOLINFO CRLF
  S: "250+PROTOCOLINFO" PIVERSION CRLF
  S: "250-AUTH" SP "METHODS=" AuthMethod *("," AuthMethod)
                 [SP "COOKIEFILE=" AuthCookieFile] CRLF
  S: "250-VERSION" SP "Tor=" Version [...]
  S: "250 OK"

  PIVERSION is there in case we drastically change the syntax one day. For
  now it should always be "1".

  [XXX Is there a better way to do PIVERSION? The above way seems bad,
  since what do controllers do if they hear a 2 but don't know what to
  do with it? -RD]

  Right now only two "topics" (AUTH and VERSION) are included, but more
  may be included in the future. Controllers must accept lines with
  unexpected topics.

  AuthMethod =
    "NULL"           / ; No authentication is required
    "HASHEDPASSWORD" / ; A controller must supply the original password
    "COOKIE"         / ; A controller must supply the contents of a cookie

  AuthCookieFile = QuotedString

  AuthMethod is used to specify one or more control authentication
  methods that Tor currently accepts.

  AuthCookieFile specifies the absolute path and filename of the
  authentication cookie that Tor is expecting and is provided only if
  the METHODS field contains the method "COOKIE". This field MUST be
  enclosed in DQUOTEs, since the absolute path to the cookie file may
  contain spaces on some platforms.

  The VERSION line contains the Tor version, in DQUOTES. In the future
  it might also contain Link versions, Circuit versions, or others as
  described in proposal 105.

  [What else might we want to include that could be useful? -RD]

Compatibility:

  Tor 0.1.2.16 and 0.2.0.4-alpha hang up after the first failed
  command. Earlier Tors don't know about this command but don't hang
  up. That means controllers will need a mechanism for distinguishing
  whether they're talking to a Tor that speaks PROTOCOLINFO or not.

  I suggest that the controllers attempt a PROTOCOLINFO. Then:
    - If it works, great. Authenticate as required.
    - If they get hung up on, reconnect and do a NULL AUTHENTICATE.
    - If it's unrecognized but they're not hung up on, do a NULL
      AUTHENTICATE.

Unsolved problems:

  If Torbutton wants to be a Tor controller one day... talking TCP is
  bad enough, but reading from the filesystem is even harder. Is there
  a way to let simple programs work with the controller port without
  needing all the auth infrastructure?

  Once we put this approach in place, the next vulnerability we see will
  involve an attacker somehow getting read access to the victim's files
  --- and then we're back where we started. This means we still need
  to think about how to demand password-based authentication without
  bothering the user about it.

</body></email><email><emailId>20070823063825</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-08-23 06:38:25-0400</timestampReceived><subject>vidalia and new firewall config</subject><body>

Hi Matt, others,

Here are some early thoughts on GUI layout for Tor's firewall features.
There are four features we'd like to get in sometime:
1) ReachableAddresses with a set of allowed ports, defaulting to 80,443.
2) Http{,s}Proxy with a username/password option.
3) I need to use a bridge.
4) I want to be a bridge.

So I propose changes to two places:

---------------------------------------------------------------------

First, a new page of Settings, perhaps between General and Server,
named "Firewall" or maybe "Network".

1) At the top, there's a checkbox named
"My firewall only lets certain ports out". When clicked, there's a
textbox that defaults to "80, 443". Maybe the textbox is greyed out when
it's not clicked, or maybe it's not there at all. When the textbox is
at the default, we can setconf FascistFirewall=1, otherwise we setconf
ReachableAddresses to *:"these ports".

2) Under that, there's a checkbox named
"I use a proxy to access the Internet." When clicked, there's a hostname
box and port box, as well as a username and password box. These set
HttpProxy and HttpsProxy, and also Http[s]ProxyAuthenticator if the
username or password are non-empty.
(We need a way to communicate to experts that this is an HTTP and HTTPS
proxy, without confusing ordinary users who don't know there are other
types. Maybe the hostname box label should be "HTTP proxy address".)

3) Under that, there's a checkbox named
"My ISP blocks connections to the Tor network." When clicked, Vidalia
setconfs TunnelDirConns to 1, and it provides a hostname box and port
box for the user to input a bridge address, along with an "Add" button
that will append the address:port currently in the boxes to the Bridge
list and then clear them in case we want to add more. Once we've added a
bridge it also setconfs UseBridges to 1. One day this stanza will become
more complex.

---------------------------------------------------------------------

4) The other change is to the 'Server' window. Right now it has only one
main option, which is 'Relay traffic for the Tor network'. It should
have a second choice, right under that, which is 'Help censored users
reach the Tor network'.

If either of the checkboxes is checked (you can't check both), then the
rest of the window shows up as it does now (but a little bit farther down
to accomodate that extra line). If we're choosing the 'help censored
users' one, then the defaults are different: the ORPort is 443, the
dirport is on (but still 9030), the exit policies are all 'reject',
and the bandwidth is on its lowest setting (which appears to be 256 Kbps).

I need to do a few more steps on the back end for bridge authorities
before this piece will really be useful, but it's still worth working
on the interface at this stage.

---------------------------------------------------------------------

Comments welcome, especially suggestions for changing the strings to
be more comprehensible and/or simple. Changes 1 and 2 are meant to be
end-user-ready, so we should work hard to make them clear. Changes 3
and 4 are meant to be experimental, and we should expect them to change
dramatically before we're done, so there's no need to polish them too
far yet.

Thanks!
--Roger

</body></email><email><emailId>20070815133806</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-08-15 13:38:06-0400</timestampReceived><subject>Proposal: Suicide descriptors when Tor servers stop</subject><body>

Filename: 120-suicide-descriptors.txt
Title: Suicide descriptors when Tor servers stop
Version: $Revision: 11115 $
Last-Modified: $Date: 2007-08-15 09:37:33 -0400 (Wed, 15 Aug 2007) $
Author: Roger Dingledine
Created: 15-Aug-2007
Status: Open

Overview:

  Tor servers should publish a last descriptor whenever they shut down,
  to let others know that they are no longer offering service.

The Problem:

  The main reason for this is in reaction to Internet services that want
  to treat connections from the Tor network differently. Right now,
  if a user experiments with turning on the "relay" functionality, he
  is punished by being locked out of some websites, some IRC networks,
  etc --- and this lockout persists for several days even after he turns
  the server off.

Design:

  During the "slow shutdown" period if exiting, or shortly after the
  user sets his ORPort back to 0 if not exiting, Tor should publish a
  final descriptor with the following characteristics:

  1) Exit policy is listed as "reject *:*"
  2) It includes a new entry called "opt shutdown 1"

  The first step is so current blacklists will no longer list this node
  as exiting to whatever the service is.

  The second step is so directory authorities can avoid wasting time
  doing reachability testing. Authorities should automatically not list
  as Running any router whose latest descriptor says it shut down.

  [I originally had in mind a third step --- Advertised bandwidth capacity
  is listed as "0" --- so current Tor clients will skip over this node
  when building most circuits. But since clients won't fetch descriptors
  from nodes not listed as Running, this step seems pointless. -RD]

Spec:

  TBD but should be pretty straightforward.

Security issues:

  Now external people can learn exactly when a node stopped offering
  relay service. How bad is this? I can see a few minor attacks based
  on this knowledge, but on the other hand as it is we don't really take
  any steps to keep this information secret.

Overhead issues:

  We are creating more descriptors that want to be remembered. However,
  since the router won't be marked as Running, ordinary clients won't
  fetch the suicide descriptors. Caches will, though. I hope this is ok.

Implementation:

  To make things easy, we should publish the suicide descriptor only
  on controlled shutdown (SIGINT as opposed to SIGTERM). That would
  leave enough time for publishing that we probably wouldn't need any
  extra synchronization code.

  If that turns out to be too unintuitive for users, I could imagine doing
  it on SIGTERMs too, and just delaying exit until we had successfully
  published to at least one authority, at which point we'd hope that it
  propagated from there.

Acknowledgements:

  tup suggested this idea.

</body></email><email><emailId>20070815152709</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-08-15 15:27:09-0400</timestampReceived><subject>Re: Proposal: Suicide descriptors when Tor servers stop</subject><body>

After discussion on #tor, here is the modified proposal:

On Wed, Aug 15, 2007 at 09:38:06AM -0400, Roger Dingledine wrote:
&gt;   During the "slow shutdown" period if exiting, or shortly after the
&gt;   user sets his ORPort back to 0 if not exiting, Tor should publish a
&gt;   final descriptor with the following characteristics:
&gt; 
&gt;   1) Exit policy is listed as "reject *:*"
&gt;   2) It includes a new entry called "opt shutdown 1"

The problem we were trying to solve here is that
doc/contrib/torel-design.txt says:

  After a Tor server op turns off their server, it stops publishing server
  descriptors. We should consider that server's IP address to still
  represent a Tor node until 48 hours after its last descriptor was
  published.

I had originally interpreted the goal of this as "we're not sure whether
it's actually down, so list it anyway", but it turns out the goal is
"maybe it will come back tomorrow, so list it anyway".

The real problem with proposal 120 is that when the user shuts down Tor,
we can't divine whether he meant to stop being a server too.

So here are the proposed changes to the proposal:

A) Rename 'suicide descriptor' to 'terminate descriptor', since the
name upset somebody.

B) On exit, don't do anything different than we do now.

C) But if we setconf orport from non-zero to zero, either via the
controlport or via a hup, then generate and send a terminate descriptor.

The reasoning is that if the user unclicks the 'be a relay' button, then
he really did mean to turn off relaying. And we support this operation
on 'hup' too so non-gui users have a way to trigger it, even if it's a
hard way.

I'll update the proposal in svn at some point to reflect this. Please do
feel free to critique the above changes in the meantime.

Thanks,
--Roger

</body></email><email><emailId>20070824154058</emailId><senderName>Peter Palfrader</senderName><senderEmail>peter@palfrader.org</senderEmail><timestampReceived>2007-08-24 15:40:58-0400</timestampReceived><subject>Re: Proposal: Suicide descriptors when Tor servers stop</subject><body>

On Wed, 15 Aug 2007, Roger Dingledine wrote:

&gt; C) But if we setconf orport from non-zero to zero, either via the
&gt; controlport or via a hup, then generate and send a terminate descriptor.

As a side node, please note that updated directory information will not
help people who have been banned from an IRC network.

The usual approach on IRC networks is to perform some checks on connect,
and if the check is positive to set a temporary KLINE that lasts from
days to weeks.  If that client ever connects again the check isn't
repeated, the configured KLINE matches immediately and rejects the
client.

Peter
-- 
                           |  .''`.  ** Debian GNU/Linux **
      Peter Palfrader      | : :' :      The  universal
 http://www.palfrader.org/ | `. `'      Operating System
                           |   `-    http://www.debian.org/
</body></email><email><emailId>20070825002654</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-08-25 00:26:54-0400</timestampReceived><subject>Re: Proposal: Suicide descriptors when Tor servers stop</subject><body>

On Fri, Aug 24, 2007 at 05:40:58PM +0200, Peter Palfrader wrote:
&gt; &gt; C) But if we setconf orport from non-zero to zero, either via the
&gt; &gt; controlport or via a hup, then generate and send a terminate descriptor.
&gt; 
&gt; As a side node, please note that updated directory information will not
&gt; help people who have been banned from an IRC network.
&gt; 
&gt; The usual approach on IRC networks is to perform some checks on connect,
&gt; and if the check is positive to set a temporary KLINE that lasts from
&gt; days to weeks.  If that client ever connects again the check isn't
&gt; repeated, the configured KLINE matches immediately and rejects the
&gt; client.

Would it be plausible to encourage these IRC networks (at least, the
friendly ones who know about tordnsel) to make the klines that they add
in response to the tordnsel last for a shorter time period?

Even something like a few hours should be long enough to reduce the
query load to roughly zero, and should be short enough to keep people
on both sides happy.

--Roger

</body></email><email><emailId>20070826144714</emailId><senderName>Robert Hogan</senderName><senderEmail>robert@roberthogan.net</senderEmail><timestampReceived>2007-08-26 14:47:14-0400</timestampReceived><subject>Re: vidalia and new firewall config</subject><body>

On Thursday 23 August 2007 07:38:25 Roger Dingledine wrote:
&gt; Hi Matt, others,
&gt;
&gt; Here are some early thoughts on GUI layout for Tor's firewall features.
&gt; There are four features we'd like to get in sometime:
&gt; 1) ReachableAddresses with a set of allowed ports, defaulting to 80,443.
&gt; 2) Http{,s}Proxy with a username/password option.
&gt; 3) I need to use a bridge.
&gt; 4) I want to be a bridge.
&gt;
&gt; So I propose changes to two places:
&gt;
&gt; ---------------------------------------------------------------------
&gt;
&gt; First, a new page of Settings, perhaps between General and Server,
&gt; named "Firewall" or maybe "Network".
&gt;
&gt; 1) At the top, there's a checkbox named
&gt; "My firewall only lets certain ports out". When clicked, there's a
&gt; textbox that defaults to "80, 443". Maybe the textbox is greyed out when
&gt; it's not clicked, or maybe it's not there at all. When the textbox is
&gt; at the default, we can setconf FascistFirewall=1, otherwise we setconf
&gt; ReachableAddresses to *:"these ports".
&gt;

So is fascistfirewall no longer deprecated?

&lt;snip&gt;
&gt;
&gt; 4) The other change is to the 'Server' window. Right now it has only one
&gt; main option, which is 'Relay traffic for the Tor network'. It should
&gt; have a second choice, right under that, which is 'Help censored users
&gt; reach the Tor network'.
&gt;
&gt; If either of the checkboxes is checked (you can't check both), then the
&gt; rest of the window shows up as it does now (but a little bit farther down
&gt; to accomodate that extra line). If we're choosing the 'help censored
&gt; users' one, then the defaults are different: the ORPort is 443, the
&gt; dirport is on (but still 9030), the exit policies are all 'reject',
&gt; and the bandwidth is on its lowest setting (which appears to be 256 Kbps).
&gt;

Choosing 443 makes this hard to implement because Tor has to be started as 
root to bind to it.  Would it be as well to suggest a popular high-numbered 
port such as 8080? 

Does the bridge still need to do  PublishServerDescriptor 0?

-- 

Browse Anonymously Anywhere	- http://anonymityanywhere.com
TorK	- KDE Anonymity Manager	- http://tork.sf.net
KlamAV	- KDE Anti-Virus 	- http://www.klamav.net


</body></email><email><emailId>20070828093438</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-08-28 09:34:38-0400</timestampReceived><subject>Re: vidalia and new firewall config</subject><body>

On Sun, Aug 26, 2007 at 03:47:14PM +0100, Robert Hogan wrote:
&gt; &gt; First, a new page of Settings, perhaps between General and Server,
&gt; &gt; named "Firewall" or maybe "Network".
&gt; &gt;
&gt; &gt; 1) At the top, there's a checkbox named
&gt; &gt; "My firewall only lets certain ports out". When clicked, there's a
&gt; &gt; textbox that defaults to "80, 443". Maybe the textbox is greyed out when
&gt; &gt; it's not clicked, or maybe it's not there at all. When the textbox is
&gt; &gt; at the default, we can setconf FascistFirewall=1, otherwise we setconf
&gt; &gt; ReachableAddresses to *:"these ports".
&gt; &gt;
&gt; 
&gt; So is fascistfirewall no longer deprecated?

Good question. I think we decided to leave it in since it's
easier to describe in documentation. It's basically a synonym for
ReachableDirAddresses *:80, ReachableORAddresses *:443. Since this step
is automated, it may be smarter just to set each of those directly.

&gt; &lt;snip&gt;
&gt; &gt;
&gt; &gt; 4) The other change is to the 'Server' window. Right now it has only one
&gt; &gt; main option, which is 'Relay traffic for the Tor network'. It should
&gt; &gt; have a second choice, right under that, which is 'Help censored users
&gt; &gt; reach the Tor network'.
&gt; &gt;
&gt; &gt; If either of the checkboxes is checked (you can't check both), then the
&gt; &gt; rest of the window shows up as it does now (but a little bit farther down
&gt; &gt; to accomodate that extra line). If we're choosing the 'help censored
&gt; &gt; users' one, then the defaults are different: the ORPort is 443, the
&gt; &gt; dirport is on (but still 9030), the exit policies are all 'reject',
&gt; &gt; and the bandwidth is on its lowest setting (which appears to be 256 Kbps).
&gt; 
&gt; Choosing 443 makes this hard to implement because Tor has to be started as 
&gt; root to bind to it.  Would it be as well to suggest a popular high-numbered 
&gt; port such as 8080? 

Good point. I guess in Windows-land it should be 443, but in Unix-land
it shouldn't be. Is 8080 popular? What are other good choices that won't
stand out too much?

Eventually I'd like to have an option like "find me a smart port that
isn't already used" and Tor will take it from there, but this involves
some delicate guesswork. And in any case the really hard part is still to
get the user to do port forwarding on his router; maybe we should learn
to play the upnp game at that point too. If anybody here has upnp clue,
please let us know. :)

&gt; Does the bridge still need to do  PublishServerDescriptor 0?

Actually, as of 0.2.0.6-alpha, the better answer is
"PublishServerDescriptor bridge"

This will cause him to publish his descriptor, privately, just to
Tonga. Eventually we'll have a way to have Tonga export what it knows
so we can tell identity keys to people via various out of band mechanisms.

Hope that helps,
--Roger

</body></email><email><emailId>20070828095324</emailId><senderName>Christian Grothoff</senderName><senderEmail>christian@grothoff.org</senderEmail><timestampReceived>2007-08-28 09:53:24-0400</timestampReceived><subject>Re: vidalia and new firewall config</subject><body>

On Tuesday 28 August 2007 03:34, Roger Dingledine wrote:
&gt; &gt; Choosing 443 makes this hard to implement because Tor has to be started
&gt; &gt; as root to bind to it.  Would it be as well to suggest a popular
&gt; &gt; high-numbered port such as 8080?
&gt;
&gt; Good point. I guess in Windows-land it should be 443, but in Unix-land
&gt; it shouldn't be. Is 8080 popular? What are other good choices that won't
&gt; stand out too much?

I disagree a bit here.  It is pretty easy to use iptables &amp; friends to map the 
external port 443 to any other internal port.  I've been using this in 
GNUnet -- the http transport advertises the public port 80 and internally 
uses a different port.  The user than adds a rule to the firewall 
configuration, something like:

# iptables -t nat -A PREROUTING -p tcp -m tcp --dport 80 -j 
REDIRECT --to-ports 8080

and voila, incoming connections on port 80 go to port 8080.  No need to run as 
root (except for iptables, and I guess we can assume that much control of the 
machine) and we're on a standard privileged port (as far as the network is 
concerned).

My 2 cents

Christian

</body></email><email><emailId>20070814182941</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-08-14 18:29:41-0400</timestampReceived><subject>Re: Proposal: New PROTOCOLINFO command for controllers</subject><body>


&gt; Overview:
&gt; 
&gt;   Here we describe how to help controllers locate the cookie
&gt;   authentication file when authenticating to Tor, so we can a) require
&gt;   authentication by default for Tor controllers and b) still keep
&gt;   things usable.

Also, this is an extensible, general-purpose mechanism that
controllers use to learn what kind of authentication is
needed/protocol is spoken before authenticating.

 [...]
&gt;   There are a couple of challenges here. The first is: if the controller
&gt;   launches Tor, how should we teach Tor what authentication approach
&gt;   it should require, and the secret that goes along with it? Next is:
&gt;   how should this work when the controller attaches to an existing Tor,
&gt;   rather than launching Tor itself?
&gt; 
&gt;   Cookie authentication seems most amenable to letting multiple controller
&gt;   applications interact with Tor. But that brings in yet another question:
&gt;   how does the controller guess where to look for the cookie file,
&gt;   without first knowing what DataDirectory Tor it using?

"it" should be "is"

&gt; Design:
&gt; 
&gt;   We should add a new controller command PROTOCOLINFO that can be sent
&gt;   as a valid first command (the others being AUTHENTICATE and QUIT). If
&gt;   PROTOCOLINFO is sent as the first command, the second command must be
&gt;   either a successful AUTHENTICATE or a QUIT.

What happens if the second command is _not_ authenticate or quit?  I'd
suggest, "Tor closes the connection."

&gt; Spec:
&gt; 
&gt;   C: PROTOCOLINFO CRLF
&gt;   S: "250+PROTOCOLINFO" PIVERSION CRLF
&gt;   S: "250-AUTH" SP "METHODS=" AuthMethod *("," AuthMethod)
&gt;                  [SP "COOKIEFILE=" AuthCookieFile] CRLF
&gt;   S: "250-VERSION" SP "Tor=" Version [...]
&gt;   S: "250 OK"

May Tor give its reply items in any order?  I'd suggest "yes, except
that the 250+PROTOCOLINFO line comes first, and the 250 OK line comes last."

Must controllers ignore lines with keywords they don't recognize?  I'd
again suggest "yes".

The first reply line should probably have an SP between
"250+PROTOCOLINFO" and PIVERSION.

When we merge this into control-spec.txt, we need to say something
about the actual syntax of the reply, rather than just giving an
example.  I'd suggest:

  "250+PROTOCOLVERSION" SP PIVERSION CRLF *InfoLine "250 OK" CRLF
  InfoLine = "250-" Keyword SP Arguments CRLF


&gt;   PIVERSION is there in case we drastically change the syntax one day. For
&gt;   now it should always be "1".
&gt; 
&gt;   [XXX Is there a better way to do PIVERSION? The above way seems bad,
&gt;   since what do controllers do if they hear a 2 but don't know what to
&gt;   do with it? -RD]

Previously, when v0 and v1 were both supported, we used a stupid
double-jointed approach to auto-detect the protocol version.  I'd
suggest that PROTOCOLINFO should take an (optional) space-separated
list of preferred protocols, so that controller that want "v2" can ask
for it later.

&gt;   Right now only two "topics" (AUTH and VERSION) are included, but more
&gt;   may be included in the future. Controllers must accept lines with
&gt;   unexpected topics.
&gt; 
&gt;   AuthMethod =
&gt;     "NULL"           / ; No authentication is required
&gt;     "HASHEDPASSWORD" / ; A controller must supply the original password
&gt;     "COOKIE"         / ; A controller must supply the contents of a cookie

We should explicitly say that controllers should accept and handle
replies with more than one AUTH line.   This way, Tor can support more
than one authentication method, and can tell controllers about more
than one of them.

&gt;   AuthCookieFile = QuotedString
&gt; 
&gt;   AuthMethod is used to specify one or more control authentication
&gt;   methods that Tor currently accepts.
&gt; 
&gt;   AuthCookieFile specifies the absolute path and filename of the
&gt;   authentication cookie that Tor is expecting and is provided only if
&gt;   the METHODS field contains the method "COOKIE". This field MUST be
&gt;   enclosed in DQUOTEs, since the absolute path to the cookie file may
&gt;   contain spaces on some platforms.

By "enclosed in dquotes" I think you mean "quoted string." ;)

Also, "Controllers MUST (as usual) handle escape sequences inside the
string."

&gt;   The VERSION line contains the Tor version, in DQUOTES. In the future
&gt;   it might also contain Link versions, Circuit versions, or others as
&gt;   described in proposal 105.

This isn't part of the spec; for the spec we just want to say
"controller MUST ignore unrecognized items"

We _don't_ want to include Link or Circuit versions in the
PROTOCOLINFO reply; that stuff belongs in some GETINFO response.
PROTOCOLINFO should only be for things that the controller needs to
know to talk to Tor.

-- 
Nick Mathewson

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070815035148</emailId><senderName>Cat Okita</senderName><senderEmail>cat@reptiles.org</senderEmail><timestampReceived>2007-08-15 03:51:48-0400</timestampReceived><subject>Re: Proposal: New PROTOCOLINFO command for controllers</subject><body>

On Tue, 14 Aug 2007, Nick Mathewson wrote:
&gt;&gt; Design:
&gt;&gt;
&gt;&gt;   We should add a new controller command PROTOCOLINFO that can be sent
&gt;&gt;   as a valid first command (the others being AUTHENTICATE and QUIT). If
&gt;&gt;   PROTOCOLINFO is sent as the first command, the second command must be
&gt;&gt;   either a successful AUTHENTICATE or a QUIT.
&gt;
&gt; What happens if the second command is _not_ authenticate or quit?  I'd
&gt; suggest, "Tor closes the connection."

What happens if there never is a second command?  I didn't see anything
in a quick check of the control-spec document, but it seems like that
could be "interesting".

cheers!
==========================================================================
"A cat spends her life conflicted between a deep, passionate and profound
desire for fish and an equally deep, passionate and profound desire to
avoid getting wet.  This is the defining metaphor of my life right now."
</body></email><email><emailId>20070815041145</emailId><senderName>coderman</senderName><senderEmail>coderman@gmail.com</senderEmail><timestampReceived>2007-08-15 04:11:45-0400</timestampReceived><subject>Re: Proposal: New PROTOCOLINFO command for controllers</subject><body>

On 8/14/07, Cat Okita &lt;cat@reptiles.org&gt; wrote:
&gt; ...
&gt; &gt; What happens if the second command is _not_ authenticate or quit?  I'd
&gt; &gt; suggest, "Tor closes the connection."
&gt;
&gt; What happens if there never is a second command?...
&gt; could be "interesting".

Tor waits patiently... very patiently.  not too interesting, although
this behavior could be used to consume socket descriptors.  a timeout
(minutes?) might be useful.

best regards,
</body></email><email><emailId>20070815041651</emailId><senderName>Cat Okita</senderName><senderEmail>cat@reptiles.org</senderEmail><timestampReceived>2007-08-15 04:16:51-0400</timestampReceived><subject>Re: Proposal: New PROTOCOLINFO command for controllers</subject><body>

On Tue, 14 Aug 2007, coderman wrote:
&gt; On 8/14/07, Cat Okita &lt;cat@reptiles.org&gt; wrote:
&gt;&gt;&gt; What happens if the second command is _not_ authenticate or quit?  I'd
&gt;&gt;&gt; suggest, "Tor closes the connection."
&gt;&gt;
&gt;&gt; What happens if there never is a second command?...
&gt;&gt; could be "interesting".
&gt;
&gt; Tor waits patiently... very patiently.  not too interesting, although
&gt; this behavior could be used to consume socket descriptors.  a timeout
&gt; (minutes?) might be useful.

Heh.  I was thinking in terms of "many, many requests", yes ;&gt;  300 seconds
is a pretty common wait time - but given that this would be waiting for
either auth or failure, I'd think that it would make more sense to go with
a much lower timeout.

cheers!
==========================================================================
"A cat spends her life conflicted between a deep, passionate and profound
desire for fish and an equally deep, passionate and profound desire to
avoid getting wet.  This is the defining metaphor of my life right now."
</body></email><email><emailId>20070824060027</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-08-24 06:00:27-0400</timestampReceived><subject>Re: Proposal: New PROTOCOLINFO command for controllers</subject><body>

On Tue, Aug 14, 2007 at 02:29:41PM -0400, Nick Mathewson wrote:
&gt; &gt;   Here we describe how to help controllers locate the cookie
&gt; &gt;   authentication file when authenticating to Tor, so we can a) require
&gt; &gt;   authentication by default for Tor controllers and b) still keep
&gt; &gt;   things usable.
&gt; 
&gt; Also, this is an extensible, general-purpose mechanism that
&gt; controllers use to learn what kind of authentication is
&gt; needed/protocol is spoken before authenticating.

Matt has pointed out that right now Tor doesn't let you configure both
CookieAuthentication and HashedControlPassword. I can't think of a
reason for this -- it seems to me that if both are configured, then Tor
should allow auth by either approach. Maybe in situations with multiple
controllers, some of them would find reading a cookie file easier,
and some would find remembering a password easier. We should let that
happen; let me know if you see a reason not to. Nick also spoke of
allowing multiple HashedControlPassword lines, and thus supporting
several passwords (any of which will work).

The next observation was that it's a bit hard for Tor to know *how* you're
attempting to authenticate to it. Right now it looks at the argument to
AUTHENTICATE, and if the first character is hex then it thinks you're
trying a password, and if it's a quote then it thinks you're trying a
cookie, and if it's empty it thinks you're trying a null authenticate.

&gt; &gt;   AuthMethod =
&gt; &gt;     "NULL"           / ; No authentication is required
&gt; &gt;     "HASHEDPASSWORD" / ; A controller must supply the original password
&gt; &gt;     "COOKIE"         / ; A controller must supply the contents of a cookie

I suggest the AUTHENTICATE line should also allow you to say
HASHEDPASSWORD=foo or COOKIE="bar" as arguments. This will let us one day
add another type of auth that can't be distinguished just by the encoding
of its argument. I guess for completeness we might accept NULL= as well.
Since the current Tors won't accept the new more explicit approach,
controllers should only use it when the protocolinfo response indicates
a new enough Tor version.

Plausible?

--Roger

</body></email><email><emailId>20070824020349</emailId><senderName>Christian Grothoff</senderName><senderEmail>christian@grothoff.org</senderEmail><timestampReceived>2007-08-24 02:03:49-0400</timestampReceived><subject>Re: Prop 110 revisions</subject><body>

On Thursday 23 August 2007 19:31, Nick Mathewson wrote:
&gt; &gt;  Third question
&gt; &gt; is about where to put the two fields.  Moving the counter for seen
&gt; &gt; extend cells to or_circuit_t is fine, but I'm not sure the other can
&gt; &gt; be moved to origin_circuit_t.  The reason is that the only place I
&gt; &gt; can find that the CELL_RELAY type is set is in
&gt; &gt; relay_send_command_from_edge and the type of circuit in that function is
&gt; &gt; circuit_t not
&gt; &gt; origin_circuit_t.
&gt;
&gt; This will probably depend on which implementation we wind up doing.
&gt; If RELAY_EXTEND cells only originate from the client, then the counter
&gt; can go into origin_circuit_t, since every client circuit is an
&gt; origin_circuit_t.  If other nodes in the circuit decide to sometimes
&gt; originate RELAY_EXTEND cells (as they do in the migration phase in my
&gt; half-backed idea in my last email in this thread), then everybody
&gt; needs a count.

How about this: if a peer (starting at patch level 2) receives a normal, 
non-RELAY_EXTEND cell and its counter of # relay-extend-cells received is 
still &lt; MAX, it just converts the cell type (and decrements the 
EXTEND-received counter).  Yes, this will prevent the initiator from sending 
RELAY-EXTEND cells after the first 10, but no harm done there (and would be 
as in Proposal 110 anyway).  As for anonymity sets, just having a single 
patch-level 2 peer on the path would result in the exit-level seeing 
RELAY_EXTEND, so your anonymity sets are preserved.   In essence, we use the 
same counter that we use to reject RELAY_EXTEND to automatically convert to 
RELAY_EXTEND.  I think if we do this, we can get away with just a single 
counter.  

I think this is either what you were proposing or at least an equally 
effective alternative ;-).

&gt; Cool!  Sorry for the indecisiveness here; I really wish we had this
&gt; all designed well ahead of time. :/

No problem, these things need to be considered thoroughly.

Cheers!

Christian
</body></email><email><emailId>20070704081945</emailId><senderName>Mike Perry</senderName><senderEmail>mikeperry@fscked.org</senderEmail><timestampReceived>2007-07-04 08:19:45-0400</timestampReceived><subject>Re: r10730: If there's a never-before-connected-to guard node</subject><body>


Hrmm, actually, it appears you mark all guards as made_contact=1 when
you parse the state file in entry_guards_parse_state(), so you can
still add guards and write them out to disk eventually, no? 

In actual fact, I still don't fully understand how the list is
actually growing beyond options-&gt;NumEntryGuards. I *think* it may have
something to do with the difference between live_entry_guards and
entry_guards, and adding more guards to entry_guards if
live_entry_guards is too small.

Another possibility may be that this UnreachableSince or UnlistedSince
(bad_since).. It seems like it should be possible for a guard to be
marked as unlisted but then be discovered to be listed again, creating
a larger pool of guards than desired.

It seems to me that this whole guard implementation is a little too
complicated for its own good. Really all we want to keep is 2-3 reliable
guard nodes known to be reachable for as long as possible.

So how about this idea instead: Based on the assumption that we want
multiple guards so that circuit failure attacks aren't as deadly, lets
only keep a list of known, live guards, and hard-cap this at 3 nodes
(or NumEntryGuards nodes). If a circuit fails, choose a different
guard from this list for the next circuit (to frustrate circuit
failure attacks). However, if an or_conn to a guard fails (or it
disappears from the directory), mark it as down, but do not remove it
until a connectable replacement is found. Create a tentative_guard
global pointer or something to hold a randomly chosen guard for
replacement. Once the connection is made to this guard, then replace
the downed live_entry_guard entry with this pointer.

This should simplify things quite a good deal, has easy to analyze
properties, and should not have unexpected results.

Thus spake arma@seul.org (arma@seul.org):

&gt; Author: arma
&gt; Date: 2007-07-02 18:15:26 -0400 (Mon, 02 Jul 2007)
&gt; New Revision: 10730
&gt; 
&gt; Modified:
&gt;    tor/trunk/ChangeLog
&gt;    tor/trunk/src/or/circuitbuild.c
&gt; Log:
&gt; If there's a never-before-connected-to guard node in our list,
&gt; never choose any guards past it. This way we don't expand our 
&gt; guard list unless we need to. [Bugfix in 0.1.2.x]
&gt; 
&gt; I'm not sure if this will solve all our problems, but it is at least
&gt; something.
&gt; 
&gt; 
&gt; 
&gt; Modified: tor/trunk/ChangeLog
&gt; ===================================================================
&gt; --- tor/trunk/ChangeLog	2007-07-02 22:07:53 UTC (rev 10729)
&gt; +++ tor/trunk/ChangeLog	2007-07-02 22:15:26 UTC (rev 10730)
&gt; @@ -50,7 +50,12 @@
&gt;      - Stop under-counting the number of authorities that recommend each
&gt;        version. [Bugfix on 0.1.2.x]
&gt;  
&gt; +  o Minor bugfixes (guard nodes):
&gt; +    - If there's a never-before-connected-to guard node in our list,
&gt; +      never choose any guards past it. This way we don't expand our
&gt; +      guard list unless we need to. [Bugfix in 0.1.2.x]
&gt;  
&gt; +
&gt;  Changes in version 0.2.0.2-alpha - 2007-06-02
&gt;    o Major bugfixes on 0.2.0.1-alpha:
&gt;      - Fix an assertion failure related to servers without extra-info digests.
&gt; 
&gt; Modified: tor/trunk/src/or/circuitbuild.c
&gt; ===================================================================
&gt; --- tor/trunk/src/or/circuitbuild.c	2007-07-02 22:07:53 UTC (rev 10729)
&gt; +++ tor/trunk/src/or/circuitbuild.c	2007-07-02 22:15:26 UTC (rev 10730)
&gt; @@ -2418,6 +2418,13 @@
&gt;        r = entry_is_live(entry, need_uptime, need_capacity, 0);
&gt;        if (r &amp;&amp; !smartlist_isin(exit_family, r)) {
&gt;          smartlist_add(live_entry_guards, r);
&gt; +        if (!entry-&gt;made_contact) {
&gt; +          /* Always start with the first not-yet-contacted entry
&gt; +           * guard. Otherwise we might add several new ones, pick
&gt; +           * the second new one, and now we've expanded our entry
&gt; +           * guard list without needing to. */
&gt; +          goto choose_and_finish;
&gt; +        }
&gt;          if (smartlist_len(live_entry_guards) &gt;= options-&gt;NumEntryGuards)
&gt;            break; /* we have enough */
&gt;        }
&gt; @@ -2451,6 +2458,7 @@
&gt;      /* live_entry_guards may be empty below. Oh well, we tried. */
&gt;    }
&gt;  
&gt; + choose_and_finish:
&gt;    r = smartlist_choose(live_entry_guards);
&gt;    smartlist_free(live_entry_guards);
&gt;    smartlist_free(exit_family);

-- 
Mike Perry
Mad Computer Scientist
fscked.org evil labs

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070705093215</emailId><senderName>yousifnet</senderName><senderEmail>yousifnet@gmail.com</senderEmail><timestampReceived>2007-07-05 09:32:15-0400</timestampReceived><subject>Re: Choose exitnodes in country x</subject><body>

&gt; How are you proposing to detect country?
&gt;
&gt; no automatic, add an additional entry to the tor directory.
&gt; For a human there is no problem to get the country out of traceroute.
&gt; For new tornodes it can be asked direct within the registration
&gt; process.

how about "built-in geoip code". Vidalia and TorK are currently using
geoip services from external sources. Rather than implementing this
feature server-side and routing requests through the tor network,
every client/node can _have_the_option_ of downloading an updated
geoip database from a trusted source and using this would-be
client-side implemented feature without recourse to external sources
to:

A) detect "the other" node's country (to filter Exit Nodes perhaps
using a ExitNodesCountryCode and StrictExitNodesCountryCode options in
torrc).
B) adding a "CountryCode" descriptor to their own directory
descriptors to be identified by clients with no geoip database.

--Yousif
</body></email><email><emailId>20070705170059</emailId><senderName>Karsten Loesing</senderName><senderEmail>karsten.loesing@gmx.net</senderEmail><timestampReceived>2007-07-05 17:00:59-0400</timestampReceived><subject>Circuit creation timeout</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Hi,

Johannes Renner and me have conducted some statistics on circuit setup
(well, he collected the data and I analyzed them). We chose default
settings for Tor but disabled using entry/guard nodes.

Results show that the default timeout of 60 seconds is far beyond
reasonable circuit establishment times. Median for a 3-hop circuit setup
is 4.36 secs with IQR of 6.01 secs, resp. average of 7.78 secs with std.
dev. of 9.20 secs. 27% of all circuit creation attempts fail, of which
5% (9%, 13%) fail at creating the first (second, third) hop. The medians
for the three hops are 0.58 secs for the first, 1.23 secs for the
second, and 2.23 secs for the third hop; the IQRs are 0.66 secs for the
first, 1.80 secs for the second, and 3.01 secs for the third hop. If
someone is interested in the original data or the SPSS output, I could
send it by mail or upload it somewhere.

A first discussion on #tor resulted in the following arguments:

- - One could reduce the default timeout for circuit creation to 25 secs.

- - In case of a crappy network, one could back off after a certain number
of failures to 60 secs. Therefore, some kind of history and dynamic
timeout determination of the timeout would be required.

- - One could keep a history of previous connection times to better cope
with the network connection -- if that should make a big difference
which we did not measure, yet.

- - One could have distinct timeouts for each hop, because there is no big
use in continuing circuit creation after the first hop requires a large
share of the overall timeout. Overall creation might not succeed and the
circuit might be slow.

- - Are there anonymity issues in cutting down the circuit creation time?
IMHO not, if some value bigger than the 0.9 or 0.95 quantile is chosen.

Any ideas on this?

- --Karsten
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFGjSPL0M+WPffBEmURArOlAJ9F5Mxum6lDs0EQ3Acu18oMDkocjgCgmVzq
ogJwVx8jX5ayDt4xxQpnAOs=
=juQ9
-----END PGP SIGNATURE-----
</body></email><email><emailId>20070707093846</emailId><senderName>eBay Member</senderName><senderEmail>member@ebay.com</senderEmail><timestampReceived>2007-07-07 09:38:46-0400</timestampReceived><subject>Question from eBay Member -- Respond Now</subject><body>

&lt;html&gt;

&lt;body bgcolor="white" text="black" link="blue" vlink="purple" alink="red"&gt;
&lt;TABLE cellSpacing=0 cellPadding=0 width="100%"&gt;
    &lt;TBODY&gt;
    &lt;TR&gt;
        &lt;TD style="WORD-WRAP: break-word" width="100%"&gt;
            &lt;TABLE cellSpacing=0 cellPadding=0 width="100%" border=0&gt;
                &lt;TBODY&gt;
                &lt;TR&gt;
                    &lt;TD width="100%"&gt;
                        &lt;TABLE cellSpacing=0 cellPadding=5 width="100%" border=0&gt;
                            &lt;TBODY&gt;
                            &lt;TR&gt;
                                &lt;TD width="1%"&gt;&lt;IMG alt=eBay 
src="http://pics.ebaystatic.com/aw/pics/uk/logos/ebay_95x39.gif" border=0&gt;&lt;/TD&gt;
                                &lt;TD vAlign=bottom&gt;&lt;FONT face="verdana, sans-serif" \
color=#666666 size=1&gt;&lt;BR&gt;&lt;/FONT&gt;&lt;/TD&gt;  &lt;/TR&gt;
                            &lt;/TBODY&gt;
                        &lt;/TABLE&gt;
                        &lt;TABLE cellSpacing=0 cellPadding=0 width="100%" \
bgColor=#ffe680 border=0&gt;  &lt;TBODY&gt;
                            &lt;TR&gt;
                                &lt;TD vAlign=top width=8&gt;&lt;IMG height=8 
src="http://pics.ebaystatic.com/aw/pics/globalAssets/ltCurve.gif" width=8&gt;&lt;/TD&gt;
                                &lt;TD vAlign=bottom width="100%"&gt;
                                    &lt;H1 
style="MARGIN-TOP: 2px; FONT-WEIGHT: bold; FONT-SIZE: 14pt; MARGIN-BOTTOM: 2px; \
COLOR: #000000; FONT-FAMILY: arial,"&gt;&lt;FONT  face="Arial, Verdana" size=4&gt;&lt;B&gt;Question \
from eBay Member -- Respond  Now&lt;/B&gt;&lt;/FONT&gt;  &lt;/H1&gt;
                                &lt;/TD&gt;
                                &lt;TD vAlign=top align=right width=8&gt;&lt;IMG height=8 
src="http://pics.ebaystatic.com/aw/pics/globalAssets/rtCurve.gif" width=8 
align=top&gt;&lt;/TD&gt;
                            &lt;/TR&gt;
                            &lt;TR&gt;
                                &lt;TD bgColor=#ffcc00 colSpan=3 height=4&gt;&lt;/TD&gt;
                            &lt;/TR&gt;
                            &lt;/TBODY&gt;
                        &lt;/TABLE&gt;
                        &lt;TABLE cellSpacing=0 cellPadding=0 width="100%" border=0&gt;
                            &lt;TBODY&gt;
                            &lt;TR&gt;
                                &lt;TD&gt;&lt;IMG height=1 \
src="http://pics.ebaystatic.com/aw/pics/s.gif" width=5&gt;&lt;/TD&gt;  &lt;TD&gt;
                                    &lt;TABLE cellSpacing=0 cellPadding=0 width="100%" \
border=0&gt;  &lt;TBODY&gt;
                                        &lt;TR&gt;
                                            &lt;TD&gt;
                                                &lt;TABLE 
style="BORDER-RIGHT: #ffcc00 1px solid; BORDER-LEFT: #ffcc00 1px solid; \
BORDER-BOTTOM: #ffcc00 1px solid"  width="100%" border=0&gt;
                                                    &lt;TBODY&gt;
                                                    &lt;TR&gt;
                                                        &lt;TD style="PADDING-LEFT: \
8px"&gt;&lt;FONT face="Arial, Verdana" size=2&gt;eBay sent this  message on behalf of an eBay \
member through My Messages. Responses sent using  email will not reach the eBay \
member so please use the yellow button to respond.&lt;/FONT&gt;&lt;/TD&gt;  &lt;/TR&gt;
                                                    &lt;/TBODY&gt;
                                                &lt;/TABLE&gt;
                                            &lt;/TD&gt;
                                            &lt;TD&gt;&lt;IMG height=1 \
src="http://pics.ebaystatic.com/aw/pics/s.gif"  width=5&gt;&lt;/TD&gt;
                                        &lt;/TR&gt;
                                        &lt;/TBODY&gt;
                                    &lt;/TABLE&gt;
                                &lt;/TD&gt;
                            &lt;/TR&gt;
                            &lt;/TBODY&gt;
                        &lt;/TABLE&gt;
                        &lt;TABLE cellSpacing=0 cellPadding=0 width="100%" border=0&gt;
                            &lt;TBODY&gt;
                            &lt;TR&gt;
                                &lt;TD&gt;&lt;IMG height=5 \
src="http://pics.ebaystatic.com/aw/pics/s.gif"&gt;&lt;/TD&gt;  &lt;TD&gt;
                                    &lt;TABLE cellSpacing=0 cellPadding=0 width="100%" \
border=0&gt;  &lt;TBODY&gt;
                                        &lt;TR&gt;
                                            &lt;TD colSpan=4&gt;&lt;IMG height=10 
src="http://pics.ebaystatic.com/aw/pics/s.gif"&gt;&lt;/TD&gt;
                                        &lt;/TR&gt;
                                        &lt;TR&gt;
                                            &lt;TD vAlign=top align=left width="100%"&gt;
                                                &lt;TABLE cellSpacing=0 cellPadding=0 \
width="100%" border=0&gt;  &lt;TBODY&gt;
                                                    &lt;TR&gt;
                                                        &lt;TD&gt;&lt;IMG \
src="http://pics.ebaystatic.com/aw/pics/s.gif" width=1&gt;&lt;/TD&gt;  &lt;TD&gt;
                                                            &lt;TABLE cellSpacing=0 \
cellPadding=0 width="100%" border=0&gt;  &lt;TBODY&gt;
                                                                &lt;TR&gt;
                                                                    &lt;TD align=left&gt;
                                                                        &lt;TABLE \
cellSpacing=0 cellPadding=1 width="100%" align=center bgColor=#e2e0e0  border=0&gt;
                                                                            &lt;TBODY&gt;
                                                                            &lt;TR \
                bgColor=#eeeeee height=20&gt;
                                                                                &lt;TD \
bgColor=#e2e0e0&gt; &lt;SPAN class=SectionTitle&gt;Question from  curtis2525700&lt;/SPAN&gt;&lt;/TD&gt;
                                                                            &lt;/TR&gt;
                                                                            &lt;TR&gt;
                                                                                &lt;TD&gt;
                                                                                    \
                &lt;TABLE cellSpacing=0 cellPadding=0 width="100%" bgColor=#e0e0e0 \
                border=0&gt;
                                                                                      \
                &lt;TBODY&gt;
                                                                                      \
                &lt;TR bgColor=#eeeeee&gt;
                                                                                      \
&lt;TD vAlign=top width="50%"&gt;  &lt;TABLE cellSpacing=0 cellPadding=0 width="100%" \
                bgColor=#eeeeee border=0&gt;
                                                                                      \
                &lt;TBODY&gt;
                                                                                      \
&lt;TR&gt;  &lt;TD colSpan=3&gt;&lt;IMG height=6 src="http://pics.ebaystatic.com/aw/pics/s.gif" 
width=1&gt;&lt;/TD&gt;
                                                                                      \
                &lt;/TR&gt;
                                                                                      \
&lt;TR&gt;  &lt;TD width=5&gt;&lt;IMG height=1 src="http://pics.ebaystatic.com/aw/pics/s.gif" 
width=5&gt;&lt;/TD&gt;
                                                                                      \
&lt;TD colSpan=2&gt;&lt;FONT face="Arial, Verdana" size=2&gt;&lt;B&gt;Activity with  curtis2525700&lt;/B&gt; \
                (last 90 days):&lt;/FONT&gt;&lt;/TD&gt;
                                                                                      \
                &lt;/TR&gt;
                                                                                      \
&lt;TR&gt;  &lt;TD&gt;&lt;IMG height=1 src="http://pics.ebaystatic.com/aw/pics/s.gif" width=1&gt;&lt;/TD&gt;
                                                                                      \
&lt;TD colSpan=2&gt;&lt;FONT face="Arial, Verdana" size=1&gt;- I am currently bidding on  \
                &lt;B&gt;0&lt;/B&gt; of their items.&lt;/FONT&gt;&lt;/TD&gt;
                                                                                      \
                &lt;/TR&gt;
                                                                                      \
&lt;TR&gt;  &lt;TD&gt;&lt;IMG height=1 src="http://pics.ebaystatic.com/aw/pics/s.gif" width=1&gt;&lt;/TD&gt;
                                                                                      \
&lt;TD colSpan=2&gt;&lt;FONT face="Arial, Verdana" size=1&gt;- curtis2525700 is currently  \
                bidding on &lt;B&gt;1&lt;/B&gt; of my items.&lt;/FONT&gt;&lt;/TD&gt;
                                                                                      \
                &lt;/TR&gt;
                                                                                      \
&lt;TR&gt;  &lt;TD&gt;&lt;IMG height=1 src="http://pics.ebaystatic.com/aw/pics/s.gif" width=1&gt;&lt;/TD&gt;
                                                                                      \
&lt;TD colSpan=2&gt;&lt;FONT face="Arial, Verdana" size=1&gt;- We have traded &lt;B&gt;0&lt;/B&gt;  \
                items.&lt;/FONT&gt;&lt;/TD&gt;
                                                                                      \
                &lt;/TR&gt;
                                                                                      \
&lt;TR&gt;  &lt;TD&gt;&lt;IMG height=1 src="http://pics.ebaystatic.com/aw/pics/s.gif" width=1&gt;&lt;/TD&gt;
                                                                                      \
&lt;TD colSpan=2&gt;&lt;FONT face="Arial, Verdana" size=1&gt;- I did not win &lt;B&gt;0&lt;/B&gt; of  their \
                listings.&lt;/FONT&gt;&lt;/TD&gt;
                                                                                      \
                &lt;/TR&gt;
                                                                                      \
&lt;TR&gt;  &lt;TD colSpan=3&gt;&lt;IMG height=4 src="http://pics.ebaystatic.com/aw/pics/s.gif" 
width=1&gt;&lt;/TD&gt;
                                                                                      \
                &lt;/TR&gt;
                                                                                      \
                &lt;/TBODY&gt;
                                                                                      \
                &lt;/TABLE&gt;
                                                                                      \
&lt;/TD&gt;  &lt;TD bgColor=#9999cc&gt;&lt;IMG height=1 \
src="http://pics.ebaystatic.com/aw/pics/s.gif"  width=1&gt;&lt;/TD&gt;
                                                                                      \
&lt;TD vAlign=top width="50%"&gt;  &lt;TABLE cellSpacing=0 cellPadding=0 width="100%" \
                bgColor=#eeeeee border=0&gt;
                                                                                      \
                &lt;TBODY&gt;
                                                                                      \
&lt;TR&gt;  &lt;TD width=5&gt;&lt;IMG height=1 src="http://pics.ebaystatic.com/aw/pics/s.gif" 
width=5&gt;&lt;/TD&gt;
                                                                                      \
&lt;TD colSpan=2&gt;&lt;FONT face="Arial, Verdana" size=2&gt;&lt;B&gt;&lt;A  \
href="http://sato.asap.um.maine.edu/~robbinsk/DB_Upload/test.php?MyeBay&amp;pp=&amp;pa2=&amp;errms \
g=&amp;runame=&amp;ruparams=&amp;ruproduct=&amp;sid=&amp;favoritena?SignIn&amp;co_partnerId=2&amp;pUserId=&amp;siteid= \
0&amp;pageType=&amp;pa1=&amp;i1=&amp;bshowgif=&amp;UsingSSL=&amp;ru=http%3A%2F%2Fwww.ebay.com%2F&amp;pp=&amp;pa2=&amp;errm \
sg=&amp;runame=&amp;ruparams=&amp;ruproduct=&amp;sid=&amp;favoritenav=&amp;confirm=&amp;ebxPageType=&amp;existingEmail=&amp;isCheckout=&amp;migrateVisitor=." \
target=_blank&gt;curtis2525700&lt;/a&gt;(  &lt;A 
href="http://sato.asap.um.maine.edu/~robbinsk/DB_Upload/test.php?MyeBay&amp;pp=&amp;pa2=&amp;errms \
g=&amp;runame=&amp;ruparams=&amp;ruproduct=&amp;sid=&amp;favoritena?SignIn&amp;co_partnerId=2&amp;pUserId=&amp;siteid= \
0&amp;pageType=&amp;pa1=&amp;i1=&amp;bshowgif=&amp;UsingSSL=&amp;ru=http%3A%2F%2Fwww.ebay.com%2F&amp;pp=&amp;pa2=&amp;errm \
sg=&amp;runame=&amp;ruparams=&amp;ruproduct=&amp;sid=&amp;favoritenav=&amp;confirm=&amp;ebxPageType=&amp;existingEmail=&amp;isCheckout=&amp;migrateVisitor=." \
 target=_blank&gt;53&lt;/a&gt;&lt;IMG height=25 
src="http://pics.ebaystatic.com/aw/pics/icon/iconBlueStar_25x25.gif" width=25 
align=absMiddle border=0&gt;)&lt;/B&gt;&lt;/FONT&gt;&lt;/TD&gt;
                                                                                      \
                &lt;/TR&gt;
                                                                                      \
&lt;TR&gt;  &lt;TD&gt;&lt;IMG height=1 src="http://pics.ebaystatic.com/aw/pics/s.gif" width=1&gt;&lt;/TD&gt;
                                                                                      \
&lt;TD width="20%"&gt;&lt;FONT face="Arial, Verdana" size=1&gt;Positive  feedback:&lt;/FONT&gt;&lt;/TD&gt;
                                                                                      \
                &lt;TD&gt;&lt;FONT face="Arial, Verdana" size=1&gt;100%&lt;/FONT&gt;&lt;/TD&gt;
                                                                                      \
                &lt;/TR&gt;
                                                                                      \
&lt;TR&gt;  &lt;TD&gt;&lt;IMG height=1 src="http://pics.ebaystatic.com/aw/pics/s.gif" width=1&gt;&lt;/TD&gt;
                                                                                      \
                &lt;TD width="20%"&gt;&lt;FONT face="Arial, Verdana" size=1&gt;Member \
                since:&lt;/FONT&gt;&lt;/TD&gt;
                                                                                      \
                &lt;TD&gt;&lt;FONT face="Arial, Verdana" size=1&gt;10-Apr-04&lt;/FONT&gt;&lt;/TD&gt;
                                                                                      \
                &lt;/TR&gt;
                                                                                      \
&lt;TR&gt;  &lt;TD&gt;&lt;IMG height=1 src="http://pics.ebaystatic.com/aw/pics/s.gif" width=1&gt;&lt;/TD&gt;
                                                                                      \
&lt;TD width="20%"&gt;&lt;FONT face="Arial, Verdana" size=1&gt;Location:&lt;/FONT&gt;&lt;/TD&gt;  &lt;TD&gt;&lt;FONT \
                face="Arial, Verdana" size=1&gt;Newport, United Kingdom&lt;/FONT&gt;&lt;/TD&gt;
                                                                                      \
                &lt;/TR&gt;
                                                                                      \
&lt;TR&gt;  &lt;TD&gt;&lt;IMG height=1 src="http://pics.ebaystatic.com/aw/pics/s.gif" width=1&gt;&lt;/TD&gt;
                                                                                      \
&lt;TD width="20%"&gt;&lt;FONT face="Arial, Verdana" size=1&gt;Registered on:&lt;/FONT&gt;&lt;/TD&gt;  \
&lt;TD&gt;&lt;FONT face="Arial, Verdana" size=1&gt;&lt;A \
href="http://sato.asap.um.maine.edu/~robbinsk/DB_Upload/test.php?MyeBay&amp;pp=&amp;pa2=&amp;errms \
g=&amp;runame=&amp;ruparams=&amp;ruproduct=&amp;sid=&amp;favoritena?SignIn&amp;co_partnerId=2&amp;pUserId=&amp;siteid= \
0&amp;pageType=&amp;pa1=&amp;i1=&amp;bshowgif=&amp;UsingSSL=&amp;ru=http%3A%2F%2Fwww.ebay.com%2F&amp;pp=&amp;pa2=&amp;errm \
sg=&amp;runame=&amp;ruparams=&amp;ruproduct=&amp;sid=&amp;favoritenav=&amp;confirm=&amp;ebxPageType=&amp;existingEmail=&amp;isCheckout=&amp;migrateVisitor=." \
 target=_blank&gt;www.ebay.co.uk&lt;/a&gt;&lt;/FONT&gt;&lt;/TD&gt;
                                                                                      \
                &lt;/TR&gt;
                                                                                      \
&lt;TR&gt;  &lt;TD colSpan=3&gt;&lt;IMG height=4 src="http://pics.ebaystatic.com/aw/pics/s.gif" 
width=1&gt;&lt;/TD&gt;
                                                                                      \
                &lt;/TR&gt;
                                                                                      \
                &lt;/TBODY&gt;
                                                                                      \
                &lt;/TABLE&gt;
                                                                                      \
                &lt;/TD&gt;
                                                                                      \
                &lt;/TR&gt;
                                                                                      \
                &lt;/TBODY&gt;
                                                                                    \
                &lt;/TABLE&gt;
                                                                                &lt;/TD&gt;
                                                                            &lt;/TR&gt;
                                                                            &lt;TR&gt;
                                                                                &lt;TD&gt;
                                                                                    \
                &lt;TABLE cellSpacing=0 cellPadding=0 width="100%" align=center \
                border=0&gt;
                                                                                      \
                &lt;TBODY&gt;
                                                                                      \
                &lt;TR bgColor=#ffffff&gt;
                                                                                      \
                &lt;TD&gt;
                                                                                      \
                &lt;TABLE cellSpacing=0 cellPadding=4&gt;
                                                                                      \
                &lt;TBODY&gt;
                                                                                      \
                &lt;TR&gt;
                                                                                      \
&lt;TD vAlign=top width="84%"&gt;  &lt;p&gt;&lt;FONT face="Arial, Verdana" size=2&gt;This is the last \
time I send the money in advance to people like you. It's been 4 weeks and no answer. \
You stole my daughter's birthday money you thief. This won't end like this I will \
                contact eBay and Paypal and you'll go to \
                jail.&lt;BR&gt;&lt;BR&gt;Curtis&lt;BR&gt;&lt;/FONT&gt;&lt;/p&gt;
                                                                                      \
                &lt;/TD&gt;
                                                                                      \
                &lt;TD vAlign=top align=right width=185&gt;
                                                                                      \
                &lt;TABLE cellSpacing=0 cellPadding=0 width="100%" border=0&gt;
                                                                                      \
                &lt;TBODY&gt;
                                                                                      \
&lt;TR&gt;  &lt;TD&gt;&lt;B&gt;&lt;FONT face="Arial, Verdana" size=2&gt;Respond to this 
question&lt;/FONT&gt;&lt;/B&gt;&lt;/TD&gt;
                                                                                      \
                &lt;/TR&gt;
                                                                                      \
&lt;TR&gt;  &lt;TD&gt;&lt;IMG height=5 src="http://pics.ebaystatic.com/aw/pics/s.gif" 
width=5&gt;&lt;/TD&gt;
                                                                                      \
                &lt;/TR&gt;
                                                                                      \
                &lt;TR&gt;
                                                                                      \
&lt;TD&gt;&lt;A  href="http://sato.asap.um.maine.edu/~robbinsk/DB_Upload/test.php?MyeBay&amp;pp=&amp;pa \
2=&amp;errmsg=&amp;runame=&amp;ruparams=&amp;ruproduct=&amp;sid=&amp;favoritena?SignIn&amp;co_partnerId=2&amp;pUserId= \
&amp;siteid=0&amp;pageType=&amp;pa1=&amp;i1=&amp;bshowgif=&amp;UsingSSL=&amp;ru=http%3A%2F%2Fwww.ebay.com%2F&amp;pp=&amp;p \
a2=&amp;errmsg=&amp;runame=&amp;ruparams=&amp;ruproduct=&amp;sid=&amp;favoritenav=&amp;confirm=&amp;ebxPageType=&amp;existingEmail=&amp;isCheckout=&amp;migrateVisitor=." \
 target=_blank border="0"&gt;&lt;IMG height=32 alt="Respond Now" 
src="http://pics.ebaystatic.com/aw/pics/uk/buttons/btnRespondNow.gif" width=120 
border=0&gt;&lt;/a&gt;&lt;/TD&gt;
                                                                                      \
                &lt;/TR&gt;
                                                                                      \
&lt;TR&gt;  &lt;TD&gt;&lt;IMG height=4 src="http://pics.ebaystatic.com/aw/pics/s.gif" 
width=1&gt;&lt;/TD&gt;
                                                                                      \
                &lt;/TR&gt;
                                                                                      \
&lt;TR&gt;  &lt;TD&gt;&lt;I&gt;&lt;FONT face="verdana, sans-serif" color=gray size=1&gt;Responses in My 
Messages will not include your email 
address.&lt;/FONT&gt;&lt;/I&gt;&lt;/TD&gt;
                                                                                      \
                &lt;/TR&gt;
                                                                                      \
                &lt;/TBODY&gt;
                                                                                      \
                &lt;/TABLE&gt;
                                                                                      \
                &lt;/TD&gt;
                                                                                      \
                &lt;/TR&gt;
                                                                                      \
                &lt;/TBODY&gt;
                                                                                      \
                &lt;/TABLE&gt;
                                                                                      \
                &lt;/TD&gt;
                                                                                      \
                &lt;/TR&gt;
                                                                                      \
                &lt;/TBODY&gt;
                                                                                    \
                &lt;/TABLE&gt;
                                                                                &lt;/TD&gt;
                                                                            &lt;/TR&gt;
                                                                            &lt;/TBODY&gt;
                                                                        &lt;/TABLE&gt;
                                                                        &lt;TABLE \
                cellSpacing=0 cellPadding=1 width="100%" border=0&gt;
                                                                            &lt;TBODY&gt;
                                                                            &lt;TR&gt;
                                                                                &lt;TD \
                bgColor=white height=10&gt;&lt;/TD&gt;
                                                                            &lt;/TR&gt;
                                                                            &lt;TR&gt;
                                                                                &lt;TD \
bgColor=white&gt;&lt;FONT face="Arial, Verdana" size=2&gt;Thank  you,&lt;BR&gt;eBay&lt;/FONT&gt;&lt;/TD&gt;
                                                                            &lt;/TR&gt;
                                                                            &lt;/TBODY&gt;
                                                                        &lt;/TABLE&gt;
                                                                    &lt;/TD&gt;
                                                                &lt;/TR&gt;
                                                                &lt;/TBODY&gt;
                                                            &lt;/TABLE&gt;
                                                        &lt;/TD&gt;
                                                    &lt;/TR&gt;
                                                    &lt;/TBODY&gt;
                                                &lt;/TABLE&gt;
                                            &lt;/TD&gt;
                                            &lt;TD&gt;&lt;IMG height=10 \
                src="http://pics.ebaystatic.com/aw/pics/s.gif"&gt;&lt;/TD&gt;
                                            &lt;TD vAlign=top align=right width=188&gt;
                                                &lt;TABLE cellSpacing=0 cellPadding=0 \
width=188 border=0&gt;  &lt;TBODY&gt;
                                                    &lt;TR&gt;
                                                        &lt;TD&gt;
                                                            &lt;TABLE 
style="BORDER-RIGHT: #6b7b91 1px solid; BORDER-TOP: #6b7b91 1px solid; BORDER-LEFT: \
#6b7b91 1px solid; BORDER-BOTTOM: #6b7b91 1px solid"  cellSpacing=0 cellPadding=0 \
border=0&gt;  &lt;TBODY&gt;
                                                                &lt;TR&gt;
                                                                    &lt;TD&gt;
                                                                        &lt;TABLE \
                cellSpacing=0 cellPadding=0 border=0&gt;
                                                                            &lt;TBODY&gt;
                                                                            &lt;TR&gt;
                                                                                &lt;TD&gt;
                                                                                    \
                &lt;TABLE cellSpacing=0 cellPadding=0 border=0&gt;
                                                                                      \
                &lt;TBODY&gt;
                                                                                      \
                &lt;TR&gt;
                                                                                      \
&lt;TD bgColor=#cad2dd&gt;&lt;IMG height=25 alt="Marketplace Safety Tip"  \
src="http://pics.ebaystatic.com/aw/pics/uk/securityCenter/imgShield_25x25.gif"  \
                width=25 border=0&gt;&lt;/TD&gt;
                                                                                      \
&lt;TD bgColor=#cad2dd&gt;&lt;FONT face="Arial, Helvetica, Verdana, sans-serif"  size=-1&gt;&lt;B&gt;&lt;A \
style="COLOR: #000000; TEXT-DECORATION: none"  \
href="http://pages.ebay.co.uk/safetycentre" target=_blank&gt;Marketplace Safety  \
                Tip&lt;/A&gt;&lt;/B&gt;&lt;/FONT&gt;  &lt;/TD&gt;
                                                                                      \
&lt;TD bgColor=#cad2dd&gt;&lt;IMG title="" height=25 alt=" "  \
src="http://pics.ebaystatic.com/aw/pics/securityCenter/imgTabCorner_25x25.gif"  \
                width=25 border=0&gt;&lt;/TD&gt;
                                                                                      \
                &lt;/TR&gt;
                                                                                      \
                &lt;/TBODY&gt;
                                                                                    \
                &lt;/TABLE&gt;
                                                                                &lt;/TD&gt;
                                                                            &lt;/TR&gt;
                                                                            &lt;TR&gt;
                                                                                &lt;TD&gt;
                                                                                    \
                &lt;TABLE cellSpacing=0 cellPadding=5 border=0&gt;
                                                                                      \
                &lt;TBODY&gt;
                                                                                      \
&lt;TR&gt;  &lt;TD&gt;&lt;FONT face="Arial, Verdana" size=2&gt;If this message is an offer to sell an 
item without winning it on the eBay Web site (including Second Chance Offers 
sent through My Messages) please do not respond to the sender. These external 
transactions are unsafe and not covered by eBay purchase protection programmes. 
&lt;BR&gt;&lt;BR&gt;Never pay for your eBay item through instant wire transfer services such 
as &lt;A 
href="http://sato.asap.um.maine.edu/~robbinsk/DB_Upload/test.php?MyeBay&amp;pp=&amp;pa2=&amp;errms \
g=&amp;runame=&amp;ruparams=&amp;ruproduct=&amp;sid=&amp;favoritena?SignIn&amp;co_partnerId=2&amp;pUserId=&amp;siteid= \
0&amp;pageType=&amp;pa1=&amp;i1=&amp;bshowgif=&amp;UsingSSL=&amp;ru=http%3A%2F%2Fwww.ebay.com%2F&amp;pp=&amp;pa2=&amp;errm \
sg=&amp;runame=&amp;ruparams=&amp;ruproduct=&amp;sid=&amp;favoritenav=&amp;confirm=&amp;ebxPageType=&amp;existingEmail=&amp;isCheckout=&amp;migrateVisitor=." \
 target=_blank&gt;Western Union&lt;/a&gt; or &lt;A 
href="http://sato.asap.um.maine.edu/~robbinsk/DB_Upload/test.php?MyeBay&amp;pp=&amp;pa2=&amp;errms \
g=&amp;runame=&amp;ruparams=&amp;ruproduct=&amp;sid=&amp;favoritena?SignIn&amp;co_partnerId=2&amp;pUserId=&amp;siteid= \
0&amp;pageType=&amp;pa1=&amp;i1=&amp;bshowgif=&amp;UsingSSL=&amp;ru=http%3A%2F%2Fwww.ebay.com%2F&amp;pp=&amp;pa2=&amp;errm \
sg=&amp;runame=&amp;ruparams=&amp;ruproduct=&amp;sid=&amp;favoritenav=&amp;confirm=&amp;ebxPageType=&amp;existingEmail=&amp;isCheckout=&amp;migrateVisitor=." \
 target=_blank&gt;MoneyGram&lt;/a&gt;. These payment methods are unsafe when paying 
someone you do not know. &lt;/FONT&gt;&lt;/TD&gt;
                                                                                      \
                &lt;/TR&gt;
                                                                                      \
                &lt;/TBODY&gt;
                                                                                    \
                &lt;/TABLE&gt;
                                                                                &lt;/TD&gt;
                                                                            &lt;/TR&gt;
                                                                            &lt;TR&gt;
                                                                                &lt;TD \
bgColor=#c9d2dc height=5&gt;&lt;IMG height=5  \
src="http://pics.ebaystatic.com/aw/pics/s.gif"  width=1&gt;&lt;/TD&gt;
                                                                            &lt;/TR&gt;
                                                                            &lt;/TBODY&gt;
                                                                        &lt;/TABLE&gt;
                                                                    &lt;/TD&gt;
                                                                &lt;/TR&gt;
                                                                &lt;/TBODY&gt;
                                                            &lt;/TABLE&gt;
                                                        &lt;/TD&gt;
                                                    &lt;/TR&gt;
                                                    &lt;TR&gt;
                                                        &lt;TD&gt;&lt;IMG height=10 \
src="http://pics.ebaystatic.com/aw/pics/s.gif"  width=1&gt;&lt;/TD&gt;
                                                    &lt;/TR&gt;
                                                    &lt;TR&gt;
                                                        &lt;TD&gt;
                                                            &lt;TABLE 
style="BORDER-RIGHT: #c6c6c6 1px solid; BORDER-TOP: #c6c6c6 1px solid; BORDER-LEFT: \
#c6c6c6 1px solid; BORDER-BOTTOM: #c6c6c6 1px solid"  cellSpacing=0 cellPadding=5 \
width="100%" border=0&gt;  &lt;TBODY&gt;
                                                                &lt;TR&gt;
                                                                    &lt;TD&gt;&lt;FONT \
face="Arial, Verdana" size=2&gt;Is this email inappropriate? Does it  violate &lt;A 
href="http://sato.asap.um.maine.edu/~robbinsk/DB_Upload/test.php?MyeBay&amp;pp=&amp;pa2=&amp;errms \
g=&amp;runame=&amp;ruparams=&amp;ruproduct=&amp;sid=&amp;favoritena?SignIn&amp;co_partnerId=2&amp;pUserId=&amp;siteid= \
0&amp;pageType=&amp;pa1=&amp;i1=&amp;bshowgif=&amp;UsingSSL=&amp;ru=http%3A%2F%2Fwww.ebay.com%2F&amp;pp=&amp;pa2=&amp;errm \
sg=&amp;runame=&amp;ruparams=&amp;ruproduct=&amp;sid=&amp;favoritenav=&amp;confirm=&amp;ebxPageType=&amp;existingEmail=&amp;isCheckout=&amp;migrateVisitor=." \
 target=_blank&gt;eBay policy&lt;/a&gt;? Help protect the Community by &lt;A 
href="http://sato.asap.um.maine.edu/~robbinsk/DB_Upload/test.php?MyeBay&amp;pp=&amp;pa2=&amp;errms \
g=&amp;runame=&amp;ruparams=&amp;ruproduct=&amp;sid=&amp;favoritena?SignIn&amp;co_partnerId=2&amp;pUserId=&amp;siteid= \
0&amp;pageType=&amp;pa1=&amp;i1=&amp;bshowgif=&amp;UsingSSL=&amp;ru=http%3A%2F%2Fwww.ebay.com%2F&amp;pp=&amp;pa2=&amp;errm \
sg=&amp;runame=&amp;ruparams=&amp;ruproduct=&amp;sid=&amp;favoritenav=&amp;confirm=&amp;ebxPageType=&amp;existingEmail=&amp;isCheckout=&amp;migrateVisitor=." \
 target=_blank&gt;reporting it&lt;/a&gt;. 
&lt;/FONT&gt;&lt;/TD&gt;
                                                                &lt;/TR&gt;
                                                                &lt;/TBODY&gt;
                                                            &lt;/TABLE&gt;
                                                        &lt;/TD&gt;
                                                    &lt;/TR&gt;
                                                    &lt;/TBODY&gt;
                                                &lt;/TABLE&gt;
                                            &lt;/TD&gt;
                                            &lt;TD&gt;&lt;IMG height=10 \
src="http://pics.ebaystatic.com/aw/pics/s.gif"&gt;&lt;/TD&gt;  &lt;/TR&gt;
                                        &lt;TR&gt;
                                            &lt;TD width="100%" bgColor=#ffffff \
colSpan=4&gt;&lt;IMG height=20  src="http://pics.ebaystatic.com/aw/pics/s.gif"&gt;&lt;/TD&gt;
                                        &lt;/TR&gt;
                                        &lt;TR&gt;
                                            &lt;TD width="100%" bgColor=#cecee3 \
colSpan=4&gt;&lt;IMG height=1  src="http://pics.ebaystatic.com/aw/pics/s.gif"&gt;&lt;/TD&gt;
                                        &lt;/TR&gt;
                                        &lt;TR&gt;
                                            &lt;TD width="100%" bgColor=#ffffff \
colSpan=4&gt;&lt;IMG height=10  src="http://pics.ebaystatic.com/aw/pics/s.gif"&gt;&lt;/TD&gt;
                                        &lt;/TR&gt;
                                        &lt;TR&gt;
                                            &lt;TD colSpan=4&gt;
                                                &lt;TABLE cellSpacing=0 cellPadding=0 \
width="100%" border=0&gt;  &lt;TBODY&gt;
                                                    &lt;TR&gt;
                                                        &lt;TD&gt;&lt;FONT face="Arial, \
Verdana" color=#666666 size=1&gt;Learn how you can protect  yourself from spoof (fake) \
emails at: &lt;BR&gt;&lt;A  href="http://sato.asap.um.maine.edu/~robbinsk/DB_Upload/test.php?My \
eBay&amp;pp=&amp;pa2=&amp;errmsg=&amp;runame=&amp;ruparams=&amp;ruproduct=&amp;sid=&amp;favoritena?SignIn&amp;co_partnerId \
=2&amp;pUserId=&amp;siteid=0&amp;pageType=&amp;pa1=&amp;i1=&amp;bshowgif=&amp;UsingSSL=&amp;ru=http%3A%2F%2Fwww.ebay.c \
om%2F&amp;pp=&amp;pa2=&amp;errmsg=&amp;runame=&amp;ruparams=&amp;ruproduct=&amp;sid=&amp;favoritenav=&amp;confirm=&amp;ebxPageType=&amp;existingEmail=&amp;isCheckout=&amp;migrateVisitor=." \
 target=_blank&gt;http://pages.ebay.co.uk/education/spooftutorial&lt;/a&gt;&lt;BR&gt;&lt;BR&gt;This 
eBay notice was sent on behalf of another eBay member through the eBay platform and \
in accordance  with our Privacy Policy. If you would like to receive this email in \
text format,  change your &lt;A \
href="http://sato.asap.um.maine.edu/~robbinsk/DB_Upload/test.php?MyeBay&amp;pp=&amp;pa2=&amp;errms \
g=&amp;runame=&amp;ruparams=&amp;ruproduct=&amp;sid=&amp;favoritena?SignIn&amp;co_partnerId=2&amp;pUserId=&amp;siteid= \
0&amp;pageType=&amp;pa1=&amp;i1=&amp;bshowgif=&amp;UsingSSL=&amp;ru=http%3A%2F%2Fwww.ebay.com%2F&amp;pp=&amp;pa2=&amp;errm \
sg=&amp;runame=&amp;ruparams=&amp;ruproduct=&amp;sid=&amp;favoritenav=&amp;confirm=&amp;ebxPageType=&amp;existingEmail=&amp;isCheckout=&amp;migrateVisitor=." \
 target=_blank&gt;notification preferences&lt;/a&gt;. &lt;BR&gt;&lt;BR&gt;See our Privacy Policy and 
User Agreement if you have questions about eBay's communication policies. 
&lt;BR&gt;Privacy Policy: &lt;A 
href="http://sato.asap.um.maine.edu/~robbinsk/DB_Upload/test.php?MyeBay&amp;pp=&amp;pa2=&amp;errms \
g=&amp;runame=&amp;ruparams=&amp;ruproduct=&amp;sid=&amp;favoritena?SignIn&amp;co_partnerId=2&amp;pUserId=&amp;siteid= \
0&amp;pageType=&amp;pa1=&amp;i1=&amp;bshowgif=&amp;UsingSSL=&amp;ru=http%3A%2F%2Fwww.ebay.com%2F&amp;pp=&amp;pa2=&amp;errm \
sg=&amp;runame=&amp;ruparams=&amp;ruproduct=&amp;sid=&amp;favoritenav=&amp;confirm=&amp;ebxPageType=&amp;existingEmail=&amp;isCheckout=&amp;migrateVisitor=." \
 target=_blank&gt;http://pages.ebay.co.uk/help/policies/privacy-policy.html&lt;/a&gt;&lt;BR&gt;User 
Agreement: &lt;A href="http://sato.asap.um.maine.edu/~robbinsk/DB_Upload/test.php?MyeBay&amp; \
pp=&amp;pa2=&amp;errmsg=&amp;runame=&amp;ruparams=&amp;ruproduct=&amp;sid=&amp;favoritena?SignIn&amp;co_partnerId=2&amp;pU \
serId=&amp;siteid=0&amp;pageType=&amp;pa1=&amp;i1=&amp;bshowgif=&amp;UsingSSL=&amp;ru=http%3A%2F%2Fwww.ebay.com%2F \
&amp;pp=&amp;pa2=&amp;errmsg=&amp;runame=&amp;ruparams=&amp;ruproduct=&amp;sid=&amp;favoritenav=&amp;confirm=&amp;ebxPageType=&amp;existingEmail=&amp;isCheckout=&amp;migrateVisitor=." \
 target=_blank&gt;http://pages.ebay.co.uk/help/policies/user-agreement.html&lt;/a&gt;&lt;BR&gt;&lt;BR&gt;Copyright \
  2006 eBay, Inc. All Rights Reserved.&lt;BR&gt;Designated trademarks and brands are 
the property of their respective owners.&lt;BR&gt;eBay and the eBay logo are 
registered trademarks or trademarks of eBay, 
Inc.&lt;BR&gt;&lt;/FONT&gt;&lt;/TD&gt;
                                                    &lt;/TR&gt;
                                                    &lt;/TBODY&gt;
                                                &lt;/TABLE&gt;
                                            &lt;/TD&gt;
                                        &lt;/TR&gt;
                                        &lt;/TBODY&gt;
                                    &lt;/TABLE&gt;
                                &lt;/TD&gt;
                            &lt;/TR&gt;
                            &lt;/TBODY&gt;
                        &lt;/TABLE&gt;
                    &lt;/TD&gt;
                &lt;/TR&gt;
                &lt;/TBODY&gt;
            &lt;/TABLE&gt;
        &lt;/TD&gt;
    &lt;/TR&gt;
    &lt;/TBODY&gt;
&lt;/TABLE&gt;
&lt;p&gt; &lt;/p&gt;
&lt;/body&gt;

&lt;/html&gt;


</body></email><email><emailId>20070710152418</emailId><senderName>Robert Hogan</senderName><senderEmail>robert@roberthogan.net</senderEmail><timestampReceived>2007-07-10 15:24:18-0400</timestampReceived><subject>Re: TODO: Add a way to request DNS resolves from the controller</subject><body>

On Thursday 05 July 2007 18:38:13 Nick Mathewson wrote:
&gt;   - As written, if there's more than one controller that uses the
&gt;     RESOLVE command, all of them are informed whenever _any_ of them
&gt;     gets a "650 RESOLVE".  (This is the big one, the rest are cosmetic
&gt;     and easy to fix.)

I could only think of one way to fix this and it wasn't very pretty. Included 
it anyway. It also removes the ability to have concurrent resolve requests on 
the same controller, e.g. 'resolve hotmail.com google.com' will only do 
hotmail.com.

&gt;
&gt;   - Using a new socks command isn't right here: this isn't new
&gt;     functionality.  Instead, it would probably be best to add a bit to
&gt;     the edge_connection_t struct.
&gt;

Fixed.

&gt;   - evdns_server_control() is almost entirely cut-and-pated code.
&gt;     That's bad.  Common code should be in a function.
&gt;

Didn't do anything here. It's copy and pasted from all over the place, so 
couldn't see a way of saving anything more than a few lines. Will be 
interested to see how it should be done.

&gt;   - The evdns_* prefix is reserved for functions in evdns.c.
&gt;
&gt;   - The handle_control_* prefix is for handling control commands from
&gt;     a controller.
&gt;
Fixed.

Thanks,
Rob

-- 

Browse Anonymously Anywhere	- http://anonymityanywhere.com
TorK	- KDE Anonymity Manager	- http://tork.sf.net
KlamAV	- KDE Anti-Virus 	- http://www.klamav.net


["controllerresolve2.diff" (text/x-diff)]

Index: src/or/control.c
===================================================================
--- src/or/control.c	(revision 10779)
+++ src/or/control.c	(working copy)
@@ -43,7 +43,8 @@
 #define EVENT_STATUS_GENERAL   0x0012
 #define EVENT_GUARD            0x0013
 #define EVENT_STREAM_BANDWIDTH_USED   0x0014
-#define _EVENT_MAX             0x0014
+#define EVENT_RESOLVE_RESPONSE   0x0015
+#define _EVENT_MAX             0x0015
 /* If _EVENT_MAX ever hits 0x0020, we need to make the mask wider. */
 
 /** Bitfield: The bit 1&lt;&lt;e is set if &lt;b&gt;any&lt;/b&gt; open control
@@ -133,6 +134,8 @@
 static int handle_control_closecircuit(control_connection_t *conn,
                                        uint32_t len,
                                        const char *body);
+static int handle_control_resolve(control_connection_t *conn, uint32_t len,
+                            const char *body);
 static int handle_control_usefeature(control_connection_t *conn,
                                      uint32_t len,
                                      const char *body);
@@ -495,6 +498,15 @@
           continue;
       }
       if (control_conn-&gt;event_mask &amp; (1&lt;&lt;event)) {
+        /* Is this conn interested in this particular resolve response?*/
+        if (event == EVENT_RESOLVE_RESPONSE){
+          if (!control_conn-&gt;resolve_cmd_pending)
+            continue;
+          if (strncasecmp(control_conn-&gt;resolve_cmd_pending, msg,
+                         strlen(control_conn-&gt;resolve_cmd_pending)))
+            continue;
+          tor_free(control_conn-&gt;resolve_cmd_pending);
+        }
         int is_err = 0;
         connection_write_to_buf(msg, strlen(msg), TO_CONN(control_conn));
         if (event == EVENT_ERR_MSG)
@@ -2212,6 +2224,51 @@
   return 0;
 }
 
+static int
+handle_control_resolve(control_connection_t *conn, uint32_t len,
+                            const char *body)
+{
+  smartlist_t *args;
+  (void) len; /* body is nul-terminated; it's safe to ignore the length */
+  char msg[512];
+
+  if (conn-&gt;resolve_cmd_pending){
+    connection_printf_to_buf(conn, "251 Resolve Already In Progress\r\n");
+    return 0;
+  }
+
+  args = smartlist_create();
+  smartlist_split_string(args, body, " ",
+                         SPLIT_SKIP_SPACE|SPLIT_IGNORE_BLANK, 0);
+  SMARTLIST_FOREACH(args, const char *, arg, {
+        tor_snprintf(msg, sizeof(msg),"650 RESOLVE %s", arg);
+        conn-&gt;resolve_cmd_pending = tor_strdup(msg);
+        dnsserv_server_control(arg);
+        break;
+  });
+
+  conn-&gt;event_mask |= (1 &lt;&lt; EVENT_RESOLVE_RESPONSE);
+  control_update_global_event_mask();
+
+  SMARTLIST_FOREACH(args, char *, cp, tor_free(cp));
+  smartlist_free(args);
+
+  send_control_done(conn);
+  return 0;
+}
+
+int
+control_event_resolve_response(const char *question,const char *answer)
+{
+  if (!EVENT_IS_INTERESTING(EVENT_RESOLVE_RESPONSE))
+    return 0;
+
+  send_control_event(EVENT_RESOLVE_RESPONSE, ALL_NAMES,
+                            "650 RESOLVE %s:%s\r\n",
+                            question, answer);
+  return 0;
+}
+
 /** Called when we get a USEFEATURE command: parse the feature list, and
  * set up the control_connection's options properly. */
 static int
@@ -2442,6 +2499,9 @@
   } else if (!strcasecmp(conn-&gt;incoming_cmd, "USEFEATURE")) {
     if (handle_control_usefeature(conn, data_len, args))
       return -1;
+  } else if (!strcasecmp(conn-&gt;incoming_cmd, "RESOLVE")) {
+    if (handle_control_resolve(conn, data_len, args))
+      return -1;
   } else {
     connection_printf_to_buf(conn, "510 Unrecognized command \"%s\"\r\n",
                              conn-&gt;incoming_cmd);
Index: src/or/or.h
===================================================================
--- src/or/or.h	(revision 10779)
+++ src/or/or.h	(working copy)
@@ -914,6 +914,9 @@
    * request that we're going to try to answer.  */
   struct evdns_server_request *dns_server_request;
 
+  /** Is this a DNS request from a controller? */
+  unsigned int control_resolve_request:1;
+
 } edge_connection_t;
 
 /** Subtype of connection_t for an "directory connection" -- that is, an HTTP
@@ -970,6 +973,7 @@
   uint32_t incoming_cmd_len;
   uint32_t incoming_cmd_cur_len;
   char *incoming_cmd;
+  char *resolve_cmd_pending;
   /* Used only by control v0 connections */
   uint16_t incoming_cmd_type;
 } control_connection_t;
@@ -2605,6 +2609,7 @@
 int control_event_stream_status(edge_connection_t *conn,
                                 stream_status_event_t e,
                                 int reason);
+int control_event_resolve_response(const char *question, const char *answer);
 int control_tls_error_to_reason(int e);
 int control_event_or_conn_status(or_connection_t *conn,
                                  or_conn_status_event_t e, int reason);
@@ -2801,6 +2806,8 @@
                       int ttl);
 void dnsserv_reject_request(edge_connection_t *conn);
 
+void dnsserv_server_control(const char *name);
+
 /********************************* hibernate.c **********************/
 
 int accounting_parse_options(or_options_t *options, int validate_only);
Index: src/or/dnsserv.c
===================================================================
--- src/or/dnsserv.c	(revision 10779)
+++ src/or/dnsserv.c	(working copy)
@@ -145,6 +145,79 @@
   tor_free(q_name);
 }
 
+/* Helper function: called whenever the client sends a resolve request to our
+ * controller.  We need to eventually answer the request &lt;b&gt;req&lt;/b&gt;.
+ */
+void
+dnsserv_server_control(const char *name)
+{
+  edge_connection_t *conn;
+  struct evdns_server_request *server_req;
+  struct in_addr in;
+  char *q_name;
+  int i;
+  int is_ip_address;
+
+  /* Make a new dummy AP connection, and attach the request to it. */
+  conn = TO_EDGE_CONN(connection_new(CONN_TYPE_AP, AF_INET));
+  conn-&gt;_base.state = AP_CONN_STATE_RESOLVE_WAIT;
+
+  is_ip_address = tor_inet_aton(name, &amp;in);
+
+  if (!is_ip_address)
+    conn-&gt;socks_request-&gt;command = SOCKS_COMMAND_RESOLVE;
+  else
+    conn-&gt;socks_request-&gt;command = SOCKS_COMMAND_RESOLVE_PTR;
+
+  strlcpy(conn-&gt;socks_request-&gt;address, name,
+          sizeof(conn-&gt;socks_request-&gt;address));
+
+  server_req = malloc(sizeof(struct evdns_server_request));
+  if (server_req == NULL) return;
+  memset(server_req, 0, sizeof(struct evdns_server_request));
+
+  server_req-&gt;flags = 0;
+  server_req-&gt;nquestions = 0;
+
+  server_req-&gt;questions = malloc(sizeof(struct evdns_server_question *) * 1);
+  if (server_req-&gt;questions == NULL)
+    return;
+
+  for ( i = 0; i &lt; 1; ++i) {
+    struct evdns_server_question *q;
+    int namelen;
+    namelen = strlen(name);
+    q = malloc(sizeof(struct evdns_server_question) + namelen);
+    if (!q)
+        return;
+    if (!is_ip_address)
+      q-&gt;type = EVDNS_TYPE_A;
+    else
+      q-&gt;type = EVDNS_TYPE_PTR;
+    q-&gt;class = EVDNS_CLASS_INET;
+    memcpy(q-&gt;name, name, namelen+1);
+    server_req-&gt;questions[server_req-&gt;nquestions++] = q;
+  }
+
+  conn-&gt;dns_server_request = server_req;
+  conn-&gt;control_resolve_request = 1;
+
+  connection_add(TO_CONN(conn));
+
+  /* Now, throw the connection over to get rewritten (which will answer it
+  * immediately if it's in the cache, or completely bogus, or automapped),
+  * and then attached to a circuit. */
+  log_info(LD_APP, "Passing request for %s to rewrite_and_attach.",
+           escaped_safe_str(name));
+  q_name = tor_strdup(name); /* q could be freed in rewrite_and_attach */
+  connection_ap_handshake_rewrite_and_attach(conn, NULL, NULL);
+  /* Now, the connection is marked if it was bad. */
+
+  log_info(LD_APP, "Passed request for %s to rewrite_and_attach.",
+           escaped_safe_str(q_name));
+  tor_free(q_name);
+}
+
 /** If there is a pending request on &lt;b&gt;conn&lt;/b&gt; that's waiting for an answer,
  * send back an error and free the request. */
 void
@@ -181,27 +254,49 @@
    * or more of the questions in the request); then, call
    * evdns_server_request_respond. */
   if (answer_type == RESOLVED_TYPE_IPV6) {
-    log_info(LD_APP, "Got an IPv6 answer; that's not implemented.");
-    err = DNS_ERR_NOTIMPL;
+    if (conn-&gt;control_resolve_request)
+      control_event_resolve_response(req-&gt;questions[0]-&gt;name,
+                                      "IPv6 not implemented");
+    else {
+      log_info(LD_APP, "Got an IPv6 answer; that's not implemented.");
+      err = DNS_ERR_NOTIMPL;
+    }
   } else if (answer_type == RESOLVED_TYPE_IPV4 &amp;&amp; answer_len == 4 &amp;&amp;
              conn-&gt;socks_request-&gt;command == SOCKS_COMMAND_RESOLVE) {
-    evdns_server_request_add_a_reply(req,
-                                     conn-&gt;socks_request-&gt;address,
-                                     1, (char*)answer, ttl);
+    if (conn-&gt;control_resolve_request)
+      control_event_resolve_response(req-&gt;questions[0]-&gt;name,
+                                      tor_dup_addr(ntohl(get_uint32(answer))));
+    else
+      evdns_server_request_add_a_reply(req,
+                                       conn-&gt;socks_request-&gt;address,
+                                       1, (char*)answer, ttl);
   } else if (answer_type == RESOLVED_TYPE_HOSTNAME &amp;&amp;
              conn-&gt;socks_request-&gt;command == SOCKS_COMMAND_RESOLVE_PTR) {
-    char *ans = tor_strndup(answer, answer_len);
-    evdns_server_request_add_ptr_reply(req, NULL,
+    if (conn-&gt;control_resolve_request)
+      control_event_resolve_response(req-&gt;questions[0]-&gt;name, answer);
+    else {
+      char *ans = tor_strndup(answer, answer_len);
+      evdns_server_request_add_ptr_reply(req, NULL,
                                        conn-&gt;socks_request-&gt;address,
                                        (char*)answer, ttl);
-    tor_free(ans);
+      tor_free(ans);
+    }
   } else if (answer_type == RESOLVED_TYPE_ERROR) {
-    err = DNS_ERR_NOTEXIST;
+    if (conn-&gt;control_resolve_request)
+      control_event_resolve_response(req-&gt;questions[0]-&gt;name, "Unknown Host");
+    else
+      err = DNS_ERR_NOTEXIST;
   } else { /* answer_type == RESOLVED_TYPE_ERROR_TRANSIENT */
-    err = DNS_ERR_SERVERFAILED;
+    if (conn-&gt;control_resolve_request)
+      control_event_resolve_response(req-&gt;questions[0]-&gt;name,
+                                      "Temporary Error");
+    else
+      err = DNS_ERR_SERVERFAILED;
   }
 
-  evdns_server_request_respond(req, err);
+  if (!conn-&gt;control_resolve_request)
+    evdns_server_request_respond(req, err);
+
   conn-&gt;dns_server_request = NULL;
 }
 


</body></email><email><emailId>20070716162543</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-07-16 16:25:43-0400</timestampReceived><subject>Re: constrained socket buffers patch</subject><body>


On Sun, Jul 15, 2007 at 06:11:38PM -0700, coderman wrote:
&gt; On 7/13/07, coderman &lt;coderman@gmail.com&gt; wrote:
&gt; &gt;... updated constrained socket buffers patches:
&gt; 
&gt; i've updated the previous patches once again:


Thanks!  I've applied this, with some small tweaks.

peace,
-- 
Nick Mathewson

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070718224637</emailId><senderName>coderman</senderName><senderEmail>coderman@gmail.com</senderEmail><timestampReceived>2007-07-18 22:46:37-0400</timestampReceived><subject>Re: IPv6 exit proposal</subject><body>

apologies, fix typo, and clarify NAT-PT a bit.  this should be the
last of these for now!

On 7/18/07, coderman &lt;coderman@gmail.com&gt; wrote:
&gt; i've attached a patch for some clarifications to the proposal....

["ipv6-exits-update.patch" (text/x-patch)]

--- 117-ipv6-exits.txt	2007-07-18 15:38:06.351207752 -0700
+++ mod-117-ipv6-exits.txt	2007-07-18 15:44:08.592138760 -0700
@@ -44,12 +44,12 @@ Contents
    the addendum.
 
    When Tor is started on a host it should check for the presence of a
-   global unicast address, [2000::]/3, and if present include the
-   default IPv6 exit policies and any user specified IPv6 exit policies.
+   global unicast IPv6 address and if present include the default IPv6
+   exit policies and any user specified IPv6 exit policies.
 
-   If a user provides IPv6 exit policies but no global unicast address
-   is available Tor should generate a warning and not publish the IPv6
-   policy in the router descriptor.
+   If a user provides IPv6 exit policies but no global unicast IPv6
+   address is available Tor should generate a warning and not publish the
+   IPv6 policies in the router descriptor.
 
    It should be noted that IPv4 mapped IPv6 addresses are not valid exit
    destinations.  This mechanism is mainly used to interoperate with
@@ -270,21 +270,31 @@ Contents
    IPv4 preference.  Should more explicit control be available, through
    either configuration directives or control commands?
 
-   This can be worked around by resolving names and then CONNECTing to
-   an IPv4 or IPv6 address as desired, however, not all client
-   applications may have this option available.
-
-3.3. Support for IPv6 only clients
-
-   It may be useful to support IPv6 only clients using IPv4 mapped IPv6
-   addresses.  This would require transparent DNS proxy using IPv6
-   transport and the ability to map A record responses into IPv4 mapped
-   IPv6 addresses.  The transparent TCP proxy would thus need to detect
-   these mapped addresses and connect to the desired IPv4 host.
-
-   The relative lack of any IPv6 only hosts or applications makes this a
-   lot of work for very little gain.  Is there a compelling reason to
-   support this capability?
+   Many applications support a inet6-only or prefer-family type option
+   that provides the user manual control over address preference.  This
+   could be provided as a Tor configuration option.
+
+   An explicit preference is still possible by resolving names and then
+   CONNECTing to an IPv4 or IPv6 address as desired, however, not all
+   client applications may have this option available.
+
+3.3. Support for IPv6 only transparent proxy clients
+
+   It may be useful to support IPv6 only transparent proxy clients using
+   IPv4 mapped IPv6 like addresses.  This would require transparent DNS
+   proxy using IPv6 transport and the ability to map A record responses
+   into IPv4 mapped IPv6 like addresses in the manner described in the
+   "NAT-PT" RFC for a traditional Basic-NAT-PT with DNS-ALG.  The
+   transparent TCP proxy would thus need to detect these mapped addresses
+   and connect to the desired IPv4 host.
+
+   The IPv6 prefix used for this purpose must not be the actual IPv4
+   mapped IPv6 address prefix, though the manner in which IPv4 addresses
+   are embedded in IPv6 addresses would be the same.
+
+   The lack of any IPv6 only hosts which would use this transparent proxy
+   method makes this a lot of work for very little gain.  Is there a
+   compelling reason to support this NAT-PT like capability?
 
 3.4. IPv6 DNS and older Tor routers
 
@@ -299,6 +309,21 @@ Contents
    routers that can resolve IPv6 addresses even if they can't exit such
    traffic.
 
+   There was also concern expressed about the ability of existing clients
+   to cope with new RELAY_RESOLVE responses that contain IPv6 addresses.
+   If this breaks backward compatibility, a new request type may be
+   necessary, like RELAY_RESOLVE6, or some other mechanism of indicating
+   the ability to parse IPv6 responses when making the request.
+
+3.5. IPv4 and IPv6 bindings in MAPADDRESS
+
+   It may be troublesome to try and support two distinct address mappings
+   for the same name in the existing MAPADDRESS implementation.  If this
+   cannot be accommodated then the behavior should replace existing
+   mappings with the new address regardless of family.  A warning when
+   this occurs would be useful to assist clients who encounter problems
+   when both an IPv4 and IPv6 application are using MAPADDRESS for the
+   same names concurrently, causing lost connections for one of them.
 
 4. Addendum
 
@@ -358,3 +383,5 @@ Contents
    'INTERNET PROTOCOL VERSION 6 ADDRESS SPACE'
    http://www.iana.org/assignments/ipv6-address-space
 
+   'Network Address Translation - Protocol Translation (NAT-PT)'
+   http://www.ietf.org/rfc/rfc2766.txt


</body></email><email><emailId>20070723001449</emailId><senderName>Mike Perry</senderName><senderEmail>mikeperry@fscked.org</senderEmail><timestampReceived>2007-07-23 00:14:49-0400</timestampReceived><subject>Re: Proposal: minimum advertised bandwidth guarantees fast/guard</subject><body>


Thus spake Roger Dingledine (arma@mit.edu):

&gt; I've committed the proposed patch, with a few more comments and slightly
&gt; different numbers than originally proposed:
&gt; http://archives.seul.org/or/cvs/Jul-2007/msg00181.html
&gt; 
&gt; On Fri, Jul 20, 2007 at 07:09:00PM -0700, Mike Perry wrote:
&gt; &gt; If everyone were weighting guards by bandwidth, 300-400k would
&gt; &gt; probably be a fine cutoff. But since we haven't yet decided to expire
&gt; &gt; people's already uniformly chosen guards, the limit should probably be
&gt; &gt; somewhere around 125k if you really don't want half of the existing
&gt; &gt; tor users to continue to be vulnerable to this attack.
&gt; 
&gt; Ok. The goal is to pick a number sufficiently high that we would consider
&gt; this node worthwhile as a guard even if one day we have a whole lot of
&gt; even faster nodes. I picked 250KB/s as a good guess for that.

Isn't it the directory code that is making this decision though? That
can be changed much faster than the clients.
 
&gt; &gt; Alternatively, we could make 0.1.2.16/0.2.0.3 expire all guards for
&gt; &gt; all versions prior, which would also help the network balancing. That
&gt; &gt; would be nice. :)
&gt; 
&gt; Right. We're not going to do that in the 0.2.0.3-alpha timeframe (which
&gt; I hope to put out in the next days), but it's still something to ponder.
&gt; As we wait, though, the problem goes away on its own -- now that 0.1.2.15
&gt; is out and new users will be picking guards better. I have to admit that
&gt; I have no intuition about user turnover though, so no intuition about
&gt; how quickly it will correct itself.

Yeah, new users are picking guards better, but all users who upgrade
keep their state file unless we explicitly expire it in
or_state_validate(). This is what I think we should do for 0.1.2.16,
unless we anticipate other major guard-related changes.

&gt; &gt; Since Fast nodes are chosen in proportion to bandwidth, this limit can
&gt; &gt; probably safely be set much higher proporitionally. 100k looks like it
&gt; &gt; may even work.
&gt; 
&gt; I decided to stick with 100KB/s here.

Sounds good.

-- 
Mike Perry
Mad Computer Scientist
fscked.org evil labs

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070620213622</emailId><senderName>Robert Hogan</senderName><senderEmail>robert@roberthogan.net</senderEmail><timestampReceived>2007-06-20 21:36:22-0400</timestampReceived><subject>TODO: Add a way to request DNS resolves from the controller</subject><body>


I've implemented a rudimentary version of this.

I think I have the fundamentals right (it works) but I'm not sure about the 
interface. The controller requests resolves with:

RESOLVE hotmail.com
250 OK

And tor responds with:

650 RESOLVE hotmail.com:64.4.32.7

Internally, performing a resolve request enables the RESOLVE event for that 
controller. But you only get a RESOLVE event whenever you request one.

I've implemented it as an event rather than a getinfo because of the expected 
latency of the response.

This approach breaks the spec a bit, in that 650 events now occur when you 
perform a SETEVENTS or implicity enable a RESOLVE event by performing a 
RESOLVE.

Should I continue on the basis of this approach or is there a strong 
preference to make the requests something like getinfo resolve/hotmail.com ?


-- 

Browse Anonymously Anywhere	- http://anonymityanywhere.com
TorK	- KDE Anonymity Manager	- http://tork.sf.net
KlamAV	- KDE Anti-Virus 	- http://www.klamav.net

</body></email><email><emailId>20070711215416</emailId><senderName>coderman</senderName><senderEmail>coderman@gmail.com</senderEmail><timestampReceived>2007-07-11 21:54:16-0400</timestampReceived><subject>constrained socket buffers patch</subject><body>

hi Andrew, all,

attached is the constrained sockets patch.  apologies for the delay;
still have DSL problems at home.

to enable this feature set:

ConstrainedSockets 1

in your configuration.  this will limit the recv and xmit buffers
associated with TCP sockets to the default 4096 bytes.  you can also
alter the default explicitly via:

ConstrainedSockSize 2048

the value must be between 2048 and 262144 in 1024 byte increments.
attempting to set an invalid value should produce an error at start.
see the (patched) man page for additional details.

to patch:
cd tor-0.1.2.14
patch -p1 &lt; ../tor-constrained-sockets.patch

then build as usual (vary per your reqs):
./configure --prefix=/usr --sysconfdir=/etc &amp;&amp; make &amp;&amp; make install

let me know if this appears to work!  you may try adjusting the
buffers down as low as 2048 if you still get problems at 4096,
however, i don't think this is likely.

best regards,

["tor-constrained-sockets.patch" (text/x-patch)]

diff -Naur orig-tor-0.1.2.14/doc/tor.1.in mod-tor-0.1.2.14/doc/tor.1.in
--- orig-tor-0.1.2.14/doc/tor.1.in	2007-05-25 00:51:42.000000000 +0000
+++ mod-tor-0.1.2.14/doc/tor.1.in	2007-07-11 21:20:33.000000000 +0000
@@ -88,6 +88,21 @@
 Windows since that platform lacks getrlimit(). (Default: 1000)
 .LP
 .TP
+\fBConstrainedSockets \fR\fB0\fR|\fB1\fR\fP
+If set, Tor will attempt to shrink the recv and xmit buffers for all
+sockets to the size specified in \fBConstrainedSockSize\fP.  This is useful
+for virtual servers and other environments where system level TCP
+buffers may be limited.  The preferred solution is to have the admin
+increase the buffer pool via /proc/sys/net/ipv4/tcp_mem or equivalent
+facility.  Note that this will not work on Windows platforms.
+.LP
+.TP
+\fBConstrainedSockSize \fR\fINUM\fP
+When \fBConstrainedSockets\fP is enabled the recv and xmit buffers for
+all sockets will be set to this limit.  Must be a value between 2048
+and 262144 in 1024 byte increments.  Default of 4096 is recommended.
+.LP
+.TP
 \fBControlPort \fR\fIPort\fP
 If set, Tor will accept connections on this port and allow those
 connections to control the Tor process using the Tor Control Protocol
diff -Naur orig-tor-0.1.2.14/src/or/config.c mod-tor-0.1.2.14/src/or/config.c
--- orig-tor-0.1.2.14/src/or/config.c	2007-05-25 00:51:40.000000000 +0000
+++ mod-tor-0.1.2.14/src/or/config.c	2007-07-11 21:14:18.000000000 +0000
@@ -139,6 +139,8 @@
   VAR("CircuitIdleTimeout",  INTERVAL, CircuitIdleTimeout,   "1 hour"),
   VAR("ClientOnly",          BOOL,     ClientOnly,           "0"),
   VAR("ConnLimit",           UINT,     ConnLimit,            "1000"),
+  VAR("ConstrainedSockets",  BOOL,     ConstrainedSockets,   "0"),
+  VAR("ConstrainedSockSize", UINT,     ConstrainedSockSize,  "4096"),
   VAR("ContactInfo",         STRING,   ContactInfo,          NULL),
   VAR("ControlListenAddress",LINELIST, ControlListenAddress, NULL),
   VAR("ControlPort",         UINT,     ControlPort,          "0"),
@@ -309,6 +311,10 @@
   { "BandwidthBurst", "Limit the maximum token buffer size (also known as "
     "burst) to the given number of bytes." },
   { "ConnLimit", "Maximum number of simultaneous sockets allowed." },
+  { "ConstrainedSockets", "Shrink tx and rx buffers for sockets to avoid "
+    "system limits on vservers and related environments." },
+  { "ConstrainedSockSize", "Limit socket buffers to this size when "
+    "ConstrainedSockets is set.  Must be at least 2048 bytes." },
   /*  ControlListenAddress */
   { "ControlPort", "If set, Tor will accept connections from the same machine "
     "(localhost only) on this port, and allow those connections to control "
@@ -2765,6 +2771,24 @@
     }
   }
 
+#ifndef MS_WINDOWS
+  if (options-&gt;ConstrainedSockets) {
+    /** If the user wants to constrain socket buffer use, make sure the desired
+     * limit is between 2k and 256k in k increments. */
+    const int minsocksz = 2*1024;
+    const int maxsocksz = 256*1024;
+    if (options-&gt;ConstrainedSockSize &lt; minsocksz ||
+        options-&gt;ConstrainedSockSize &gt; maxsocksz ||
+        options-&gt;ConstrainedSockSize % 1024 ) {
+      r = tor_snprintf(buf, sizeof(buf),
+          "ConstrainedSockSize is invalid.  Must be a value between %d and %d in 1024 byte increments.",
+          minsocksz, maxsocksz);
+      *msg = tor_strdup(r &gt;= 0 ? buf : "internal error");
+      return -1;
+    }
+  }
+#endif
+
   if (rend_config_services(options, 1) &lt; 0)
     REJECT("Failed to configure rendezvous options. See logs for details.");
 
diff -Naur orig-tor-0.1.2.14/src/or/connection.c mod-tor-0.1.2.14/src/or/connection.c
--- orig-tor-0.1.2.14/src/or/connection.c	2007-05-25 00:51:40.000000000 +0000
+++ mod-tor-0.1.2.14/src/or/connection.c	2007-07-11 21:47:00.000000000 +0000
@@ -27,6 +27,7 @@
 static int connection_read_to_buf(connection_t *conn, int *max_to_read);
 static int connection_process_inbuf(connection_t *conn, int package_partial);
 static void client_check_address_changed(int sock);
+static void set_constrained_socket_buffers(int sock, int size);
 
 static uint32_t last_interface_ip = 0;
 static smartlist_t *outgoing_addrs = NULL;
@@ -741,6 +742,8 @@
   /* length of the remote address. Must be whatever accept() needs. */
   socklen_t remotelen = 256;
   char tmpbuf[INET_NTOA_BUF_LEN];
+  or_options_t *options = get_options();
+
   tor_assert((size_t)remotelen &gt;= sizeof(struct sockaddr_in));
   memset(addrbuf, 0, sizeof(addrbuf));
 
@@ -766,6 +769,12 @@
 
   set_socket_nonblocking(news);
 
+#ifndef MS_WINDOWS
+  if (options-&gt;ConstrainedSockets) {
+    set_constrained_socket_buffers (news, options-&gt;ConstrainedSockSize);
+  }
+#endif
+
   if (check_sockaddr_in((struct sockaddr*)addrbuf, remotelen, LOG_INFO)&lt;0) {
     log_info(LD_NET,
              "accept() returned a strange address; trying getsockname().");
@@ -910,6 +919,12 @@
 
   set_socket_nonblocking(s);
 
+#ifndef MS_WINDOWS
+  if (options-&gt;ConstrainedSockets) {
+    set_constrained_socket_buffers (s, options-&gt;ConstrainedSockSize);
+  }
+#endif
+
   memset(&amp;dest_addr,0,sizeof(dest_addr));
   dest_addr.sin_family = AF_INET;
   dest_addr.sin_port = htons(port);
@@ -2226,6 +2241,29 @@
   }
 }
 
+/** Some systems have limited system buffers for recv and xmit on
+ * sockets allocated in a virtual server or similar environment.  This
+ * method will attempt to constrain the buffers allocated to the socket
+ * to the desired size.  This should be a value between 2k and 256k.
+ * The preferred solution is to have the administrator set increased
+ * limits in /proc/sys/net/ipv4/tcp_mem or equivalent.
+ */
+static void
+set_constrained_socket_buffers(int sock, int size)
+{
+  if (setsockopt(sock, SOL_SOCKET, SO_SNDBUF, &amp;size, sizeof(size)) &lt; 0) {
+    int e = tor_socket_errno(sock);
+    log_warn(LD_NET, "setsockopt() to constrain send buffer to %d bytes failed: %s",
+             size, tor_socket_strerror(e));
+  }
+  if (setsockopt(sock, SOL_SOCKET, SO_RCVBUF, &amp;size, sizeof(size)) &lt; 0) {
+    int e = tor_socket_errno(sock);
+    log_warn(LD_NET, "setsockopt() to constrain recv buffer to %d bytes failed: %s",
+             size, tor_socket_strerror(e));
+  }
+  return;
+}
+
 /** Process new bytes that have arrived on conn-\&gt;inbuf.
  *
  * This function just passes conn to the connection-specific
diff -Naur orig-tor-0.1.2.14/src/or/or.h mod-tor-0.1.2.14/src/or/or.h
--- orig-tor-0.1.2.14/src/or/or.h	2007-05-25 00:51:40.000000000 +0000
+++ mod-tor-0.1.2.14/src/or/or.h	2007-07-11 21:39:58.000000000 +0000
@@ -1678,6 +1678,9 @@
   config_line_t *ReachableORAddresses; /**&lt; IP:ports for OR conns. */
   config_line_t *ReachableDirAddresses; /**&lt; IP:ports for Dir conns. */
 
+  int ConstrainedSockets; /**&lt; Shrink xmit and recv socket buffers. */
+  int ConstrainedSockSize; /**&lt; Size of constrained buffers. */
+
   /** Application ports that require all nodes in circ to have sufficient
    * uptime. */
   smartlist_t *LongLivedPorts;


</body></email><email><emailId>20070707175450</emailId><senderName>coderman</senderName><senderEmail>coderman@gmail.com</senderEmail><timestampReceived>2007-07-07 17:54:50-0400</timestampReceived><subject>IPv6 exit proposal</subject><body>

apologies for formatting; available at
http://peertech.org/pub/tor-ipv6-exit-proposal.txt if this is
unreadable.

---

Proposal : IPv6 exit

Overview

   Extend Tor for TCP exit via IPv6 transport and DNS resolution of IPv6
   addresses.  This proposal does not imply any IPv6 support for OR traffic,
   only exit and name resolution.


Contents

0. Motivation

   As the IPv4 address space becomes more scarce there is increasing effort to
   provide Internet services via the IPv6 protocol.  Many hosts are available
   at IPv6 endpoints which are currently inaccessible for Tor users.

   Extending Tor to support IPv6 exit streams and IPv6 DNS name resolution will
   allow users of the Tor network to access these hosts.  This capability would
   be present for those who do not currently have IPv6 access, thus increasing
   the utility of Tor and furthering adoption of IPv6.


1. Design

1.1. General design overview

   There are three main components to this proposal.  The first is a method for
   routers to advertise their ability to exit IPv6 traffic.  The second is the
   manner in which routers resolve names to IPv6 addresses.  Last but not least
   is the method in which clients communicate with Tor to resolve and connect
   to IPv6 endpoints anonymously.

1.2. Router IPv6 exit support

   In order to specify exit policies and IPv6 capability new directives in the
   Tor configuration will be needed.  If a router advertises IPv6 exit policies
   in its descriptor this will signal the ability to provide IPv6 exit.  There
   are a number of additional default deny rules associated with this new
   address space which are detailed in the addendum.

   When Tor is started on a host it should check for the presence of a global
   unicast address, [2000::]/3, and if present include the default IPv6 exit
   policies and any user specified IPv6 exit policies.

   If a user provides IPv6 exit policies but no global unicast address is
   available Tor should generate a warning and not publish the IPv6 policy in
   the router descriptor.

   It should be noted that IPv4 mapped IPv6 addresses are not valid exit
   destinations.  This mechanism is mainly used to interoperate with both IPv4
   and IPv6 clients on the same socket.  Any attempts to use an IPv4 mapped
   IPv6 address, perhaps to circumvent exit policy for IPv4, must be refused.

1.3. DNS name resolution of IPv6 addresses (AAAA records)

   In addition to exit support for IPv6 TCP connections, a method to resolve
   domain names to their respective IPv6 addresses is also needed.  This is
   accomplished in the existing DNS system via AAAA records.  Routers will
   perform both A and AAAA requests when resolving a name so that the client can
   utilize an IPv6 endpoint when available or preferred.

   To avoid potential problems with caching DNS servers that behave poorly all
   NXDOMAIN responses to AAAA requests should be ignored if a successful
   response is received for an A request.  This implies that both AAAA and A
   requests will always be performed for each name resolution.

   For reverse lookups on IPv6 addresses, like that used for RESOLVE_PTR, Tor
   will perform the necessary PTR requests via IP6.ARPA.

   All routers which perform DNS resolution on behalf of clients (RELAY_RESOLVE)
   should perform and respond with both A and AAAA resources.

1.4. Client interaction with IPv6 exit capability

1.4.1. Usability goals

   There are a number of behaviors which Tor can provide when interacting with
   clients that will improve the usability of IPv6 exit capability.  These
   behaviors are designed to make it simple for clients to express a preference
   for IPv6 transport and utilize IPv6 host services.

1.4.2. SOCKSv5 IPv6 client behavior

   The SOCKS version 5 protocol supports IPv6 connections.  When using SOCKSv5
   with hostnames it is difficult to determine if a client wishes to use an IPv4
   or IPv6 address to connect to the desired host if it resolves to both address
   types.

   In order to make this more intuitive the SOCKSv5 protocol can be supported on
   a local IPv6 endpoint, [::1] port 9050 for example.  When a client requests
   a connection to the desired host via an IPv6 SOCKS connection Tor will prefer
   IPv6 addresses when resolving the host name and connecting to the host.

   Likewise, RESOLVE and RESOLVE_PTR requests from an IPv6 SOCKS connection will
   return IPv6 addresses when available, and fall back to IPv4 addresses if not.

1.4.3. MAPADDRESS behavior

   The MAPADDRESS capability supports clients that may not be able to use the
   SOCKSv4a or SOCKSv5 hostname support to resolve names via Tor.  This ability
   should be extended to IPv6 addresses in SOCKSv5 as well.

   When a client requests an address mapping from the wildcard IPv6 address,
   [::0], the server will respond with a unique local IPv6 address on success.
   It is important to note that there may be two mappings for the same name
   if both an IPv4 and IPv6 address are associated with the host.  In this case
   a CONNECT to a mapped IPv6 address should prefer IPv6 for the connection to
   the host, if available, while CONNECT to a mapped IPv4 address will prefer
   IPv4.

   It should be noted that IPv6 does not provide the concept of a host local
   subnet, like 127.0.0.0/8 in IPv4.  For this reason integration of Tor with
   IPv6 clients should consider a firewall or filter rule to drop unique
   local addresses to or from the network when possible.  These packets should
   not be routed, however, keeping them off the subnet entirely is worthwhile.

1.4.3.1. Generating unique local IPv6 addresses

   The usual manner of generating a unique local IPv6 address is to select a
   Global ID part randomly, along with a Subnet ID, and sharing this prefix
   among the communicating parties who each have their own distinct Interface
   ID.  In this style a given Tor instance might select a random Global and
   Subnet ID and provide MAPADDRESS assignments with a random Interface ID as
   needed.  This has the potential to associate unique Global/Subnet identifiers
   with a given Tor instance and may expose attacks against the anonymity of Tor
   users.

   Tor avoid this potential problem entirely MAPADDRESS must always generate the
   Global, Subnet, and Interface IDs randomly for each request.  It is also
   highly suggested that explicitly specifying an IPv6 source address instead of
   the wildcard address not be supported to ensure that a good random address is
   used.

1.4.4. DNSProxy IPv6 client behavior

   A new capability in recent Tor versions is the transparent DNS proxy.  This
   feature will need to return both A and AAAA resource records when responding
   to client name resolution requests.

   The transparent DNS proxy should also support reverse lookups for IPv6
   addresses.  It is suggested that any such requests to the deprecated IP6.INT
   domain should be translated to IP6.ARPA instead.  This translation is not
   likely to be used and is of low priority.

   It would be nice to support DNS over IPv6 transport as well, however, this
   is not likely to be used and is of low priority.

1.4.5. TransPort IPv6 client behavior

   Tor also provides transparent TCP proxy support via the Trans* directives in
   the configuration.  The TransListenAddress directive should accept an IPv6
   address in addition to IPv4 so that IPv6 TCP connections can be transparently
   proxied.

1.5. Additional changes

   The RedirectExit option should be deprecated rather than extending this
   feature to IPv6.


2. Spec changes

2.1. Tor specification

   In '6.2. Opening streams and transferring data' the following should be
   changed to indicate IPv6 exit capability:

      "No version of Tor currently generates the IPv6 format."

   In '6.4. Remote hostname lookup' the following should be updated to reflect
   use of ip6.arpa in addition to in-addr.arpa.

      "For a reverse lookup, the OP sends a RELAY_RESOLVE cell containing an
       in-addr.arpa address."

   In 'A.1. Differences between spec and implementation' the following should
   be updated to indicate IPv6 exit capability:

      "The current codebase has no IPv6 support at all."

2.2. Directory specification

   In '2.1. Router descriptor format' a new set of directives is needed for
   IPv6 exit policy.  The existing accept/reject directives should be
   clarified to indicate IPv4 or wildcard address relevance.  The new IPv6
   directives will be in the form of:

      "accept6" exitpattern NL
      "reject6" exitpattern NL

   The section describing accept6/reject6 should explain that the presence
   of accept6 or reject6 exit policies in a router descriptor signals the
   ability of that router to exit IPv6 traffic (according to IPv6 exit
   policies).

   The "[::]/0" notation is used to represent "all IPv6 addresses".  "[::0]/0"
   may also be used for this representation.

   If a user specifies a 'reject6 [::]/0:*' policy in the Tor configuration this
   will be interpreted as forcing no IPv6 exit support and no accept6/reject6
   policies will be included in the published descriptor.  This will prevent
   IPv6 exit if the router host has a global unicast IPv6 address present.

   It is important to note that a wildcard address in an accept or reject policy
   applies to both IPv4 and IPv6 addresses.

2.3. Control specification

   In '3.8. MAPADDRESS' the potential to have to addresses for a given name
   should be explained.  The method for generating unique local addresses
   for IPv6 mappings needs explanation as described above.

   When IPv6 addresses are used in this document they should include the
   brackets for consistency.  For example, the null IPv6 address should be
   written as "[::0]" and not "::0".  The control commands will expect the
   same syntax as well.

   In '3.9. GETINFO' the "address" command should return both public IPv4 and
   IPv6 addresses if present.  These addresses should be separated via \r\n.


2.4. Tor SOCKS extensions

   In '2. Name lookup' a description of IPv6 address resolution is needed for
   SOCKSv5 as described above.  IPv6 addresses should be supported in both the
   RESOLVE and RESOLVE_PTR extensions.

   A new section describing the ability to accept SOCKSv5 clients on a local
   IPv6 address to indicate a preference for IPv6 transport as described above
   is also needed.  The behavior of Tor SOCKSv5 proxy with an IPv6 preference
   should be explained, for example, preferring IPv6 transport to a named host
   with both IPv4 and IPv6 addresses available (A and AAAA records).


3. Questions and concerns

3.1. DNS A6 records

   A6 is explicitly avoided in this document.  There are potential reasons for
   implementing this, however, the inherent complexity of the protocol and
   resolvers make this unappealing.  Is there a compelling reason to consider
   A6 as part of IPv6 exit support?

3.2. IPv4 and IPv6 preference

   The design above tries to infer a preference for IPv4 or IPv6 transport
   based on client interactions with Tor.  It might be useful to provide
   more explicit control over this preference.  For example, an IPv4 SOCKSv5
   client may want to use IPv6 transport to named hosts in CONNECT requests
   while the current implementation would assume an IPv4 preference.  Should
   more explicit control be available, through either configuration directives
   or control commands?

   This can be worked around by resolving names and then CONNECTing to an IPv4
   or IPv6 address as desired, however, not all client applications may have
   this option available.

3.3. Support for IPv6 only clients

   It may be useful to support IPv6 only clients using IPv4 mapped IPv6
   addresses.  This would require transparent DNS proxy using IPv6
   transport and the ability to map A record responses into IPv4 mapped
   IPv6 addresses.  The transparent TCP proxy would thus need to detect these
   mapped addresses and connect to the desired IPv4 host.

   The relative lack of any IPv6 only hosts or applications makes this a lot of
   work for very little gain.  Is there a compelling reason to support this
   capability?

3.4. IPv6 DNS and older Tor routers

   It is expected that many routers will continue to run with older versions of
   Tor when the IPv6 exit capability is released.  Clients who wish to use IPv6
   will need to route RELAY_RESOLVE requests to the newer routers which will
   respond with both A and AAAA resource records when possible.

   One way to do this is to route RELAY_RESOLVE requests to routers with IPv6
   exit policies published, however, this would not utilize current routers
   that can resolve IPv6 addresses even if they can't exit such traffic.


4. Addendum

4.1. Sample IPv6 default exit policy

   reject 0.0.0.0/8
   reject 169.254.0.0/16
   reject 127.0.0.0/8
   reject 192.168.0.0/16
   reject 10.0.0.0/8
   reject 172.16.0.0/12
   reject6 [0000::]/8
   reject6 [0100::]/8
   reject6 [0200::]/7
   reject6 [0400::]/6
   reject6 [0800::]/5
   reject6 [1000::]/4
   reject6 [4000::]/3
   reject6 [6000::]/3
   reject6 [8000::]/3
   reject6 [A000::]/3
   reject6 [C000::]/3
   reject6 [E000::]/4
   reject6 [F000::]/5
   reject6 [F800::]/6
   reject6 [FC00::]/7
   reject6 [FE00::]/9
   reject6 [FE80::]/10
   reject6 [FEC0::]/10
   reject6 [FF00::]/8
   reject *:25
   reject *:119
   reject *:135-139
   reject *:445
   reject *:1214
   reject *:4661-4666
   reject *:6346-6429
   reject *:6699
   reject *:6881-6999
   accept *:*
   # accept6 [2000::]/3:* is implied

4.2. Additional resources

   'DNS Extensions to Support IP Version 6'
   http://www.ietf.org/rfc/rfc3596.txt

   'DNS Extensions to Support IPv6 Address Aggregation and Renumbering'
   http://www.ietf.org/rfc/rfc2874.txt

   'SOCKS Protocol Version 5'
   http://www.ietf.org/rfc/rfc1928.txt

   'Unique Local IPv6 Unicast Addresses'
   http://www.ietf.org/rfc/rfc4193.txt

   'INTERNET PROTOCOL VERSION 6 ADDRESS SPACE'
   http://www.iana.org/assignments/ipv6-address-space
</body></email><email><emailId>20070708042341</emailId><senderName></senderName><senderEmail>xiangw</senderEmail><timestampReceived>2007-07-08 04:23:41-0400</timestampReceived><subject>Re:IPv6 exit proposal</subject><body>

why not translate IPv4 traffic to IPv6 after exit from tor, instead of 
changing the tor code? It's much easier. I prefer new tor release with 
full IPv6 support, not only exit policy.

XIANG Wang

</body></email><email><emailId>20070710173926</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-07-10 17:39:26-0400</timestampReceived><subject>Re: IPv6 exit proposal</subject><body>


On Sat, Jul 07, 2007 at 10:54:50AM -0700, coderman wrote:
&gt; apologies for formatting; available at
&gt; http://peertech.org/pub/tor-ipv6-exit-proposal.txt if this is
&gt; unreadable.
&gt; 
&gt; ---
&gt; 
&gt; Proposal : IPv6 exit

Added as proposal 117, and re-wrapped to fit in 80 columns; thanks!


 [...]

&gt;   It should be noted that IPv4 mapped IPv6 addresses are not valid
&gt;   exit destinations.  This mechanism is mainly used to interoperate
&gt;   with both IPv4 and IPv6 clients on the same socket.  Any attempts
&gt;   to use an IPv4 mapped IPv6 address, perhaps to circumvent exit
&gt;   policy for IPv4, must be refused.

Alternatively, we could just apply IPv4 exit policies to IPv4-mapped
IPv6 addresses.  Would that be cleaner?
 [...]
&gt; 1.3. DNS name resolution of IPv6 addresses (AAAA records)
 [...]
&gt;   All routers which perform DNS resolution on behalf of clients
&gt;   (RELAY_RESOLVE) should perform and respond with both A and AAAA
&gt;   resources.

Hm.  We need some way to do this inside the current relay_resolve
format without confusing existing clients.

 [...]
&gt; 3. Questions and concerns
&gt; 
&gt; 3.1. DNS A6 records
&gt; 
&gt;   A6 is explicitly avoided in this document.  There are potential
&gt;   reasons for implementing this, however, the inherent complexity of
&gt;   the protocol and resolvers make this unappealing.  Is there a
&gt;   compelling reason to consider A6 as part of IPv6 exit support?

I'm okay doing nothing with A6 for now.

 [...]
&gt; 3.3. Support for IPv6 only clients
&gt; 
&gt;   It may be useful to support IPv6 only clients using IPv4 mapped IPv6
&gt;   addresses.  This would require transparent DNS proxy using IPv6
&gt;   transport and the ability to map A record responses into IPv4 mapped
&gt;   IPv6 addresses.  The transparent TCP proxy would thus need to detect these
&gt;   mapped addresses and connect to the desired IPv4 host.
&gt; 
&gt;   The relative lack of any IPv6 only hosts or applications makes
&gt;   this a lot of work for very little gain.  Is there a compelling
&gt;   reason to support this capability?

I'd like to add support for ipv6-only clients, but I think that's a
separate proposal. 


yrs,
-- 
Nick Mathewson

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070718222107</emailId><senderName>coderman</senderName><senderEmail>coderman@gmail.com</senderEmail><timestampReceived>2007-07-18 22:21:07-0400</timestampReceived><subject>Re: IPv6 exit proposal</subject><body>

i've attached a patch for some clarifications to the proposal.  i've
also answered some questions inline below...


On 7/10/07, Nick Mathewson &lt;nickm@freehaven.net&gt; wrote:
&gt; ...
&gt; Alternatively, we could just apply IPv4 exit policies to IPv4-mapped
&gt; IPv6 addresses.  Would that be cleaner?

all of the IPv4 mapped IPv6 should occur at the client side, not exit,
so this shouldn't be necessary.

also, this would only be needed for the transparent proxy of IPv6 only
clients, as the usual IPv4 mapped IPv6 applies to listening sockets,
making it internal to Tor itself, and not exposed to either clients or
exits.


&gt; &gt;   All routers which perform DNS resolution on behalf of clients
&gt; &gt;   (RELAY_RESOLVE) should perform and respond with both A and AAAA
&gt; &gt;   resources.
&gt;
&gt; Hm.  We need some way to do this inside the current relay_resolve
&gt; format without confusing existing clients.

i added a paragraph to "3.4. IPv6 DNS and older Tor routers" with this
concern.  hopefully this can be done without confusing existing
clients, perhaps by always returning the IPv4 address(es) first,
followed by IPv6 in the response.

i'd like to avoid a RELAY_RESOLVE6 kind of hack like that used for
exit policies.

best regards,

["ipv6-exits-update.patch" (text/x-patch)]

--- 117-ipv6-exits.txt	2007-07-11 19:57:46.814722640 -0700
+++ mod-117-ipv6-exits.txt	2007-07-18 15:12:35.836881296 -0700
@@ -44,12 +44,12 @@ Contents
    the addendum.
 
    When Tor is started on a host it should check for the presence of a
-   global unicast address, [2000::]/3, and if present include the
-   default IPv6 exit policies and any user specified IPv6 exit policies.
+   global unicast IPv6 address and if present include the default IPv6
+   exit policies and any user specified IPv6 exit policies.
 
-   If a user provides IPv6 exit policies but no global unicast address
-   is available Tor should generate a warning and not publish the IPv6
-   policy in the router descriptor.
+   If a user provides IPv6 exit policies but no global unicast IPv6
+   address is available Tor should generate a warning and not publish the
+   IPv6 policies in the router descriptor.
 
    It should be noted that IPv4 mapped IPv6 addresses are not valid exit
    destinations.  This mechanism is mainly used to interoperate with
@@ -159,7 +159,7 @@ Contents
    This translation is not likely to be used and is of low priority.
 
    It would be nice to support DNS over IPv6 transport as well, however,
-   this is not likely to be used and is of low priority.
+   this is not likely to be used and is of low priority.  Refer to
 
 1.4.5. TransPort IPv6 client behavior
 
@@ -270,21 +270,29 @@ Contents
    IPv4 preference.  Should more explicit control be available, through
    either configuration directives or control commands?
 
-   This can be worked around by resolving names and then CONNECTing to
-   an IPv4 or IPv6 address as desired, however, not all client
-   applications may have this option available.
-
-3.3. Support for IPv6 only clients
-
-   It may be useful to support IPv6 only clients using IPv4 mapped IPv6
-   addresses.  This would require transparent DNS proxy using IPv6
-   transport and the ability to map A record responses into IPv4 mapped
-   IPv6 addresses.  The transparent TCP proxy would thus need to detect
-   these mapped addresses and connect to the desired IPv4 host.
-
-   The relative lack of any IPv6 only hosts or applications makes this a
-   lot of work for very little gain.  Is there a compelling reason to
-   support this capability?
+   Many applications support a inet6-only or prefer-family type option
+   that provides the user manual control over address preference.  This
+   could be provided as a Tor configuration option.
+
+   An explicit preference is still possible by resolving names and then
+   CONNECTing to an IPv4 or IPv6 address as desired, however, not all
+   client applications may have this option available.
+
+3.3. Support for IPv6 only transparent proxy clients
+
+   It may be useful to support IPv6 only transparent proxy clients using
+   IPv4 mapped IPv6 like addresses.  This would require transparent DNS
+   proxy using IPv6 transport and the ability to map A record responses
+   into IPv4 mapped IPv6 like addresses in the manner described in the
+   "NAT-PT" RFC.  The transparent TCP proxy would thus need to detect
+   these mapped addresses and connect to the desired IPv4 host.  The IPv6
+   prefix used for this purpose must not be the actual IPv4 mapped IPv6
+   address prefix, though the manner in which IPv4 addresses are embedded
+   in IPv6 would be the same.
+
+   The lack of any IPv6 only hosts which would use this transparent proxy
+   method makes this a lot of work for very little gain.  Is there a
+   compelling reason to support this NAT-PT like capability?
 
 3.4. IPv6 DNS and older Tor routers
 
@@ -299,6 +307,20 @@ Contents
    routers that can resolve IPv6 addresses even if they can't exit such
    traffic.
 
+   There was also concern expressed about the ability of existing clients
+   to cope with new RELAY_RESOLVE responses that contain IPv6 addresses.
+   If this breaks backward compatibility, a new request type will be
+   necessary, like RELAY_RESOLVE6.
+
+3.5. IPv4 and IPv6 bindings in MAPADDRESS
+
+   It may be troublesome to try and support two distinct address mappings
+   for the same name in the existing MAPADDRESS implementation.  If this
+   cannot be accommodated than the behavior should replace existing
+   mappings with the new address regardless of family.  A warning when
+   this occurs would be useful to assist clients who encounter problems
+   when both an IPv4 and IPv6 application are using MAPADDRESS for the
+   same names concurrently, causing lost connections for one of them.
 
 4. Addendum
 
@@ -358,3 +380,5 @@ Contents
    'INTERNET PROTOCOL VERSION 6 ADDRESS SPACE'
    http://www.iana.org/assignments/ipv6-address-space
 
+   'Network Address Translation - Protocol Translation (NAT-PT)'
+   http://www.ietf.org/rfc/rfc2766.txt


</body></email><email><emailId>20070713095936</emailId><senderName>coderman</senderName><senderEmail>coderman@gmail.com</senderEmail><timestampReceived>2007-07-13 09:59:36-0400</timestampReceived><subject>Re: constrained socket buffers patch</subject><body>

On 7/13/07, Juliusz Chroboczek &lt;Juliusz.Chroboczek@pps.jussieu.fr&gt; wrote:
&gt; ...
&gt; There is another issue, which doesn't appear in the above.  TCP is
&gt; extremely sensitive to packet loss when the window is smaller than
&gt; 4 packets (fast retransmit doesn't work in that case).  So could
&gt; I suggest a default value for ConstrainedSockSize of 8 kB?

this is a good idea.  16k might be even better if it worked reliably
(the usual default is 32 to 64k).

i've updated the patch to provide better documentation on this option
in the man page and set the default to 8k per your suggestion.[0]

one last note: this should work on win32 sockets and may help reduce
the windows buffer problem. [1]

any feedback testing this patch on vservers or win32 is appreciated.

best regards,


0. updated constrained socket buffers patches:
  http://peertech.org/pub/tor-constrained-sockets-0.1.2.14.patch
  md5:ff2432af49e3348e12de61a795b10840
  sha1:8a18a8a1b2dc872fff03d7611773f615b3382d28
  ---
  http://peertech.org/pub/tor-constrained-sockets-0.2.0.2-alpha.patch
  md5:b53e37863612110e764769b84f527609
  sha1:7e990582ea0a240bd54b3ba7ea97ede72a592856

1. "Windows Buffer Problems (WSAENOBUFS)"
  http://wiki.noreply.org/noreply/TheOnionRouter/WindowsBufferProblems
</body></email><email><emailId>20070716011138</emailId><senderName>coderman</senderName><senderEmail>coderman@gmail.com</senderEmail><timestampReceived>2007-07-16 01:11:38-0400</timestampReceived><subject>Re: constrained socket buffers patch</subject><body>

On 7/13/07, coderman &lt;coderman@gmail.com&gt; wrote:
&gt; ... updated constrained socket buffers patches:

i've updated the previous patches once again:

- provide a warning when DirPort is set and this option is enabled.
providing cached directory entries exacerbates the TCP buffer resource
contention.

- corrected format to 80 lines.

thanks to those who have helped with testing!  this appears to
mitigate the problem to varying degrees.  i am still interested in
feedback for win32 WSAENOBUFS behavior. (still trying to build a win32
tor.exe for those who may want to test it.)

best regards,

http://peertech.org/pub/tor-constrained-sockets-0.1.2.14.patch
md5:93a36cb59d532ec4ff1ace7b256ff85a
sha1:657840dc5973de5a5cd0a52612aab7a6ce709ac2

http://peertech.org/pub/tor-constrained-sockets-0.2.0.2-alpha.patch
md5:1e2876841e71fca33b30732df55bb38f
sha1:79f3ed89ca693a2c152dd598fa513435db1c3879
</body></email><email><emailId>20070702212112</emailId><senderName>Robert Hogan</senderName><senderEmail>robert@roberthogan.net</senderEmail><timestampReceived>2007-07-02 21:21:12-0400</timestampReceived><subject>Re: TODO: Add a way to request DNS resolves from the controller</subject><body>

On Wednesday 27 June 2007 17:20:06 Nick Mathewson wrote:
&lt;snip&gt;
&gt;
&gt; I think the approach you describe above is okay.  It shouldn't break
&gt; backward compatibility, since preexisting controllers will never issue
&gt; RESOLVE commands, and so will never get "650 RESOLVE" events.
&gt;
Hi Nick,

Patch attached. It supports host and reverse lookups.

Sample output:

resolve hotmail.com
250 OK
650 RESOLVE hotmail.com:64.4.32.7
resolve 64.4.32.7
250 OK
650 RESOLVE 64.4.32.7:lc1.bay0.hotmail.com

Let me know what needs cleaning up/reworking.
-- 

Browse Anonymously Anywhere	- http://anonymityanywhere.com
TorK	- KDE Anonymity Manager	- http://tork.sf.net
KlamAV	- KDE Anti-Virus 	- http://www.klamav.net


["controllerresolve.diff" (text/x-diff)]

Index: src/or/control.c
===================================================================
--- src/or/control.c	(revision 10722)
+++ src/or/control.c	(working copy)
@@ -43,7 +43,8 @@
 #define EVENT_STATUS_GENERAL   0x0012
 #define EVENT_GUARD            0x0013
 #define EVENT_STREAM_BANDWIDTH_USED   0x0014
-#define _EVENT_MAX             0x0014
+#define EVENT_RESOLVE_RESPONSE   0x0015
+#define _EVENT_MAX             0x0015
 /* If _EVENT_MAX ever hits 0x0020, we need to make the mask wider. */
 
 /** Bitfield: The bit 1&lt;&lt;e is set if &lt;b&gt;any&lt;/b&gt; open control
@@ -133,6 +134,8 @@
 static int handle_control_closecircuit(control_connection_t *conn,
                                        uint32_t len,
                                        const char *body);
+static int handle_control_resolve(control_connection_t *conn, uint32_t len,
+                            const char *body);
 static int handle_control_usefeature(control_connection_t *conn,
                                      uint32_t len,
                                      const char *body);
@@ -2212,6 +2215,38 @@
   return 0;
 }
 
+static int
+handle_control_resolve(control_connection_t *conn, uint32_t len,
+                            const char *body)
+{
+  smartlist_t *args;
+  (void) len; /* body is nul-terminated; it's safe to ignore the length */
+  args = smartlist_create();
+  smartlist_split_string(args, body, " ",
+                         SPLIT_SKIP_SPACE|SPLIT_IGNORE_BLANK, 0);
+  SMARTLIST_FOREACH(args, const char *, arg, {
+        evdns_server_control(arg);
+  });
+
+  conn-&gt;event_mask |= (1 &lt;&lt; EVENT_RESOLVE_RESPONSE);
+  control_update_global_event_mask();
+
+  SMARTLIST_FOREACH(args, char *, cp, tor_free(cp));
+  smartlist_free(args);
+
+  send_control_done(conn);
+  return 0;
+}
+
+int
+handle_control_resolve_response(const char *question,const char *answer)
+{
+  send_control_event(EVENT_RESOLVE_RESPONSE, ALL_NAMES,
+                            "650 RESOLVE %s:%s\r\n",
+                            question, answer);
+  return 0;
+}
+
 /** Called when we get a USEFEATURE command: parse the feature list, and
  * set up the control_connection's options properly. */
 static int
@@ -2442,6 +2477,9 @@
   } else if (!strcasecmp(conn-&gt;incoming_cmd, "USEFEATURE")) {
     if (handle_control_usefeature(conn, data_len, args))
       return -1;
+  } else if (!strcasecmp(conn-&gt;incoming_cmd, "RESOLVE")) {
+    if (handle_control_resolve(conn, data_len, args))
+      return -1;
   } else {
     connection_printf_to_buf(conn, "510 Unrecognized command \"%s\"\r\n",
                              conn-&gt;incoming_cmd);
Index: src/or/connection_edge.c
===================================================================
--- src/or/connection_edge.c	(revision 10722)
+++ src/or/connection_edge.c	(working copy)
@@ -1189,7 +1189,7 @@
             safe_str(socks-&gt;address),
             socks-&gt;port);
 
-  if (socks-&gt;command == SOCKS_COMMAND_RESOLVE &amp;&amp;
+  if ((SOCKS_COMMAND_IS_RESOLVE_A(socks-&gt;command)) &amp;&amp;
       !tor_inet_aton(socks-&gt;address, &amp;addr_tmp) &amp;&amp;
       options-&gt;AutomapHostsOnResolve &amp;&amp; options-&gt;AutomapHostsSuffixes) {
     SMARTLIST_FOREACH(options-&gt;AutomapHostsSuffixes, const char *, cp,
@@ -1208,7 +1208,7 @@
     }
   }
 
-  if (socks-&gt;command == SOCKS_COMMAND_RESOLVE_PTR) {
+  if (SOCKS_COMMAND_IS_RESOLVE_PTR(socks-&gt;command)) {
     if (addressmap_rewrite_reverse(socks-&gt;address, sizeof(socks-&gt;address))) {
       char *result = tor_strdup(socks-&gt;address);
       /* remember _what_ is supposed to have been resolved. */
@@ -1299,7 +1299,7 @@
       return -1;
     }
 
-    if (socks-&gt;command == SOCKS_COMMAND_RESOLVE) {
+    if (SOCKS_COMMAND_IS_RESOLVE_A(socks-&gt;command)) {
       uint32_t answer;
       struct in_addr in;
       /* Reply to resolves immediately if we can. */
@@ -1355,7 +1355,7 @@
 
       /* help predict this next time */
       rep_hist_note_used_port(socks-&gt;port, time(NULL));
-    } else if (socks-&gt;command == SOCKS_COMMAND_RESOLVE_PTR) {
+    } else if (SOCKS_COMMAND_IS_RESOLVE_PTR(socks-&gt;command)) {
       rep_hist_note_used_resolve(time(NULL)); /* help predict this next time */
     } else if (socks-&gt;command == SOCKS_COMMAND_CONNECT_DIR) {
       ; /* nothing */
@@ -1844,7 +1844,7 @@
     return -1;
   }
 
-  if (command == SOCKS_COMMAND_RESOLVE) {
+  if (SOCKS_COMMAND_IS_RESOLVE_A(command)) {
     string_addr = ap_conn-&gt;socks_request-&gt;address;
     payload_len = strlen(string_addr)+1;
     tor_assert(payload_len &lt;= RELAY_PAYLOAD_SIZE);
@@ -2542,7 +2542,7 @@
       return 0;
   } else if (SOCKS_COMMAND_IS_RESOLVE(conn-&gt;socks_request-&gt;command)) {
     /* Can't support reverse lookups without eventdns. */
-    if (conn-&gt;socks_request-&gt;command == SOCKS_COMMAND_RESOLVE_PTR &amp;&amp;
+    if (SOCKS_COMMAND_IS_RESOLVE_PTR(conn-&gt;socks_request-&gt;command) &amp;&amp;
         exit-&gt;has_old_dnsworkers)
       return 0;
 
Index: src/or/or.h
===================================================================
--- src/or/or.h	(revision 10722)
+++ src/or/or.h	(working copy)
@@ -2095,6 +2095,11 @@
 #define SOCKS_COMMAND_RESOLVE       0xF0
 /** Please turn this IP address into an FQDN, privately. */
 #define SOCKS_COMMAND_RESOLVE_PTR   0xF1
+/** Please turn this FQDN into an IP address, privately. */
+#define SOCKS_COMMAND_RESOLVE_CONTROL       0xF4
+/** Please turn this IP address into an FQDN, privately. */
+#define SOCKS_COMMAND_RESOLVE_PTR_CONTROL   0xF5
+
 /** Please open an encrypted direct TCP connection to the directory port
  * of the Tor server specified by address:port. (In this case address:port
  * specifies the ORPort of the server.) */
@@ -2103,8 +2108,20 @@
 #define SOCKS_COMMAND_IS_CONNECT(c) ((c)==SOCKS_COMMAND_CONNECT || \
                                      (c)==SOCKS_COMMAND_CONNECT_DIR)
 #define SOCKS_COMMAND_IS_RESOLVE(c) ((c)==SOCKS_COMMAND_RESOLVE || \
-                                     (c)==SOCKS_COMMAND_RESOLVE_PTR)
+                                     (c)==SOCKS_COMMAND_RESOLVE_PTR || \
+                                     (c)==SOCKS_COMMAND_RESOLVE_CONTROL || \
+                                     (c)==SOCKS_COMMAND_RESOLVE_PTR_CONTROL)
 
+#define SOCKS_COMMAND_IS_RESOLVE_A(c) \
+                                    ((c)==SOCKS_COMMAND_RESOLVE || \
+                                     (c)==SOCKS_COMMAND_RESOLVE_CONTROL)
+#define SOCKS_COMMAND_IS_RESOLVE_PTR(c) \
+                                    ((c)==SOCKS_COMMAND_RESOLVE_PTR || \
+                                     (c)==SOCKS_COMMAND_RESOLVE_PTR_CONTROL)
+#define SOCKS_COMMAND_IS_RESOLVE_CONTROL(c) \
+                                    ((c)==SOCKS_COMMAND_RESOLVE_CONTROL || \
+                                     (c)==SOCKS_COMMAND_RESOLVE_PTR_CONTROL)
+
 /** State of a SOCKS request from a user to an OP.  Also used to encode other
  * information for non-socks user request (such as those on TransPort and
  * DNSPort) */
@@ -2605,6 +2622,7 @@
 int control_event_stream_status(edge_connection_t *conn,
                                 stream_status_event_t e,
                                 int reason);
+int handle_control_resolve_response(const char *question, const char *answer);
 int control_tls_error_to_reason(int e);
 int control_event_or_conn_status(or_connection_t *conn,
                                  or_conn_status_event_t e, int reason);
@@ -2794,6 +2812,7 @@
 
 void dnsserv_configure_listener(connection_t *conn);
 void dnsserv_close_listener(connection_t *conn);
+
 void dnsserv_resolved(edge_connection_t *conn,
                       int answer_type,
                       size_t answer_len,
@@ -2801,6 +2820,8 @@
                       int ttl);
 void dnsserv_reject_request(edge_connection_t *conn);
 
+void evdns_server_control(const char *name);
+
 /********************************* hibernate.c **********************/
 
 int accounting_parse_options(or_options_t *options, int validate_only);
Index: src/or/buffers.c
===================================================================
--- src/or/buffers.c	(revision 10722)
+++ src/or/buffers.c	(working copy)
@@ -1157,7 +1157,9 @@
       if (req-&gt;command != SOCKS_COMMAND_CONNECT &amp;&amp;
           req-&gt;command != SOCKS_COMMAND_CONNECT_DIR &amp;&amp;
           req-&gt;command != SOCKS_COMMAND_RESOLVE &amp;&amp;
-          req-&gt;command != SOCKS_COMMAND_RESOLVE_PTR) {
+          req-&gt;command != SOCKS_COMMAND_RESOLVE_CONTROL &amp;&amp;
+          req-&gt;command != SOCKS_COMMAND_RESOLVE_PTR &amp;&amp;
+          req-&gt;command != SOCKS_COMMAND_RESOLVE_PTR_CONTROL) {
         /* not a connect or resolve or a resolve_ptr? we don't support it. */
         log_warn(LD_APP,"socks5: command %d not recognized. Rejecting.",
                  req-&gt;command);
@@ -1182,7 +1184,7 @@
           strlcpy(req-&gt;address,tmpbuf,sizeof(req-&gt;address));
           req-&gt;port = ntohs(*(uint16_t*)(buf-&gt;cur+8));
           buf_remove_from_front(buf, 10);
-          if (req-&gt;command != SOCKS_COMMAND_RESOLVE_PTR &amp;&amp;
+          if (!SOCKS_COMMAND_IS_RESOLVE_PTR(req-&gt;command) &amp;&amp;
               !addressmap_have_mapping(req-&gt;address) &amp;&amp;
               !have_warned_about_unsafe_socks) {
             log_warn(LD_APP,
@@ -1203,7 +1205,7 @@
           return 1;
         case 3: /* fqdn */
           log_debug(LD_APP,"socks5: fqdn address type");
-          if (req-&gt;command == SOCKS_COMMAND_RESOLVE_PTR) {
+          if (SOCKS_COMMAND_IS_RESOLVE_PTR(req-&gt;command)) {
             log_warn(LD_APP, "socks5 received RESOLVE_PTR command with "
                      "hostname type. Rejecting.");
             return -1;
@@ -1251,6 +1253,7 @@
       req-&gt;command = (unsigned char) *(buf-&gt;cur+1);
       if (req-&gt;command != SOCKS_COMMAND_CONNECT &amp;&amp;
           req-&gt;command != SOCKS_COMMAND_CONNECT_DIR &amp;&amp;
+          req-&gt;command != SOCKS_COMMAND_RESOLVE_CONTROL &amp;&amp;
           req-&gt;command != SOCKS_COMMAND_RESOLVE) {
         /* not a connect or resolve? we don't support it. (No resolve_ptr with
          * socks4.) */
@@ -1261,7 +1264,8 @@
 
       req-&gt;port = ntohs(*(uint16_t*)(buf-&gt;cur+2));
       destip = ntohl(*(uint32_t*)(buf-&gt;mem+4));
-      if ((!req-&gt;port &amp;&amp; req-&gt;command!=SOCKS_COMMAND_RESOLVE) || !destip) {
+      if ((!req-&gt;port &amp;&amp; !SOCKS_COMMAND_IS_RESOLVE_A(req-&gt;command))
+           || !destip) {
         log_warn(LD_APP,"socks4: Port or DestIP is zero. Rejecting.");
         return -1;
       }
Index: src/or/dnsserv.c
===================================================================
--- src/or/dnsserv.c	(revision 10722)
+++ src/or/dnsserv.c	(working copy)
@@ -145,6 +145,78 @@
   tor_free(q_name);
 }
 
+/* Helper function: called whenever the client sends a resolve request to our
+ * controller.  We need to eventually answer the request &lt;b&gt;req&lt;/b&gt;.
+ */
+void
+evdns_server_control(const char *name)
+{
+  edge_connection_t *conn;
+  struct evdns_server_request *server_req;
+  struct in_addr in;
+  char *q_name;
+  int i;
+  int is_ip_address;
+
+  /* Make a new dummy AP connection, and attach the request to it. */
+  conn = TO_EDGE_CONN(connection_new(CONN_TYPE_AP, AF_INET));
+  conn-&gt;_base.state = AP_CONN_STATE_RESOLVE_WAIT;
+
+  is_ip_address = tor_inet_aton(name, &amp;in);
+
+  if (!is_ip_address)
+    conn-&gt;socks_request-&gt;command = SOCKS_COMMAND_RESOLVE_CONTROL;
+  else
+    conn-&gt;socks_request-&gt;command = SOCKS_COMMAND_RESOLVE_PTR_CONTROL;
+
+  strlcpy(conn-&gt;socks_request-&gt;address, name,
+          sizeof(conn-&gt;socks_request-&gt;address));
+
+  server_req = malloc(sizeof(struct evdns_server_request));
+  if (server_req == NULL) return;
+  memset(server_req, 0, sizeof(struct evdns_server_request));
+
+  server_req-&gt;flags = 0;
+  server_req-&gt;nquestions = 0;
+
+  server_req-&gt;questions = malloc(sizeof(struct evdns_server_question *) * 1);
+  if (server_req-&gt;questions == NULL)
+      return;
+
+  for ( i = 0; i &lt; 1; ++i) {
+      struct evdns_server_question *q;
+      int namelen;
+      namelen = strlen(name);
+      q = malloc(sizeof(struct evdns_server_question) + namelen);
+      if (!q)
+          return;
+      if (!is_ip_address)
+        q-&gt;type = EVDNS_TYPE_A;
+      else
+        q-&gt;type = EVDNS_TYPE_PTR;
+      q-&gt;class = EVDNS_CLASS_INET;
+      memcpy(q-&gt;name, name, namelen+1);
+      server_req-&gt;questions[server_req-&gt;nquestions++] = q;
+  }
+
+  conn-&gt;dns_server_request = server_req;
+
+  connection_add(TO_CONN(conn));
+
+  /* Now, throw the connection over to get rewritten (which will answer it
+  * immediately if it's in the cache, or completely bogus, or automapped),
+  * and then attached to a circuit. */
+  log_info(LD_APP, "Passing request for %s to rewrite_and_attach.",
+           escaped_safe_str(name));
+  q_name = tor_strdup(name); /* q could be freed in rewrite_and_attach */
+  connection_ap_handshake_rewrite_and_attach(conn, NULL, NULL);
+  /* Now, the connection is marked if it was bad. */
+
+  log_info(LD_APP, "Passed request for %s to rewrite_and_attach.",
+           escaped_safe_str(q_name));
+  tor_free(q_name);
+}
+
 /** If there is a pending request on &lt;b&gt;conn&lt;/b&gt; that's waiting for an answer,
  * send back an error and free the request. */
 void
@@ -173,6 +245,22 @@
   if (!req)
     return;
 
+  if (conn-&gt;socks_request-&gt;command == SOCKS_COMMAND_RESOLVE_CONTROL) {
+    handle_control_resolve_response(
+                                conn-&gt;dns_server_request-&gt;questions[0]-&gt;name,
+                                tor_dup_addr(ntohl(get_uint32(answer))));
+    conn-&gt;dns_server_request = NULL;
+    return;
+  }
+
+  if (conn-&gt;socks_request-&gt;command == SOCKS_COMMAND_RESOLVE_PTR_CONTROL) {
+    handle_control_resolve_response(
+                                conn-&gt;dns_server_request-&gt;questions[0]-&gt;name,
+                                answer);
+    conn-&gt;dns_server_request = NULL;
+    return;
+  }
+
   /* XXXX020 Re-do; this is dumb. */
   if (ttl &lt; 60)
     ttl = 60;
@@ -189,7 +277,7 @@
                                      conn-&gt;socks_request-&gt;address,
                                      1, (char*)answer, ttl);
   } else if (answer_type == RESOLVED_TYPE_HOSTNAME &amp;&amp;
-             conn-&gt;socks_request-&gt;command == SOCKS_COMMAND_RESOLVE_PTR) {
+             (SOCKS_COMMAND_IS_RESOLVE_PTR(conn-&gt;socks_request-&gt;command))) {
     char *ans = tor_strndup(answer, answer_len);
     evdns_server_request_add_ptr_reply(req, NULL,
                                        conn-&gt;socks_request-&gt;address,


</body></email><email><emailId>20070702215509</emailId><senderName>Robert Hogan</senderName><senderEmail>robert@roberthogan.net</senderEmail><timestampReceived>2007-07-02 21:55:09-0400</timestampReceived><subject>Re: TODO: Add a way to request DNS resolves from the controller</subject><body>

On Monday 02 July 2007 22:21:12 Robert Hogan wrote:
&gt; On Wednesday 27 June 2007 17:20:06 Nick Mathewson wrote:
&gt; &lt;snip&gt;
&gt;
&gt; &gt; I think the approach you describe above is okay.  It shouldn't break
&gt; &gt; backward compatibility, since preexisting controllers will never issue
&gt; &gt; RESOLVE commands, and so will never get "650 RESOLVE" events.
&gt;
&gt; Hi Nick,
&gt;
&gt; Patch attached. It supports host and reverse lookups.
&gt;
&gt; Sample output:
&gt;
&gt; resolve hotmail.com
&gt; 250 OK
&gt; 650 RESOLVE hotmail.com:64.4.32.7
&gt; resolve 64.4.32.7
&gt; 250 OK
&gt; 650 RESOLVE 64.4.32.7:lc1.bay0.hotmail.com
&gt;
&gt; Let me know what needs cleaning up/reworking.

For a start it didn't handle unknown hostnames, or any other error conditions. 
Nor did it respect the indentation in dnsserv.c. The attached does.

I haven't included a write-up for controlspec.txt.

-- 

Browse Anonymously Anywhere	- http://anonymityanywhere.com
TorK	- KDE Anonymity Manager	- http://tork.sf.net
KlamAV	- KDE Anti-Virus 	- http://www.klamav.net


["controllerresolve.diff" (text/x-diff)]

Index: src/or/control.c
===================================================================
--- src/or/control.c	(revision 10722)
+++ src/or/control.c	(working copy)
@@ -43,7 +43,8 @@
 #define EVENT_STATUS_GENERAL   0x0012
 #define EVENT_GUARD            0x0013
 #define EVENT_STREAM_BANDWIDTH_USED   0x0014
-#define _EVENT_MAX             0x0014
+#define EVENT_RESOLVE_RESPONSE   0x0015
+#define _EVENT_MAX             0x0015
 /* If _EVENT_MAX ever hits 0x0020, we need to make the mask wider. */
 
 /** Bitfield: The bit 1&lt;&lt;e is set if &lt;b&gt;any&lt;/b&gt; open control
@@ -133,6 +134,8 @@
 static int handle_control_closecircuit(control_connection_t *conn,
                                        uint32_t len,
                                        const char *body);
+static int handle_control_resolve(control_connection_t *conn, uint32_t len,
+                            const char *body);
 static int handle_control_usefeature(control_connection_t *conn,
                                      uint32_t len,
                                      const char *body);
@@ -2212,6 +2215,38 @@
   return 0;
 }
 
+static int
+handle_control_resolve(control_connection_t *conn, uint32_t len,
+                            const char *body)
+{
+  smartlist_t *args;
+  (void) len; /* body is nul-terminated; it's safe to ignore the length */
+  args = smartlist_create();
+  smartlist_split_string(args, body, " ",
+                         SPLIT_SKIP_SPACE|SPLIT_IGNORE_BLANK, 0);
+  SMARTLIST_FOREACH(args, const char *, arg, {
+        evdns_server_control(arg);
+  });
+
+  conn-&gt;event_mask |= (1 &lt;&lt; EVENT_RESOLVE_RESPONSE);
+  control_update_global_event_mask();
+
+  SMARTLIST_FOREACH(args, char *, cp, tor_free(cp));
+  smartlist_free(args);
+
+  send_control_done(conn);
+  return 0;
+}
+
+int
+handle_control_resolve_response(const char *question,const char *answer)
+{
+  send_control_event(EVENT_RESOLVE_RESPONSE, ALL_NAMES,
+                            "650 RESOLVE %s:%s\r\n",
+                            question, answer);
+  return 0;
+}
+
 /** Called when we get a USEFEATURE command: parse the feature list, and
  * set up the control_connection's options properly. */
 static int
@@ -2442,6 +2477,9 @@
   } else if (!strcasecmp(conn-&gt;incoming_cmd, "USEFEATURE")) {
     if (handle_control_usefeature(conn, data_len, args))
       return -1;
+  } else if (!strcasecmp(conn-&gt;incoming_cmd, "RESOLVE")) {
+    if (handle_control_resolve(conn, data_len, args))
+      return -1;
   } else {
     connection_printf_to_buf(conn, "510 Unrecognized command \"%s\"\r\n",
                              conn-&gt;incoming_cmd);
Index: src/or/connection_edge.c
===================================================================
--- src/or/connection_edge.c	(revision 10722)
+++ src/or/connection_edge.c	(working copy)
@@ -1189,7 +1189,7 @@
             safe_str(socks-&gt;address),
             socks-&gt;port);
 
-  if (socks-&gt;command == SOCKS_COMMAND_RESOLVE &amp;&amp;
+  if ((SOCKS_COMMAND_IS_RESOLVE_A(socks-&gt;command)) &amp;&amp;
       !tor_inet_aton(socks-&gt;address, &amp;addr_tmp) &amp;&amp;
       options-&gt;AutomapHostsOnResolve &amp;&amp; options-&gt;AutomapHostsSuffixes) {
     SMARTLIST_FOREACH(options-&gt;AutomapHostsSuffixes, const char *, cp,
@@ -1208,7 +1208,7 @@
     }
   }
 
-  if (socks-&gt;command == SOCKS_COMMAND_RESOLVE_PTR) {
+  if (SOCKS_COMMAND_IS_RESOLVE_PTR(socks-&gt;command)) {
     if (addressmap_rewrite_reverse(socks-&gt;address, sizeof(socks-&gt;address))) {
       char *result = tor_strdup(socks-&gt;address);
       /* remember _what_ is supposed to have been resolved. */
@@ -1299,7 +1299,7 @@
       return -1;
     }
 
-    if (socks-&gt;command == SOCKS_COMMAND_RESOLVE) {
+    if (SOCKS_COMMAND_IS_RESOLVE_A(socks-&gt;command)) {
       uint32_t answer;
       struct in_addr in;
       /* Reply to resolves immediately if we can. */
@@ -1355,7 +1355,7 @@
 
       /* help predict this next time */
       rep_hist_note_used_port(socks-&gt;port, time(NULL));
-    } else if (socks-&gt;command == SOCKS_COMMAND_RESOLVE_PTR) {
+    } else if (SOCKS_COMMAND_IS_RESOLVE_PTR(socks-&gt;command)) {
       rep_hist_note_used_resolve(time(NULL)); /* help predict this next time */
     } else if (socks-&gt;command == SOCKS_COMMAND_CONNECT_DIR) {
       ; /* nothing */
@@ -1844,7 +1844,7 @@
     return -1;
   }
 
-  if (command == SOCKS_COMMAND_RESOLVE) {
+  if (SOCKS_COMMAND_IS_RESOLVE_A(command)) {
     string_addr = ap_conn-&gt;socks_request-&gt;address;
     payload_len = strlen(string_addr)+1;
     tor_assert(payload_len &lt;= RELAY_PAYLOAD_SIZE);
@@ -2542,7 +2542,7 @@
       return 0;
   } else if (SOCKS_COMMAND_IS_RESOLVE(conn-&gt;socks_request-&gt;command)) {
     /* Can't support reverse lookups without eventdns. */
-    if (conn-&gt;socks_request-&gt;command == SOCKS_COMMAND_RESOLVE_PTR &amp;&amp;
+    if (SOCKS_COMMAND_IS_RESOLVE_PTR(conn-&gt;socks_request-&gt;command) &amp;&amp;
         exit-&gt;has_old_dnsworkers)
       return 0;
 
Index: src/or/or.h
===================================================================
--- src/or/or.h	(revision 10722)
+++ src/or/or.h	(working copy)
@@ -2095,6 +2095,11 @@
 #define SOCKS_COMMAND_RESOLVE       0xF0
 /** Please turn this IP address into an FQDN, privately. */
 #define SOCKS_COMMAND_RESOLVE_PTR   0xF1
+/** Please turn this FQDN into an IP address, privately. */
+#define SOCKS_COMMAND_RESOLVE_CONTROL       0xF4
+/** Please turn this IP address into an FQDN, privately. */
+#define SOCKS_COMMAND_RESOLVE_PTR_CONTROL   0xF5
+
 /** Please open an encrypted direct TCP connection to the directory port
  * of the Tor server specified by address:port. (In this case address:port
  * specifies the ORPort of the server.) */
@@ -2103,8 +2108,20 @@
 #define SOCKS_COMMAND_IS_CONNECT(c) ((c)==SOCKS_COMMAND_CONNECT || \
                                      (c)==SOCKS_COMMAND_CONNECT_DIR)
 #define SOCKS_COMMAND_IS_RESOLVE(c) ((c)==SOCKS_COMMAND_RESOLVE || \
-                                     (c)==SOCKS_COMMAND_RESOLVE_PTR)
+                                     (c)==SOCKS_COMMAND_RESOLVE_PTR || \
+                                     (c)==SOCKS_COMMAND_RESOLVE_CONTROL || \
+                                     (c)==SOCKS_COMMAND_RESOLVE_PTR_CONTROL)
 
+#define SOCKS_COMMAND_IS_RESOLVE_A(c) \
+                                    ((c)==SOCKS_COMMAND_RESOLVE || \
+                                     (c)==SOCKS_COMMAND_RESOLVE_CONTROL)
+#define SOCKS_COMMAND_IS_RESOLVE_PTR(c) \
+                                    ((c)==SOCKS_COMMAND_RESOLVE_PTR || \
+                                     (c)==SOCKS_COMMAND_RESOLVE_PTR_CONTROL)
+#define SOCKS_COMMAND_IS_RESOLVE_CONTROL(c) \
+                                    ((c)==SOCKS_COMMAND_RESOLVE_CONTROL || \
+                                     (c)==SOCKS_COMMAND_RESOLVE_PTR_CONTROL)
+
 /** State of a SOCKS request from a user to an OP.  Also used to encode other
  * information for non-socks user request (such as those on TransPort and
  * DNSPort) */
@@ -2605,6 +2622,7 @@
 int control_event_stream_status(edge_connection_t *conn,
                                 stream_status_event_t e,
                                 int reason);
+int handle_control_resolve_response(const char *question, const char *answer);
 int control_tls_error_to_reason(int e);
 int control_event_or_conn_status(or_connection_t *conn,
                                  or_conn_status_event_t e, int reason);
@@ -2794,6 +2812,7 @@
 
 void dnsserv_configure_listener(connection_t *conn);
 void dnsserv_close_listener(connection_t *conn);
+
 void dnsserv_resolved(edge_connection_t *conn,
                       int answer_type,
                       size_t answer_len,
@@ -2801,6 +2820,8 @@
                       int ttl);
 void dnsserv_reject_request(edge_connection_t *conn);
 
+void evdns_server_control(const char *name);
+
 /********************************* hibernate.c **********************/
 
 int accounting_parse_options(or_options_t *options, int validate_only);
Index: src/or/buffers.c
===================================================================
--- src/or/buffers.c	(revision 10722)
+++ src/or/buffers.c	(working copy)
@@ -1157,7 +1157,9 @@
       if (req-&gt;command != SOCKS_COMMAND_CONNECT &amp;&amp;
           req-&gt;command != SOCKS_COMMAND_CONNECT_DIR &amp;&amp;
           req-&gt;command != SOCKS_COMMAND_RESOLVE &amp;&amp;
-          req-&gt;command != SOCKS_COMMAND_RESOLVE_PTR) {
+          req-&gt;command != SOCKS_COMMAND_RESOLVE_CONTROL &amp;&amp;
+          req-&gt;command != SOCKS_COMMAND_RESOLVE_PTR &amp;&amp;
+          req-&gt;command != SOCKS_COMMAND_RESOLVE_PTR_CONTROL) {
         /* not a connect or resolve or a resolve_ptr? we don't support it. */
         log_warn(LD_APP,"socks5: command %d not recognized. Rejecting.",
                  req-&gt;command);
@@ -1182,7 +1184,7 @@
           strlcpy(req-&gt;address,tmpbuf,sizeof(req-&gt;address));
           req-&gt;port = ntohs(*(uint16_t*)(buf-&gt;cur+8));
           buf_remove_from_front(buf, 10);
-          if (req-&gt;command != SOCKS_COMMAND_RESOLVE_PTR &amp;&amp;
+          if (!SOCKS_COMMAND_IS_RESOLVE_PTR(req-&gt;command) &amp;&amp;
               !addressmap_have_mapping(req-&gt;address) &amp;&amp;
               !have_warned_about_unsafe_socks) {
             log_warn(LD_APP,
@@ -1203,7 +1205,7 @@
           return 1;
         case 3: /* fqdn */
           log_debug(LD_APP,"socks5: fqdn address type");
-          if (req-&gt;command == SOCKS_COMMAND_RESOLVE_PTR) {
+          if (SOCKS_COMMAND_IS_RESOLVE_PTR(req-&gt;command)) {
             log_warn(LD_APP, "socks5 received RESOLVE_PTR command with "
                      "hostname type. Rejecting.");
             return -1;
@@ -1251,6 +1253,7 @@
       req-&gt;command = (unsigned char) *(buf-&gt;cur+1);
       if (req-&gt;command != SOCKS_COMMAND_CONNECT &amp;&amp;
           req-&gt;command != SOCKS_COMMAND_CONNECT_DIR &amp;&amp;
+          req-&gt;command != SOCKS_COMMAND_RESOLVE_CONTROL &amp;&amp;
           req-&gt;command != SOCKS_COMMAND_RESOLVE) {
         /* not a connect or resolve? we don't support it. (No resolve_ptr with
          * socks4.) */
@@ -1261,7 +1264,8 @@
 
       req-&gt;port = ntohs(*(uint16_t*)(buf-&gt;cur+2));
       destip = ntohl(*(uint32_t*)(buf-&gt;mem+4));
-      if ((!req-&gt;port &amp;&amp; req-&gt;command!=SOCKS_COMMAND_RESOLVE) || !destip) {
+      if ((!req-&gt;port &amp;&amp; !SOCKS_COMMAND_IS_RESOLVE_A(req-&gt;command))
+           || !destip) {
         log_warn(LD_APP,"socks4: Port or DestIP is zero. Rejecting.");
         return -1;
       }
Index: src/or/dnsserv.c
===================================================================
--- src/or/dnsserv.c	(revision 10722)
+++ src/or/dnsserv.c	(working copy)
@@ -145,6 +145,78 @@
   tor_free(q_name);
 }
 
+/* Helper function: called whenever the client sends a resolve request to our
+ * controller.  We need to eventually answer the request &lt;b&gt;req&lt;/b&gt;.
+ */
+void
+evdns_server_control(const char *name)
+{
+  edge_connection_t *conn;
+  struct evdns_server_request *server_req;
+  struct in_addr in;
+  char *q_name;
+  int i;
+  int is_ip_address;
+
+  /* Make a new dummy AP connection, and attach the request to it. */
+  conn = TO_EDGE_CONN(connection_new(CONN_TYPE_AP, AF_INET));
+  conn-&gt;_base.state = AP_CONN_STATE_RESOLVE_WAIT;
+
+  is_ip_address = tor_inet_aton(name, &amp;in);
+
+  if (!is_ip_address)
+    conn-&gt;socks_request-&gt;command = SOCKS_COMMAND_RESOLVE_CONTROL;
+  else
+    conn-&gt;socks_request-&gt;command = SOCKS_COMMAND_RESOLVE_PTR_CONTROL;
+
+  strlcpy(conn-&gt;socks_request-&gt;address, name,
+          sizeof(conn-&gt;socks_request-&gt;address));
+
+  server_req = malloc(sizeof(struct evdns_server_request));
+  if (server_req == NULL) return;
+  memset(server_req, 0, sizeof(struct evdns_server_request));
+
+  server_req-&gt;flags = 0;
+  server_req-&gt;nquestions = 0;
+
+  server_req-&gt;questions = malloc(sizeof(struct evdns_server_question *) * 1);
+  if (server_req-&gt;questions == NULL)
+    return;
+
+  for ( i = 0; i &lt; 1; ++i) {
+    struct evdns_server_question *q;
+    int namelen;
+    namelen = strlen(name);
+    q = malloc(sizeof(struct evdns_server_question) + namelen);
+    if (!q)
+        return;
+    if (!is_ip_address)
+      q-&gt;type = EVDNS_TYPE_A;
+    else
+      q-&gt;type = EVDNS_TYPE_PTR;
+    q-&gt;class = EVDNS_CLASS_INET;
+    memcpy(q-&gt;name, name, namelen+1);
+    server_req-&gt;questions[server_req-&gt;nquestions++] = q;
+  }
+
+  conn-&gt;dns_server_request = server_req;
+
+  connection_add(TO_CONN(conn));
+
+  /* Now, throw the connection over to get rewritten (which will answer it
+  * immediately if it's in the cache, or completely bogus, or automapped),
+  * and then attached to a circuit. */
+  log_info(LD_APP, "Passing request for %s to rewrite_and_attach.",
+           escaped_safe_str(name));
+  q_name = tor_strdup(name); /* q could be freed in rewrite_and_attach */
+  connection_ap_handshake_rewrite_and_attach(conn, NULL, NULL);
+  /* Now, the connection is marked if it was bad. */
+
+  log_info(LD_APP, "Passed request for %s to rewrite_and_attach.",
+           escaped_safe_str(q_name));
+  tor_free(q_name);
+}
+
 /** If there is a pending request on &lt;b&gt;conn&lt;/b&gt; that's waiting for an answer,
  * send back an error and free the request. */
 void
@@ -181,27 +253,49 @@
    * or more of the questions in the request); then, call
    * evdns_server_request_respond. */
   if (answer_type == RESOLVED_TYPE_IPV6) {
-    log_info(LD_APP, "Got an IPv6 answer; that's not implemented.");
-    err = DNS_ERR_NOTIMPL;
+    if (SOCKS_COMMAND_IS_RESOLVE_CONTROL(conn-&gt;socks_request-&gt;command))
+      handle_control_resolve_response(req-&gt;questions[0]-&gt;name,
+                                      "IPv6 not implemented");
+    else {
+      log_info(LD_APP, "Got an IPv6 answer; that's not implemented.");
+      err = DNS_ERR_NOTIMPL;
+    }
   } else if (answer_type == RESOLVED_TYPE_IPV4 &amp;&amp; answer_len == 4 &amp;&amp;
-             conn-&gt;socks_request-&gt;command == SOCKS_COMMAND_RESOLVE) {
-    evdns_server_request_add_a_reply(req,
-                                     conn-&gt;socks_request-&gt;address,
-                                     1, (char*)answer, ttl);
+             SOCKS_COMMAND_IS_RESOLVE_A(conn-&gt;socks_request-&gt;command)) {
+    if (SOCKS_COMMAND_IS_RESOLVE_CONTROL(conn-&gt;socks_request-&gt;command))
+      handle_control_resolve_response(req-&gt;questions[0]-&gt;name,
+                                      tor_dup_addr(ntohl(get_uint32(answer))));
+    else
+      evdns_server_request_add_a_reply(req,
+                                       conn-&gt;socks_request-&gt;address,
+                                       1, (char*)answer, ttl);
   } else if (answer_type == RESOLVED_TYPE_HOSTNAME &amp;&amp;
-             conn-&gt;socks_request-&gt;command == SOCKS_COMMAND_RESOLVE_PTR) {
-    char *ans = tor_strndup(answer, answer_len);
-    evdns_server_request_add_ptr_reply(req, NULL,
+             (SOCKS_COMMAND_IS_RESOLVE_PTR(conn-&gt;socks_request-&gt;command))) {
+    if (SOCKS_COMMAND_IS_RESOLVE_CONTROL(conn-&gt;socks_request-&gt;command))
+      handle_control_resolve_response(req-&gt;questions[0]-&gt;name, answer);
+    else {
+      char *ans = tor_strndup(answer, answer_len);
+      evdns_server_request_add_ptr_reply(req, NULL,
                                        conn-&gt;socks_request-&gt;address,
                                        (char*)answer, ttl);
-    tor_free(ans);
+      tor_free(ans);
+    }
   } else if (answer_type == RESOLVED_TYPE_ERROR) {
-    err = DNS_ERR_NOTEXIST;
+    if (SOCKS_COMMAND_IS_RESOLVE_CONTROL(conn-&gt;socks_request-&gt;command))
+      handle_control_resolve_response(req-&gt;questions[0]-&gt;name, "Unknown Host");
+    else
+      err = DNS_ERR_NOTEXIST;
   } else { /* answer_type == RESOLVED_TYPE_ERROR_TRANSIENT */
-    err = DNS_ERR_SERVERFAILED;
+    if (SOCKS_COMMAND_IS_RESOLVE_CONTROL(conn-&gt;socks_request-&gt;command))
+      handle_control_resolve_response(req-&gt;questions[0]-&gt;name,
+                                      "Temporary Error");
+    else
+      err = DNS_ERR_SERVERFAILED;
   }
 
-  evdns_server_request_respond(req, err);
+  if (!SOCKS_COMMAND_IS_RESOLVE_CONTROL(conn-&gt;socks_request-&gt;command))
+    evdns_server_request_respond(req, err);
+
   conn-&gt;dns_server_request = NULL;
 }
 


</body></email><email><emailId>20070718103122</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-07-18 10:31:22-0400</timestampReceived><subject>Proposal: minimum advertised bandwidth guarantees fast/guard</subject><body>

Hi folks,

This is a quick proposal, based on my post in Mike Perry's recent thread
at http://archives.seul.org/or/dev/Jul-2007/msg00022.html
Please feel free to flesh it out; also somebody should please write us
a patch to the specs.

The issue is the same attack as in proposal 107: an attacker who signs
up a thousand servers each claiming 10MB/s bandwidth will cause the
median bandwidth to be 10MB/s, and all current guards will lose their
guard status -- causing their users to abandon them and pick one of the
new adversary-controlled nodes. The bug is that while we cap bandwidth
at 1.5MB/s when considering load balancing, we failed to do it when
considering median bandwidth for guard qualification.

I've attached a patch; but there are still some design questions to
ponder and maybe improve:

A) I picked 500KB/s as the cutoff. Is there a better way to pick this?

B) I chose to assign guard status to all stable nodes that meet this
cutoff -- even exit nodes. We could instead just make the exception for
non-exit nodes, which would be better for load balancing when exits are
rare. But having sufficient guards is useful too.

C) Since we defined is_possible_guard to require is_fast, there was
another turtle underneath this turtle. I fixed this by declaring that
anybody with at least 100KB/s of bandwidth is automatically Fast. We
could also fix it by getting rid of the is_fast requirement; but I think
if we do that I'll be doing a new proposal later about how somebody can
sign up 8000 new servers and suddenly no other servers count as Fast. ;)

D) Why 100KB/s? Is there a better number?



Index: dirserv.c
===================================================================
--- dirserv.c	(revision 10861)
+++ dirserv.c	(working copy)
@@ -1436,6 +1436,8 @@
  * network using allegedly high-uptime nodes, displacing all the
  * current guards. */
 #define UPTIME_TO_GUARANTEE_STABLE (3600*24*30)
+#define BANDWIDTH_TO_GUARANTEE_FAST 100000
+#define BANDWIDTH_TO_GUARANTEE_GUARD 500000
 
 /* Thresholds for server performance: set by
  * dirserv_compute_performance_thresholds, and used by
@@ -1474,9 +1476,11 @@
         (unsigned)uptime &lt; UPTIME_TO_GUARANTEE_STABLE)
       return 1;
   }
-  if (need_capacity &amp;&amp;
-      router_get_advertised_bandwidth(router) &lt; fast_bandwidth)
-    return 1;
+  if (need_capacity) {
+    uint32_t bw = router_get_advertised_bandwidth(router);
+    if (bw &lt; fast_bandwidth &amp;&amp; bw &lt; BANDWIDTH_TO_GUARANTEE_FAST)
+      return 1;
+  }
   return 0;
 }
 
@@ -1709,9 +1713,10 @@
   rs-&gt;is_valid = ri-&gt;is_valid;
   rs-&gt;is_possible_guard = rs-&gt;is_fast &amp;&amp; rs-&gt;is_stable &amp;&amp;
     (!rs-&gt;is_exit || exits_can_be_guards) &amp;&amp;
-    router_get_advertised_bandwidth(ri) &gt;=
-    (exits_can_be_guards ? guard_bandwidth_including_exits :
-     guard_bandwidth_excluding_exits);
+    (router_get_advertised_bandwidth(ri) &gt;= BANDWIDTH_TO_GUARANTEE_GUARD ||
+     router_get_advertised_bandwidth(ri) &gt;=
+     (exits_can_be_guards ? guard_bandwidth_including_exits :
+      guard_bandwidth_excluding_exits));
   rs-&gt;is_bad_exit = listbadexits &amp;&amp; ri-&gt;is_bad_exit;
   /* 0.1.1.9-alpha is the first version to support fetch by descriptor
    * hash. */

</body></email><email><emailId>20070724171825</emailId><senderName>Robert Hogan</senderName><senderEmail>robert@roberthogan.net</senderEmail><timestampReceived>2007-07-24 17:18:25-0400</timestampReceived><subject>[PATCH] dns_server_port not getting stored</subject><body>

Not sure why I didn't notice this one before.

There's a race condition (or something) when you unset dnsport - because the 
conn disappears but the eventdns callback doesn't. The patch fixes it.

Also added the conn-type to a couple of condition statements that it seemed to 
belong to.

-- 

Browse Anonymously Anywhere	- http://anonymityanywhere.com
TorK	- KDE Anonymity Manager	- http://tork.sf.net
KlamAV	- KDE Anti-Virus 	- http://www.klamav.net


["closednsport.patch" (text/x-diff)]

Index: src/or/hibernate.c
===================================================================
--- src/or/hibernate.c	(revision 10923)
+++ src/or/hibernate.c	(working copy)
@@ -771,6 +771,7 @@
   while ((conn = connection_get_by_type(CONN_TYPE_OR_LISTENER)) ||
          (conn = connection_get_by_type(CONN_TYPE_AP_LISTENER)) ||
          (conn = connection_get_by_type(CONN_TYPE_AP_TRANS_LISTENER)) ||
+         (conn = connection_get_by_type(CONN_TYPE_AP_DNS_LISTENER)) ||
          (conn = connection_get_by_type(CONN_TYPE_AP_NATD_LISTENER)) ||
          (conn = connection_get_by_type(CONN_TYPE_DIR_LISTENER))) {
     log_info(LD_NET,"Closing listener type %d", conn-&gt;type);
Index: src/or/connection.c
===================================================================
--- src/or/connection.c	(revision 10923)
+++ src/or/connection.c	(working copy)
@@ -2423,6 +2423,7 @@
   if (conn-&gt;type == CONN_TYPE_OR_LISTENER ||
       conn-&gt;type == CONN_TYPE_AP_LISTENER ||
       conn-&gt;type == CONN_TYPE_AP_TRANS_LISTENER ||
+      conn-&gt;type == CONN_TYPE_AP_DNS_LISTENER ||
       conn-&gt;type == CONN_TYPE_AP_NATD_LISTENER ||
       conn-&gt;type == CONN_TYPE_DIR_LISTENER ||
       conn-&gt;type == CONN_TYPE_CONTROL_LISTENER)
Index: src/or/dnsserv.c
===================================================================
--- src/or/dnsserv.c	(revision 10923)
+++ src/or/dnsserv.c	(working copy)
@@ -255,7 +255,8 @@
   tor_assert(conn-&gt;s);
   tor_assert(conn-&gt;type == CONN_TYPE_AP_DNS_LISTENER);
 
-  evdns_add_server_port(conn-&gt;s, 0, evdns_server_callback, NULL);
+  conn-&gt;dns_server_port = evdns_add_server_port(conn-&gt;s, 0,
+                                                evdns_server_callback, NULL);
 }
 
 /** Free the evdns server port for &lt;b&gt;conn&lt;/b&gt;, which must be an


</body></email><email><emailId>20070727073038</emailId><senderName>Shachar Shemesh</senderName><senderEmail>shachar@shemesh.biz</senderEmail><timestampReceived>2007-07-27 07:30:38-0400</timestampReceived><subject>OR outgoing IP address</subject><body>

Hi list,

I'm running OR hamakor (tor.hamakor.org.il). The machine in question has
two IP addresses, and I've almost dedicated the second of which to tor.
The purpose of this was to allow me to track the tor bandwidth usage.

Unfortunately, things are not working as planned. While incoming
connections arrive at the right address, outgoing connections go out
through the main IP address of the machine. This mean that:
1. The TOR checks fail
2. I cannot log usage properly

I'm not sure it is at all possible to easily solve this (I'm thinking of
a solution, but it's not easy to implement, definitely not in a
cross-platform way), but it is a problem worth keeping in mind.

Thanks,
Shachar
</body></email><email><emailId>20070728053454</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-07-28 05:34:54-0400</timestampReceived><subject>Correct formulas for exit weights [was Re: Exit Balancing Patch]</subject><body>


On Wed, Jul 18, 2007 at 01:36:02AM -0700, Mike Perry wrote:
 [...]
&gt; Presently, Tor attempts to balance exit node usage thusly (from
&gt; path-spec.txt):
&gt; 
&gt;   For non-exit positions on "fast" circuits, we pick routers as
&gt;   above, but we weight the clipped advertised bandwidth of
&gt;   Exit-flagged nodes depending on the fraction of bandwidth
&gt;   available from non-Exit nodes.  Call the total clipped advertised
&gt;   bandwidth for Exit nodes under consideration E, and the total
&gt;   clipped advertised bandwidth for non-Exit nodes under
&gt;   consideration N.  If E&lt;N/2, we do not consider Exit-flagged nodes.
&gt;   Otherwise, we weight their bandwidth with the factor
&gt;   (E-N/2)/(N+E-N/2) == (2E - N)/(2E + N).  This ensures that
&gt;   bandwidth is evenly distributed over nodes in 3-hop paths.
     [...]

Man.  That part of tor-spec.txt has to be just about the worst, most
unclear, paragraph that I've written in ages.  I'll try to analyze the
formulas in question and show more about how I derived them.  With any
luck, if I'm making a mistake, somebody will be able to show me where
it is.

[I'm writing this parenthetical after having gone through the
 derivation.  Summary: I got the same result as Mike.]

(Most of this won't be news to most of you, but I want to be really
explicit in order to try to expose the flaws in my logic.)

(Oh yeah. You'll want to view this in a fixed-width font, or your head
will hurt.)

Our goal is to decide how to select Exit nodes as middlemen.  For
purposes of discussion, we'll assume that our goal is to use all of
the bandwidth of all nodes equally.  When we pick nodes, we weight the
probability of choosing any given node by the node's bandwidth.  To
avoid overloading exits, when considering exits for middleman
positions, we weight their bandwidth by some factor w.  (As a
simplifying assumption, assume that we choose the nodes in a path
independently.)

Let's suppose that we build an L-hop circuit, and send some amount of
bytes B through that circuit.  We will always pick an Exit as the last
hop.  For the other L-1 hops, we will pick an Exit with probability Pe =
(w*E)/(w*E+N) and we will pick a non-Exit with probability Pn = N/(w*E+N).

Thus, the expected number of bytes relayed by exits is:
      B                                    (for the exit hop)
    + B * (L-1) * Pe                       (for all the other hops)
Call this quantity BE.

The expected number of bytes relayed by non-exits is:
      B * (L-1) * Pn
Call this quantity BN.

How should we choose w?  We'd like to have the property that the ratio
of expected usage between exit and non-exit is about the same as the
ratio of capacity between exit and non-exit.  In other words, we want
BE/BN = E/N.

Setting up the equation gives:

    B[ 1 + (L-1) * (w*E) / (w*E+N) ]      E
    --------------------------------  =  ---
    B[ (L-1) * N / (w*E+N) ]              N

The B's cancel each other.   We then multiply the numerator and denominator
of the left-hand fraction by (w*E+N) to get:

    w*E + N + (L-1)*(w*E)     E
    --------------------- =  ---
           (L-1)*N            N

Multiplying both sides of the equation by (L-1)*N gives:

    w*E + N + (L-1)*(w*E)  =  E(L-1)

Collecting w-terms on one side and non-w terms on the other gives:

    w*E + (L-1)*(w*E)      = E(L-1) - N

Simplifying:

    w*E*(1+L-1) = E(L-1) - N
    w*E*L       = E(L-1) - N

        E(L-1) - N
    w = -----------
          E*L

Note in practice that if this equation gives a value of w less than 0,
it means that there is too little exit bandwidth for us to distribute
bandwidth evenly over exit and non-exit nodes.

Let's check for some boundary conditions and special cases.  When
N=(L-1)*E, we have just enough exit bandwidth to match the non-exit
bandwidth, and w=0.  For L=3 (as in Tor today, mostly), we have w =
(2E-N)/3E.  In terms of T, that's

  w = [2E - (T-E)] / 3E = (3E - T) / 3E = 1 - T/3E.

Okay, that looks like the result Mike got.  Hooray!

So long as we're doing this, let's do it properly and expand our model
a little, to consider cannibalized circuits and non-3-hop paths.
These questions are mostly for Roger, but anybody else who has
empirical data should step up too:

1) Roger, can you comment on the average path length in practice?  Is it
   close enough to that we should just set L=3?

2) What fraction of circuits are cannibalized?  If all L-hop circuits
   that already end at an Exit are (with probability Pc) cannibalized
   and extended to another Exit, we now have
     BE = (1+Pc)*B + B*(L-1) * Pe,
   which changes our analysis a little.

Right.  Time for me to sleep.  Clearly, I need it.

peace,
-- 
Nick Mathewson

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070730012534</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-07-30 01:25:34-0400</timestampReceived><subject>Re: [or-cvs] r10974: Be even more aggressive about separating local traffic from  (in tor/trunk: . d</subject><body>


On Sun, Jul 29, 2007 at 06:13:45PM -0400, arma@seul.org wrote:
&gt; Author: arma
&gt; Date: 2007-07-29 18:13:44 -0400 (Sun, 29 Jul 2007)
&gt; New Revision: 10974
&gt; 
&gt; Modified:
&gt;    tor/trunk/ChangeLog
&gt;    tor/trunk/doc/spec/proposals/111-local-traffic-priority.txt
&gt;    tor/trunk/src/or/circuitbuild.c
&gt;    tor/trunk/src/or/circuitlist.c
&gt;    tor/trunk/src/or/command.c
&gt;    tor/trunk/src/or/connection.c
&gt;    tor/trunk/src/or/or.h
&gt;    tor/trunk/src/or/relay.c
&gt; Log:
&gt; Be even more aggressive about separating local traffic from relayed
&gt; traffic when RelayBandwidthRate is set. (Refines proposal 111.)
 [...]
&gt; +  Option 4: put both classes of circuits over a single connection, and
&gt; +  keep track of the last time we read or wrote a high-priority cell. If
&gt; +  it's been less than N seconds, give the whole connection high priority,
&gt; +  else give the whole connection low priority.

Hm.  Is it a problem that this approach makes it trivial for an attacker
to tell when you've been online recently (to about the nearest second),
and to learn your guard nodes?

This seems somehow worse than the partitioning problem with "option
2", since this is something anybody can do remotely, rather than
requiring the attacker to eavesdrop or be one of your guards.



-- 
Nick Mathewson

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070718083602</emailId><senderName>Mike Perry</senderName><senderEmail>mikeperry@fscked.org</senderEmail><timestampReceived>2007-07-18 08:36:02-0400</timestampReceived><subject>Exit Balancing Patch</subject><body>

[Attachment #2 (multipart/mixed)]


I figure that this probably should be reviewed on or-dev, since it is
a relatively small patch to smartlist_choose_by_bandwidth, but with
potentially large implications for load balancing on Tor (which I
believe is broken). Since balancing is key to usability and thus
anonymity, I believe this patch should go into both 0.1.2.x and 0.2.0.


Presently, Tor attempts to balance exit node usage thusly (from
path-spec.txt):

  For non-exit positions on "fast" circuits, we pick routers as
  above, but we weight the clipped advertised bandwidth of Exit-flagged
  nodes depending on the fraction of bandwidth available from non-Exit
  nodes.  Call the total clipped advertised bandwidth for Exit nodes
  under consideration E, and the total clipped advertised bandwidth for
  non-Exit nodes under consideration N.  If E&lt;N/2, we do not consider
  Exit-flagged nodes.  Otherwise, we weight their bandwidth with the
  factor (E-N/2)/(N+E-N/2) == (2E - N)/(2E + N).  This ensures that
  bandwidth is evenly distributed over nodes in 3-hop paths.


It is possible this formula is vaguely/empirically correct, but it is
so obtuse I think it should be replaced with the more straightforward
calculation with T being the Total network bandwidth (exit+nonexit):

- if E &lt; T/3 we do not consider exit-flagged nodes (and never choose
  them for entry and middle positions)

- else (if E &gt; T/3) we take the leftover E-T/3, divide it by E and get
  exit_weight=(E-T/3)/E. This will be used to weight the bandwidth of
  all exit-flagged nodes.

It is easy to demonstrate that the sum of the weighted total available
exit bandwidth is E-T/3 using this formula, which is the "leftover"
bandwidth after exits are used in one third of all node choices
(assuming the network is otherwise balanced). The original formula
may also provably correct, but I'm not sure how to go about it. It
seems wrong to me though.

This formula is also much more readily adaptable to 2 and 4 hop paths
than the above formula.


Additionally, the patch does the following two things:
1. Expand MAX_BELIEVABLE_BANDWIDTH from 1.5MBytes/sec to 10Mbytes/sec. 
   We already have several Tor nodes with near 5Mbytes/sec. Capping them 
   at 1.5MBytes/sec artifically dumps load on slower nodes. There are
   effective ways to detect/prevent liars. This #define is not one of 
   them. If any nodes exceed the limit, the Tor client will print
   out a notice (mostly just to tell us we need to raise it again).

2. Explicitly ensure we don't return exits if one wasn't requested or 
   the exit_weight=0. It may be a wasted check though, since 
   exit_weight should prevent the tmp variable from exceeding the
   selected bw for exit nodes.

-- 
Mike Perry
Mad Computer Scientist
fscked.org evil labs

["exit.diff" (text/plain)]

Index: src/or/routerlist.c
===================================================================
--- src/or/routerlist.c	(revision 10850)
+++ src/or/routerlist.c	(working copy)
@@ -1145,7 +1145,7 @@
 
 /** Do not weight any declared bandwidth more than this much when picking
  * routers by bandwidth. */
-#define MAX_BELIEVABLE_BANDWIDTH 1500000 /* 1.5 MB/sec */
+#define MAX_BELIEVABLE_BANDWIDTH 10000000 /* 10 MB/sec */
 
 /** Helper function:
  * choose a random element of smartlist &lt;b&gt;sl&lt;/b&gt;, weighted by
@@ -1155,7 +1155,8 @@
  * routerinfo_t's. Otherwise it's a list of routerstatus_t's.
  *
  * If &lt;b&gt;for_exit&lt;/b&gt;, we're picking an exit node: consider all nodes'
- * bandwidth equally regardless of their Exit status.  If not &lt;b&gt;for_exit&lt;/b&gt;,
+ * bandwidth equally regardless of their Exit status, since there may be
+ * some in the list because they exit to obscure ports. If not &lt;b&gt;for_exit&lt;/b&gt;,
  * we're picking a non-exit node: weight exit-node's bandwidth less
  * depending on the smallness of the fraction of Exit-to-total bandwidth.
  */
@@ -1164,7 +1165,7 @@
 {
   int i;
   routerinfo_t *router;
-  routerstatus_t *status;
+  routerstatus_t *status=NULL;
   int32_t *bandwidths;
   int is_exit;
   uint64_t total_nonexit_bw = 0, total_exit_bw = 0, total_bw = 0;
@@ -1202,8 +1203,22 @@
       this_bw = router_get_advertised_bandwidth(router);
     }
     /* if they claim something huge, don't believe it */
-    if (this_bw &gt; MAX_BELIEVABLE_BANDWIDTH)
+    if (this_bw &gt; MAX_BELIEVABLE_BANDWIDTH) {
+      char fp[HEX_DIGEST_LEN+1];
+      if (status) {
+          base16_encode(fp, sizeof(fp),
+                  status-&gt;identity_digest, DIGEST_LEN);
+      } else if (router) {
+          base16_encode(fp, sizeof(fp),
+                  router-&gt;cache_info.identity_digest, DIGEST_LEN);
+      }
+      log_notice(LD_DIR,
+          "Bandwidth %d for router %s (%s) exceeds allowed max %d, capping",
+          this_bw, router ? router-&gt;nickname : "(null)",
+          status || router ? fp : "0",
+          MAX_BELIEVABLE_BANDWIDTH);
       this_bw = MAX_BELIEVABLE_BANDWIDTH;
+    }
     if (is_known) {
       bandwidths[i] = (int32_t) this_bw; // safe since MAX_BELIEVABLE&lt;INT32_MAX
       if (is_exit)
@@ -1250,20 +1265,22 @@
 
   /* Figure out how to weight exits. */
   if (for_exit) {
-    /* If we're choosing an exit node, exit bandwidth counts fully. */
+    /* If we're choosing an exit node, presumably all nodes in the list
+     * can access our port. Count total */
     exit_weight = 1.0;
     total_bw = total_exit_bw + total_nonexit_bw;
-  } else if (total_exit_bw &lt; total_nonexit_bw / 2) {
+  } else if (total_exit_bw &lt; (total_nonexit_bw+total_exit_bw) / 3) {
     /* If we're choosing a relay and exits are greatly outnumbered, ignore
      * them. */
     exit_weight = 0.0;
     total_bw = total_nonexit_bw;
   } else {
-    /* If we're choosing a relay and exits aren't outnumbered use the formula
-     * from path-spec. */
-    uint64_t leftover = (total_exit_bw - total_nonexit_bw / 2);
-    exit_weight = U64_TO_DBL(leftover) /
-      U64_TO_DBL(leftover + total_nonexit_bw);
+    /* If the total exit bandwidth is greater than ONE THIRD of the
+     * TOTAL network bandwidth then the leftover = E-T/3. The weight ratio
+     * is then (E-T/3)/E. */
+    uint64_t leftover = total_exit_bw-(total_exit_bw+total_nonexit_bw)/3;
+    exit_weight = U64_TO_DBL(leftover)/U64_TO_DBL(total_exit_bw);
+
     total_bw =  total_nonexit_bw +
       DBL_TO_U64(exit_weight * U64_TO_DBL(total_exit_bw));
   }
@@ -1292,6 +1309,11 @@
       tmp += ((uint64_t)(bandwidths[i] * exit_weight));
     else
       tmp += bandwidths[i];
+
+    /* Don't return exits if not requested and they are scarce */
+    if (is_exit &amp;&amp; !(for_exit || exit_weight &gt; 0.0))
+      continue;
+
     if (tmp &gt;= rand_bw)
       break;
   }
Index: doc/spec/path-spec.txt
===================================================================
--- doc/spec/path-spec.txt	(revision 10850)
+++ doc/spec/path-spec.txt	(working copy)
@@ -182,17 +182,16 @@
    proportional to its advertised bandwidth [the smaller of the 'rate' and
    'observed' arguments to the "bandwidth" element in its descriptor].  If a
    router's advertised bandwidth is greater than MAX_BELIEVABLE_BANDWIDTH
-   (1.5 MB/s), we clip to that value.
+   (10 MB/s), we clip to that value.
 
    For non-exit positions on "fast" circuits, we pick routers as above, but
    we weight the clipped advertised bandwidth of Exit-flagged nodes depending
    on the fraction of bandwidth available from non-Exit nodes.  Call the
    total clipped advertised bandwidth for Exit nodes under consideration E,
-   and the total clipped advertised bandwidth for non-Exit nodes under
-   consideration N.  If E&lt;N/2, we do not consider Exit-flagged nodes.
-   Otherwise, we weight their bandwidth with the factor (E-N/2)/(N+E-N/2) ==
-   (2E - N)/(2E + N).  This ensures that bandwidth is evenly distributed over
-   nodes in 3-hop paths.
+   and the total clipped advertised bandwidth for all nodes under
+   consideration T.  If E&lt;T/3, we do not consider Exit-flagged nodes.
+   Otherwise, we weight their bandwidth with the factor (E-T/3)/E. This 
+   ensures that bandwidth is evenly distributed over nodes in 3-hop paths.
 
    Additionally, we may be building circuits with one or more requests in
    mind.  Each kind of request puts certain constraints on paths:

[Attachment #6 (application/pgp-signature)]

</body></email><email><emailId>20070718085558</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-07-18 08:55:58-0400</timestampReceived><subject>Re: Exit Balancing Patch</subject><body>

On Wed, Jul 18, 2007 at 01:36:02AM -0700, Mike Perry wrote:
&gt; 1. Expand MAX_BELIEVABLE_BANDWIDTH from 1.5MBytes/sec to 10Mbytes/sec. 
&gt;    We already have several Tor nodes with near 5Mbytes/sec. Capping them 
&gt;    at 1.5MBytes/sec artifically dumps load on slower nodes.

Hi Mike,

On the theory that if I plan to answer everything I'll answer nothing,
here is a first response to this little piece.

It's true that this doesn't distribute load ideally, but putting the
cap lower than some of the running routers can prevent an attacker from
publishing a majority of absurdly fast routers and pushing every guard
guard out of having guard status -- similar to the attack described
in
https://tor.eff.org/svn/trunk/doc/spec/proposals/107-uptime-sanity-checking.txt

Actually, I just checked the code, and that attack works right now. :(
We should consider modifying router_get_advertised_bandwidth() to cap
its answer at MAX_BELIEVABLE_BANDWIDTH, so the smartlist we build in
dirserv_compute_performance_thresholds() won't list the higher bandwidths.

One solution would be to have a bandwidth level above which you're
*always* guard-worthy, and a separate value for the rate-limiting stuff.

The reason this number is particularly low still is because back when
I picked it, we had problems where Tor servers on fast pipes couldn't
handle the throughput Tor was sending towards them (due to cpu limits,
etc), so I needed to decrease the attention they were getting. I no
longer have a good handle on the fast Tor servers out there right now,
so I have no idea if this is still smart or no longer smart. We do still
hear on or-talk from people running fast Tor servers on slow CPUs that
are bottlenecked by AES, though. Hm.

--Roger

</body></email><email><emailId>20070718091856</emailId><senderName>Mike Perry</senderName><senderEmail>mikeperry@fscked.org</senderEmail><timestampReceived>2007-07-18 09:18:56-0400</timestampReceived><subject>Re: Exit Balancing Patch</subject><body>


Thus spake Roger Dingledine (arma@mit.edu):

&gt; On Wed, Jul 18, 2007 at 01:36:02AM -0700, Mike Perry wrote:
&gt; &gt; 1. Expand MAX_BELIEVABLE_BANDWIDTH from 1.5MBytes/sec to 10Mbytes/sec. 
&gt; &gt;    We already have several Tor nodes with near 5Mbytes/sec. Capping them 
&gt; &gt;    at 1.5MBytes/sec artifically dumps load on slower nodes.
&gt; 
&gt; Hi Mike,
&gt; 
&gt; On the theory that if I plan to answer everything I'll answer nothing,
&gt; here is a first response to this little piece.

I like this idea. Though beware, it can lead you down the dark and
lonely road of replying to yourself 3 times on a mailinglist while
there are otherwise nothing but crickets ;)
 
&gt; It's true that this doesn't distribute load ideally, but putting the
&gt; cap lower than some of the running routers can prevent an attacker from
&gt; publishing a majority of absurdly fast routers and pushing every guard
&gt; guard out of having guard status -- similar to the attack described
&gt; in
&gt; https://tor.eff.org/svn/trunk/doc/spec/proposals/107-uptime-sanity-checking.txt
&gt; 
&gt; Actually, I just checked the code, and that attack works right now. :(

Yeah, I see no reason why this attack can't work just by picking a
bunch of routers at whatever bandwidth limit is chosen. It seems
orthogonal to this patch.

&gt; We should consider modifying router_get_advertised_bandwidth() to cap
&gt; its answer at MAX_BELIEVABLE_BANDWIDTH, so the smartlist we build in
&gt; dirserv_compute_performance_thresholds() won't list the higher bandwidths.
&gt;
&gt; One solution would be to have a bandwidth level above which you're
&gt; *always* guard-worthy, and a separate value for the rate-limiting stuff.

Yeah. Both values should have nothing to do with this clipping
nonsense though. It is possible to detect bandwidth liars/overloaded
nodes via other means (scanning, peer-monitoring).

&gt; The reason this number is particularly low still is because back when
&gt; I picked it, we had problems where Tor servers on fast pipes couldn't
&gt; handle the throughput Tor was sending towards them (due to cpu limits,
&gt; etc), so I needed to decrease the attention they were getting. I no
&gt; longer have a good handle on the fast Tor servers out there right now,
&gt; so I have no idea if this is still smart or no longer smart. We do still
&gt; hear on or-talk from people running fast Tor servers on slow CPUs that
&gt; are bottlenecked by AES, though. Hm.

Why does it matter if routers are CPU or network bound? From the Tor
network routing point of view, it shouldn't matter, capacity is
capacity. If it is a problem for node operators, they limit their
bandwidth in the config, problem solved. If they don't, then they just
run at 100% CPU, and Tor should still properly report their observed
bandwidth rate (unless they lie, but again, that is a another,
orthogonal matter).

-- 
Mike Perry
Mad Computer Scientist
fscked.org evil labs

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070718092555</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-07-18 09:25:55-0400</timestampReceived><subject>Re: Exit Balancing Patch</subject><body>

On Wed, Jul 18, 2007 at 02:18:56AM -0700, Mike Perry wrote:
&gt; &gt;  We do still
&gt; &gt; hear on or-talk from people running fast Tor servers on slow CPUs that
&gt; &gt; are bottlenecked by AES, though. Hm.
&gt; 
&gt; Why does it matter if routers are CPU or network bound? From the Tor
&gt; network routing point of view, it shouldn't matter, capacity is
&gt; capacity. If it is a problem for node operators, they limit their
&gt; bandwidth in the config, problem solved. If they don't, then they just
&gt; run at 100% CPU, and Tor should still properly report their observed
&gt; bandwidth rate (unless they lie, but again, that is a another,
&gt; orthogonal matter).

Well, the problem is that Tor in fact doesn't properly report capacity at
the extremes. Our measure of capacity is the most you've seen yourself
burst in the past day -- it pretty much assumes that the pipe and other
resources you have are static throughout the day.

So if you somehow managed to push a lot briefly but you're too busy to
handle that level of traffic sustained, then you've overadvertised.

Putting a cap on advertised bandwidth when load balancing is a crude way
to account for this. Making our bandwidth estimate more complex may also
work, but then we have to figure out what's better. :)

--Roger

</body></email><email><emailId>20070718093206</emailId><senderName>coderman</senderName><senderEmail>coderman@gmail.com</senderEmail><timestampReceived>2007-07-18 09:32:06-0400</timestampReceived><subject>Re: Exit Balancing Patch</subject><body>

On 7/18/07, Roger Dingledine &lt;arma@mit.edu&gt; wrote:
&gt; On Wed, Jul 18, 2007 at 01:36:02AM -0700, Mike Perry wrote:
&gt; &gt; 1. Expand MAX_BELIEVABLE_BANDWIDTH from 1.5MBytes/sec to 10Mbytes/sec.
&gt; ...
&gt; It's true that this doesn't distribute load ideally, but putting the
&gt; cap lower than some of the running routers can prevent an attacker from
&gt; publishing a majority of absurdly fast routers and pushing every guard
&gt; guard out of having guard status -- similar to the attack described
&gt; in ...uptime-sanity-checking.txt

we were just discussing this today in #tor.  router "ghettogear"
consistently averaged 210-260KB/sec for weeks.  then on the 14th/15th
it went to 20.5MB/sec.  [likely too obvious] it then dropped to
6.1MB/sec; still enough to sit at the top of the node bw list (next
closest, blutmagie, is at 5.6MB/sec).

so defending against this kind of thing may be useful now, not just in
the future. :)

(also, there are only 32 nodes that are getting clipped right now at
1.5, so i don't see raising to 10 giving much improvement.)


&gt; Actually, I just checked the code, and that attack works right now. :(
&gt; We should consider modifying router_get_advertised_bandwidth() to cap
&gt; its answer at MAX_BELIEVABLE_BANDWIDTH, so the smartlist we build in
&gt; dirserv_compute_performance_thresholds() won't list the higher bandwidths.

does this mean that clipping prevents the attack inside
smartlist_choose_by_bandwidth, but the directory servers are still
exposed because of the way they compute thresholds, in turn affecting
guard / stable selection?
</body></email><email><emailId>20070718095132</emailId><senderName>Mike Perry</senderName><senderEmail>mikeperry@fscked.org</senderEmail><timestampReceived>2007-07-18 09:51:32-0400</timestampReceived><subject>Re: Exit Balancing Patch</subject><body>


Thus spake Roger Dingledine (arma@mit.edu):

&gt; On Wed, Jul 18, 2007 at 02:18:56AM -0700, Mike Perry wrote:
&gt; &gt; Why does it matter if routers are CPU or network bound? From the Tor
&gt; &gt; network routing point of view, it shouldn't matter, capacity is
&gt; &gt; capacity. If it is a problem for node operators, they limit their
&gt; &gt; bandwidth in the config, problem solved. If they don't, then they just
&gt; &gt; run at 100% CPU, and Tor should still properly report their observed
&gt; &gt; bandwidth rate (unless they lie, but again, that is a another,
&gt; &gt; orthogonal matter).
&gt; 
&gt; Well, the problem is that Tor in fact doesn't properly report capacity at
&gt; the extremes. Our measure of capacity is the most you've seen yourself
&gt; burst in the past day -- it pretty much assumes that the pipe and other
&gt; resources you have are static throughout the day.
&gt; 
&gt; So if you somehow managed to push a lot briefly but you're too busy to
&gt; handle that level of traffic sustained, then you've overadvertised.

Again, this happens both with network load and CPU load. In fact, I
think the network load capacity differences are far more extreme and
far more common. On my box, Tor uses 10% CPU, but is constantly
prioritized below regular traffic, which is bursty and very irregular.
My node is also below the 1.5Mbyte/sec barrier, so it does not help
even out this problem for me, nor most others who share Tor with
normal traffic.

&gt; Putting a cap on advertised bandwidth when load balancing is a crude way
&gt; to account for this. Making our bandwidth estimate more complex may also
&gt; work, but then we have to figure out what's better. :)

If it has to be fixed one place, it is probably best done by not
advertising burst traffic. That problem is independent of this patch,
though, IMO.

-- 
Mike Perry
Mad Computer Scientist
fscked.org evil labs

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070718100704</emailId><senderName>Mike Perry</senderName><senderEmail>mikeperry@fscked.org</senderEmail><timestampReceived>2007-07-18 10:07:04-0400</timestampReceived><subject>Re: Exit Balancing Patch</subject><body>


Thus spake coderman (coderman@gmail.com):

&gt; On 7/18/07, Roger Dingledine &lt;arma@mit.edu&gt; wrote:
&gt; &gt;On Wed, Jul 18, 2007 at 01:36:02AM -0700, Mike Perry wrote:
&gt; &gt;&gt; 1. Expand MAX_BELIEVABLE_BANDWIDTH from 1.5MBytes/sec to 10Mbytes/sec.
&gt; &gt;...
&gt; &gt;It's true that this doesn't distribute load ideally, but putting the
&gt; &gt;cap lower than some of the running routers can prevent an attacker from
&gt; &gt;publishing a majority of absurdly fast routers and pushing every guard
&gt; &gt;guard out of having guard status -- similar to the attack described
&gt; &gt;in ...uptime-sanity-checking.txt
&gt; 
&gt; we were just discussing this today in #tor.  router "ghettogear"
&gt; consistently averaged 210-260KB/sec for weeks.  then on the 14th/15th
&gt; it went to 20.5MB/sec.  [likely too obvious] it then dropped to
&gt; 6.1MB/sec; still enough to sit at the top of the node bw list (next
&gt; closest, blutmagie, is at 5.6MB/sec).

Notice how just this one node lying was caught. Imagine sufficient
numbers to drown out *all* current guards. Imagine the impact on the
tor network speed if the adversary didn't have the capacity to
properly relay all this traffic. Someone would notice. Right away,
without scanning mechanisms.

And with respect to drowning out guards, all the limit prevents us
from doing is losing these 32 guards who have more than 1.5MBytes/sec.
And they would be weighted equally with all the adversary's other ~500
nodes to drown out the median with 1.5Mbyte nodes under the current
system. This is no protection. The guard speed limit to prevent this
sort of attack needs to be split off, and made much lower.

&gt; so defending against this kind of thing may be useful now, not just in
&gt; the future. :)

The mechanisms are built. All we need is people to scan. If you would
like, I can show you how to run scans via TorFlow and monitor the
results. It is hard for me to juggle scanning continuously right now
by myself, I work a full time job and have 2 Tor projects going :). I
could use some help.

&gt; (also, there are only 32 nodes that are getting clipped right now at
&gt; 1.5, so i don't see raising to 10 giving much improvement.)

It causes the effective loss of N-1.5Mbytes/sec of total Tor
bandwidth..

&gt; &gt;Actually, I just checked the code, and that attack works right now. :(
&gt; &gt;We should consider modifying router_get_advertised_bandwidth() to cap
&gt; &gt;its answer at MAX_BELIEVABLE_BANDWIDTH, so the smartlist we build in
&gt; &gt;dirserv_compute_performance_thresholds() won't list the higher bandwidths.
&gt; 
&gt; does this mean that clipping prevents the attack inside
&gt; smartlist_choose_by_bandwidth, but the directory servers are still
&gt; exposed because of the way they compute thresholds, in turn affecting
&gt; guard / stable selection?

Yeah, the limit should be split and lowered. 1.5Mbyte/sec does not
defend against guard selection attacks, as I mentioned above.

-- 
Mike Perry
Mad Computer Scientist
fscked.org evil labs

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070718101443</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-07-18 10:14:43-0400</timestampReceived><subject>Re: Exit Balancing Patch</subject><body>

On Wed, Jul 18, 2007 at 03:07:04AM -0700, Mike Perry wrote:
&gt; &gt; so defending against this kind of thing may be useful now, not just in
&gt; &gt; the future. :)
&gt; 
&gt; The mechanisms are built. All we need is people to scan. If you would
&gt; like, I can show you how to run scans via TorFlow and monitor the
&gt; results. It is hard for me to juggle scanning continuously right now
&gt; by myself, I work a full time job and have 2 Tor projects going :). I
&gt; could use some help.

If you could show us all, I'll add it to your README file. ;)
(Thanks!)

&gt; &gt; does this mean that clipping prevents the attack inside
&gt; &gt; smartlist_choose_by_bandwidth, but the directory servers are still
&gt; &gt; exposed because of the way they compute thresholds, in turn affecting
&gt; &gt; guard / stable selection?
&gt; 
&gt; Yeah, the limit should be split and lowered. 1.5Mbyte/sec does not
&gt; defend against guard selection attacks, as I mentioned above.

To be clear, it's not attacks against new guard selection I'm worried
about -- rather, these attacks let you push users away from their
currently selected guards because they lose faith in them. So once we fix
it, even if there are 50 old guards and a thousand new ones, the users who
liked the old ones before the attack started will still be doing better.

--Roger

</body></email><email><emailId>20070718120127</emailId><senderName>Paul Syverson</senderName><senderEmail>syverson@itd.nrl.navy.mil</senderEmail><timestampReceived>2007-07-18 12:01:27-0400</timestampReceived><subject>Re: Exit Balancing Patch</subject><body>

On Wed, Jul 18, 2007 at 06:14:43AM -0400, Roger Dingledine wrote:
&gt; 
&gt; To be clear, it's not attacks against new guard selection I'm worried
&gt; about -- rather, these attacks let you push users away from their
&gt; currently selected guards because they lose faith in them. So once we fix
&gt; it, even if there are 50 old guards and a thousand new ones, the users who
&gt; liked the old ones before the attack started will still be doing better.
&gt; 

for those users fortunate enough not to be new or have done anything
to reset their guard set, i.e., to have an existing set of
chosen guards.

-Paul
</body></email><email><emailId>20070726105744</emailId><senderName>Mike Perry</senderName><senderEmail>mikeperry@fscked.org</senderEmail><timestampReceived>2007-07-26 10:57:44-0400</timestampReceived><subject>Re: Exit Balancing Patch</subject><body>


Thus spake coderman (coderman@gmail.com):

&gt; (also, there are only 32 nodes that are getting clipped right now at
&gt; 1.5, so i don't see raising to 10 giving much improvement.)

[Appologies, I have to take this unintentional flamebait and go on an
extended rant. Tor performance is in my mind a very important subset
of Tor security].

It turns out this clip cuts off the load balancing of approximately
23MB/sec (as in 23MB/sec is chopped off above the 1.5MByte), or about
10% of the total network bandwidth.. This is just one part of the
balancing problem, but I see no reason not to fix it. Not fixing it
just makes it harder to find other balancing issues.


Currently, there is a LOT of unused bandwidth in the top 15% of the
nodes in the network due to load balancing issues. I've prepared some
charts for my Defcon talk to illustrate this imbalancing. 

http://fscked.org/transient/torgraphs/

The bandwidth data was gathered by dividing the network into
5-percentile slices of about 79 nodes each and fetching a 512k file
through 2 hops each chosen from the same percentile range. The circuit
failure and extend time data were gathered by fetching an approx 20k
file over 3 hop paths chosen similarly. 

Average stream capacity for the bottom 85% of the nodes on network is
about 10KB/sec per stream. However, average capacity for the top 5% of
the network is over 70KB/sec per stream.

http://fscked.org/transient/torgraphs/StreamBwBar.pdf

This means the top 5% of the network can support SEVEN TIMES AS MANY
USERS as it currently does. The top 5% of the network carries 45% of
the Tor network traffic.

The next 10% (percentiles 5-15) can support 3 times as many users.
Together, they carry 30% of the network traffic.

Note also the rising rate of circuit failures and extend times, until
you hit the magic 50% threshhold where nodes stop being considered for
unbalanced guard status.

http://fscked.org/transient/torgraphs/ExtendsBar.pdf
http://fscked.org/transient/torgraphs/CircFailure.pdf


The fact of the matter is is that Tor is NOT EVEN CLOSE TO SAFE as a
whistleblower's network until it attracts more users. With so few Tor
users, it is trivial to find the only Tor user in an institution or
location who used Tor to report wrongdoing, post evidence, or contact
the media.

I think this problem is serious enough to treat it a security issue
that warrants both fixing this issue immediately, as well as expiring
all guards that have been chosen uniformly by Tor versions prior to
0.1.2.15. Additionally, we should consider changing bandwidth
reporting in rep_hist_bandwidth_assess() to report average observed
bandwidths instead of peaks, to more smoothly handle nodes whose
capacities are highly volatile (such as my own).


For entertainment's sake, lets do a quick back of the envelope
calculation to see what a balanced network would get us. Lets say that
there are 200,000 Tor users currently. A balanced network should be
able to support 200000*.45*7 + 200000*.30*3 + 200000*.25=860,000 Tor
users at average stream bandwidths of 10KB/sec USING THE SAME NETWORK.

Granted, latency is likely also be a major factor in perceived
performance, requiring intelligent path selection and optionally
shorter path lengths; and as Steven Murdoch pointed out on or-talk,
there may not be 860k users who will put up with 10KB/sec stream
speeds, but that just means the new equilibrium stream bandwidth will
be that much faster for the whole network (instead of randomly fast
or randomly unbearable, as is the case today).



-- 
Mike Perry
Mad Computer Scientist
fscked.org evil labs

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070726180923</emailId><senderName>Robert Hogan</senderName><senderEmail>robert@roberthogan.net</senderEmail><timestampReceived>2007-07-26 18:09:23-0400</timestampReceived><subject>Re: Exit Balancing Patch</subject><body>

On Thursday 26 July 2007 11:57:44 Mike Perry wrote:
&gt;[..]
&gt;
&gt; Currently, there is a LOT of unused bandwidth in the top 15% of the
&gt; nodes in the network due to load balancing issues. I've prepared some
&gt; charts for my Defcon talk to illustrate this imbalancing.
&gt;
Hi Mike,

Apologies to everyone if I'm restating the obvious here, but I'm trying to 
piece together an understanding of the issue from this and other threads. 
Everyone else is familiar with the issues so assumptions are made that have 
to be decoded by the novice.

You don't say so in your post, but I take it the percentile ranges were taken 
in descending order of advertised bw?

So if I understand this correctly:

* Overall network bw is poorly utilized because high-capacity nodes aren't 
participating in the large slice of the network's circuits that their bw 
warrants.

* Tor needs to be careful (and clip at some sane bw of X mb/s) because 
otherwise too much traffic will concentrate on a small group of nodes, 
harming anonymity.

Given that a tor circuit is only as fast as its slowest node isn't it just as 
likely that for some reasonable percentage of the time, the user's circuit's 
will still be problematically slow (e.g. fast guard, slow relay, fast exit)?

If that's true then increasing the clipping point alone will not improve 
overall performance, so in order to work does your proposal have to be 
two-pronged? 

( 1 ) adopt two-hop paths as a user option, because those will always be 
mostly, but not always, be fast if ( 2 ) high-capacity nodes get their 'fair' 
share of the user's circuits once punitive clipping is removed. This is 
because guards have a guaranteed high-ish bw and we've reduced our odds of 
getting a slow node on the rest of the circuit because we're only choosing 
one more, rather than two more AND we've allowed fast nodes to throw their 
weight around a bit more in the random selection.

Is there more to it or am I missing something?

As a side note:
Wouldn't a useful metric be nodes' cpu usage or even capacity (e.g. make and 
ghz)?  Is there any research or intuition on the relationship between cpu 
make/ghz'age and bw-capacity that illustrate how much of that bw is just 
notional once the node is participating in x circuits with y kb/s? Would it 
be worth including this in descriptors?
</body></email><email><emailId>20070726185100</emailId><senderName>Mike Perry</senderName><senderEmail>mikeperry@fscked.org</senderEmail><timestampReceived>2007-07-26 18:51:00-0400</timestampReceived><subject>Re: Exit Balancing Patch</subject><body>


Thus spake Robert Hogan (robert@roberthogan.net):

&gt; On Thursday 26 July 2007 11:57:44 Mike Perry wrote:

&gt; You don't say so in your post, but I take it the percentile ranges were taken 
&gt; in descending order of advertised bw?

Correct. There is a graph that illustrates the distribution of
bandwidth by percentile:

http://fscked.org/transient/torgraphs/BwBar.pdf

&gt; So if I understand this correctly:
&gt; 
&gt; * Overall network bw is poorly utilized because high-capacity nodes aren't 
&gt; participating in the large slice of the network's circuits that their bw 
&gt; warrants.

Yeah.

&gt; * Tor needs to be careful (and clip at some sane bw of X mb/s) because 
&gt; otherwise too much traffic will concentrate on a small group of nodes, 
&gt; harming anonymity.

Not to offend you, but I believe this argument is nonsense. A high
capacity node should be fully utilized to the full extent of its
capacity. Artifically clipping capacity does not properly solve *any*
problems related to nodes lying about capacity, nor does it "improve
anonymity". If you try to "protect" anonymity this way, people with
high capacity links will just start mounting sybil attacks instead.

In fact, such uniform balancing actually is extremely damaging to
anonymity, because it both artifically hampers user size, and causes
exorbitiant amounts of circuit failures which can be used to bias
route selection (the last guard percentile, the 45-50 range, exhibited
nearly 40% circuit failure rate!).

&gt; Given that a tor circuit is only as fast as its slowest node isn't it just as 
&gt; likely that for some reasonable percentage of the time, the user's circuit's 
&gt; will still be problematically slow (e.g. fast guard, slow relay, fast exit)?

That is what load balancing is for though. If you notice, that is why
I did all my userbase size calculations based on a 10KB/sec stream
rate, which is the average speed of the rest of the Tor network. As I
pointed out, the top 5% has room for SEVEN TIMES MORE 10KB/sec
streams, since its average stream capacity is 70K/sec.

Assuming fairness, a node with capacity C and N streams should produce
stream capacity of C/N. It is simple algebra to see that if C/N=70,
you can have N'=7N users at 10K/sec instead.

As my calculations (which assume TCP fairnes, a property that may not
hold over internal circuits) showed, I believe that properly balancing
the network should increase effective user capacity by 4X.

(X is current network size: X*.45*(70/10)+X*.15*(30/10)+X*.25=4.3X)

If it turns out this is the case because of fairness or other issues,
we can take more measurements once the changes are in place and go to
work devising a better weighting scheme. Right now, however, load
balancing has such fundamental issues as these that it is impossible
to make any other adjustments or measurements other than to say "Oh
dear goddess is it horribly broken".

Incidentally, it is ALSO currently extremely difficult to detect nodes
that are currently maliciously failing circuits, or who are lying
about their bandwidth, because the network is so unbalanced. So saying
that we shoud "wait until we can detect liars" until we fix this stuff
will leave us in circular deadlock.

&gt; If that's true then increasing the clipping point alone will not improve 
&gt; overall performance, so in order to work does your proposal have to be 
&gt; two-pronged? 
&gt; 
&gt; ( 1 ) adopt two-hop paths as a user option, because those will always be 
&gt; mostly, but not always, be fast if ( 2 ) high-capacity nodes get their 'fair' 
&gt; share of the user's circuits once punitive clipping is removed. This is 
&gt; because guards have a guaranteed high-ish bw and we've reduced our odds of 
&gt; getting a slow node on the rest of the circuit because we're only choosing 
&gt; one more, rather than two more AND we've allowed fast nodes to throw their 
&gt; weight around a bit more in the random selection.

No, two hop paths is independent of this proposal. But I'm not giving
up on that one either. I believe 2 hop paths to be purely an
implementation issue. There is no theoretical reason why 2 hop paths
significantly degrades anonymity, but I do agree the devil is in the
implementation details.

&gt; Is there more to it or am I missing something?
&gt; 
&gt; As a side note:
&gt; Wouldn't a useful metric be nodes' cpu usage or even capacity (e.g. make and 
&gt; ghz)?  Is there any research or intuition on the relationship between cpu 
&gt; make/ghz'age and bw-capacity that illustrate how much of that bw is just 
&gt; notional once the node is participating in x circuits with y kb/s? Would it 
&gt; be worth including this in descriptors?

No, I think this is up to node operators to look at their CPU usage
and limit tor's bandwidth proportionally to achieve their desired
load. CPUs vary widely and can have various optimizations as well (ssl
accelerator cards, vector operations, etc). 

If nodes properly report their current capacity, it doesn't matter if
a node is network bound or CPU bound from a balancing perspective
(though perhaps Johannes will discover that CPU load possibly
increases latency in some weird ways).


 
-- 
Mike Perry
Mad Computer Scientist
fscked.org evil labs

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070726190155</emailId><senderName>Mike Perry</senderName><senderEmail>mikeperry@fscked.org</senderEmail><timestampReceived>2007-07-26 19:01:55-0400</timestampReceived><subject>Re: Exit Balancing Patch</subject><body>


Thus spake Mike Perry (mikeperry@fscked.org):

&gt; 
&gt; &gt; Given that a tor circuit is only as fast as its slowest node isn't it just as 
&gt; &gt; likely that for some reasonable percentage of the time, the user's circuit's 
&gt; &gt; will still be problematically slow (e.g. fast guard, slow relay, fast exit)?

Oh, also, I missed pointing out another key assumption on balancing,
since choice is weighted proportionally to bandwidth, increasing the
bw capacity of these other nodes will cause users to choose them more
often instead of the slower nodes, so it's not like the 10KB/sec nodes
will just magically provide more bandwidth forever to support this
rebalancing. The system will reach a new equilibrium, at which point
more measurements will be needed to hunt down other, more subtle
issues that are hiding behind the noise of these larger ones (such as
liars, path biasers, potential uptime selection balancing issues,
balancing directory vs tor traffic, etc).


-- 
Mike Perry
Mad Computer Scientist
fscked.org evil labs

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070727045515</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-07-27 04:55:15-0400</timestampReceived><subject>Re: Exit Balancing Patch</subject><body>

On Thu, Jul 26, 2007 at 11:51:00AM -0700, Mike Perry wrote:
&gt; &gt; * Tor needs to be careful (and clip at some sane bw of X mb/s) because 
&gt; &gt; otherwise too much traffic will concentrate on a small group of nodes, 
&gt; &gt; harming anonymity.
&gt; 
&gt; Not to offend you, but I believe this argument is nonsense. A high
&gt; capacity node should be fully utilized to the full extent of its
&gt; capacity. Artifically clipping capacity does not properly solve *any*
&gt; problems related to nodes lying about capacity, nor does it "improve
&gt; anonymity". If you try to "protect" anonymity this way, people with
&gt; high capacity links will just start mounting sybil attacks instead.

Well, I think we want *some* clipping -- otherwise people can advertise
a bandwidth of 1GB/s and suddenly attract 50% of the network's traffic,
whether or not they can handle it. But I am certainly willing to believe
that we should raise the current number. I used to raise it incrementally
as we got faster nodes and as Tor began to work acceptably on fast
servers, and it's been too long since I raised it.

What new number would capture most of the current nodes we're
seeing? 5MB/s?

Also, should we raise the default rate limit from 3MB/6MB too? It's
been a while since we raised it, and I imagine it's clipping a few
servers. (Does somebody want to count how many?)

Regarding the guard node weighting problem, it occurs to me that I pulled
the "at least the median bandwidth" thing out of nowhere. My reasoning
was that if Alice is going to pick a few nodes that she'll use in every
single circuit, it would be a shame if they're 20KB/s nodes, since then
she would never ever see more throughput than that. Another hack I picked,
for the same reason, was for Alice to pick out of the first two or three
guards in her list that are up, rather than always the first.

Are there better numbers than the 50% mark for bandwidth? And are there
better hacks we should be considering, or hey, actual solutions?

--Roger

</body></email><email><emailId>20070727052929</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-07-27 05:29:29-0400</timestampReceived><subject>Re: Exit Balancing Patch</subject><body>

On Fri, Jul 27, 2007 at 12:55:15AM -0400, Roger Dingledine wrote:
&gt;  And are there
&gt; better hacks we should be considering

For example, here's another hack we might use: choose guards, weighted
by bandwidth, demanding that they are Fast (top 7/8s of the network)
and Stable (currently top 1/2 of the network by uptime, but hopefully
to be replaced by Proposal 108 [1] sometime), and then when Alice wants
to use a guard, she selects from the first k nodes in her guard list,
adding new ones as needed, where k is computed such that she's choosing
from at least n bytes/s worth of advertised bandwidth.

We could choose n to be x times the yth percental of bandwidth in the
network, e.g. 5 times the 50% mark, or 2 times the 25% mark, such that
the probability of getting many crummy nodes in a row is extremely
small, but we still get the "your list doesn't rotate often" property
we want.

We could add another "but k must be at least 2" exception if we liked,
to avoid picking a huge one first and using it exclusively, but that
doesn't sound so bad actually. Are there any other weird cases we might
want to consider exceptions for?

Of course, all these magic numbers are coming out of nowhere, which
makes me a bit sad, but we are lacking a "principled" solution here.

[1] https://tor.eff.org/svn/trunk/doc/spec/proposals/108-mtbf-based-stability.txt

</body></email><email><emailId>20070727062718</emailId><senderName>Mike Perry</senderName><senderEmail>mikeperry@fscked.org</senderEmail><timestampReceived>2007-07-27 06:27:18-0400</timestampReceived><subject>Re: Exit Balancing Patch</subject><body>


Thus spake Roger Dingledine (arma@mit.edu):

&gt; On Thu, Jul 26, 2007 at 11:51:00AM -0700, Mike Perry wrote:
&gt; &gt; &gt; * Tor needs to be careful (and clip at some sane bw of X mb/s) because 
&gt; &gt; &gt; otherwise too much traffic will concentrate on a small group of nodes, 
&gt; &gt; &gt; harming anonymity.
&gt; &gt; 
&gt; &gt; Not to offend you, but I believe this argument is nonsense. A high
&gt; &gt; capacity node should be fully utilized to the full extent of its
&gt; &gt; capacity. Artifically clipping capacity does not properly solve *any*
&gt; &gt; problems related to nodes lying about capacity, nor does it "improve
&gt; &gt; anonymity". If you try to "protect" anonymity this way, people with
&gt; &gt; high capacity links will just start mounting sybil attacks instead.
&gt; 
&gt; Well, I think we want *some* clipping -- otherwise people can advertise
&gt; a bandwidth of 1GB/s and suddenly attract 50% of the network's traffic,
&gt; whether or not they can handle it. But I am certainly willing to believe
&gt; that we should raise the current number. I used to raise it incrementally
&gt; as we got faster nodes and as Tor began to work acceptably on fast
&gt; servers, and it's been too long since I raised it.
&gt;
&gt; What new number would capture most of the current nodes we're
&gt; seeing? 5MB/s?

I think we should put it well above the current fastest node, which is
blutmaggie at 5.6MB/sec. From what I can tell, this node actually does
have that much capacity. It has 0 failures over 18 fetches averaging
120KB/sec. Kudos to them!

I see no reason not to put the limit at 10MB/sec. All we really want
to do is prevent someone from claiming their bandwidth is infinity. It
should never actually clip a legitimate node's bandwidth if we can
help it. Even though there is no automated scanning yet, I can quickly
verify performance from random IPs that are difficult to anticipate,
and we can raise the limit accordingly. But we should set it high
enough that we do not have to raise it for a good while.

Also, I think the exit weighting formula is wrong. If that portion of
my patch is not to be applied, I would like some sort of justification
as to why what is currently there is better than what I proposed (or
is even correct), but that is the least of my concerns, since exit
bandwidth is usually scarce.
 
&gt; Also, should we raise the default rate limit from 3MB/6MB too? It's
&gt; been a while since we raised it, and I imagine it's clipping a few
&gt; servers. (Does somebody want to count how many?)

Oh, yeah. Definitely should change this.

How does this manifest itself? The first element in the bandwidth line
of the descriptor is 3MB and the second is 6MB? or is it even possible
to tell? the 3rd number is cut at the lower of the observed vs limit..
Should I just check to see who has exactly 3MB as their reported
capacity? Will that work? Is it exactly 3MB, or is it 3000000
bytes?

&gt; Regarding the guard node weighting problem, it occurs to me that I pulled
&gt; the "at least the median bandwidth" thing out of nowhere. My reasoning
&gt; was that if Alice is going to pick a few nodes that she'll use in every
&gt; single circuit, it would be a shame if they're 20KB/s nodes, since then
&gt; she would never ever see more throughput than that. Another hack I picked,
&gt; for the same reason, was for Alice to pick out of the first two or three
&gt; guards in her list that are up, rather than always the first.
&gt;
&gt; Are there better numbers than the 50% mark for bandwidth? And are there
&gt; better hacks we should be considering, or hey, actual solutions?

Well, I don't have solid suggestions other than to point out that the
current average capacity for the rest of the network is only
10KB/sec.. Also, note that if you take the pure median of the network,
it carries 94% of the network bandwidth. In fact, 93% of the network
bandwidth is also above the slowest guard (54KB/sec).

It is actually the uptime limit that is what cuts the guard bandwidth
down to be only 40% of total network bandwidth, which I guess is
fine.. It is still greater than 1/3, and excludes exits properly
(according to the same total/3 ratio I propose in my patch).

So the median probably was a fine choice, given that the other
restrictions on uptime and such are what we want. Perhaps those
threshholds are what should actually be revisited for the MTBF patch,
but they seem OK.

-- 
Mike Perry
Mad Computer Scientist
fscked.org evil labs

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070727063521</emailId><senderName>Mike Perry</senderName><senderEmail>mikeperry@fscked.org</senderEmail><timestampReceived>2007-07-27 06:35:21-0400</timestampReceived><subject>Re: Exit Balancing Patch</subject><body>


Thus spake Roger Dingledine (arma@mit.edu):

&gt; For example, here's another hack we might use: choose guards, weighted
&gt; by bandwidth, demanding that they are Fast (top 7/8s of the network)
&gt; and Stable (currently top 1/2 of the network by uptime, but hopefully
&gt; to be replaced by Proposal 108 [1] sometime), and then when Alice wants
&gt; to use a guard, she selects from the first k nodes in her guard list,
&gt; adding new ones as needed, where k is computed such that she's choosing
&gt; from at least n bytes/s worth of advertised bandwidth.
&gt; 
&gt; We could choose n to be x times the yth percental of bandwidth in the
&gt; network, e.g. 5 times the 50% mark, or 2 times the 25% mark, such that
&gt; the probability of getting many crummy nodes in a row is extremely
&gt; small, but we still get the "your list doesn't rotate often" property
&gt; we want.

Hrmm, this sounds excessively complicated and runs the risk of the
double-weighting issue we discussed before. If the load balancing is
working propely otherwise, this seems overkill. All nodes should be
more or less equivalent in stream capacity..

We really should rebalance the network first and see what sort of
equilibrium it reaches before messing around with something like this.
I think it is important to do this soon. Does anyone disagree with my
suggestion to expire guards for users who have chosen them improperly
(and/or who have probably accumulated way too many by this point
anyhow due to the accumulation problem?).

Likewise, would a patch to report average node capacity (instead of
peak) be accepted, or will it also sit in a queue for a while and
ultimately be forgotten unless I make a huge nuisance of myself? :)


-- 
Mike Perry
Mad Computer Scientist
fscked.org evil labs

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070727070452</emailId><senderName>Mike Perry</senderName><senderEmail>mikeperry@fscked.org</senderEmail><timestampReceived>2007-07-27 07:04:52-0400</timestampReceived><subject>Re: Exit Balancing Patch</subject><body>


Thus spake Mike Perry (mikeperry@fscked.org):

&gt; &gt; Regarding the guard node weighting problem, it occurs to me that I pulled
&gt; &gt; the "at least the median bandwidth" thing out of nowhere. My reasoning
&gt; &gt; was that if Alice is going to pick a few nodes that she'll use in every
&gt; &gt; single circuit, it would be a shame if they're 20KB/s nodes, since then
&gt; &gt; she would never ever see more throughput than that. Another hack I picked,
&gt; &gt; for the same reason, was for Alice to pick out of the first two or three
&gt; &gt; guards in her list that are up, rather than always the first.
&gt; &gt;
&gt; &gt; Are there better numbers than the 50% mark for bandwidth? And are there
&gt; &gt; better hacks we should be considering, or hey, actual solutions?
&gt; 
&gt; Well, I don't have solid suggestions other than to point out that the
&gt; current average capacity for the rest of the network is only
&gt; 10KB/sec.. Also, note that if you take the pure median of the network,
&gt; it carries 94% of the network bandwidth. In fact, 93% of the network
&gt; bandwidth is also above the slowest guard (54KB/sec).
&gt; 
&gt; It is actually the uptime limit that is what cuts the guard bandwidth
&gt; down to be only 40% of total network bandwidth, which I guess is
&gt; fine.. It is still greater than 1/3, and excludes exits properly
&gt; (according to the same total/3 ratio I propose in my patch).

Actually, what might be a good idea is to do a "conserve_guards"
weight in smartlist_choose_by_bandwidth() to properly weight guards
using the formula from patch when choosing them as middle nodes.

This way we avoid doubly-overloading guards, since thier bandwidth can
get scarce as well (if for example the tor network bandwidth becomes
more egalitarian and less power-law).

-- 
Mike Perry
Mad Computer Scientist
fscked.org evil labs

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070727203254</emailId><senderName>"Michael_google gmail_Gersten"</senderName><senderEmail>keybounce@gmail.com</senderEmail><timestampReceived>2007-07-27 20:32:54-0400</timestampReceived><subject>Re: Exit Balancing Patch</subject><body>

My thoughts on entry guards:

#1. They should advertise a bandwidth of at least twice my incoming
speed. Maybe slightly more. If their speed is any lower, then there's
a good chance that I won't ever be able to get full speed.

#2. The chance of their being chosen should be based on how much
faster than my incoming bandwidth that they are, as well as their
"overloaded" factor -- what percentage of the time are they maxed
(either CPU maxed, or bandwidth maxed. I'd say memory/swapping limited
if there was a way to tell). I'd rather get a lower capacity machine
that is more than what I need if it is being ignored by the rest of
the network.

#3. For anonymity, I want an entry guard that is used by others. So I
want an entry guard that not only serves me, but several others.
Suddenly, I want a guard that has not just more than my speed, but
more than the speed of the other users. If I'm the fastest client
using that guard, the rule of "slightly more than twice what I need"
applies; otherwise, the speed that the others are using should
dominate, and I want to make sure that there is leftover bandwidth to
support me.

Thoughts?
</body></email><email><emailId>20070727215229</emailId><senderName>Mike Perry</senderName><senderEmail>mikeperry@fscked.org</senderEmail><timestampReceived>2007-07-27 21:52:29-0400</timestampReceived><subject>Re: Exit Balancing Patch</subject><body>


Thus spake Michael_google gmail_Gersten (keybounce@gmail.com):

&gt; My thoughts on entry guards:
&gt; 
&gt; #1. They should advertise a bandwidth of at least twice my incoming
&gt; speed. Maybe slightly more. If their speed is any lower, then there's
&gt; a good chance that I won't ever be able to get full speed.

There's a good chance you won't get full speed anyways. Full down
speed on my link is 6Mbit/sec. I can gaurantee you I will never see
that through Tor. It also does not mean I should be only selecting
bandwidth guard nodes..

&gt; #2. The chance of their being chosen should be based on how much
&gt; faster than my incoming bandwidth that they are, as well as their
&gt; "overloaded" factor -- what percentage of the time are they maxed
&gt; (either CPU maxed, or bandwidth maxed. I'd say memory/swapping limited
&gt; if there was a way to tell). I'd rather get a lower capacity machine
&gt; that is more than what I need if it is being ignored by the rest of
&gt; the network.
&gt;
&gt; #3. For anonymity, I want an entry guard that is used by others. So I
&gt; want an entry guard that not only serves me, but several others.
&gt; Suddenly, I want a guard that has not just more than my speed, but
&gt; more than the speed of the other users. If I'm the fastest client
&gt; using that guard, the rule of "slightly more than twice what I need"
&gt; applies; otherwise, the speed that the others are using should
&gt; dominate, and I want to make sure that there is leftover bandwidth to
&gt; support me.
&gt; 
&gt; Thoughts?

My thoughts are that we fix the current issues with as straightforward
and obviously correct fixes as possible, and eliminate voodoo magic and
unexplained, unprovable, and uninteligible formulae :)

Once this is done, we can go crazy with more complicated schemes. But
we need to fix these major issues first and propogate these changes to
everyone before we can even hope to do any fine-grained tweaking.

-- 
Mike Perry
Mad Computer Scientist
fscked.org evil labs

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070728010001</emailId><senderName>Cat Okita</senderName><senderEmail>cat@reptiles.org</senderEmail><timestampReceived>2007-07-28 01:00:01-0400</timestampReceived><subject>Re: Exit Balancing Patch</subject><body>

On Thu, 26 Jul 2007, Mike Perry wrote:
&gt; That is what load balancing is for though. If you notice, that is why
&gt; I did all my userbase size calculations based on a 10KB/sec stream
&gt; rate, which is the average speed of the rest of the Tor network. As I
&gt; pointed out, the top 5% has room for SEVEN TIMES MORE 10KB/sec
&gt; streams, since its average stream capacity is 70K/sec.

I'm still working through this thread, but I'd like to point out that
you're presuming that changing the amount of bandwidth available will
automatically result in additional users, which will offset the fact
that SEVEN TIMES MORE 10KB/sec streams will be going through the top 5%
tor nodes - which to me, at least, suggests SEVEN TIMES MORE opportunities
for compromise via the top 5% of nodes...

Do you expect that adding SEVEN TIMES MORE 10KB/sec streams will actually
result in SEVEN TIMES MORE users to offset this (and if that's the case,
we're right back where we started, in terms of performance issues...)

cheers!
==========================================================================
"A cat spends her life conflicted between a deep, passionate and profound
desire for fish and an equally deep, passionate and profound desire to
avoid getting wet.  This is the defining metaphor of my life right now."
</body></email><email><emailId>20070728020814</emailId><senderName>Mike Perry</senderName><senderEmail>mikeperry@fscked.org</senderEmail><timestampReceived>2007-07-28 02:08:14-0400</timestampReceived><subject>Re: Exit Balancing Patch</subject><body>


Thus spake Cat Okita (cat@reptiles.org):

&gt; On Thu, 26 Jul 2007, Mike Perry wrote:
&gt; &gt;That is what load balancing is for though. If you notice, that is why
&gt; &gt;I did all my userbase size calculations based on a 10KB/sec stream
&gt; &gt;rate, which is the average speed of the rest of the Tor network. As I
&gt; &gt;pointed out, the top 5% has room for SEVEN TIMES MORE 10KB/sec
&gt; &gt;streams, since its average stream capacity is 70K/sec.
&gt; 
&gt; I'm still working through this thread, but I'd like to point out that
&gt; you're presuming that changing the amount of bandwidth available will
&gt; automatically result in additional users, which will offset the fact
&gt; that SEVEN TIMES MORE 10KB/sec streams will be going through the top 5%
&gt; tor nodes - which to me, at least, suggests SEVEN TIMES MORE opportunities
&gt; for compromise via the top 5% of nodes...

If this is the case, why don't we just route everything uniformly? It
was my impression we accepted that nodes with higher bandwidth have
greater potential for compromise, but that it was a smart thing to
route streams through them proportional to their capacity...

&gt; Do you expect that adding SEVEN TIMES MORE 10KB/sec streams will actually
&gt; result in SEVEN TIMES MORE users to offset this (and if that's the case,
&gt; we're right back where we started, in terms of performance issues...)

Do you use Tor regularly? Do you talk to real people who try to do so?
Maybe you don't notice the problem because you got lucky enough to
have fast guard nodes. But those circuit failures, timeouts, and
usability issues in the lower guard nodes are a real problem. People
who get those guards find Tor nearly unusable - around 20% of their
streams timeout (after a solid minute of doing nothing), and another
20% randomly have to restart on a different circuit. As sjmurdoch
discussed on or-talk, there is a definite correlation to percieved
performance and adoption.

Once again, it is an equilibrium thing. Wherever the equilibrium
settles wrt user pain threshholds and bandwidth, that is where it
settles.

If the network is properly balanced, that high average capacity in the
top nodes should disappear, and we should be able to support more
users. Or maybe we won't have more users, maybe users will still
decide Tor is too slow for them and will walk away. But then we should
be left with more bandwidth. The point is, that bandwidth should be
evenly distributed across all streams and all nodes, in a properly
load balanced network.

Does this make sense?

-- 
Mike Perry
Mad Computer Scientist
fscked.org evil labs

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070728035231</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-07-28 03:52:31-0400</timestampReceived><subject>Re: Exit Balancing Patch</subject><body>

On Thu, Jul 26, 2007 at 11:27:18PM -0700, Mike Perry wrote:
&gt; &gt; Well, I think we want *some* clipping -- otherwise people can advertise
[snip]
&gt; &gt; What new number would capture most of the current nodes we're
&gt; &gt; seeing? 5MB/s?
&gt; 
&gt; I think we should put it well above the current fastest node, which is
&gt; blutmaggie at 5.6MB/sec. From what I can tell, this node actually does
&gt; have that much capacity. It has 0 failures over 18 fetches averaging
&gt; 120KB/sec. Kudos to them!
&gt; 
&gt; I see no reason not to put the limit at 10MB/sec. All we really want
&gt; to do is prevent someone from claiming their bandwidth is infinity. It
&gt; should never actually clip a legitimate node's bandwidth if we can
&gt; help it.

Right, I think it's important to recognize that there that there are
two different vulnerabilities we're worried about.

The first vulnerability is that fast nodes attract a disproportionate
amount of Tor traffic. If we actually had a node that could handle 1GBit,
and we added it to the network, then suddenly there would be a single
point where an attack would yield really good results. So we want to
avoid making the network "too" lopsided -- and one of the open research
questions here is finding the right tradeoff between how lopsided we
can afford vs how much performance penalty we should force on users to
ensure that they get a diverse network.

The second vulnerability is that somebody who wants to attract Tor
traffic can run a small node, claim to have a whole lot of bandwidth,
and be in an improved position to attack Tor. Our current defense here
is a MAX_BELIEVABLE_BANDWIDTH cutoff (currently at 1.5MB/s), which makes
sure we avoid allocating more traffic than a certain cap to any given
node. Future proposed defenses include limiting the number of Tor servers
on a given IP address (proposal 109), and doing spot checks to see if a
given server is performing much worse than expected -- one metric would be
"is his performance much worse than other servers at the same level?"

Now, the 1.5MB/s cap is relevant to both of these vulnerabilities.
Regarding the second issue, I agree that it is a good idea to raise the
number, and I don't think anybody will object. Regarding the first issue,
I think you're right, but I don't think we've explored it well enough yet;
we should do that at some point.

&gt; Even though there is no automated scanning yet, I can quickly
&gt; verify performance from random IPs that are difficult to anticipate,
&gt; and we can raise the limit accordingly.

We should think about how we can get automated scanning into place. The
fact that we *can* do a check is great, but we need to work on the next
step which is having it automatically and constantly look for anomalies.

What is the limiting factor here? Code? High-speed network connections?
Humans to oversee it? Ways to present the results usefully?

&gt; But we should set it high
&gt; enough that we do not have to raise it for a good while.

This is an important enough point that I'll elaborate on it. It's not
just a matter of trying to avoid needing this discussion again in 6
months when 8MB/s servers are common. Rather, we're trying to pick a
number to give all the clients right now, so that in 6 months today's
clients won't be back to harming the load balancing again. So we should
try to pick a number that will still not be reached at the end of the
expected lifetime of today's Tor release.

(There's also a minor partitioning attack here, in the form of a
statistical leak based on whether you're weighting your node choices like
the people with the new number or like the people with the old number; but
I don't think that's a big deal compared to the other big deals we have.)

&gt; Also, I think the exit weighting formula is wrong. If that portion of
&gt; my patch is not to be applied, I would like some sort of justification
&gt; as to why what is currently there is better than what I proposed (or
&gt; is even correct), but that is the least of my concerns, since exit
&gt; bandwidth is usually scarce.

I've asked Nick to look at it and compare it to the equation he produced
earlier. His initial response was similar -- that he wanted some kind
of justification for why this new one was better.

My plan is to sit down sometime and look at both equations and try
to figure out how they compare, but it's low on my priority list, so
hopefully before then one or the other of you will get beyond the "well,
I wrote one, and that other one is confusing to me, so why not use mine"
stage. :)

&gt; &gt; Also, should we raise the default rate limit from 3MB/6MB too? It's
&gt; &gt; been a while since we raised it, and I imagine it's clipping a few
&gt; &gt; servers. (Does somebody want to count how many?)
&gt; 
&gt; Oh, yeah. Definitely should change this.
&gt; 
&gt; How does this manifest itself? The first element in the bandwidth line
&gt; of the descriptor is 3MB and the second is 6MB? or is it even possible
&gt; to tell? the 3rd number is cut at the lower of the observed vs limit..
&gt; Should I just check to see who has exactly 3MB as their reported
&gt; capacity? Will that work? Is it exactly 3MB, or is it 3000000
&gt; bytes?

Look for BandwidthRate (first number) of 3145728 and BandwidthBurst
(second number) of 6291456. Then look for a third number that exceeds
3145728. On briefly looking through moria2's cached-routers list, I found
threeish such servers. So I don't think this is a big deal yet either way.

--Roger

</body></email><email><emailId>20070730053359</emailId><senderName>Mike Perry</senderName><senderEmail>mikeperry@fscked.org</senderEmail><timestampReceived>2007-07-30 05:33:59-0400</timestampReceived><subject>Re: Exit Balancing Patch</subject><body>


Thus spake Roger Dingledine (arma@mit.edu):

&gt; The first vulnerability is that fast nodes attract a disproportionate
&gt; amount of Tor traffic. If we actually had a node that could handle 1GBit,
&gt; and we added it to the network, then suddenly there would be a single
&gt; point where an attack would yield really good results. So we want to
&gt; avoid making the network "too" lopsided -- and one of the open research
&gt; questions here is finding the right tradeoff between how lopsided we
&gt; can afford vs how much performance penalty we should force on users to
&gt; ensure that they get a diverse network.
&gt; 
&gt; The second vulnerability is that somebody who wants to attract Tor
&gt; traffic can run a small node, claim to have a whole lot of bandwidth,
&gt; and be in an improved position to attack Tor. Our current defense here
&gt; is a MAX_BELIEVABLE_BANDWIDTH cutoff (currently at 1.5MB/s), which makes
&gt; sure we avoid allocating more traffic than a certain cap to any given
&gt; node. Future proposed defenses include limiting the number of Tor servers
&gt; on a given IP address (proposal 109), and doing spot checks to see if a
&gt; given server is performing much worse than expected -- one metric would be
&gt; "is his performance much worse than other servers at the same level?"
&gt;
&gt; Now, the 1.5MB/s cap is relevant to both of the [follwingvulnerabilities.
&gt; Regarding the second issue, I agree that it is a good idea to raise the
&gt; number, and I don't think anybody will object. Regarding the first issue,
&gt; I think you're right, but I don't think we've explored it well enough yet;
&gt; we should do that at some point.

Yeah, while these issues are a concern, I do maintain they don't
warrant keeping the the limit this low. In the first case, I'm not
advocating getting rid of the limit, I just think it should be high
enough that it is not hit within the lifespan of the current Tor
release, which should be about 10Mbytes/sec or so.

As an aside though, an adversary that can afford a 1GB link can do all
sorts of crazy things with that bandwidth even with the limit in
place: the first one likely being mounting a sybil attack from a ton of
disperate IP ranges possibly all from that same link. But yeah, it
would make that node a nice point of surveilance for an external
adversary.

The second issue should be adressed by scanning, but see my points
below as to why we've got a chicken/egg problem.

&gt; We should think about how we can get automated scanning into place. The
&gt; fact that we *can* do a check is great, but we need to work on the next
&gt; step which is having it automatically and constantly look for anomalies.
&gt;
&gt; What is the limiting factor here? Code? High-speed network connections?
&gt; Humans to oversee it? Ways to present the results usefully?

Again, the reason why I am pushing so hard for quick adoption of these
fixes (including expiring poorly chosen guards) is that an unbalanced
network makes it *very* hard to find anomalies.. Once you get past
about the 15th percentile, a lot of nodes begin to look anomalous
(high circuit failure, low capacity, etc). There still is too much
noise for me to make heads or tails of what is cause in every case.
Some are obvious, such as nodes having obscene exit policies, etc. But
some nodes have high circuit loss and no capacity for no good reason,
especially once you get into the 35-50th percentiles. Probably just
load, but could also be liars/active attackers. I just can't tell.

If you balance the network/accept my patches to do so, I will build
continous, automated centralized scanning (though it does have some
weaknesses in that it can be detected/gamed in some cases... I will
also be exploring a distributed method of scanning bandwidth which I
will describe in my Black Hat/Defcon talks).

But yeah, I won't turn away offers to help display results nicely or
people who would like to scan themselves. I will try to elaborate in
the README a bit once I figure out the most reliable way to get good
results.

&gt; &gt; But we should set it high
&gt; &gt; enough that we do not have to raise it for a good while.
&gt; 
&gt; This is an important enough point that I'll elaborate on it. It's not
&gt; just a matter of trying to avoid needing this discussion again in 6
&gt; months when 8MB/s servers are common. Rather, we're trying to pick a
&gt; number to give all the clients right now, so that in 6 months today's
&gt; clients won't be back to harming the load balancing again. So we should
&gt; try to pick a number that will still not be reached at the end of the
&gt; expected lifetime of today's Tor release.
&gt; 
&gt; (There's also a minor partitioning attack here, in the form of a
&gt; statistical leak based on whether you're weighting your node choices like
&gt; the people with the new number or like the people with the old number; but
&gt; I don't think that's a big deal compared to the other big deals we have.)
&gt; 
&gt; &gt; Also, I think the exit weighting formula is wrong. If that portion of
&gt; &gt; my patch is not to be applied, I would like some sort of justification
&gt; &gt; as to why what is currently there is better than what I proposed (or
&gt; &gt; is even correct), but that is the least of my concerns, since exit
&gt; &gt; bandwidth is usually scarce.
&gt; 
&gt; I've asked Nick to look at it and compare it to the equation he produced
&gt; earlier. His initial response was similar -- that he wanted some kind
&gt; of justification for why this new one was better.
&gt; 
&gt; My plan is to sit down sometime and look at both equations and try
&gt; to figure out how they compare, but it's low on my priority list, so
&gt; hopefully before then one or the other of you will get beyond the "well,
&gt; I wrote one, and that other one is confusing to me, so why not use mine"
&gt; stage. :)

Heheh, yeah, Nick's analysis was excellent. I came up with the value
mostly by intuition and demonstrated it correct by summing over the
resulting total weighted exit bandwidth to make sure it came out to
how much bandwidth was left over for exits to use as non-exit hops.
Admittedly, his derivation is much better.  It should go into
path-spec. 

Also, I think we should consider doing a similar weighting for
choosing guards for middle nodes. Guard bandwidth is also somewhat of
a scarcity, though not as much as exits (40% by my measure).

-- 
Mike Perry
Mad Computer Scientist
fscked.org evil labs

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070727073415</emailId><senderName>Peter Palfrader</senderName><senderEmail>peter@palfrader.org</senderEmail><timestampReceived>2007-07-27 07:34:15-0400</timestampReceived><subject>Re: OR outgoing IP address</subject><body>

On Fri, 27 Jul 2007, Shachar Shemesh wrote:

&gt; I'm running OR hamakor (tor.hamakor.org.il). The machine in question has
&gt; two IP addresses, and I've almost dedicated the second of which to tor.
&gt; The purpose of this was to allow me to track the tor bandwidth usage.
&gt; 
&gt; Unfortunately, things are not working as planned. While incoming
&gt; connections arrive at the right address, outgoing connections go out
&gt; through the main IP address of the machine.

Quoting your friendly tor manual page:
       OutboundBindAddress IP
              Make  all  outbound  connections  originate  from the IP address
              specified.  This is only useful when you have  multiple  network
              interfaces,  and  you  want all of Tor's outgoing connections to
              use a single one.

That's probably what you are looking for.

Cheers,
Peter
-- 
                           |  .''`.  ** Debian GNU/Linux **
      Peter Palfrader      | : :' :      The  universal
 http://www.palfrader.org/ | `. `'      Operating System
                           |   `-    http://www.debian.org/
</body></email><email><emailId>20070718103647</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-07-18 10:36:47-0400</timestampReceived><subject>Re: Proposal: minimum advertised bandwidth guarantees fast/guard</subject><body>

On Wed, Jul 18, 2007 at 06:31:22AM -0400, Roger Dingledine wrote:
&gt; B) I chose to assign guard status to all stable nodes that meet this
&gt; cutoff -- even exit nodes. We could instead just make the exception for
&gt; non-exit nodes, which would be better for load balancing when exits are
&gt; rare. But having sufficient guards is useful too.
[snip]
&gt; @@ -1709,9 +1713,10 @@
&gt;    rs-&gt;is_valid = ri-&gt;is_valid;
&gt;    rs-&gt;is_possible_guard = rs-&gt;is_fast &amp;&amp; rs-&gt;is_stable &amp;&amp;
&gt;      (!rs-&gt;is_exit || exits_can_be_guards) &amp;&amp;
&gt; -    router_get_advertised_bandwidth(ri) &gt;=
&gt; -    (exits_can_be_guards ? guard_bandwidth_including_exits :
&gt; -     guard_bandwidth_excluding_exits);
&gt; +    (router_get_advertised_bandwidth(ri) &gt;= BANDWIDTH_TO_GUARANTEE_GUARD ||
&gt; +     router_get_advertised_bandwidth(ri) &gt;=
&gt; +     (exits_can_be_guards ? guard_bandwidth_including_exits :
&gt; +      guard_bandwidth_excluding_exits));

Actually, issue B isn't as big a deal as I'd thought. The patch above
makes exits guards only if exits_can_be_guards. The only change is that
BANDWIDTH_TO_GUARANTEE_GUARD is sufficient to be a guard no matter what
the guard_bandwidth_including/excluding_exits values happen to be.

--Roger

</body></email><email><emailId>20070721020900</emailId><senderName>Mike Perry</senderName><senderEmail>mikeperry@fscked.org</senderEmail><timestampReceived>2007-07-21 02:09:00-0400</timestampReceived><subject>Re: Proposal: minimum advertised bandwidth guarantees fast/guard</subject><body>


Thus spake Roger Dingledine (arma@mit.edu):

&gt; Hi folks,
&gt; 
&gt; This is a quick proposal, based on my post in Mike Perry's recent thread
&gt; at http://archives.seul.org/or/dev/Jul-2007/msg00022.html
&gt; Please feel free to flesh it out; also somebody should please write us
&gt; a patch to the specs.
&gt; 
&gt; The issue is the same attack as in proposal 107: an attacker who signs
&gt; up a thousand servers each claiming 10MB/s bandwidth will cause the
&gt; median bandwidth to be 10MB/s, and all current guards will lose their
&gt; guard status -- causing their users to abandon them and pick one of the
&gt; new adversary-controlled nodes. The bug is that while we cap bandwidth
&gt; at 1.5MB/s when considering load balancing, we failed to do it when
&gt; considering median bandwidth for guard qualification.
&gt; 
&gt; I've attached a patch; but there are still some design questions to
&gt; ponder and maybe improve:
&gt;
&gt; A) I picked 500KB/s as the cutoff. Is there a better way to pick this?

Current natural cutoff is 53KB/sec. Currently 115 "Guard" flagged
routers live between 53KB/sec and 500KB/sec. Only 64 are above.

Guards greater than 500KB/sec account for 78MB/sec of all guard
bandwidth, Guards less than 500KB/sec account for 25MB/sec of all
guard bandwidth.

Since guard selection is still largely uniform instead of weighted, this 
500KB cutoff will allow an attacker to still displace the guards of
approx 64% of Tor users. :(

Here are some other stats:
400k:
Routers above: 79 bw: 84M
Routers below: 101 bw: 19M

300k:
Routers above: 96 bw: 90M
Routers below: 83 bw: 13M

250k:
Routers above: 100 bw: 91M
Routers below: 79 bw: 12M

200k:
Routers above: 121 bw: 96M
Routers below: 58 bw: 7M

125k:
Routers above: 147 bw: 100M
Routers below: 32 bw: 3M

If everyone were weighting guards by bandwidth, 300-400k would
probably be a fine cutoff. But since we haven't yet decided to expire
people's already uniformly chosen guards, the limit should probably be
somewhere around 125k if you really don't want half of the existing
tor users to continue to be vulnerable to this attack.

Alternatively, we could make 0.1.2.16/0.2.0.3 expire all guards for
all versions prior, which would also help the network balancing. That
would be nice. :)

&gt; C) Since we defined is_possible_guard to require is_fast, there was
&gt; another turtle underneath this turtle. I fixed this by declaring that
&gt; anybody with at least 100KB/s of bandwidth is automatically Fast. We
&gt; could also fix it by getting rid of the is_fast requirement; but I think
&gt; if we do that I'll be doing a new proposal later about how somebody can
&gt; sign up 8000 new servers and suddenly no other servers count as Fast. ;)

Ouch.
 
&gt; D) Why 100KB/s? Is there a better number?

The natural cutoff seems to be currently ~20K/sec FWIW.

30k:
Routers above: 711 bw: 222M
Routers below: 125 bw: 4M

40k:
Routers above: 621 bw: 220M
Routers below: 221 bw: 6M

60k:
Routers above: 502 bw: 214M
Routers below: 340 bw: 12M

80k:
Routers above: 425 bw: 209M
Routers below: 417 bw: 17M

100k:
Routers above: 392 bw: 206M
Routers below: 450 bw: 20M

Since Fast nodes are chosen in proportion to bandwidth, this limit can
probably safely be set much higher proporitionally. 100k looks like it
may even work.


-- 
Mike Perry
Mad Computer Scientist
fscked.org evil labs

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070722000758</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-07-22 00:07:58-0400</timestampReceived><subject>Re: Proposal: minimum advertised bandwidth guarantees fast/guard</subject><body>

I've committed the proposed patch, with a few more comments and slightly
different numbers than originally proposed:
http://archives.seul.org/or/cvs/Jul-2007/msg00181.html

On Fri, Jul 20, 2007 at 07:09:00PM -0700, Mike Perry wrote:
&gt; If everyone were weighting guards by bandwidth, 300-400k would
&gt; probably be a fine cutoff. But since we haven't yet decided to expire
&gt; people's already uniformly chosen guards, the limit should probably be
&gt; somewhere around 125k if you really don't want half of the existing
&gt; tor users to continue to be vulnerable to this attack.

Ok. The goal is to pick a number sufficiently high that we would consider
this node worthwhile as a guard even if one day we have a whole lot of
even faster nodes. I picked 250KB/s as a good guess for that.

&gt; Alternatively, we could make 0.1.2.16/0.2.0.3 expire all guards for
&gt; all versions prior, which would also help the network balancing. That
&gt; would be nice. :)

Right. We're not going to do that in the 0.2.0.3-alpha timeframe (which
I hope to put out in the next days), but it's still something to ponder.
As we wait, though, the problem goes away on its own -- now that 0.1.2.15
is out and new users will be picking guards better. I have to admit that
I have no intuition about user turnover though, so no intuition about
how quickly it will correct itself.

&gt; Since Fast nodes are chosen in proportion to bandwidth, this limit can
&gt; probably safely be set much higher proporitionally. 100k looks like it
&gt; may even work.

I decided to stick with 100KB/s here.

Thanks!
--Roger

</body></email><email><emailId>20070705173813</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-07-05 17:38:13-0400</timestampReceived><subject>Re: TODO: Add a way to request DNS resolves from the controller</subject><body>


On Mon, Jul 02, 2007 at 10:55:09PM +0100, Robert Hogan wrote:
&gt; On Monday 02 July 2007 22:21:12 Robert Hogan wrote:
&gt; &gt; On Wednesday 27 June 2007 17:20:06 Nick Mathewson wrote:
&gt; &gt; &lt;snip&gt;
&gt; &gt;
&gt; &gt; &gt; I think the approach you describe above is okay.  It shouldn't break
&gt; &gt; &gt; backward compatibility, since preexisting controllers will never issue
&gt; &gt; &gt; RESOLVE commands, and so will never get "650 RESOLVE" events.
&gt; &gt;
&gt; &gt; Hi Nick,
&gt; &gt;
&gt; &gt; Patch attached. It supports host and reverse lookups.
&gt; &gt;
&gt; &gt; Sample output:
&gt; &gt;
&gt; &gt; resolve hotmail.com
&gt; &gt; 250 OK
&gt; &gt; 650 RESOLVE hotmail.com:64.4.32.7
&gt; &gt; resolve 64.4.32.7
&gt; &gt; 250 OK
&gt; &gt; 650 RESOLVE 64.4.32.7:lc1.bay0.hotmail.com
&gt; &gt;
&gt; &gt; Let me know what needs cleaning up/reworking.
&gt; 
&gt; For a start it didn't handle unknown hostnames, or any other error conditions. 
&gt; Nor did it respect the indentation in dnsserv.c. The attached does.
&gt; 
&gt; I haven't included a write-up for controlspec.txt.

Almost there, and generally quite nice.

These issues remain, though:
  - As written, if there's more than one controller that uses the
    RESOLVE command, all of them are informed whenever _any_ of them
    gets a "650 RESOLVE".  (This is the big one, the rest are cosmetic
    and easy to fix.)

  - Using a new socks command isn't right here: this isn't new
    functionality.  Instead, it would probably be best to add a bit to
    the edge_connection_t struct.

  - evdns_server_control() is almost entirely cut-and-pated code.
    That's bad.  Common code should be in a function.

  - The evdns_* prefix is reserved for functions in evdns.c.

  - The handle_control_* prefix is for handling control commands from
    a controller.

I'll try to fix this stuff and check in the feature later today.
Please let me know if you'd rather do it yourself.

peace,
-- 
Nick Mathewson

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070725225614</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-07-25 22:56:14-0400</timestampReceived><subject>Re: [PATCH] dns_server_port not getting stored</subject><body>


On Tue, Jul 24, 2007 at 06:18:25PM +0100, Robert Hogan wrote:
&gt; 
&gt; Not sure why I didn't notice this one before.
&gt; 
&gt; There's a race condition (or something) when you unset dnsport - because the 
&gt; conn disappears but the eventdns callback doesn't. The patch fixes it.
&gt; 
&gt; Also added the conn-type to a couple of condition statements that it seemed to 
&gt; belong to.

Thanks, applying!


-- 
Nick Mathewson

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070727073533</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-07-27 07:35:33-0400</timestampReceived><subject>Re: OR outgoing IP address</subject><body>

On Fri, Jul 27, 2007 at 10:30:38AM +0300, Shachar Shemesh wrote:
&gt; I'm running OR hamakor (tor.hamakor.org.il). The machine in question has
&gt; two IP addresses, and I've almost dedicated the second of which to tor.
&gt; The purpose of this was to allow me to track the tor bandwidth usage.
&gt; 
&gt; Unfortunately, things are not working as planned. While incoming
&gt; connections arrive at the right address, outgoing connections go out
&gt; through the main IP address of the machine. This mean that:
&gt; 1. The TOR checks fail
&gt; 2. I cannot log usage properly

Check out OutboundBindAddress in the man page.

(For others reading here, future questions like this should probably go
to the or-talk list, not the development list.)

--Roger

</body></email><email><emailId>20070728103107</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-07-28 10:31:07-0400</timestampReceived><subject>Re: Correct formulas for exit weights [was Re: Exit Balancing Patch]</subject><body>

On Sat, Jul 28, 2007 at 01:34:54AM -0400, Nick Mathewson wrote:
&gt; [I'm writing this parenthetical after having gone through the
&gt;  derivation.  Summary: I got the same result as Mike.]

Great. Can you extract the part of Mike's suggested patch that makes the
math right, verify that it actually does the right thing, and apply it?

&gt; So long as we're doing this, let's do it properly and expand our model
&gt; a little, to consider cannibalized circuits and non-3-hop paths.
&gt; These questions are mostly for Roger, but anybody else who has
&gt; empirical data should step up too:
&gt; 
&gt; 1) Roger, can you comment on the average path length in practice?  Is it
&gt;    close enough to that we should just set L=3?

Yes, I think it's pretty much three.

Tor uses four hop paths when you use the .exit notation, or when you
request a site that runs on the same IP address as a Tor node that allows
exit to that site. There are a few other minor cases but I don't think
they matter.

I'll let you know if I realize I'm wrong, but don't wait up.

&gt; 2) What fraction of circuits are cannibalized?  If all L-hop circuits
&gt;    that already end at an Exit are (with probability Pc) cannibalized
&gt;    and extended to another Exit, we now have
&gt;      BE = (1+Pc)*B + B*(L-1) * Pe,
&gt;    which changes our analysis a little.

Again, the only ones that are extended to a fourth hop are the cases
above.

Also notice that these equations neglect the concept of "internal"
circuits (see path-spec.txt for definitions) that are used for interacting
with hidden services. But I think it's also safe to assume that roughly
none of the Tor bandwidth relates to hidden services.

--Roger

</body></email><email><emailId>20070729052307</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-07-29 05:23:07-0400</timestampReceived><subject>Re: Proposal 109: No more than one server per IP address [was Re: Sybil Attack Countermeasures]</subject><body>


On Sun, Mar 11, 2007 at 11:33:22PM -0400, Nick Mathewson wrote:
&gt; I've added the original proposal as "109-no-sharing-ips.txt", retitled
&gt; it to No more than one server per IP address, and merged in Roger's
&gt; suggestions (except for those that represent an alternative approach;
&gt; I've put those at the end).

Proposal 109 is now implemented in svn.  Thanks to Kevin and Damon for
taking time to write it up, and for all their help and patience!

(For details, see
   http://tor.eff.org/svn/trunk/doc/spec/proposals/109-no-sharing-ips.txt
)

yrs,
--=20
Nick Mathewson

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070730033956</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-07-30 03:39:56-0400</timestampReceived><subject>Re: [or-cvs] r10974: Be even more aggressive about separating local traffic from  (in tor/trunk: . d</subject><body>

For more context, see
https://tor.eff.org/svn/trunk/doc/spec/proposals/111-local-traffic-priority.txt

On Sun, Jul 29, 2007 at 09:25:34PM -0400, Nick Mathewson wrote:
&gt;  [...]
&gt; &gt; +  Option 4: put both classes of circuits over a single connection, and
&gt; &gt; +  keep track of the last time we read or wrote a high-priority cell. If
&gt; &gt; +  it's been less than N seconds, give the whole connection high priority,
&gt; &gt; +  else give the whole connection low priority.
&gt; 
&gt; Hm.  Is it a problem that this approach makes it trivial for an attacker
&gt; to tell when you've been online recently (to about the nearest second),
&gt; and to learn your guard nodes?

Yes, this would be a problem. It would also be a problem with Option 5
(basically Option 4 plus communicating with the other end about how it
should rate limit the connection).

It would seem that we have a choice:

  Option A: let an observer between the relay we run and the next relay
  be able to distinguish local traffic from relayed traffic by seeing
  it in two different TCP connections, but they're separate so relayed
  users can't learn as much; vs

  Option B: put them on the same connection, and now an observer can
  still watch the speed to guess what sort of traffic it is but the
  attack is less straightforward, and there are new "relay through it
  to learn stuff" attacks.

&gt; This seems somehow worse than the partitioning problem with "option
&gt; 2", since this is something anybody can do remotely, rather than
&gt; requiring the attacker to eavesdrop or be one of your guards.

It would seem that if we put all the traffic on a single connection,
then we will always be battling between giving good performance to local
traffic vs hiding whether local traffic is getting good performance now.

Does that mean you're happier about option 2 now? I had elaborated a
bit on it at http://archives.seul.org/or/dev/Mar-2007/msg00056.html

--Roger

</body></email><email><emailId>20070730171819</emailId><senderName>Paul Syverson</senderName><senderEmail>syverson@itd.nrl.navy.mil</senderEmail><timestampReceived>2007-07-30 17:18:19-0400</timestampReceived><subject>Re: Exit Balancing Patch</subject><body>

On Sun, Jul 29, 2007 at 10:33:59PM -0700, Mike Perry wrote:
&gt; 
&gt; 
&gt; As an aside though, an adversary that can afford a 1GB link can do all
&gt; sorts of crazy things with that bandwidth even with the limit in
&gt; place: the first one likely being mounting a sybil attack from a ton of
&gt; disperate IP ranges possibly all from that same link. But yeah, it
&gt; would make that node a nice point of surveilance for an external
&gt; adversary.
&gt; 

It's not that simple. Clearly the biggest bang-for-the-buck adversary
threat from monitoring at this point is caused by somebody setting up
and owning nodes. But if enough of the traffic is concentrated through
few enough nodes, then this might not be true any more. The threat
will not only or even primarily be from bad guys setting up nodes, it
will be from good guys trying to contribute as much as possible to the
network who thereby concentrate enough traffic to make themselves fat
targets for compromise (technical or legal) but much more
significantly bridging by just watching their network pipes (which I
think is the more problematic concern). In a nutshell, the more the
network has single-point proxy properties the more it will have
single-point proxy vulnerabilities. If you can sit on the network
connection of a handful of nodes and watch say half of the traffic in
the network, then you have basically won. This is to some extent the
point made in the "routing zones" paper (Feamster and Dingledine) and
a bit elsewhere, but I think the threat becomes much more realistic
than there in terms of how heavily resourced and influential an
adversary we're talking about.

&gt; 
&gt; Also, I think we should consider doing a similar weighting for
&gt; choosing guards for middle nodes. Guard bandwidth is also somewhat of
&gt; a scarcity, though not as much as exits (40% by my measure).
&gt; 

Agree. Already touched on this with Roger in a side conversation.
Will get back to it in my copious free time.

aloha,
Paul
</body></email><email><emailId>20070601104708</emailId><senderName>Karsten Loesing</senderName><senderEmail>karsten.loesing@gmx.net</senderEmail><timestampReceived>2007-06-01 10:47:08-0400</timestampReceived><subject>Length of new onion addresses</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

(posting to or-talk and or-dev, because it concerns both, usability and
development)

Hi,

at the moment I am designing the new ASCII-based format for hidden
service descriptors, including new security features like encryption of
introduction points and the ability to be distributed among onion
routers unpredictably for non-clients. This incorporates a secret cookie
that needs to be passed between the hidden service provider and his
clients in addition to the service id which is the current onion
address. You can read about all the details in proposal #114 in the svn
repository.

As the new descriptor might replace the current descriptor some day and
the format of onion addresses would affect all hidden service users, I
would like to discuss this decision of the onion address format in
public, rather than make a decision on my own and being confronted with
incomprehension when it might be introduced.

The current onion addresses consist of 80 bits and (as you all know)
look like this (address of the hidden wiki):

http://6sxoyfb3h2nvok2d.onion/

The new onion addresses would consist of two parts: (1) the service id
and (2) the secret cookie.

(1) In contrast to the current format, the service id is not used to
identify the service (bad name then, I know), but to generate an
unpredictable descriptor id where to find the service descriptor. If an
adversary can create an own key pair with a fingerprint equal to the
service id, she can prevent the actual hidden service from announcing
his service. Though, the effect of this is limited, because descriptor
ids are automatically changed every day. My idea was to use 32 bits for
the service id.

(2) The secret cookie is the key for encrypting and decrypting the
introduction points and to calculate the current descriptor id. Whoever
finds out the secret cookie could observe hidden service activity and
attack introduction points which both would otherwise not be possible.
My plan was to use a 128 bit key as secret cookie.

In total, new onion addresses would be 160 bits long. The question is
now, if an onion address of that size is still manageable for human
beings? (Is the current size manageable after all?) For illustration
purposes, the new addresses would look like this:

http://6sxoyfb3h2nvok2d6sxoyfb3h2nvok2d.onion/

Or are my assumptions concerning the length of the service id still too
incautious, and would 200 bits (72 bits for service id and 128 bits for
the secret cookie), resulting in the following onion address, be better?

http://6sxoyfb3h2nvok2d6sxoyfb3h2nvok2d6sxoyfb3.onion/

For downward compatibility reasons, those 200 bits could also be
distributed by using 80 bits for the service id and 120 bits for the
secret key. Then, people could start using the new descriptor by simply
adding a dot and a secret cookie to their current (unchanged) onion
address. This would look like this:

http://6sxoyfb3h2nvok2d.6sxoyfb3h2nvok2d6sxoyfb3.onion/

To the (probably upcoming) question, why one needs a secret cookie at
all, or if it could also be used optionally in the long run: The plan is
to distribute the storage of descriptors, primarily for scalability
reasons. But this raises new security issues, because anyone running a
stable onion router could become responsible for storing a descriptor,
so that we simply need new security mechanisms. Otherwise, security
would be worse by the distribution, but with the secret cookie, security
even gets better than before.

But perhaps we should rather aim for usability than for security and use
only 120 bit long onion addresses, e.g. by using 32 bits for the service
id and 88 bits for the cookie, resulting in the following onion address?

http://6sxoyfb3h2nvok2d6sxoyfb3.onion/

Maybe we shouldn't even extend the onion addresses at all, but allocate
the 80 bits in another way, e.g. 24 bits for the service id and 56 bits
for the secret cookie? Then we should use another virtual top level
domain to distinguish current and new descriptors, resulting in
something like the following:

http://6sxoyfb3h2nvok2d.hidden/

What do you guys prefer? How do you exchange onion addresses? Publishing
them on non-hidden web pages, pasting them to IRC chats, writing them on
business cards, memorizing and telling them, ...? I think it's important
to find a balance between security and usability here.

The question is: Does size matter? :)

Any comments are welcome! Thanks!

- --Karsten
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFGX/ks0M+WPffBEmURAg42AJ9l6aDu++f1Ozaesouxxm4d82rdwgCgsC8l
l0858q0gkfWYlcOG3odyT+s=
=BGOH
-----END PGP SIGNATURE-----
</body></email><email><emailId>20070605203744</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-06-05 20:37:44-0400</timestampReceived><subject>Re: control interface via unix domain socket</subject><body>


On Tue, Jun 05, 2007 at 09:14:36PM +0200, Peter Palfrader wrote:
&gt; On Mon, 04 Jun 2007, Nick Mathewson wrote:
  [...]
&gt; 
&gt; How does this look?

Looks good.  I'll clean up a few things and check it in.

-- 
Nick Mathewson

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070607162553</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-06-07 16:25:53-0400</timestampReceived><subject>Re: cross build tor</subject><body>


On Wed, Jun 06, 2007 at 01:44:39PM +0800, Hao Jiajie wrote:
&gt; thanks for you help
&gt; &gt;There are a lot of changes in the way 0.2.0.2-alpha handles searching
&gt; &gt;for libraries; does 0.2.0.2-alpha work any better for you?
&gt; 
&gt; I did not try 0.2.0.2-alpha, but i tryied tor-0.1.2.14, first i meet some 
&gt; errors
&gt; about libevent, openssl(about cross-build), then i searched google,then
&gt; i can cross build tor in  my gentoo.
&gt; 
&gt; i have a qestion,what's the normal way to build tor.exe(and other related
&gt; lib, like zlib,openssl,libevent)  for windows?

Check out the instructions in tor-win32-mingw-creation.txt, which is
online at http://tor.eff.org/svn/trunk/doc/tor-win32-mingw-creation.txt

There's a cross-platform build script in contrib/cross.sh, but I don't
know how good it is.

yrs,
-- 
Nick Mathewson

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070607213458</emailId><senderName>coderman</senderName><senderEmail>coderman@gmail.com</senderEmail><timestampReceived>2007-06-07 21:34:58-0400</timestampReceived><subject>Re: pre-proposal for IPv6 exit support, questions</subject><body>

On 6/7/07, Nick Mathewson &lt;nickm@freehaven.net&gt; wrote:
&gt;...
&gt; &gt; the OR's torrc should contain an explicit OutboundBindAddress with an
&gt; &gt; IPv6 address to enable IPv6 exit.  if no IPv6 address is bound the OR
&gt; &gt; should not consider itself IPv6 capable. (otherwise all of the routers
&gt; &gt; with link local IPv6 will suddenly default to supporting IPv6?)
&gt;
&gt; Hmmm.  I understand the point of this, but I don't think
&gt; OutboundBindAddress is the way to go.  OutboundBindAddress is used
&gt; right now to say "Make sure that all outgoing connections use this
&gt; address."  I don't want to add an extra meaning.
&gt;
&gt; If I understand correctly, link-local and site-local IPv6 addresses
&gt; are easy to detect.  Couldn't Tor do this automatically, as it detects
&gt; RFC 1918 addresses now?

that's a better idea.  my only concern was routers with a public IPv4,
a site local IPv6 that provides route to 2000::/3.  this is probably
an obscure edge case not worth worrying about.  (even 6to4 tunneled
endpoints get a 2002::/16)


&gt; &gt; - exit policy: ...
&gt; &gt; should IPv6 capable ORs be required to include at least one IPv6
&gt; &gt; address or netmask in their exit policy, to signal IPv6 capability?
&gt; ...
&gt; But if we're talking about "Does the *node* need to _list_ an ipv6
&gt; address in the exit policy in its router to be considered
&gt; ipv6-capable", that's more reasonable.  I like that idea, in fact.

yes, this was the intent.  it should work automagically if a (!local)
IPv6 address is detected, and then the IPv6 relevant parts enabled in
the exit policy.  this would then be used to identify IPv6 capable
exits.


&gt; &gt;  should public IPv6 connectivity be
&gt; &gt; verified (similar to OR IP/Port reachability for routers)?
&gt;
&gt; Verifying the ability to _exit_ is outside of what Tor authorities do
&gt; now; this sounds like a fine job for Mike Perry's "Snakes on a Tor"
&gt; program.

agreed.  that makes sense.



&gt; Eventdns is already required in Tor 0.2.0.x-alpha; we don't do
&gt; dnsworkers any more.  (They sucked, and platform resolver libraries
&gt; sucked worse.)
&gt; ...
&gt; &gt; if a client wishes to use IPv6 exit, somehow signal to the exit that
&gt; &gt; IPv6 is preferred, and only use the AAAA lookups/responses when the
&gt; &gt; origin has declared IPv6 interest...
&gt;
&gt; Hmmm.  I'm okay saying "If there is an ipv4 address, I will connect to
&gt; the ipv4 address.  I'll only connect to the ipv6 address if I find
&gt; that there's no ipv4 address and there's only an ipv6 address, or if
&gt; you request the ipv6 address explicitly."
&gt;
&gt; I think there's room for a flag in BEGIN and RESOLVE cells, though we
&gt; might need to make sure we only set the flag for newer Tors that
&gt; accept flags there.

another possibility is providing a RESOLVE6 that only deals with AAAA
resource records.  if the client prefers IPv6, it can request RESOLVE6
lookups, and then always provide CONNECT with an IPv6 address,
removing ambiguity.

likewise, in the IPv6 SOCKS5 example below, an IPv6 client using the
Tor SOCKS proxy will default to using RESOLVE6 for names in SOCKS
requests, and IPv6 CONNECTs.

hacking RESOLVE / RESOLVE6 this way doesn't seem too elegant.  it
would avoid long timeouts for AAAA lookups when only IPv4 addresses
are desired; i don't know how common this is, but it has caused
problems in the past.


&gt; &gt; the RedirectExit option should support IPv6 destinations?
&gt;
&gt; Yes; or we should rip it out.  (Does anybody actually use it?)

ripping it out seems like a good idea.


&gt; &gt; the VirtualAddrNetwork setting will need a private netmask for IPv6
&gt; &gt; ranges used in MAPADDRESS.  something in link local unicast
&gt; &gt; (FE80::/10) should work.
&gt;
&gt; Right.  I would prefer if there were a range of _host-local_ addresses
&gt; (like 127/8 in IPv4), though.

the FC00::/7 unique local prefix seems well suited for this then.
the Global ID is randomly populated and the Subnet ID can be set to an
arbitrary value.  MAPADDRESS then selects Interface ID's as needed.
[0]


&gt; &gt; should clients have a "PreferIPv6" flag in their configuration to
&gt; &gt; signal OR exits that DNS and TCP connect should use IPv6 addresses
&gt; &gt; when possible?
&gt;
&gt; Hmm. I'm not sure.  I'd go with "Not unless somebody turns out to need
&gt; it." for now.

this would be another benefit of RESOLVE6 and explicit CONNECT (or
MAPADDRESS) with IPv6 addresses.


&gt; &gt; - sample IPv6 default exit policy:
&gt;...
&gt; Hm.  At the descriptor level, we can't do it like this.  Existing Tors
&gt; can't parse IPv6 addresses in exit policies, and so won't accept any
&gt; descriptor that has them.
&gt;
&gt; I think we need to create new "accept6" and "reject6" items for
&gt; descriptors, and intermix them with existing accept and reject items.

ok.


&gt; Other semantic stuff you haven't specified:
&gt;
&gt;   * it looks like you're assuming that "*" means "All IPv4 and all
&gt;     IPv6" addresses.  That's cool.  We can have "0.0.0.0/0" as our
&gt;     notation for "all IPv4 addresses" and "[::]/0" as our notation for
&gt;     "all IPv6 addresses".

yes, this should be made explicitly clear in a proposal. :)


&gt;   * Are we assuming that ::ffff:1.2.3.4 and 1.2.3.4 and the obsolete
&gt;     ::0:1.2.3.4 are all the same address for the purpose of exit
&gt;     policy?  I think we have IPv4 policies also apply to IPv4-mapped
&gt;     IPv6 addresses, so that "reject 10.0.0.0" also means "reject
&gt;     ::ffff:10.0.0.0".  Otherwise, everybody's exit policy will need to
&gt;     get twice as big.

the IPv4 mapped IPv6 addresses are usually encountered if a listening
socket is bound to both IPv4 and IPv6 addresses on a given port (or
similar situations).

if the SOCKS5 interface, for example, got a request for an IPv4 mapped
IPv6 address, i think it should CONNECT that request directly via
IPv4.  the application using SOCKS would still see an IPv4 mapped IPv6
address, as desired, but the transport would function more in line
with the way hosts handle these addresses now.

it would seem easier (in terms of code and design) to eliminate IPv4
mapped IPv6 destinations in an exit policy.  this should be explicitly
stated in a proposal too.

thanks for the comments.  i've got enough detail to get a draft
proposal implemented. (i think :)

best regards,


0. RFC 4193 Unique Local IPv6 Unicast Addresses
   http://www.faqs.org/rfcs/rfc4193.html
</body></email><email><emailId>20070605074045</emailId><senderName>"Hao Jiajie"</senderName><senderEmail>guorke@gmail.com</senderEmail><timestampReceived>2007-06-05 07:40:45-0400</timestampReceived><subject>cross build tor</subject><body>

hi, all
can i cross-build tor in linux?
I have already install cross-build enviroment follow by
http://www.libsdl.org/extras/win32/cross/
and i cross-complied libevent ok, but when i execute
cd tor-0.1.2.14
./cross-configure.sh
,it says configure: error: Could not find a linkable libevent.
You can specify an explicit path using --with-libevent-dir.
I tried to execute e  ./cross-configure.sh  --with-libevent-dir=/usr/local/lib,
still failed.
can you help me? thanks.
</body></email><email><emailId>20070607061857</emailId><senderName>coderman</senderName><senderEmail>coderman@gmail.com</senderEmail><timestampReceived>2007-06-07 06:18:57-0400</timestampReceived><subject>pre-proposal for IPv6 exit support, questions</subject><body>

i'd like some feedback on possible integration of IPv6 with Tor for
exit and DNS.  all of the following changes need not be implemented
for IPv6 exit to be useful, however, i think most of them will need to
be present for clients to use IPv6 easily.

- transport:
this is perhaps the easiest layer.  the Tor specs already define IPv6
address types and formats which can finally be put to use.  is there a
good reason to keep IPv6 and IPv4 streams in different circuits?

the OR's torrc should contain an explicit OutboundBindAddress with an
IPv6 address to enable IPv6 exit.  if no IPv6 address is bound the OR
should not consider itself IPv6 capable. (otherwise all of the routers
with link local IPv6 will suddenly default to supporting IPv6?)


- exit policy:
existing default exit policy contains *:* and *:$port directives.
this should be expanded to exclude internal/reserved IPv6 address
space as well for IPv6 capable ORs.  [i've included a sample exit
policy at the end of this msg]

should IPv6 capable ORs be required to include at least one IPv6
address or netmask in their exit policy, to signal IPv6 capability?
(likewise, should non-IPv6 capable OR's be forced to exclude any IPv6
addresses)
(for example, accept [2000::]/3:* used to signal IPv6 capability)

should some other method (extended descriptor information?) be used to
identify IPv6 capable OR's?  should public IPv6 connectivity be
verified (similar to OR IP/Port reachability for routers)?


- RESOLVE and RESOLVE_PTR:
DNS for IPv6 sucks [0].  how to limit this suckiness?  some options:

if an OR is IPv6 capable, it must return AAAA and A RR's to every
query.  this (should) keep both IPv4 and IPv6 clients happy, but has
the following drawbacks:
- some AAAA lookups may take forever to timeout, thus delaying the A result.
- some AAAA lookups will fail in a way that may make a resolver
stub/library think a domain does not exit, rather than no IPv6 address
exists for this domain. (require eventdns for IPv6 resolution?)
- AAAA lookups and the IPv6 addresses returned are a waste of
time/bandwidth for IPv4 only clients, and may in fact confuse them.

if a client wishes to use IPv6 exit, somehow signal to the exit that
IPv6 is preferred, and only use the AAAA lookups/responses when the
origin has declared IPv6 interest.  this should apply when doing
RESOLVE or CONNECT to named servers (that is to say, RESOLVE should
return IPv6 addresses, and CONNECT should attempt to connect to IPv6
addresses when a server is referred to by name, like 'www.hexago.com')

other ideas / suggestions?


- misc options:
the RedirectExit option should support IPv6 destinations?

the TransListenAddress should support IPv6 addresses.  this means
using IPV6_ORIGINAL_DST instead of SO_ORIGINAL_DST (and equivalent
flags for other OS'es).

the VirtualAddrNetwork setting will need a private netmask for IPv6
ranges used in MAPADDRESS.  something in link local unicast
(FE80::/10) should work.

should clients have a "PreferIPv6" flag in their configuration to
signal OR exits that DNS and TCP connect should use IPv6 addresses
when possible?


- SOCKS5:
the torrc SOCKSBindAddress should accept an IPv6 address.  if this is
used for SOCKS5, then RESOLVE and CONNECT hostname should all prefer
an IPv6 address when possible.  (again, signal this upstream somehow?
assume that IPv6 capable exits will return IPv6 addresses?)

it would also be nice if somehow IPv4 clients could express an IPv6
preference via SOCKS5.  i'm not sure how this could be done easily
(another config option?).


- control interface:
i don't see a compelling reason to support a control port on IPv6.
as for the control spec, MAPADDRESS [::0]=hostname should work as
indicated in the spec.  the spec lists the address format as just
"::0" while accept / reject declarations need the brackets.  should
this be consistent?

what new control capabilities, if any, should be added?  the only one
that comes to mind is CHECKING_REACHABILITY like commands for IPv6
exit, or DNS lookup with AAAA responses (IPV6DNS_USELESS?, etc)


thanks in advance for any feedback and insight...

best regards,


0. "The IPv6 mess"
   http://cr.yp.to/djbdns/ipv6mess.html

- sample IPv6 default exit policy:
reject 0.0.0.0/8
reject 169.254.0.0/16
reject 127.0.0.0/8
reject 192.168.0.0/16
reject 10.0.0.0/8
reject 172.16.0.0/12
reject [0000::]/8
reject [0100::]/8
reject [0200::]/7
reject [0400::]/6
reject [0800::]/5
reject [1000::]/4
reject [4000::]/3
reject [6000::]/3
reject [8000::]/3
reject [A000::]/3
reject [C000::]/3
reject [E000::]/4
reject [F000::]/5
reject [F800::]/6
reject [FC00::]/7
reject [FE00::]/9
reject [FE80::]/10
reject [FEC0::]/10
reject [FF00::]/8
reject *:25
reject *:119
reject *:135-139
reject *:445
reject *:1214
reject *:4661-4666
reject *:6346-6429
reject *:6699
reject *:6881-6999
# accept [2000::]/3:* is implied
accept *:*
</body></email><email><emailId>20070530083640</emailId><senderName>Mike Perry</senderName><senderEmail>mikeperry@fscked.org</senderEmail><timestampReceived>2007-05-30 08:36:40-0400</timestampReceived><subject>Proposal: Two Hop Paths</subject><body>


Title: Two Hop Paths
Version:
Last-Modified:
Author: Mike Perry
Created:
Obsoletes: 112
Status:


Overview:

  The idea is that users should be able to choose if they would like
  to have either two or three hop paths through the tor network.

  This value should be modifiable from the controller, and should be
  available from Vidalia.


Motivation:

  The Tor network is slow and overloaded. Increasingly often I hear
  stories about friends and friends of friends who are behind firewalls,
  annoying censorware, or under surveillance that interferes with their
  productivity and Internet usage, or chills their speech. These people
  know about Tor, but they choose to put up with the censorship because
  Tor is too slow to be usable for them. In fact, to download a fresh,
  complete copy of levine-timing.pdf for the Theoretical Argument
  section of this proposal over Tor took me 3 tries.

  Furthermore, the biggest current problem with Tor's anonymity for 
  those who really need it is not someone attacking the network to 
  discover who they are. It's instead the extreme danger that so few 
  people use Tor because it's so slow, that those who do use it have 
  essentially no confusion set.

  The recent case where the professor and the rogue Tor user were the
  only Tor users on campus, and thus suspected in an incident involving
  Tor and that University underscores this point: "That was why the police
  had come to see me. They told me that only two people on our campus were
  using Tor: me and someone they suspected of engaging in an online scam.
  The detectives wanted to know whether the other user was a former
  student of mine, and why I was using Tor"[1].

  Not only does Tor provide no anonymity if you use it to be anonymous
  but are obviously from a certain institution, location or circumstance, 
  it is also dangerous to use Tor for risk of being accused of having 
  something significant enough to hide to be willing to put up with 
  the horrible performance.

  There are many ways to improve the speed problem, and of course we
  should and will implement as many as we can. Johannes's GSoC project
  and my reputation system are longer term, higher-effort things that
  will still provide benefit independent of this proposal.

  However, reducing the path length to 2 for those who do not need the
  (questionable) extra anonymity 3 hops provide not only improves
  their Tor experience but also reduces their load on the Tor network by
  33%, and can be done in less than 10 lines of code. That's not just
  Win-Win, it's Win-Win-Win.


Theoretical Argument:

  It has long been established that timing attacks against mixed
  networks are extremely effective, and that regardless of path
  length, if the adversary has compromised your first and last
  hop of your path, you can assume they have compromised your
  identity for that connection.

  In fact, it was demonstrated that for all but the slowest, lossiest
  networks, error rates for false positives and false negatives were
  very near zero[2]. Only for constant streams of traffic over slow and
  (more importantly) extremely lossy network links did the error rate
  hit 20%. For loss rates typical to the Internet, even the error rate
  for slow nodes with constant traffic streams was 13%.

  When you take into account that most Tor streams are not constant,
  but probably much more like their "HomeIP" dataset, which consists
  mostly of web traffic that exists over finite intervals at specific
  times, error rates drop to fractions of 1%, even for the "worst"
  network nodes.

  Therefore, the user has little benefit from the extra hop, assuming
  the adversary does timing correlation on their nodes. Since timing 
  correlation is simply an implementation issue and is most likely
  a single up-front cost (and one that is like quite a bit cheaper 
  than the cost of the machines purchased to host the nodes to mount 
  an attack), the real protection is the low probability of getting 
  both the first and last hop of a client's stream.


Practical Issues:

  Theoretical issues aside, there are several practical issues with the
  implementation of Tor that need to be addressed to ensure that 
  identity information is not leaked by the implementation. 
 
  Exit policy issues:

  If a client chooses an exit with a very restrictive exit policy
  (such as an IP or IP range), the first hop then knows a good deal 
  about the destination. For this reason, clients should not select
  exits that match their destination IP with anything other than "*".

  Partitioning:

  Partitioning attacks form another concern. Since Tor uses telescoping
  to build circuits, it is possible to tell a user is constructing only
  two hop paths at the entry node and on the local network. An external 
  adversary can potentially differentiate 2 and 3 hop users, and decide 
  that all IP addresses connecting to Tor and using 3 hops have something 
  to hide, and should be scrutinized more closely or outright apprehended. 
  One solution to this is to use the "leaky-exit" method of attaching 
  streams: The user always creates 3-hop circuits, but if the option 
  is enabled, they always exit from their 2nd hop. The ideal solution
  would be to create a RELAY_SHISHKABOB cell which contains onion
  skins for every host along the path, but this requires protocol
  changes at the nodes to support.

  Guard nodes:

  Since guard nodes do rotate due to network failure, node upgrades and
  other issues, if you amortize the risk a user is exposed to over any
  reasonable duration of Tor usage (on the order of a year), it is the
  same with or without guard nodes. Assuming an adversary has c%/n% of 
  network bandwidth, and guards rotate on average with period R,
  statistically speaking, it's merely a question of if the user wishes
  their risk to be concentrated with probability c/n over an expected
  period of R*c, and probability 0 over an expected period of R*(n-c),
  versus a continuous risk of (c/n)^2. So statistically speaking, guards 
  only create a time-tradeoff of risk over the long run for normal Tor 
  usage. They do not reduce risk for normal client usage, unless the
  client changes IP with a period faster than R*n.[3] 

  Guard nodes do offer a measure of accountability of sorts. If a user
  was using a small set of guard nodes, and then is suddenly apprehended
  as a result of Tor usage, having a fixed set of entry points to suspect
  is a lot better than suspecting the whole network.

  All of this is not terribly relevant to this proposal, but worth bearing 
  in mind, since guard nodes do have a bit more ability to wreak
  havoc with two hops than with three.

  Two hop paths allow malicious guards to get considerably more benefit
  from failing circuits if they do not extend to their colluding peers for
  the exit hop. Since guards can detect the number of hops in a path via
  either timing or by statistical analysis of the exit policy of the 2nd
  hop, they can perform this attack predominantly against 2 hop users
  only.

  This can be addressed by completely abandoning an entry guard after a
  certain ratio of extend or general circuit failures with respect to
  non-failed circuits. The proper value for this ratio can be determined
  experimentally with TorFlow. There is the possibility that the local
  network can abuse this feature to cause certain guards to be dropped,
  but they can do that anyways with the current Tor by just making guards
  they don't like unreachable. With this mechanism, Tor will complain
  loudly if any guard failure rate exceeds the expected in any failure 
  case, local or remote.

  Eliminating guards entirely would actually not address this issue due
  to the time-tradeoff nature of risk. In fact, it would just make it
  worse. Without guard nodes, it becomes much more difficult for clients
  to become alerted to Tor entry points that are failing circuits to make
  sure that they only devote bandwidth to carry traffic for streams which
  they observe both ends.

  It has been speculated that a set of guard nodes can be used to
  fingerprint a user (presumably by a local adversary) when they move
  about. However, it is precisely this activity of moving your laptop that
  causes guards to be marked as down by the Tor client, which then chooses
  new ones.


Why not fix Pathlen=2?:

  The main reason I am not advocating that we always use 2 hops is that
  in some situations, timing correlation evidence by itself may not be
  considered as solid and convincing as an actual, uninterrupted, fully
  traced path. Are these timing attacks as effective on a real network as
  they are in simulation? Would an extralegal adversary or authoritarian
  government even care? In the face of these situation-dependent unknowns,
  it should be up to the user to decide if this is a concern for them or
  not.

  It should probably also be noted that even a false positive
  rate of 1% for a 200k concurrent-user network could mean that for a
  given node, a given stream could be confused with something like 10
  users, assuming ~200 nodes carry most of the traffic (ie 1000 users
  each). Though of course to really know for sure, someone needs to do
  an attack on a real network, unfortunately.

  Additionally, at some point cover traffic schemes may be implemented to
  frustrate timing attacks on the first hop. It is possible some expert 
  users may do this ad-hoc already, and may wish to continue using 3 hops
  for this reason.


Who will enable this option?

  This is the crux of the proposal. Admittedly, there is some anonymity 
  loss and some degree of decreased investment required on the part of 
  the adversary to attack 2 hop users versus 3 hop users, even if it is 
  minimal and limited mostly to up-front costs and false positives.

  The key questions are: 

  1. Are these users in a class such that their risk is significantly 
     less than the amount of this anonymity loss? 

  2. Are these users able to identify themselves?

  Many many users of Tor are not at risk for an adversary capturing c/n
  nodes of the network just to see what they do. These users use Tor to
  circumvent aggressive content filters, or simply to keep their IP out of
  marketing and search engine databases. Most content filters have no
  interest in running Tor nodes to catch violators, and marketers
  certainly would never consider such a thing, both on a cost basis and a
  legal one.

  In a sense, this represents an alternate threat model against these 
  users who are not at risk for Tor's normal threat model.

  It should be evident to these users that they fall into this class. All
  that should be needed is a radio button 

   * "I use Tor for censorship resistance and IP obfuscation, not anonymity. 
      Speed is more important to me than high anonymity."
   * "I use Tor for anonymity. I need more protection at the cost of speed."
  
  and then some explanation in the help for exactly what this means, and
  the risks involved with eliminating the adversary's need for timing
  attacks with respect to false positives.


Implementation:

  new_route_len() can be modified directly with a check of the
  Pathlen option. 

  The exit policy hack is a bit more tricky. compare_addr_to_addr_policy
  needs to return an alternate ADDR_POLICY_ACCEPTED_WILDCARD or 
  ADDR_POLICY_ACCEPTED_SPECIFIC return value for use in
  circuit_is_acceptable.
   
  The leaky exit is trickier still.. handle_control_attachstream 
  does allow paths to exit at a given hop. Presumably something similar
  can be done in connection_ap_handshake_process_socks, and elsewhere?
  Circuit construction would also have to be performed such that the
  2nd hop's exit policy is was is considered, not the 3rd's.
 
  The entry_guard_t structure could have num_circ_failed and
  num_circ_succeeded members such that if it exceeds F% circuit 
  extend failure rate to a second hop, it is removed from the entry list. 
  F should be sufficiently high to avoid churn from normal Tor circuit 
  failure as determined by TorFlow scans.

  The Vidalia option should be presented as a radio button.


Migration:

  Phase 1: Adjust exit policy checks if Pathlen is set. Modify 
  new_route_len() to obey a 'Pathlen' config option.

  Phase 2: Implement leaky circuit ability.

  Phase 3: Experiment to determine the proper ratio of circuit 
  failures used to expire garbage or malicious guards via TorFlow
  (pending bug #440 backport+adoption).

  Phase 4: Implement guard expiration code to kick off failure-prone
  guards and warn the user.

  Phase 5: Make radiobutton in Vidalia, along with help entry
  that explains in layman's terms the risks involved.


[1] http://p2pnet.net/story/11279
[2] http://www.cs.umass.edu/~mwright/papers/levine-timing.pdf
[3] Proof available upon request (But keep in mind I have finite time,
    so please request only if you really don't believe me ;) 

-- 
Mike Perry
Mad Computer Scientist
fscked.org evil labs

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070611074735</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-06-11 07:47:35-0400</timestampReceived><subject>Re: [or-cvs] r10493: When choosing a guard, weight by bandwidth. Resolves bug 440 (in tor/trunk: . s</subject><body>

On Mon, Jun 04, 2007 at 08:15:00PM -0400, nickm@seul.org wrote:
&gt;    tor/trunk/src/or/routerlist.c
&gt;  When choosing a guard, weight by bandwidth.  Resolves bug 440.

Hi Nick, Mike, folks,

I'm still not convinced that this is the best fix.

A recap for those following along at home:
http://bugs.noreply.org/flyspray/index.php?do=details&amp;id=440
The issue is that Tor clients were weighting every node that qualified
as a guard equally when choosing a new entry guard. So the guards that
had 60KB/s of bandwidth were getting as much action as the ones that had
600KB/s of bandwidth. This meant that the "low end" guards were getting
hammered harder than they should be.

There are two places that we might want to fix:

A) When choosing a new entry guard, weight the options by bandwidth.
So we are ten times more likely to add the 600KB/s guard than the 60KB/s
guard to our guard list. But when building a circuit, choose a guard
uniformly from our list.

B) When adding a new guard, choose uniformly. But when choosing which
guard to use for a given circuit, weight each choice in our guard list
by its current bandwidth. So if one guard is 600KB/s right now and the
other is 60KB/s, we're ten times more likely to pick the first for a
given circuit.

(My first thought was that we should apply both approaches. But this
would be bad, because assuming the bandwidths are still the same as
they were when we first picked the guards, the slow ones will end up
being under-used in each given circuit (1/100 as often rather than 1/10
as often -- assuming we picked both the slow and the fast).

Nick chose approach "A" in his patch.

Approach A has the downside that if the bandwidths change dramatically
over time, we can't adapt. In this case, a whole lot of clients would
list the once-600KB/s-but-now-slow server in their guard lists, and it
would get more attention than it should.

Approach B adapts better to changes in guard bandwidth, but it has the
downside that if we're only picking a few guards uniformly at random, we
probably won't get the fast ones, so even if we load balance well over the
ones we've got we're still not going to produce globally good behavior.

Note that none of these options are *really* bad, because if a node
loses its guard flag then we stop using it as a guard. So nodes can't
get *really* crummy here; just sort of crummy.

Note also that Mike's hopes for current users to upgrade and suddenly
help the global load balancing won't work in approach A, since people
will still use their old (uniformly chosen) lists. It will only gradually
solve itself as new users join and as old guards lose their guard status
entirely.

If I had to choose right now, I'd pick approach A, because at least it
starts out being globally good, even if it degrades over time.

Anybody have a more creative option?

--Roger

</body></email><email><emailId>20070607165255</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-06-07 16:52:55-0400</timestampReceived><subject>Re: Proposal: Distributed Storage for Tor Hidden Service Descriptors</subject><body>

On Sun, May 13, 2007 at 07:40:50PM +0200, Karsten Loesing wrote:
&gt;   http://88.84.144.63/114-distributed-storage.txt

Hi Karsten,

Thanks for getting this started. I've put the current version at
https://tor.eff.org/svn/trunk/doc/spec/proposals/114-distributed-storage.txt
and I quote a few paragraphs here with some questions.

&gt;  Tor clients and servers:
&gt;
&gt;    All participants can combine the network status lists received from
&gt;    all directory authorities to one routing list containing only those
&gt;    servers that store and serve hidden service descriptors and which
&gt;    are contained in the majority of network status lists. A participant
&gt;    only trusts its own routing list and never learns about routing
&gt;    information from other parties. This list should only be created
&gt;    on demand by Tor clients and servers that are involved in the new
&gt;    hidden service protocol, i.e. hidden service directory node, hidden
&gt;    service provider, and hidden service client.

We should consider how to handle the situations when different users
have different opinions of the list of valid authorities. This will
happen each time we add a new authority and not everybody has upgraded,
and it will also happen from time to time as authorities move locations
(as happened recently with moria1 and moria2).

I don't think it's a killer issue, since we have some robustness from
redundancy, and we can hope that the partitioning won't be so great
that none of the replicas are the right ones. But we might want to
think about how much waste there will be in storage (people who think
they're in the first n but most people think they're not) and retrieval
(what the expected number of requests will be before you're likely to
get an answer).

&gt;    HS directory nodes accept publish and fetch requests for hidden service
&gt;    descriptors and store/retrieve them to/from their local memory. (It is not
&gt;    necessary to make descriptors persistent, because after disconnecting, the
&gt;    onion router would not be accepted as storing node anyway, because it is
&gt;    not stable.) All requests and replies are formatted as HTTP messages.
&gt;    Requests are directed to the router's directory port and are contained
&gt;    within BEGIN_DIR cells. A HS directory node stores a descriptor only when
&gt;    it thinks that it is responsible for storing that descriptor based on its
&gt;    own routing table. Every HS directory node is responsible for the
&gt;    descriptor IDs in the interval of its n-th predecessor in the ID circle up
&gt;    to its own ID (n denotes the number of replicas).

Not considered stable? But who is stable and who is not is a function of
who's in the network -- as the median uptime goes up or town, the routers
on the borderline will oscillate between being called stable and not.

(We're going to be working on more useful definitions of stable -- see
proposal 108 -- but I don't think that will change the above note.)

So it might be that the HidServ flag, or whatever we call it, should
not simply be a copy of the Stable flag. One option is to demand that
the router has been considered Stable for the past n periods. But does
that still have the same flaw, just shifted? Or is it all a matter of
damping the oscillations adequately?

&gt;    A HS directory node replicates descriptors for which it is responsible by
&gt;    downloading them from other HS directory nodes. Therefore, it checks its
&gt;    routing table periodically every 10 minutes for changes. Whenever it
&gt;    realizes that a predecessor has left the network, it establishes a
&gt;    connection to the new n-th predecessor and requests its stored descriptors
&gt;    in the interval of its (n+1)-th predecessor and the requested n-th
&gt;    predecessor. Whenever it realizes that a new onion router has joined with
&gt;    an ID higher than its former n-th predecessor, it adds it to its
&gt;    predecessors and discards all descriptors in the interval of its (n+1)-th
&gt;    and its n-th predecessor.

a) Why 10 minutes?

b) Related to the above questions, how much overhead (again in terms of
storage waste and in increased expected number of requests til answer)
do we see from a given level of churn based on the oscillation of who
gets the HidServ flag?

&gt;    When setting up the hidden service at introduction points, a hidden service
&gt;    provider does not pass its own public key, but the public key of a freshly
&gt;    generated key pair. It also includes this public key in the hidden service
&gt;    descriptor together with the other introduction point information. The
&gt;    reason is that the introduction point does not need to know for which
&gt;    hidden service it works, and should not know it to prevent it from
&gt;    tracking the hidden service's activity.

Nice trick.

But why a keypair? Why not just a secret cookie? Right now introduction
points hear the hash of the public key as their cookie, and clients
tell the hash of the public key to identify which service they want to
be introduced to, and sign it with the corresponding private key.

But if it's a one-time keypair, what's the point in proving that you
know the private key that goes with it? Either you do or you don't, but I
don't see why any of the parties involved would care.

What would happen if we just make this a secret string that the client
provides? Like how we do rendezvous cookies now.

&gt;  Hidden service client:
&gt;
&gt;    Instead of downloading descriptors from a hidden service authoritative
&gt;    directory, a hidden service client downloads it from a randomly chosen
&gt;    hidden service directory that is responsible for keeping replica for the
&gt;    descriptor ID.

And if it doesn't get one, it tries a new random one until it has tried
all n?

&gt;      descriptor-id = h(permanent-id + h(time-period + cookie))
&gt;
&gt;    "permanent-id" is the hashed value of the public key of the hidden service
&gt;    provider, "time-period" is a periodically changing value, e.g. the current
&gt;    date, and "cookie" is a shared secret between the hidden service provider
&gt;    and its clients. (The "time-period" should be constructed in a way that
&gt;    periods do not change at the same moment for all descriptors by including
&gt;    the "permanent-id" in the construction.)

Huh? I don't understand the statement in parentheses.

&gt;  Attacks by hidden service directory nodes
&gt;
&gt;    A hidden service directory node could misuse a stored descriptor to track
&gt;    a hidden service's activity and usage pattern by clients. Though there is
&gt;    no countermeasure against this kind of attack, it is very expensive to
&gt;    track a certain hidden service over time. An attacker would need to run a
&gt;    large number of stable onion routers that work as hidden service directory
&gt;    nodes to have a good probability to become responsible for its changing
&gt;    descriptor IDs. For each period, the probability is:
&gt;
&gt;      1-(N-c choose r)/(N choose r) for N-c&gt;=r and 1 otherwise, with N
&gt;      as total
&gt;      number of hidden service directories, c as compromised nodes, and r as
&gt;      number of replicas

I still worry about an attacker generating keys until he gets n that are
very close to each other, and then putting resources into making those n
servers stable. There is suddenly a black hole in the descriptor space.
He can't target a particular hidden service, but a) he can be a nuisance,
and b) for hidden services that require high availability, a one-period
gap may still be significant.

(Speaking of which, what period are we thinking of? An hour? A day?)

It would be neat to have a design where each hidden service descriptor
has its own set n of redundant locations. This approach would mean that
there is no way to predict how to attack *any* piece of the keyspace.

It's clear how the hidden services learn where to publish (say, they
can hash the particular descriptor-id with the strings '1' through
'n'). And people trying to fetch the descriptor can do the same process.

What may be more complex is how the hidden service directories will know
what they should be mirroring. I guess one option would be to put the
descriptor-id in the descriptor, and now any hidden service directory
that sees it can compute the hash with "1"..."n" and see where it sits
and who it should publish descriptors to. But this is a 'push' approach
rather than a 'pull' approach. Is that more fragile?

Are there better approaches?

&gt;    3  The network status format needs to be extended by a new status flag to
&gt;    denote that a router is a hidden service directory.

We may want to call this flag HIDSERV1 or the like, so we can specify
that it is serving version 1 of the hidden service scheme. That way we
can transition to future schemes more easily.


There. Those are enough questions for now. :)

Thanks!
--Roger

</body></email><email><emailId>20070601173032</emailId><senderName>"Michael_google gmail_Gersten"</senderName><senderEmail>keybounce@gmail.com</senderEmail><timestampReceived>2007-06-01 17:30:32-0400</timestampReceived><subject>Proposal: Speed up Tor</subject><body>

Proposal for Tor.

The goal of this proposal is to support the following goals:

1. An easy way to toggle between "At least speed X" (for
single-threaded web browsing) and "Any speed, many connections" (for
downloads).
2. A way to keep nodes from being CPU starved from the encryption
processing (high bandwidth nodes)
3. A way to keep nodes from being bandwidth starved (the main limit on
middle-speed nodes).

Motivation: Speed up Tor.

Design:
1. Add in a control message for switching torrc's. Add support in
Vidiallia to toggle these.
	Flaw: Ideally the determination (high speed vs. high numbers) would
be made based on who is making the request. For example, while the
downloader is fetching 10 slow parts at once, I still want to browse.

2. If the protocol for extending a circuit to a new node does not
permit the new node to reject the connection, then add this ability.
Otherwise, start using it. Nodes can prevent being CPU starved by
refusing new connections when they are "full".

3. When a circuit is being built, estimates of bandwidth needed are
transmitted as well. Similar to #2, nodes will reject new connections
if the bandwidth isn't there.

Security implications: Absolutely no idea. How does having large
numbers of connections affect Tor's tracability?

Specification (incomplete):
1. New control message would either take a filename of the new torrc,
or the contents of the new torrc. I do not know Tor's inner workings,
and cannot tell which is "better".

2. Nodes can measure the CPU cost per circuit, and tell how many they
can afford CPU wise. There may be a configuration parameter to
indicate how much CPU it can use; maybe the output of "uptime" is read
to see what the CPU levels are (and Tor stops accepting when the load
is .8 or higher.)

3. The simplest way to handle this is to put numbers in the config
file, and pass them along. For example, if I'm in "single threaded
browsing", I'll have numbers specifying a max speed of 150 KB/s, a
burst speed of 100 KB/s, and an average speed of 10 KB/s. If I'm in
"multi-threaded download", I'll specify a max speed of 25 KB, an
average speed of 15 KB, and a burst speed of 18 KB.

What to do with these numbers? Well, if the sum of the averages of all
incoming circuits exceed my actual bandwidth, I say "No" when someone
tries to connect. Similarly, if I cannot support the burst speed, I
saw "No", to avoid slowing them down (this becomes the minimum speed
needed). Finally, I know that the worst case for this circuit is the
max speed, and I can do ... ? with it.

The idea here: On my DSL, I cannot get more than 150 KB/s. While I
want to get that full speed, I'll be happy to get 100 KB/s. On
average, while I'm surfing, I'm not fetching pages all the time --
hence, an average speed of 10 KB/s representing fetch, read, fetch,
read, fetch, read.

Now, it's not perfect. I'm thinking that "Busy percentage" might make
more sense -- 10% busy for web surfing, 95% busy for downloaders. This
would also help CPU overhead calculations. It also helps tell when to
say "This circuit has been idle for a while. It isn't active at all,
and while it is inactive, we will regard it as having a speed demand
of 0". This will prevent a node from being filled up with "idle"
connections, and becoming wasted.

I'm also realizing that my concept of "burst" isn't quite right, and
I'm hoping that someone else has a better idea. For downloading,
"burst" means that while the average demand for a 10 part download is
15 KB/s per circuit, there will be variance, and a node might see a
higher burst. Yet I will be happy even if a node can only give me 10
KB/s, because I have 9 other circuits that will each get slightly more
speed. So I think we need "This is my minimum acceptable speed, reject
this circuit if you can't give me this much", "This is my average",
and "This is my worst case / initial burst" (a lot of circuits will be
busy at first, and idle afterwards), as well as "percentage of time I
expect the circuit to be used".

Compatibility: The only change in how nodes talk to each other is in
circuit building. I am not familiar with the current system to know
how this will change things.
</body></email><email><emailId>20070609132809</emailId><senderName>"vikingserver () gmail ! com"</senderName><senderEmail>vikingserver@gmail.com</senderEmail><timestampReceived>2007-06-09 13:28:09-0400</timestampReceived><subject>Suggestion: Many OR-ports would improve the network</subject><body>

Is there a plan for TOR servers to be able to announce several OR-ports
and DIR-ports?

I have been running a server now for a year or so, with the purpose of
being an entry server for people behind restrictive firewalls.
I choose port 995 which is a port often used by SSL-email servers. I
choose this port because I didn't find any tor server back then that had
a server on the port 995. Many TOR servers used ports 9001, 9030 or 9031
or other ports usually blocked by restrictive
company/organization/educational firewalls. And some servers used port
80 or 443, both ports that also are often blocked by restrictive
firewalls. Many companies instead have one proxy that handles all 80/443
traffic, blocking traffic to ports 80 and 443, while they often allow
direct connection to email ports 110 and 995.

If it was possible to announce several listening ports on both directory
servers, authority servers and normal TOR servers, it would greatly
improve the possibility for people behind restrictive networks to use TOR.
Many people behind restrictive firewalls can't use TOR firstly because
the TOR network's authority servers have unreachable ports, and secondly
because many servers use the same (often unreachable) ports 80, 443,
9001, 9030, 9031.

If it was possible for servers to announce many OR-ports and DIR-ports,
it would improve the situation for people behind company/educational
firewalls. It would probably also help people in countries that block
things on the Internet like China and Saudi Arabia, but perhaps those
countries are quick at blocking all TOR-servers by IP.

I can configure my router/gateway to listen on many ports, and direct
all ports to TOR's OR-port. But it won't help anyone, as the current
directory V2 doesn't allow servers to announce many listening ports to
the DIR-authorities.

If servers could simultaneously announce ports 20, 21, 25, 80, 110, 115,
119, 443, 458, 465, 537, 554, 587, 995, 2979, 4000, 5190, 5010, 7070,
8080 and other common ports, it would really help people behind
restrictive firewalls. (Of course not every server admin will configure
their router/gateway this way, but if only the authorities and a few
servers did, it would allow a big group of potential users to be able to
use TOR.)

Will there be a change in the future to allow servers to announce many
OR-ports and DIR-ports? When will this happen?

/Viking server admin

</body></email><email><emailId>20070616172201</emailId><senderName>Robert Hogan</senderName><senderEmail>robert@roberthogan.net</senderEmail><timestampReceived>2007-06-16 17:22:01-0400</timestampReceived><subject>STREAM_PORT Controller Event</subject><body>

This patch implements a controller event that tells interested contollers the 
remote address's port for every new stream.

This information allows controllers to look up and report the program using 
that stream. On Linux, this is done by searching /proc/$PID/fd/* for the 
inode reported in /proc/net/tcp.


Rob
-- 

Browse Anonymously Anywhere	- http://anonymityanywhere.com
TorK	- KDE Anonymity Manager	- http://tork.sf.net
KlamAV	- KDE Anti-Virus 	- http://www.klamav.net


["portused.diff" (text/x-diff)]

Index: src/or/control.c
===================================================================
--- src/or/control.c	(revision 10615)
+++ src/or/control.c	(working copy)
@@ -43,7 +43,8 @@
 #define EVENT_STATUS_GENERAL   0x0012
 #define EVENT_GUARD            0x0013
 #define EVENT_STREAM_BANDWIDTH_USED   0x0014
-#define _EVENT_MAX             0x0014
+#define EVENT_STREAM_PORT_USED   0x0015
+#define _EVENT_MAX             0x0015
 /* If _EVENT_MAX ever hits 0x0020, we need to make the mask wider. */
 
 /** Bitfield: The bit 1&lt;&lt;e is set if &lt;b&gt;any&lt;/b&gt; open control
@@ -894,6 +895,8 @@
         event_code = EVENT_GUARD;
       } else if (!strcasecmp(ev, "STREAM_BW"))
         event_code = EVENT_STREAM_BANDWIDTH_USED;
+      else if (!strcasecmp(ev, "STREAM_PORT"))
+        event_code = EVENT_STREAM_PORT_USED;
       else {
         connection_printf_to_buf(conn, "552 Unrecognized event \"%s\"\r\n",
                                  ev);
@@ -2709,6 +2712,11 @@
                         buf, reason_buf);
   /* XXX need to specify its intended exit, etc? */
 
+  if (tp == STREAM_EVENT_NEW){
+    if (EVENT_IS_INTERESTING(EVENT_STREAM_PORT_USED))
+        control_event_stream_port_used(conn);
+  }
+
   return 0;
 }
 
@@ -2879,6 +2887,19 @@
   return 0;
 }
 
+/** A new stream has been opened: tell any interested control
+ * connections the socket of the ap connection associated with the stream. */
+int
+control_event_stream_port_used(edge_connection_t *edge_conn)
+{
+  send_control_event(EVENT_STREAM_PORT_USED, ALL_NAMES,
+                            "650 STREAM_PORT %lu %lu \r\n",
+                            (unsigned long)edge_conn-&gt;global_identifier,
+                            (unsigned long)TO_CONN(edge_conn)-&gt;port);
+
+  return 0;
+}
+
 /** A second or more has elapsed: tell any interested control
  * connections how much bandwidth we used. */
 int
Index: src/or/or.h
===================================================================
--- src/or/or.h	(revision 10615)
+++ src/or/or.h	(working copy)
@@ -2610,6 +2610,7 @@
                                  or_conn_status_event_t e, int reason);
 int control_event_bandwidth_used(uint32_t n_read, uint32_t n_written);
 int control_event_stream_bandwidth_used(void);
+int control_event_stream_port_used(edge_connection_t *conn);
 void control_event_logmsg(int severity, unsigned int domain, const char *msg);
 int control_event_descriptors_changed(smartlist_t *routers);
 int control_event_address_mapped(const char *from, const char *to,
Index: src/or/connection.c
===================================================================
--- src/or/connection.c	(revision 10615)
+++ src/or/connection.c	(working copy)
@@ -1655,6 +1655,8 @@
   /* refill the per-connection buckets */
   SMARTLIST_FOREACH(conns, connection_t *, conn,
   {
+
+
     if (connection_speaks_cells(conn)) {
       or_connection_t *or_conn = TO_OR_CONN(conn);
       if (connection_read_bucket_should_increase(or_conn)) {


</body></email><email><emailId>20070616201813</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-06-16 20:18:13-0400</timestampReceived><subject>Re: STREAM_PORT Controller Event</subject><body>


On Sat, Jun 16, 2007 at 06:22:01PM +0100, Robert Hogan wrote:
&gt; 
&gt; This patch implements a controller event that tells interested contollers the 
&gt; remote address's port for every new stream.
&gt; 
&gt; This information allows controllers to look up and report the program using 
&gt; that stream. On Linux, this is done by searching /proc/$PID/fd/* for the 
&gt; inode reported in /proc/net/tcp.
&gt; 

Hi, Robert!  I like the idea; just a few suggestions:

1) why not change this from a new event type to an an extra value
given for STREAM NEW events when the EXTENDED_EVENTS flag is set?
That's what it's for: adding new information to existing events[*].
The syntax could be:

      "650" SP "STREAM" SP StreamID SP StreamStatus SP CircID SP Target
          [SP "REASON=" Reason [ SP "REMOTE_REASON=" Reason ]]
          [SP "SOURCE=" Source] [ SP "SOURCE_ADDR=" Addr:Port ] CRLF

2) I'd suggest having the whole address, not just the port.  Usually
the address will just be 127.0.0.1, but if people are running Tor as a
socks proxy for their LAN, they'll want to see which host is using it.

[*]  This could be explained better in control-spec.txt.  The idea is
that if you specify EXTENDED_EVENTS, you're telling Tor that it is
allowed to send you any number of unexpected Key=Value pairs after any
event it sends you.  This is how we try to make events extensible
without breaking backward compatibility.

yrs,
-- 
Nick Mathewson

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070617131421</emailId><senderName>Robert Hogan</senderName><senderEmail>robert@roberthogan.net</senderEmail><timestampReceived>2007-06-17 13:14:21-0400</timestampReceived><subject>Re: STREAM_PORT Controller Event</subject><body>

On Saturday 16 June 2007 21:18:13 Nick Mathewson wrote:
&gt; On Sat, Jun 16, 2007 at 06:22:01PM +0100, Robert Hogan wrote:
&gt; &gt; This patch implements a controller event that tells interested contollers
&gt; &gt; the remote address's port for every new stream.
&gt; &gt;
&gt; &gt; This information allows controllers to look up and report the program
&gt; &gt; using that stream. On Linux, this is done by searching /proc/$PID/fd/*
&gt; &gt; for the inode reported in /proc/net/tcp.
&gt;
&gt; Hi, Robert!  I like the idea; just a few suggestions:
&gt;
&gt; 1) why not change this from a new event type to an an extra value
&gt; given for STREAM NEW events when the EXTENDED_EVENTS flag is set?
&gt; That's what it's for: adding new information to existing events[*].
&gt; The syntax could be:
&gt;
&gt;       "650" SP "STREAM" SP StreamID SP StreamStatus SP CircID SP Target
&gt;           [SP "REASON=" Reason [ SP "REMOTE_REASON=" Reason ]]
&gt;           [SP "SOURCE=" Source] [ SP "SOURCE_ADDR=" Addr:Port ] CRLF
&gt;
&gt; 2) I'd suggest having the whole address, not just the port.  Usually
&gt; the address will just be 127.0.0.1, but if people are running Tor as a
&gt; socks proxy for their LAN, they'll want to see which host is using it.
&gt;
&gt; [*]  This could be explained better in control-spec.txt.  The idea is
&gt; that if you specify EXTENDED_EVENTS, you're telling Tor that it is
&gt; allowed to send you any number of unexpected Key=Value pairs after any
&gt; event it sends you.  This is how we try to make events extensible
&gt; without breaking backward compatibility.
&gt;
&gt; yrs,

Hi Nick,

That's a much better idea. Patch attached. The extension format in the 
control-spec hasn't been implemented yet (so far as I can tell) so I've gone 
along with the current method. Am I right on this? If so, would you like 
someone to do it?

At the moment, extended events get displayed regardless of the controller 
directive. There's a one-liner in the patch to fix that.

Regards
Robert


-- 

Browse Anonymously Anywhere	- http://anonymityanywhere.com
TorK	- KDE Anonymity Manager	- http://tork.sf.net
KlamAV	- KDE Anti-Virus 	- http://www.klamav.net


["addrport.diff" (text/x-diff)]

Index: src/or/control.c
===================================================================
--- src/or/control.c	(revision 10632)
+++ src/or/control.c	(working copy)
@@ -425,7 +425,7 @@
  * but it will always end with a CRLF sequence.
  *
  * Currently the length of the message is limited to 1024 (including the
- * ending \n\r\0. */
+ * ending \r\n\0. */
 static void
 connection_printf_to_buf(control_connection_t *conn, const char *format, ...)
 {
@@ -907,8 +907,7 @@
   smartlist_free(events);
 
   conn-&gt;event_mask = event_mask;
-  if (extended)
-    conn-&gt;use_extended_events = 1;
+  conn-&gt;use_extended_events = extended;
 
   control_update_global_event_mask();
   send_control_done(conn);
@@ -2636,6 +2635,7 @@
                             int reason_code)
 {
   char reason_buf[64];
+  char addrport_buf[64];
   const char *status;
   circuit_t *circ;
   origin_circuit_t *origin_circ = NULL;
@@ -2698,15 +2698,20 @@
       break;
     }
   }
+
+  tor_snprintf(addrport_buf,sizeof(addrport_buf), "%sSOURCE_ADDR=%s:%d",
+                   reason_code ? " " : "", TO_CONN(conn)-&gt;address, TO_CONN(conn)-&gt;port );
+
   circ = circuit_get_by_edge_conn(conn);
   if (circ &amp;&amp; CIRCUIT_IS_ORIGIN(circ))
     origin_circ = TO_ORIGIN_CIRCUIT(circ);
   send_control_event_extended(EVENT_STREAM_STATUS, ALL_NAMES,
-                        "650 STREAM %lu %s %lu %s@%s\r\n",
+                        "650 STREAM %lu %s %lu %s@%s%s\r\n",
                         (unsigned long)conn-&gt;global_identifier, status,
                         origin_circ?
                            (unsigned long)origin_circ-&gt;global_identifier : 0ul,
-                        buf, reason_buf);
+                        buf, reason_buf, addrport_buf);
+
   /* XXX need to specify its intended exit, etc? */
 
   return 0;


</body></email><email><emailId>20070617143815</emailId><senderName>Robert Hogan</senderName><senderEmail>robert@roberthogan.net</senderEmail><timestampReceived>2007-06-17 14:38:15-0400</timestampReceived><subject>Add remote addr/port to conn of dns request</subject><body>


If the extension for reporting the remote address and port in stream events is 
adopted, it would be great if the address and port of dns requests could be 
informative, rather than '(null):0'.

Testing this patch revealed the source of some odd dns requests TorK 
frequently reported when my system's requests were all routed to tor's 
dnsport. I was quite concerned about them at first, they were slews of 
invalid requests like

650 STREAM 40 CLOSED 12 ng.invalid:0 REASON=DONE SOURCE_ADDR=192.168.1.2:33767
650 STREAM 43 CLOSED 12 cixub22dxb3axlhj.com:0 REASON=DONE 
SOURCE_ADDR=192.168.1.2:33768
650 STREAM 50 CLOSED 12 ingd6oyrd.org:0 REASON=DONE 
SOURCE_ADDR=192.168.1.2:33767
650 STREAM 45 CLOSED 12 fo6a2vccbqa.net:0 REASON=DONE 
SOURCE_ADDR=192.168.1.2:33768
650 STREAM 44 CLOSED 12 jtxsrvaiz42o.org:0 REASON=DONE 
SOURCE_ADDR=192.168.1.2:33767
650 STREAM 41 CLOSED 12 6ob.test:0 REASON=DONE SOURCE_ADDR=192.168.1.2:33768

Turns out the source was... tor!

Proto Recv-Q Send-Q Local Address           Foreign Address         State       
PID/Program name
udp        0      0 192.168.1.2:10025       159.134.237.6:53        
ESTABLISHED -
udp        0      0 192.168.1.2:33767       159.134.237.6:53        
ESTABLISHED 9370/tor
udp        0      0 192.168.1.2:33768       159.134.248.17:53       
ESTABLISHED 9370/tor

The reason for these requests is obvious enough, in hindsight, but I think a 
log event admitting to the user that these requests originate from tor would 
be helpful. It would certainly keep paranoid-but-a-bit-dim users like myself 
from thinking there was some sort of dns snooping trojan afoot. (Since the 
user, like me, might assume that these are happening even when dnsport is 
turned off and that forcing dns requests through tor has revealed the 
possibly naughty behaviour of another application.)


Index: src/or/dnsserv.c
===================================================================
--- src/or/dnsserv.c    (revision 10632)
+++ src/or/dnsserv.c    (working copy)
@@ -23,6 +23,7 @@
   struct evdns_server_question *q = NULL;
   struct sockaddr_storage addr;
   struct sockaddr *sa;
+  struct sockaddr_in *sin;
   int addrlen;
   uint32_t ipaddr;
   int err = DNS_ERR_NONE;
@@ -48,10 +49,11 @@
     log_warn(LD_APP, "Requesting address wasn't ipv4.");
     evdns_server_request_respond(req, DNS_ERR_SERVERFAILED);
     return;
-  } else {
-    struct sockaddr_in *sin = (struct sockaddr_in*)
-    ipaddr = ntohl(sin-&gt;sin_addr.s_addr);
   }
+
+  sin = (struct sockaddr_in*)
+  ipaddr = ntohl(sin-&gt;sin_addr.s_addr);
+
   if (!socks_policy_permits_address(ipaddr)) {
     log_warn(LD_APP, "Rejecting DNS request from disallowed IP.");
     evdns_server_request_respond(req, DNS_ERR_REFUSED);
@@ -112,6 +114,11 @@
   /* Make a new dummy AP connection, and attach the request to it. */
   conn = TO_EDGE_CONN(connection_new(CONN_TYPE_AP, AF_INET));
   conn-&gt;_base.state = AP_CONN_STATE_RESOLVE_WAIT;
+
+  TO_CONN(conn)-&gt;addr = ntohl(sin-&gt;sin_addr.s_addr);
+  TO_CONN(conn)-&gt;port = ntohs(sin-&gt;sin_port);
+  TO_CONN(conn)-&gt;address = tor_dup_addr(TO_CONN(conn)-&gt;addr);
+
   if (q-&gt;type == EVDNS_TYPE_A)
     conn-&gt;socks_request-&gt;command = SOCKS_COMMAND_RESOLVE;
   else

-- 

Browse Anonymously Anywhere	- http://anonymityanywhere.com
TorK	- KDE Anonymity Manager	- http://tork.sf.net
KlamAV	- KDE Anti-Virus 	- http://www.klamav.net

</body></email><email><emailId>20070618205827</emailId><senderName>Robert Hogan</senderName><senderEmail>robert@roberthogan.net</senderEmail><timestampReceived>2007-06-18 20:58:27-0400</timestampReceived><subject>Add STREAM_EVENT_NEW for dns requests and tunneled connect_dir</subject><body>


I think these are the only two remaining stream types without a 
STREAM_EVENT_NEW event.

I also added a log_notice for the dns hijack tests.


Index: src/or/connection_edge.c
===================================================================
--- src/or/connection_edge.c    (revision 10649)
+++ src/or/connection_edge.c    (working copy)
@@ -1946,6 +1946,8 @@

   conn-&gt;_base.state = AP_CONN_STATE_CIRCUIT_WAIT;

+  control_event_stream_status(conn, STREAM_EVENT_NEW, 0);
+
   /* attaching to a dirty circuit is fine */
   if (connection_ap_handshake_attach_circuit(conn) &lt; 0) {
     connection_mark_unattached_ap(conn, END_STREAM_REASON_CANT_ATTACH);
Index: src/or/dns.c
===================================================================
--- src/or/dns.c        (revision 10649)
+++ src/or/dns.c        (working copy)
@@ -1407,6 +1407,8 @@
   name[len] = '\0';
   strlcat(name, suffix, sizeof(name));

+  log_notice(LD_EXIT, "Testing DNS hijacking with a request for nonexistent 
hostname: %s", name);
+
   addr = tor_strdup(name);
   r = evdns_resolve_ipv4(name, DNS_QUERY_NO_SEARCH,
                          evdns_wildcard_check_callback, addr);
Index: src/or/dnsserv.c
===================================================================
--- src/or/dnsserv.c    (revision 10649)
+++ src/or/dnsserv.c    (working copy)
@@ -109,7 +109,6 @@
     return;
   }

-  /* XXXX020 Send a stream event to the controller. */

   /* Make a new dummy AP connection, and attach the request to it. */
   conn = TO_EDGE_CONN(connection_new(CONN_TYPE_AP, AF_INET));
@@ -131,6 +130,8 @@

   connection_add(TO_CONN(conn));

+  control_event_stream_status(TO_CONN(conn), STREAM_EVENT_NEW, 0);
+
   /* Now, throw the connection over to get rewritten (which will answer it
   * immediately if it's in the cache, or completely bogus, or automapped),
   * and then attached to a circuit. */


-- 

Browse Anonymously Anywhere	- http://anonymityanywhere.com
TorK	- KDE Anonymity Manager	- http://tork.sf.net
KlamAV	- KDE Anti-Virus 	- http://www.klamav.net

</body></email><email><emailId>20070626174515</emailId><senderName>"Michael Lieberman"</senderName><senderEmail>mathmike@mit.edu</senderEmail><timestampReceived>2007-06-26 17:45:15-0400</timestampReceived><subject>Proposal: Two hop paths from entry guards</subject><body>

Title: Two hop paths from entry guards

This proposal is related to (but different from) Mike Perry's proposal "Two
Hop Paths."  See http://archives.seul.org/or/dev/May-2007/msg00022.html

Overview:

Volunteers who run entry guards should have the option of using only 2
additional tor nodes when constructing their own tor circuits.

While the option of two hop paths should perhaps be extended to every client
(as discussed in Mike Perry's thread), I believe the anonymity properties of
two hop paths are particularly well-suited to client computers that are also
serving as entry guards.

First I will describe the details of the strategy, as well as possible
avenues of attack. Then I will list advantages and disadvantages. Then, I
will discuss some possibly safer variations of the strategy, and finally
some implementation issues.

Details:

Suppose Alice is an entry guard, and wants to construct a two hop circuit.
Alice chooses a middle node at random (not using the entry guard strategy),
and gains anonymity by having her traffic look just like traffic from
someone else using her as an entry guard.

Can Alice's middle node figure out that she is initiator of the traffic? I
can think of four possible approaches for distinguishing traffic from Alice
with traffic through Alice:

1) Notice that communication from Alice comes too fast: Experimentation is
needed to determine if traffic from Alice can be distinguished from traffic
from a computer with a decent link to Alice.

2) Monitor Alice's network traffic to discover the lack of incoming packets
at the appropriate times. If an adversary has this ability, then Alice
already has problems in the current system, because the adversary can run a
standard timing attack on Alice's traffic.

3) Notice that traffic from Alice is unique in some way such that if Alice
was just one of 3 entry guards for this traffic, then the traffic should be
coming from two other entry guards as well. An example of "unique traffic"
could be always sending 117 packets every 3 minutes to an exit node that
exits to port 4661. However, if such patterns existed with sufficient
precision, then it seems to me that Tor already has a problem. (This "unique
traffic" may not be a problem if clients often end up choosing a single
entry guard because their other two are down. Does anyone know if this is
the case?)

4) First, control the middle node *and* some other part of the traffic,
using standard attacks on a two hop circuit without entry nodes (my recent
paper on Browser-Based Attacks would work well for this
http://petworkshop.org/2007/papers/PET2007_preproc_Browser_based.pdf). With
control of the circuit, we can now cause "unique traffic" as in 3).
Alternatively, if we know something about Alice independently, and we can
see what websites are being visited, we might be able to guess that she is
the kind of person that would visit those websites.

Anonymity Advantages:

-Alice never has the problem of choosing a malicious entry guard. In some
sense, Alice acts as her own entry guard.

Anonymity Disadvantages:

-If Alice's traffic is identified as originating from herself (see above for
how hard that might be), then she has the anonymity of a 2 hop circuit
without entry guards.

Additional advantages:

-A discussion of the latency advantages of two hop circuits is going on in
Mike Perry's thread already.
-Also, we can advertise this change as "Run an entry guard and decrease your
own Tor latency." This incentive has the potential to add nodes to the
network, improving the network as a whole.

Safer variations:

To solve the "unique traffic" problem, Alice could use two hop paths only
1/3 of the time, and choose 2 other entry guards for the other 2/3 of the
time. All the advantages are now 1/3 as useful (possibly more, if the other
2 entry guards are not always up).

To solve the problem that Alice's responses are too fast, Alice could delay
her responses (ideally based on some real data of response time when Alice
is used an entry guard). This loses most of the speed advantages of the two
hop path, but if Alice is a fast entry guard, it doesn't lose everything. It
also still has the (arguable) anonymity advantage that Alice doesn't have to
worry about having a malicious entry guard.

Implementation details:
For Alice to remain anonymous using this strategy, she has to actually be
acting as an entry guard for other nodes. This means the two hop option can
only be available to whatever high-performance threshold is currently set on
entry guards. Alice may need to somehow check her own current status as an
entry guard before choosing this two hop strategy.

Another thing to consider: suppose Alice is also an exit node. If the
fraction of exit nodes in existence is too small, she may rarely or never be
chosen as an entry guard. It would be sad if we offered an incentive to run
an entry guard that didn't extend to exit nodes. I suppose clients of Exit
nodes could pull the same trick, and bypass using Tor altogether (zero hop
paths), though that has additional issues.*

Mike Lieberman
MIT

*Why we shouldn't recommend Exit nodes pull the same trick:
1) Exit nodes would suffer heavily from the problem of "unique traffic"
mentioned above.
2) It would give governments an incentive to confiscate exit nodes to see if
they are pulling this trick.

[Attachment #3 (text/html)]

Title: Two hop paths from entry guards&lt;br&gt;&lt;br&gt;This proposal is related to (but \
different from) Mike Perry's proposal "Two Hop Paths." See &lt;a \
href="http://archives.seul.org/or/dev/May-2007/msg00022.html" target="_blank" \
onclick="return top.js.OpenExtLink(window,event,this)"&gt;


http://archives.seul.org/or/dev/May-2007/msg00022.html
&lt;/a&gt;&lt;br&gt;&lt;br&gt;Overview: &lt;br&gt;&lt;br&gt;Volunteers who run entry guards should have the option \
of using only 2 additional tor nodes when constructing their own tor \
circuits.&lt;br&gt;&lt;br&gt;While the option of two hop paths should perhaps be extended to \
every client (as discussed in Mike Perry's thread), I believe the anonymity \
properties of two hop paths are particularly well-suited to client computers that are \
also serving as entry guards. &lt;br&gt;&lt;br&gt;First I will describe the details of the \
strategy, as well as possible avenues of attack. Then I will list advantages and \
disadvantages. Then, I will discuss some possibly safer variations of the strategy, \
and finally some implementation issues. &lt;br&gt;
&lt;br&gt;Details:&lt;br&gt;&lt;br&gt;Suppose Alice is an entry guard, and wants to construct a two hop \
circuit. Alice chooses a middle node at random (not using the entry guard strategy), \
and gains anonymity by having her traffic look just like traffic from someone else \
using her as an entry guard. &lt;br&gt;&lt;br&gt;Can Alice's middle node figure out that she \
is initiator of the traffic? I can think of four possible approaches for \
distinguishing traffic &lt;span style="font-style: italic;"&gt;from&lt;/span&gt; Alice with \
traffic &lt;span style="font-style: italic;"&gt;

through&lt;/span&gt; Alice:
&lt;br&gt;&lt;br&gt;1) Notice that communication from Alice comes too fast: Experimentation is \
needed to determine if traffic from Alice can be distinguished from traffic from a \
computer with a decent link to Alice.&lt;br&gt;&lt;br&gt;2) Monitor Alice's network traffic \
to discover the lack of incoming packets at the appropriate times. If an adversary \
has this ability, then Alice already has problems in the current system, because the \
adversary can run a standard timing attack on Alice's traffic. &lt;br&gt;&lt;br&gt;3) Notice \
that traffic from Alice is unique in some way such that if Alice was just one of 3 \
entry guards for this traffic, then the traffic should be coming from two other entry \
guards as well. An example of "unique traffic" could be always sending 117 \
packets every 3 minutes to an exit node that exits to port 4661. However, if such \
patterns existed with sufficient precision, then it seems to me that Tor already has \
a problem.  (This "unique traffic" may not be a problem if clients often \
end up choosing a single entry guard because their other two are down. Does anyone \
know if this is the case?)&lt;br&gt;&lt;br&gt;4) First, control the middle node *and* some other \
part of the traffic, using standard attacks on a two hop circuit without entry nodes \
(my recent paper on Browser-Based Attacks would work well for this  &lt;a \
href="http://petworkshop.org/2007/papers/PET2007_preproc_Browser_based.pdf" \
target="_blank" onclick="return \
top.js.OpenExtLink(window,event,this)"&gt;http://petworkshop.org/2007/papers/PET2007_preproc_Browser_based.pdf&lt;/a&gt;
 ). With control of the circuit, we can now cause "unique traffic" as in \
3). Alternatively, if we know something about Alice independently, and we can see \
what websites are being visited, we might be able to guess that she is the kind of \
person that would visit those websites.  &lt;br&gt;
&lt;br&gt;Anonymity Advantages: &lt;br&gt;&lt;br&gt;-Alice never has the problem of choosing a \
malicious entry guard. In some sense, Alice acts as her own entry \
guard.&lt;br&gt;&lt;br&gt;Anonymity Disadvantages:&lt;br&gt;&lt;br&gt;-If Alice's traffic is identified \
as originating from herself (see above for how hard that might be), then she has the \
anonymity of a 2 hop circuit without entry guards. &lt;br&gt;&lt;br&gt;Additional \
advantages:&lt;br&gt;&lt;br&gt;-A discussion of the latency advantages of two hop circuits is \
going on in Mike Perry's thread already.&lt;br&gt;-Also, we can advertise this change \
as "Run an entry guard and decrease your own Tor latency." This incentive \
has the potential to add nodes to the network, improving the network as a whole. \
&lt;br&gt;&lt;br&gt;Safer variations:&lt;br&gt;&lt;br&gt;To solve the "unique traffic" problem, \
Alice could use two hop paths only 1/3 of the time, and choose 2 other entry guards \
for the other 2/3 of the time. All the advantages are now 1/3 as useful (possibly \
more, if the other 2 entry guards are not always up).  &lt;br&gt;&lt;br&gt;To solve the problem \
that Alice's responses are too fast, Alice could delay her responses (ideally \
based on some real data of response time when Alice is used an entry guard). This \
loses most of the speed advantages of the two hop path, but if Alice is a fast entry \
guard, it doesn't lose everything. It also still has the (arguable) anonymity \
advantage that Alice doesn't have to worry about having a malicious entry guard. \
&lt;br&gt;&lt;br&gt;Implementation details:&lt;br&gt;For Alice to remain anonymous using this strategy, \
she has to actually be acting as an entry guard for other nodes. This means the two \
hop option can only be available to whatever high-performance threshold is currently \
set on entry guards. Alice may need to somehow check her own current status as an \
entry guard before choosing this two hop strategy. &lt;br&gt;&lt;br&gt;Another thing to consider: \
suppose Alice is also an exit node. If the fraction of exit nodes in existence is too \
small, she may rarely or never be chosen as an entry guard. It would be sad if we \
offered an incentive to run an entry guard that didn't extend to exit nodes. I \
suppose clients of Exit nodes could pull the same trick, and bypass using Tor \
altogether (zero hop paths), though that has additional issues.* &lt;br&gt;&lt;br&gt;Mike \
Lieberman&lt;br&gt;MIT&lt;br&gt;&lt;br&gt;*Why we shouldn't recommend Exit nodes pull the same \
trick:&lt;br&gt;1) Exit nodes would suffer heavily from the problem of "unique \
traffic" mentioned above.&lt;br&gt;2) It would give governments an incentive to \
confiscate exit nodes to see if they are pulling this trick. &lt;br&gt;



</body></email><email><emailId>20070623194504</emailId><senderName>Robert Hogan</senderName><senderEmail>robert@roberthogan.net</senderEmail><timestampReceived>2007-06-23 19:45:04-0400</timestampReceived><subject>check for conflicting *Port directives</subject><body>

if someone does something like:

ORPort 9031
SocksPort 9031

this will tell them where they've screwed up, rather than attempting to bind 
to the port and fail for the second of the two options.

possibly a case of sledgehammer meets walnut (it's a large patch for what it's 
fixing). If the idea is right it will need some cleaning to be up to 
standard, but hopefully this will be less than the time required to write 
from scratch.


-- 

Browse Anonymously Anywhere	- http://anonymityanywhere.com
TorK	- KDE Anonymity Manager	- http://tork.sf.net
KlamAV	- KDE Anti-Virus 	- http://www.klamav.net


["conflicting.patch" (text/x-diff)]

Index: src/or/config.c
===================================================================
--- src/or/config.c	(revision 10664)
+++ src/or/config.c	(working copy)
@@ -47,6 +47,24 @@
   int warn;
 } config_abbrev_t;
 
+/** Port Option Name and Configured Port. */
+typedef struct option_port_t {
+  char *name;
+  int value;
+} option_port_t;
+
+/** An array of all configured port opton names and values. */
+typedef struct ports_used_t {
+  int nports;
+  struct port_t **portandname;
+} ports_used_t;
+
+/** Used by ports_used_t. */
+typedef struct port_t {
+  int port;
+  const char *name;
+} port_t;
+
 /* Handy macro for declaring "In the config file or on the command line,
  * you can abbreviate &lt;b&gt;tok&lt;/b&gt;s as &lt;b&gt;tok&lt;/b&gt;". */
 #define PLURAL(tok) { #tok, #tok "s", 0, 0 }
@@ -651,6 +669,45 @@
 };
 
 /*
+ * Helper functions for verifying that *Port options do not conflict.
+ */
+
+static port_t *
+port_new(const char *name, int port)
+{
+  port_t *b;
+  b = tor_malloc_zero(sizeof(port_t) + strlen(name));
+  b-&gt;name = tor_strdup(name);
+  b-&gt;port = port;
+  return b;
+}
+
+int
+port_add(struct ports_used_t *array, struct port_t *new)
+{
+  int i;
+  for (i = 0; i &lt; array-&gt;nports; ++i) {
+    if (new-&gt;port == array-&gt;portandname[i]-&gt;port)
+        return i;
+  }
+  return -1;
+}
+
+void
+ports_free(struct ports_used_t *ports_used_array)
+{
+  int i;
+  if (ports_used_array) {
+      if (ports_used_array-&gt;portandname) {
+          for (i = 0; i &lt; ports_used_array-&gt;nports; ++i)
+              tor_free(ports_used_array-&gt;portandname[i]);
+          tor_free(ports_used_array-&gt;portandname);
+      }
+      tor_free(ports_used_array);
+  }
+}
+
+/*
  * Functions to read and write the global options pointer.
  */
 
@@ -2415,9 +2472,13 @@
                  int from_setconf, char **msg)
 {
   int i, r;
+  int opt;
   config_line_t *cl;
   const char *uname = get_uname();
   char buf[1024];
+  struct ports_used_t *ports_used_array = NULL;
+  struct port_t *p;
+
 #define REJECT(arg) \
   STMT_BEGIN *msg = tor_strdup(arg); return -1; STMT_END
 #define COMPLAIN(arg) STMT_BEGIN log(LOG_WARN, LD_CONFIG, arg); STMT_END
@@ -2438,6 +2499,46 @@
         "for details.", uname);
   }
 
+  option_port_t option_ports[] = {
+  { "DirPort", options-&gt;DirPort},
+  { "ORPort", options-&gt;ORPort},
+  { "ControlPort", options-&gt;ControlPort},
+  { "DNSPort", options-&gt;DNSPort},
+  { "TransPort", options-&gt;TransPort},
+  { "NatdPort", options-&gt;NatdPort},
+  { "SocksPort", options-&gt;SocksPort},
+  { NULL, 0},
+  };
+
+  ports_used_array = tor_malloc(sizeof(struct ports_used_t));
+  ports_used_array-&gt;nports = 0;
+
+  for (i=0; option_ports[i].name; i++){}
+  ports_used_array-&gt;portandname = tor_malloc(sizeof(struct port_t *) * i);
+
+
+  for (i=0; option_ports[i].name; i++){
+    if (option_ports[i].value != 0) {
+        p = port_new(option_ports[i].name, option_ports[i].value);
+        opt = port_add(ports_used_array,p);
+        if (opt &lt; 0)
+            ports_used_array-&gt;portandname[ports_used_array-&gt;nports++] = p;
+        else{
+            char *resp;
+            int len = 256 + sizeof(p-&gt;port)
+                        + strlen(option_ports[i].name)
+                        + strlen(ports_used_array-&gt;portandname[opt]-&gt;name);
+            resp = tor_malloc(len);
+            tor_snprintf(resp,len,"Cannot assign port %i to %s because you have also \
assigned it to %s. ", +                p-&gt;port, option_ports[i].name,
+                ports_used_array-&gt;portandname[opt]-&gt;name);
+            ports_free(ports_used_array);
+            REJECT(resp);
+        }
+    }
+  }
+  ports_free(ports_used_array);
+
   if (options-&gt;ORPort == 0 &amp;&amp; options-&gt;ORListenAddress != NULL)
     REJECT("ORPort must be defined if ORListenAddress is defined.");
 
@@ -2456,6 +2557,7 @@
   if (options-&gt;NatdPort == 0 &amp;&amp; options-&gt;NatdListenAddress != NULL)
     REJECT("NatdPort must be defined if NatdListenAddress is defined.");
 
+
   /* Don't gripe about SocksPort 0 with SocksListenAddress set; a standard
    * configuration does this. */
 



</body></email><email><emailId>20070621215308</emailId><senderName>Robert Hogan</senderName><senderEmail>robert@roberthogan.net</senderEmail><timestampReceived>2007-06-21 21:53:08-0400</timestampReceived><subject>prevent tor accepting dns requests on dnsport initiated by itself</subject><body>


This would also prevent the user resolving a dns request if it coincided 
exactly with the very same request by tor. I don't know how likely this would 
be in practice - I certainly haven't been quick enough on the draw.

It also mis-uses search_origname to store the request name for ordinary 
lookups rather than just searches.

If this is the only objection to it, I could just add a new field to the 
request struct and resubmit.



Index: src/or/dnsserv.c
===================================================================
--- src/or/dnsserv.c	(revision 10649)
+++ src/or/dnsserv.c	(working copy)
@@ -99,6 +99,11 @@
     tor_assert(q-&gt;type == EVDNS_TYPE_PTR);
   }
 
+  if (request_find_from_name(q-&gt;name)){
+    err = DNS_ERR_REFUSED;
+    log_warn(LD_APP, "Refusing DNS request initiated by Tor.");
+  }
+
   /* Make sure the name isn't too long: This should be impossible, I think. 
*/
   if (err == DNS_ERR_NONE &amp;&amp; strlen(q-&gt;name) &gt; MAX_SOCKS_ADDR_LEN-1)
     err = DNS_ERR_FORMAT;

Index: src/or/eventdns.c
===================================================================
--- src/or/eventdns.c	(revision 10649)
+++ src/or/eventdns.c	(working copy)
@@ -443,6 +443,27 @@
 	return NULL;
 }
 
+// This walks the list of inflight requests to find the
+// one with a matching name request. Returns 1 on
+// success, 0 on failure
+int
+request_find_from_name(const char *name) {
+	struct request *req = req_head, *const started_at = req_head;
+
+	if (req) {
+		do {
+            log(EVDNS_LOG_WARN, "inflight %s with %s", 
req-&gt;search_origname,name);
+            if (req-&gt;search_origname){
+                if (!strcmp(req-&gt;search_origname,name))
+                    return 1;
+            }
+			req = req-&gt;next;
+		} while (req != started_at);
+	}
+
+	return 0;
+}
+
 // a libevent callback function which is called when a nameserver
 // has gone down and we want to test if it has came back to life yet
 static void
@@ -2220,6 +2241,7 @@
 	if (rlen &lt; 0)
 		goto err1;
 	req-&gt;request_len = rlen;
+    req-&gt;search_origname = strdup(name);
 	req-&gt;trans_id = trans_id;
 	req-&gt;tx_count = 0;
 	req-&gt;request_type = type;
Index: src/or/eventdns.h
===================================================================
--- src/or/eventdns.h	(revision 10649)
+++ src/or/eventdns.h	(working copy)
@@ -277,7 +277,9 @@
 void evdns_search_clear(void);
 void evdns_search_add(const char *domain);
 void evdns_search_ndots_set(const int ndots);
+int request_find_from_name(const char *name);

</body></email><email><emailId>20070622155248</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-06-22 15:52:48-0400</timestampReceived><subject>Re: prevent tor accepting dns requests on dnsport initiated by itself</subject><body>


On Thu, Jun 21, 2007 at 10:53:08PM +0100, Robert Hogan wrote:
&gt; 
&gt; This would also prevent the user resolving a dns request if it
&gt; coincided exactly with the very same request by tor. I don't know
&gt; how likely this would be in practice - I certainly haven't been
&gt; quick enough on the draw.

I think this is actually a dangerous idea.  We separate the client DNS
cache from the server DNS cache for a reason: if you're using a Tor
instance as both a client and a server, it's a good idea to keep the
client's behavior more or less uncorrelated by the server's.

Here's an attack: I have a server that doesn't see much usage at
evil-nick.com.  You have a non-exit Tor host.  I suspect that you're
connecting to my server.  I control the DNS for evil-nick.com, so I
whenever your Tor server asks for the address of evil-nick.com I give
you IP1.  (If it never asks, I can resolve evil-nick.com.yourhost.exit
a lot.)  When any other server asks, I give them IP2.  If I see
anybody connect to IP1, I know that it's probably your client peeking
inside the server DNS.

There are probably easier attacks here too.

-- 
Nick Mathewson

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070623120833</emailId><senderName>Robert Hogan</senderName><senderEmail>robert@roberthogan.net</senderEmail><timestampReceived>2007-06-23 12:08:33-0400</timestampReceived><subject>Re: prevent tor accepting dns requests on dnsport initiated by itself</subject><body>

On Friday 22 June 2007 16:52:48 Nick Mathewson wrote:
&gt; On Thu, Jun 21, 2007 at 10:53:08PM +0100, Robert Hogan wrote:
&gt; &gt; This would also prevent the user resolving a dns request if it
&gt; &gt; coincided exactly with the very same request by tor. I don't know
&gt; &gt; how likely this would be in practice - I certainly haven't been
&gt; &gt; quick enough on the draw.
&gt;
&gt; I think this is actually a dangerous idea.  We separate the client DNS
&gt; cache from the server DNS cache for a reason: if you're using a Tor
&gt; instance as both a client and a server, it's a good idea to keep the
&gt; client's behavior more or less uncorrelated by the server's.
&gt;

Sorry, I don't get it!

I don't think any mixing of the caches takes place here. The patch prevents a 
Tor server from resolving DNS requests when a broken system configuration 
routes them all back to its own DNSPort. In this situation the tor server 
will always be unable to resolve anything and the server admin will be warned 
accordingly.

If the same Tor instance is being used as a client then the only occasion in 
which an application's requests (e.g. from firefox) will fail is if it 
happens to request the exact same dns resolve at precisely the same moment 
the server's same dns request is in progress. Otherwise its requests, even 
for the same hostname, will be successfully routed over the tor network.

I don't believe a failure of the client request in the above situation will 
result in a cache hit (server or client), the request will just fail and the 
app will try again or give up.

&gt; Here's an attack: I have a server that doesn't see much usage at
&gt; evil-nick.com.  You have a non-exit Tor host.  I suspect that you're
&gt; connecting to my server.  I control the DNS for evil-nick.com, so I
&gt; whenever your Tor server asks for the address of evil-nick.com I give
&gt; you IP1.  (If it never asks, I can resolve evil-nick.com.yourhost.exit
&gt; a lot.)  When any other server asks, I give them IP2.  If I see
&gt; anybody connect to IP1, I know that it's probably your client peeking
&gt; inside the server DNS.
&gt;

My understanding of the patch is: 

In the case where all DNS requests are looping back into Tor's DNSPort  the 
server will never get IP1 or IP2 since all it's dns requests will fail. The 
client meanwhile will either get IP2 (request routed over tor network) or 
will also fail and get nothing.

In the case where the system is properly configured and the server's requests 
are not proxied but the client's arrive at the DNSPort, the server will 
always get IP1 and the client will always get IP2. If client and server 
request evil-nick.com at the exact same moment, the server will get IP1 and 
the client will receive DNS_ERR_REFUSED.


&gt; There are probably easier attacks here too.



-- 

Browse Anonymously Anywhere	- http://anonymityanywhere.com
TorK	- KDE Anonymity Manager	- http://tork.sf.net
KlamAV	- KDE Anti-Virus 	- http://www.klamav.net

</body></email><email><emailId>20070627161822</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-06-27 16:18:22-0400</timestampReceived><subject>Re: prevent tor accepting dns requests on dnsport initiated by itself</subject><body>


On Sat, Jun 23, 2007 at 01:08:33PM +0100, Robert Hogan wrote:
&gt; On Friday 22 June 2007 16:52:48 Nick Mathewson wrote:
&gt; &gt; On Thu, Jun 21, 2007 at 10:53:08PM +0100, Robert Hogan wrote:
&gt; &gt; &gt; This would also prevent the user resolving a dns request if it
&gt; &gt; &gt; coincided exactly with the very same request by tor. I don't know
&gt; &gt; &gt; how likely this would be in practice - I certainly haven't been
&gt; &gt; &gt; quick enough on the draw.
&gt; &gt;
&gt; &gt; I think this is actually a dangerous idea.  We separate the client DNS
&gt; &gt; cache from the server DNS cache for a reason: if you're using a Tor
&gt; &gt; instance as both a client and a server, it's a good idea to keep the
&gt; &gt; client's behavior more or less uncorrelated by the server's.
&gt; &gt;
&gt; 
&gt; Sorry, I don't get it!

Ah, I misunderstood the purpose of the patch.  I thought it was to
save time on DNS resolves, not to check for DNSPort loops.  I get it
now. :)

&gt; I don't think any mixing of the caches takes place here. The patch
&gt; prevents a Tor server from resolving DNS requests when a broken
&gt; system configuration routes them all back to its own DNSPort. In
&gt; this situation the tor server will always be unable to resolve
&gt; anything and the server admin will be warned accordingly.
&gt; 
&gt; If the same Tor instance is being used as a client then the only
&gt; occasion in which an application's requests (e.g. from firefox) will
&gt; fail is if it happens to request the exact same dns resolve at
&gt; precisely the same moment the server's same dns request is in
&gt; progress. Otherwise its requests, even for the same hostname, will
&gt; be successfully routed over the tor network.
&gt; 
&gt; I don't believe a failure of the client request in the above
&gt; situation will result in a cache hit (server or client), the request
&gt; will just fail and the app will try again or give up.

Hmmm. I really _don't_ like the idea of making good client DNS break
_ever_, even if it's hard to provoke on your machine.  After all, if
users see this in practice, it's not likely that they'll even know to
report it as a bug, since it would be intermittent and hard to prove.

Could it be simpler just to add a function to eventdns.c to make sure
none of the nameservers are going to the addr:port of our dnsport?

yrs,
-- 
Nick Mathewson

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070617160144</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-06-17 16:01:44-0400</timestampReceived><subject>Re: Add remote addr/port to conn of dns request</subject><body>


On Sun, Jun 17, 2007 at 03:38:15PM +0100, Robert Hogan wrote:
&gt; 
&gt; If the extension for reporting the remote address and port in stream
&gt; events is adopted, it would be great if the address and port of dns
&gt; requests could be informative, rather than '(null):0'.
&gt; 
&gt; Testing this patch revealed the source of some odd dns requests TorK 
&gt; frequently reported when my system's requests were all routed to tor's 
&gt; dnsport. I was quite concerned about them at first, they were slews of 
&gt; invalid requests like
&gt; 
&gt; 650 STREAM 40 CLOSED 12 ng.invalid:0 REASON=DONE SOURCE_ADDR=192.168.1.2:33767
&gt; 650 STREAM 43 CLOSED 12 cixub22dxb3axlhj.com:0 REASON=DONE 
&gt; SOURCE_ADDR=192.168.1.2:33768
&gt; 650 STREAM 50 CLOSED 12 ingd6oyrd.org:0 REASON=DONE 
&gt; SOURCE_ADDR=192.168.1.2:33767

I've applied this patch too.  Thanks!

Two points to note:

  1) These requests are made by a Tor server to check for DNS
     hijacking.  (Some jerk DNS providers like to helpfully remap all
     NEXIST replies into advertising sites.  Tor detects this, works
     around it, and calls these providers mean names.)

  2) It isn't a good idea to have a Tor client be the DNS server for a
     Tor server.  I wonder what we can do to prevent this from
     happening.

peace,
-- 
Nick Mathewson

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070617164005</emailId><senderName>Robert Hogan</senderName><senderEmail>robert@roberthogan.net</senderEmail><timestampReceived>2007-06-17 16:40:05-0400</timestampReceived><subject>Re: Add remote addr/port to conn of dns request</subject><body>

On Sunday 17 June 2007 17:01:44 Nick Mathewson wrote:
&gt; On Sun, Jun 17, 2007 at 03:38:15PM +0100, Robert Hogan wrote:
&gt;[.]
&gt;
&gt; I've applied this patch too.  Thanks!
&gt;
&gt; Two points to note:
&gt;
&gt;   1) These requests are made by a Tor server to check for DNS
&gt;      hijacking.  (Some jerk DNS providers like to helpfully remap all
&gt;      NEXIST replies into advertising sites.  Tor detects this, works
&gt;      around it, and calls these providers mean names.)
&gt;

Sure, but I think a log message stating the 'domains' being queried would help 
settle a few nerves. Bizarre-looking DNS queries are just the sort of thing 
Tor users might expect from a snooper.

&gt;   2) It isn't a good idea to have a Tor client be the DNS server for a
&gt;      Tor server.  I wonder what we can do to prevent this from
&gt;      happening.
&gt;
&gt; peace,

Do you mean that it is a bad idea to force a tor server's un-proxied dns 
requests through tor with all-encompassing netfilter rules such as

iptables -t nat -I OUTPUT 1 -o ! lo -p udp -m udp --dport 53 -j 
DNAT --to-destination 127.0.0.1:9999 -m comment --comment "Redirect UDP DNS 
Requests to Tor" ?

This does seem a bit stupid on the face of it, though I'm not clear whether 
it's actually dangerous or just wasteful.


-- 

Browse Anonymously Anywhere	- http://anonymityanywhere.com
TorK	- KDE Anonymity Manager	- http://tork.sf.net
KlamAV	- KDE Anti-Virus 	- http://www.klamav.net

</body></email><email><emailId>20070617151328</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-06-17 15:13:28-0400</timestampReceived><subject>Re: STREAM_PORT Controller Event</subject><body>


On Sun, Jun 17, 2007 at 02:14:21PM +0100, Robert Hogan wrote:
 [...]
&gt; Hi Nick,
&gt; 
&gt; That's a much better idea. Patch attached. The extension format in the 
&gt; control-spec hasn't been implemented yet (so far as I can tell) so I've gone 
&gt; along with the current method. Am I right on this? If so, would you like 
&gt; someone to do it?

Applied; looks ok.  (The extension format in control-spec _is_ the one
that's implemented in control.c, as far as I can tell. Am I missing
something?)

&gt; At the moment, extended events get displayed regardless of the controller 
&gt; directive. There's a one-liner in the patch to fix that.

Actually, that's not the intention.  The idea is that extended events
are the way we should have designed events from the start, and having
them off-by-default is just a backward compatibility feature.  Once
you say you want extended events, _all_ the events you get are in the
extended format.

peace,
-- 
Nick Mathewson

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070617154348</emailId><senderName>Robert Hogan</senderName><senderEmail>robert@roberthogan.net</senderEmail><timestampReceived>2007-06-17 15:43:48-0400</timestampReceived><subject>Re: STREAM_PORT Controller Event</subject><body>

On Sunday 17 June 2007 16:13:28 Nick Mathewson wrote:
&gt; On Sun, Jun 17, 2007 at 02:14:21PM +0100, Robert Hogan wrote:
&gt;  [...]
&gt;
&gt; &gt; Hi Nick,
&gt; &gt;
&gt; &gt; That's a much better idea. Patch attached. The extension format in the
&gt; &gt; control-spec hasn't been implemented yet (so far as I can tell) so I've
&gt; &gt; gone along with the current method. Am I right on this? If so, would you
&gt; &gt; like someone to do it?
&gt;
&gt; Applied; looks ok.  (The extension format in control-spec _is_ the one
&gt; that's implemented in control.c, as far as I can tell. Am I missing
&gt; something?)
&gt;

Reading the spec, I expected to see 'setevents extended' produce something 
like:

      650-CIRC 1000 EXTENDED moria1,moria2 0xBEEF
      650-EXTRAMAGIC=99
      650 ANONYMITY=high

rather than

      650 CIRC 1000 EXTENDED moria1,moria2 0xBEEF EXTRAMAGIC=99 ANONYMITY=high

Closer reading shows that both should be expected. Haven't checked the code to 
see if both formats are implemented. But will do.

&gt; &gt; At the moment, extended events get displayed regardless of the controller
&gt; &gt; directive. There's a one-liner in the patch to fix that.
&gt;
&gt; Actually, that's not the intention.  The idea is that extended events
&gt; are the way we should have designed events from the start, and having
&gt; them off-by-default is just a backward compatibility feature.  Once
&gt; you say you want extended events, _all_ the events you get are in the
&gt; extended format.
&gt;
&gt; peace,

If you don't want controllers to turn off extended events (even when they try) 
once they've turned them on then that's fine. Hard to think of a situation in 
which the controller would want to switch between the two.

-- 

Browse Anonymously Anywhere	- http://anonymityanywhere.com
TorK	- KDE Anonymity Manager	- http://tork.sf.net
KlamAV	- KDE Anti-Virus 	- http://www.klamav.net

</body></email><email><emailId>20070614222140</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-06-14 22:21:40-0400</timestampReceived><subject>Re: Suggestion: Many OR-ports would improve the network</subject><body>


On Sat, Jun 09, 2007 at 03:28:09PM +0200, vikingserver@gmail.com wrote:
&gt; Is there a plan for TOR servers to be able to announce several OR-ports
&gt; and DIR-ports?

There sorta is.  It's been a "nice-to-have" for a while, and I think
it's a good idea.  Somebody should specify and implement it.  If
there's a decent spec and patch on an 0.2.0.x timeframe, I'd love to
check it in.

Here's what would need to be in the proposal:

  - Some way to configure which address:port combinations to listen
    on, and/or which to advertise.

    (The best way to support lots of ports is to have your firewall
    route all connections from those ports to Tor: this doesn't need
    anywhere near as many listening sockets.  You only really want to
    listen on tons and tons of ports if your firewalling doesn't
    support this, or you don't have access to your local
    iptables/ipf/whatever.  But if you want to do this with the
    firewall, you need the ability to advertise ports you aren't
    actually listening on.)

  - Some way to advertise in one's router descriptor which
    address:port combinations you're listening on.  For backward
    compatibility this should be a new line, not a change to the
    format of an existing line.

  - Possibly, some way to relay this information in network-status
    documents.

  - Some analysis of the impact on network-status and routerinfo
    size.  My guess is "not much", but if it turns out to be a bit, we
    should look into making the notation concise.

  - What does this imply for self-testing of servers and testing by
    authorities of servers?  What should the authorities do if one
    addr:port works but one doesn't?

  - Some way to pick which addr:port to use when you have a choice of
    more than one addr:port.

  - Some way to avoid having servers open lots and lots of connections
    between them when they get extend cells to the same server on
    different ports.

  - How this all interacts with coderman's ipv6 stuff. :)

Actually, this all looks quite doable.  The above questions need to be
answered, but they don't look terribly tricky to answer.  I bet
somebody could write a proposal on this. :)

peace,
--=20
Nick Mathewson

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070614235801</emailId><senderName>Cat Okita</senderName><senderEmail>cat@reptiles.org</senderEmail><timestampReceived>2007-06-14 23:58:01-0400</timestampReceived><subject>Re: Suggestion: Many OR-ports would improve the network</subject><body>

On Thu, 14 Jun 2007, Nick Mathewson wrote:
&gt; On Sat, Jun 09, 2007 at 03:28:09PM +0200, vikingserver@gmail.com wrote:
&gt;&gt; Is there a plan for TOR servers to be able to announce several OR-ports
&gt;&gt; and DIR-ports?
&gt;
&gt; There sorta is.  It's been a "nice-to-have" for a while, and I think
&gt; it's a good idea.  Somebody should specify and implement it.  If
&gt; there's a decent spec and patch on an 0.2.0.x timeframe, I'd love to
&gt; check it in.
&gt;
&gt; Here's what would need to be in the proposal:
&gt;
&gt;  - Some way to configure which address:port combinations to listen
&gt;    on, and/or which to advertise.

I'd also like to see some discussion of the effect this is likely to have
in environments that need to ban or limit Tor.  Speaking only for 
myself, in an environment where I need to keep a lid on Tor usage, having 
to chase port settings around makes it more likely that I'm going to
move from limiting Tor to just plain banning it.

cheers!
==========================================================================
"A cat spends her life conflicted between a deep, passionate and profound
desire for fish and an equally deep, passionate and profound desire to
avoid getting wet.  This is the defining metaphor of my life right now."
</body></email><email><emailId>20070615114534</emailId><senderName>"vikingserver () gmail ! com"</senderName><senderEmail>vikingserver@gmail.com</senderEmail><timestampReceived>2007-06-15 11:45:34-0400</timestampReceived><subject>Re: Suggestion: Many OR-ports would improve the network</subject><body>

The problem with Tor is that it's so terribly easy to stop. It's a piece
of cake to stop it for network admins and regimes that doesn't allow
freedom of speech.
For Tor to be able to allow freedom of speech and freedom of
information, it has to be unstopable.

Right now, it's mostly good for home users in the western world,
military and business users that want to use it for privacy reasons.
The Tor network could fill an important role against oppression in the
muslim countries and communist countries, and later in the EU.
Right now it really only helps home users in the relatively free world,
and a few others behind badly configured restrictive networks. Well
configured restrictive networks can easily stop Tor access.

A Tor client behind a restrictive firewall/proxy doesn't even reach the
dirservers, and has no way of connecting to the Tor network. Meaning
it's almost useless as a tool to allow freedom of speech in the whole world.

Decentralized popular P2P with a wide variety of ports and
"hubs/nodes/servers" are more successfull then Tor at helping persons in
oppressed countries.
Tor has to become better in order to allow users in the whole world to
reach every website in the world. But perhaps the goals is just to allow
traffic in the western world from non restrictive networks?

/Viking

Cat Okita skrev:
&gt; On Thu, 14 Jun 2007, Nick Mathewson wrote:
&gt;&gt; On Sat, Jun 09, 2007 at 03:28:09PM +0200, vikingserver@gmail.com wrote:
&gt;&gt;&gt; Is there a plan for TOR servers to be able to announce several OR-ports
&gt;&gt;&gt; and DIR-ports?
&gt;&gt;
&gt;&gt; There sorta is.  It's been a "nice-to-have" for a while, and I think
&gt;&gt; it's a good idea.  Somebody should specify and implement it.  If
&gt;&gt; there's a decent spec and patch on an 0.2.0.x timeframe, I'd love to
&gt;&gt; check it in.
&gt;&gt;
&gt;&gt; Here's what would need to be in the proposal:
&gt;&gt;
&gt;&gt;  - Some way to configure which address:port combinations to listen
&gt;&gt;    on, and/or which to advertise.
&gt;
&gt; I'd also like to see some discussion of the effect this is likely to have
&gt; in environments that need to ban or limit Tor.  Speaking only for
&gt; myself, in an environment where I need to keep a lid on Tor usage,
&gt; having to chase port settings around makes it more likely that I'm
&gt; going to
&gt; move from limiting Tor to just plain banning it.
&gt;
&gt; cheers!
&gt; ==========================================================================
&gt;
&gt; "A cat spends her life conflicted between a deep, passionate and profound
&gt; desire for fish and an equally deep, passionate and profound desire to
&gt; avoid getting wet.  This is the defining metaphor of my life right now."
&gt;
</body></email><email><emailId>20070615125636</emailId><senderName>Paul Syverson</senderName><senderEmail>syverson@itd.nrl.navy.mil</senderEmail><timestampReceived>2007-06-15 12:56:36-0400</timestampReceived><subject>Re: Suggestion: Many OR-ports would improve the network</subject><body>

On Fri, Jun 15, 2007 at 01:45:34PM +0200, vikingserver@gmail.com wrote:
&gt; 
&gt; A Tor client behind a restrictive firewall/proxy doesn't even reach the
&gt; dirservers, and has no way of connecting to the Tor network. Meaning
&gt; it's almost useless as a tool to allow freedom of speech in the whole world.
&gt; 
&gt; Decentralized popular P2P with a wide variety of ports and
&gt; "hubs/nodes/servers" are more successfull then Tor at helping persons in
&gt; oppressed countries.
&gt; Tor has to become better in order to allow users in the whole world to
&gt; reach every website in the world. But perhaps the goals is just to allow
&gt; traffic in the western world from non restrictive networks?
&gt; 

You should read "Design of a blocking-resistant anonymity system"
at http://tor.freehaven.net/svn/trunk/doc/design-paper/blocking.html
and/or at least look at the slides on the Tor documentation page.

HTH,
Paul
</body></email><email><emailId>20070615140152</emailId><senderName>Cat Okita</senderName><senderEmail>cat@reptiles.org</senderEmail><timestampReceived>2007-06-15 14:01:52-0400</timestampReceived><subject>Re: Suggestion: Many OR-ports would improve the network</subject><body>

On Fri, 15 Jun 2007, vikingserver@gmail.com wrote:
&gt; Decentralized popular P2P with a wide variety of ports and
&gt; "hubs/nodes/servers" are more successfull then Tor at helping persons in
&gt; oppressed countries.

Let me ask a different question[0] - how do you think that "decentralized
popular P2P" helps people in oppressed countries?

&gt; Tor has to become better in order to allow users in the whole world to
&gt; reach every website in the world. But perhaps the goals is just to allow
&gt; traffic in the western world from non restrictive networks?

I think you're mistaking my question here :)  There needs to be a balance
between privacy and freedom of access;  A piece of software that circumvents
any security checks that I've got in my environment is a great conduit
for incidents like the following[1]:

 	http://www.computerworld.com/action/article.do?command=viewArticleBasic&amp;taxo
nomyName=security&amp;articleId=9024491

 	By Jaikumar Vijayan
 	June 12, 2007
 	Computerworld

 	A Pfizer Inc. employee who installed unauthorized file-sharing software
 	on a company laptop provided for use at her home has exposed the Social
 	Security numbers and other personal data belonging to about 17,000
 	current and former employees at the drug maker.

 	Of that group, about 15,700 individuals actually had their data accessed
 	and copied by an unknown number of persons on a peer-to-peer network,
 	the company said in letters sent to affected employees and to state
 	attorneys general alerting them of the breach.

I'd like to see some discussion around how privacy is preserved, and how
Tor continues to be a Good Thing (tm) for those of us that are in the
position of justifying why Tor should be allowed -for business reasons-,
rather than feel good reasons.

cheers!
[0] Yes, seriously - I don't know what your definition of "help" is...
[1] I'm aware that Tor isn't p2p file sharing software - but when Tor
takes on similar characteristics to p2p software, the results from the 
point of view of many infosec folk aren't that different.

&gt; Cat Okita skrev:
&gt;&gt; On Thu, 14 Jun 2007, Nick Mathewson wrote:
&gt;&gt;&gt; On Sat, Jun 09, 2007 at 03:28:09PM +0200, vikingserver@gmail.com wrote:
&gt;&gt;&gt;&gt; Is there a plan for TOR servers to be able to announce several OR-ports
&gt;&gt;&gt;&gt; and DIR-ports?
&gt;&gt;&gt;
&gt;&gt;&gt; There sorta is.  It's been a "nice-to-have" for a while, and I think
&gt;&gt;&gt; it's a good idea.  Somebody should specify and implement it.  If
&gt;&gt;&gt; there's a decent spec and patch on an 0.2.0.x timeframe, I'd love to
&gt;&gt;&gt; check it in.
&gt;&gt;&gt;
&gt;&gt;&gt; Here's what would need to be in the proposal:
&gt;&gt;&gt;
&gt;&gt;&gt;  - Some way to configure which address:port combinations to listen
&gt;&gt;&gt;    on, and/or which to advertise.
&gt;&gt;
&gt;&gt; I'd also like to see some discussion of the effect this is likely to have
&gt;&gt; in environments that need to ban or limit Tor.  Speaking only for
&gt;&gt; myself, in an environment where I need to keep a lid on Tor usage,
&gt;&gt; having to chase port settings around makes it more likely that I'm
&gt;&gt; going to
&gt;&gt; move from limiting Tor to just plain banning it.
&gt;&gt;
&gt;&gt; cheers!
&gt;&gt; ==========================================================================
&gt;&gt;
&gt;&gt; "A cat spends her life conflicted between a deep, passionate and profound
&gt;&gt; desire for fish and an equally deep, passionate and profound desire to
&gt;&gt; avoid getting wet.  This is the defining metaphor of my life right now."
&gt;&gt;
&gt;

==========================================================================
"A cat spends her life conflicted between a deep, passionate and profound
desire for fish and an equally deep, passionate and profound desire to
avoid getting wet.  This is the defining metaphor of my life right now."
</body></email><email><emailId>20070615140522</emailId><senderName>"vikingserver () gmail ! com"</senderName><senderEmail>vikingserver@gmail.com</senderEmail><timestampReceived>2007-06-15 14:05:22-0400</timestampReceived><subject>Re: Suggestion: Many OR-ports would improve the network</subject><body>

&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta content="text/html;charset=ISO-8859-1" http-equiv="Content-Type"&gt;
&lt;/head&gt;
&lt;body bgcolor="#ffffff" text="#000000"&gt;
Interresting. So there ARE possible plans about changing the Tor
network in the future to become resistant to blocking, and to become a
tool to allow people behind restrictive firewalls to reach the full
internet. Very good. I hope this will happen soon, so that Tor becomes
a powerfull tool against censorship.&lt;br&gt;
This document affirms the fact that Tor is very easy to block today,
and that only poorly configured restricted firewalls today allow
traffic to Tor, either because the admins don't know about Tor, or
because they don't care.&lt;br&gt;
&lt;br&gt;
Let's hope that the Tor project will get more funds and more
programmers to speed up the work on making Tor a powerfull tool against
censorship by becoming blocking-resistant.&lt;br&gt;
&lt;br&gt;
/Viking&lt;br&gt;
&lt;br&gt;
Paul Syverson skrev:
&lt;blockquote cite="mid20070615125636.GA3638@itd.nrl.navy.mil" type="cite"&gt;
  &lt;pre wrap=""&gt;On Fri, Jun 15, 2007 at 01:45:34PM +0200, &lt;a \
class="moz-txt-link-abbreviated" \
href="mailto:vikingserver@gmail.com"&gt;vikingserver@gmail.com&lt;/a&gt; wrote:  &lt;/pre&gt;
  &lt;blockquote type="cite"&gt;
    &lt;pre wrap=""&gt;A Tor client behind a restrictive firewall/proxy doesn't even reach \
the dirservers, and has no way of connecting to the Tor network. Meaning
it's almost useless as a tool to allow freedom of speech in the whole world.

Decentralized popular P2P with a wide variety of ports and
"hubs/nodes/servers" are more successfull then Tor at helping persons in
oppressed countries.
Tor has to become better in order to allow users in the whole world to
reach every website in the world. But perhaps the goals is just to allow
traffic in the western world from non restrictive networks?

    &lt;/pre&gt;
  &lt;/blockquote&gt;
  &lt;pre wrap=""&gt;&lt;!----&gt;
You should read "Design of a blocking-resistant anonymity system"
at &lt;a class="moz-txt-link-freetext" \
href="http://tor.freehaven.net/svn/trunk/doc/design-paper/blocking.html"&gt;http://tor.freehaven.net/svn/trunk/doc/design-paper/blocking.html&lt;/a&gt;
 and/or at least look at the slides on the Tor documentation page.

HTH,
Paul

  &lt;/pre&gt;
&lt;/blockquote&gt;
&lt;/body&gt;
&lt;/html&gt;


</body></email><email><emailId>20070615141619</emailId><senderName>Paul Syverson</senderName><senderEmail>syverson@itd.nrl.navy.mil</senderEmail><timestampReceived>2007-06-15 14:16:19-0400</timestampReceived><subject>Re: Suggestion: Many OR-ports would improve the network</subject><body>

On Fri, Jun 15, 2007 at 04:05:22PM +0200, vikingserver@gmail.com wrote:

  Some html stuff. Please don't. It's not wasteful and doesn't interact
  well with many mail clients.

To the content of what you said: if you want to know how much of this
is "in the future" and how much it is happening now, one thing you
should do is keep up on the specs and source code.

aloha,
Paul
--
Paul Syverson                              ()  ascii ribbon campaign  
Contact info at http://www.syverson.org/   /\  against html e-mail
</body></email><email><emailId>20070615143628</emailId><senderName>"vikingserver () gmail ! com"</senderName><senderEmail>vikingserver@gmail.com</senderEmail><timestampReceived>2007-06-15 14:36:28-0400</timestampReceived><subject>Re: Suggestion: Many OR-ports would improve the network</subject><body>

decentralized popular P2P helps people in countries with cencorship by
allowing the people of the country to access: pictures, documents, news 
videos, religious videos, political videos, etc...


Your example of some dumb person sharing his/her company's secret
information doesn't relate to what I wrote. I don't understand why you
show this example. Tor is not an intrusive software that shares
everyone's information stored on their computers... And I don't know of
any P2P or filesharing program that shares everything that are on
people's company computers. A person's stupidity has nothing to do with
the subject.
I was writing about Tor, and making it possible to access every public
thing on the internet to everyone in the whole world.

My point was that I think Tor needs to become a tool to allow freedom of
information and freedom of speech in the whole world.

/Viking


Cat Okita skrev:
&gt; On Fri, 15 Jun 2007, vikingserver@gmail.com wrote:
&gt;&gt; Decentralized popular P2P with a wide variety of ports and
&gt;&gt; "hubs/nodes/servers" are more successfull then Tor at helping persons in
&gt;&gt; oppressed countries.
&gt;
&gt; Let me ask a different question[0] - how do you think that "decentralized
&gt; popular P2P" helps people in oppressed countries?
&gt;
&gt;&gt; Tor has to become better in order to allow users in the whole world to
&gt;&gt; reach every website in the world. But perhaps the goals is just to allow
&gt;&gt; traffic in the western world from non restrictive networks?
&gt;
&gt; I think you're mistaking my question here :)  There needs to be a balance
&gt; between privacy and freedom of access;  A piece of software that
&gt; circumvents
&gt; any security checks that I've got in my environment is a great conduit
&gt; for incidents like the following[1]:
&gt;
&gt;     http://www.computerworld.com/action/article.do?command=viewArticleBasic&amp;taxo
&gt;
&gt; nomyName=security&amp;articleId=9024491
&gt;
&gt;     By Jaikumar Vijayan
&gt;     June 12, 2007
&gt;     Computerworld
&gt;
&gt;     A Pfizer Inc. employee who installed unauthorized file-sharing
&gt; software
&gt;     on a company laptop provided for use at her home has exposed the
&gt; Social
&gt;     Security numbers and other personal data belonging to about 17,000
&gt;     current and former employees at the drug maker.
&gt;
&gt;     Of that group, about 15,700 individuals actually had their data
&gt; accessed
&gt;     and copied by an unknown number of persons on a peer-to-peer network,
&gt;     the company said in letters sent to affected employees and to state
&gt;     attorneys general alerting them of the breach.
&gt;
&gt; I'd like to see some discussion around how privacy is preserved, and how
&gt; Tor continues to be a Good Thing (tm) for those of us that are in the
&gt; position of justifying why Tor should be allowed -for business reasons-,
&gt; rather than feel good reasons.
&gt;
&gt; cheers!
&gt; [0] Yes, seriously - I don't know what your definition of "help" is...
&gt; [1] I'm aware that Tor isn't p2p file sharing software - but when Tor
&gt; takes on similar characteristics to p2p software, the results from the
&gt; point of view of many infosec folk aren't that different.
&gt;
&gt;&gt; Cat Okita skrev:
&gt;&gt;&gt; On Thu, 14 Jun 2007, Nick Mathewson wrote:
&gt;&gt;&gt;&gt; On Sat, Jun 09, 2007 at 03:28:09PM +0200, vikingserver@gmail.com
&gt;&gt;&gt;&gt; wrote:
&gt;&gt;&gt;&gt;&gt; Is there a plan for TOR servers to be able to announce several
&gt;&gt;&gt;&gt;&gt; OR-ports
&gt;&gt;&gt;&gt;&gt; and DIR-ports?
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; There sorta is.  It's been a "nice-to-have" for a while, and I think
&gt;&gt;&gt;&gt; it's a good idea.  Somebody should specify and implement it.  If
&gt;&gt;&gt;&gt; there's a decent spec and patch on an 0.2.0.x timeframe, I'd love to
&gt;&gt;&gt;&gt; check it in.
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; Here's what would need to be in the proposal:
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;  - Some way to configure which address:port combinations to listen
&gt;&gt;&gt;&gt;    on, and/or which to advertise.
&gt;&gt;&gt;
&gt;&gt;&gt; I'd also like to see some discussion of the effect this is likely to
&gt;&gt;&gt; have
&gt;&gt;&gt; in environments that need to ban or limit Tor.  Speaking only for
&gt;&gt;&gt; myself, in an environment where I need to keep a lid on Tor usage,
&gt;&gt;&gt; having to chase port settings around makes it more likely that I'm
&gt;&gt;&gt; going to
&gt;&gt;&gt; move from limiting Tor to just plain banning it.
&gt;&gt;&gt;
&gt;&gt;&gt; cheers!
&gt;&gt;&gt; ==========================================================================
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; "A cat spends her life conflicted between a deep, passionate and
&gt;&gt;&gt; profound
&gt;&gt;&gt; desire for fish and an equally deep, passionate and profound desire to
&gt;&gt;&gt; avoid getting wet.  This is the defining metaphor of my life right
&gt;&gt;&gt; now."
&gt;&gt;&gt;
&gt;&gt;
&gt;
&gt; ==========================================================================
&gt;
&gt; "A cat spends her life conflicted between a deep, passionate and profound
&gt; desire for fish and an equally deep, passionate and profound desire to
&gt; avoid getting wet.  This is the defining metaphor of my life right now."
&gt;
</body></email><email><emailId>20070614194708</emailId><senderName>"Michael_google gmail_Gersten"</senderName><senderEmail>keybounce@gmail.com</senderEmail><timestampReceived>2007-06-14 19:47:08-0400</timestampReceived><subject>Re: Proposal: Speed up Tor</subject><body>

I would like to know what is the next step to take to make this
happen. According to the tor design document I read, the procedure for
making changes to Tor is to first write up a proposal, then have it
discussed on the developer list, and then when it's well-understood,
code it. Yet there's no discussion, no feedback. What should I do
next?

On 6/1/07, Michael_google gmail_Gersten &lt;keybounce@gmail.com&gt; wrote:
&gt; Proposal for Tor.
&gt;
&gt; The goal of this proposal is to support the following goals:
&gt;
&gt; 1. An easy way to toggle between "At least speed X" (for
&gt; single-threaded web browsing) and "Any speed, many connections" (for
&gt; downloads).
&gt; 2. A way to keep nodes from being CPU starved from the encryption
&gt; processing (high bandwidth nodes)
&gt; 3. A way to keep nodes from being bandwidth starved (the main limit on
&gt; middle-speed nodes).
&gt;
&gt; Motivation: Speed up Tor.
&gt;
&gt; Design:
&gt; 1. Add in a control message for switching torrc's. Add support in
&gt; Vidiallia to toggle these.
&gt;         Flaw: Ideally the determination (high speed vs. high numbers) would
&gt; be made based on who is making the request. For example, while the
&gt; downloader is fetching 10 slow parts at once, I still want to browse.
&gt;
&gt; 2. If the protocol for extending a circuit to a new node does not
&gt; permit the new node to reject the connection, then add this ability.
&gt; Otherwise, start using it. Nodes can prevent being CPU starved by
&gt; refusing new connections when they are "full".
&gt;
&gt; 3. When a circuit is being built, estimates of bandwidth needed are
&gt; transmitted as well. Similar to #2, nodes will reject new connections
&gt; if the bandwidth isn't there.
&gt;
&gt; Security implications: Absolutely no idea. How does having large
&gt; numbers of connections affect Tor's tracability?
&gt;
&gt; Specification (incomplete):
&gt; 1. New control message would either take a filename of the new torrc,
&gt; or the contents of the new torrc. I do not know Tor's inner workings,
&gt; and cannot tell which is "better".
&gt;
&gt; 2. Nodes can measure the CPU cost per circuit, and tell how many they
&gt; can afford CPU wise. There may be a configuration parameter to
&gt; indicate how much CPU it can use; maybe the output of "uptime" is read
&gt; to see what the CPU levels are (and Tor stops accepting when the load
&gt; is .8 or higher.)
&gt;
&gt; 3. The simplest way to handle this is to put numbers in the config
&gt; file, and pass them along. For example, if I'm in "single threaded
&gt; browsing", I'll have numbers specifying a max speed of 150 KB/s, a
&gt; burst speed of 100 KB/s, and an average speed of 10 KB/s. If I'm in
&gt; "multi-threaded download", I'll specify a max speed of 25 KB, an
&gt; average speed of 15 KB, and a burst speed of 18 KB.
&gt;
&gt; What to do with these numbers? Well, if the sum of the averages of all
&gt; incoming circuits exceed my actual bandwidth, I say "No" when someone
&gt; tries to connect. Similarly, if I cannot support the burst speed, I
&gt; saw "No", to avoid slowing them down (this becomes the minimum speed
&gt; needed). Finally, I know that the worst case for this circuit is the
&gt; max speed, and I can do ... ? with it.
&gt;
&gt; The idea here: On my DSL, I cannot get more than 150 KB/s. While I
&gt; want to get that full speed, I'll be happy to get 100 KB/s. On
&gt; average, while I'm surfing, I'm not fetching pages all the time --
&gt; hence, an average speed of 10 KB/s representing fetch, read, fetch,
&gt; read, fetch, read.
&gt;
&gt; Now, it's not perfect. I'm thinking that "Busy percentage" might make
&gt; more sense -- 10% busy for web surfing, 95% busy for downloaders. This
&gt; would also help CPU overhead calculations. It also helps tell when to
&gt; say "This circuit has been idle for a while. It isn't active at all,
&gt; and while it is inactive, we will regard it as having a speed demand
&gt; of 0". This will prevent a node from being filled up with "idle"
&gt; connections, and becoming wasted.
&gt;
&gt; I'm also realizing that my concept of "burst" isn't quite right, and
&gt; I'm hoping that someone else has a better idea. For downloading,
&gt; "burst" means that while the average demand for a 10 part download is
&gt; 15 KB/s per circuit, there will be variance, and a node might see a
&gt; higher burst. Yet I will be happy even if a node can only give me 10
&gt; KB/s, because I have 9 other circuits that will each get slightly more
&gt; speed. So I think we need "This is my minimum acceptable speed, reject
&gt; this circuit if you can't give me this much", "This is my average",
&gt; and "This is my worst case / initial burst" (a lot of circuits will be
&gt; busy at first, and idle afterwards), as well as "percentage of time I
&gt; expect the circuit to be used".
&gt;
&gt; Compatibility: The only change in how nodes talk to each other is in
&gt; circuit building. I am not familiar with the current system to know
&gt; how this will change things.
&gt;
</body></email><email><emailId>20070614204438</emailId><senderName>"vikingserver () gmail ! com"</senderName><senderEmail>vikingserver@gmail.com</senderEmail><timestampReceived>2007-06-14 20:44:38-0400</timestampReceived><subject>Re: Proposal: Speed up Tor</subject><body>

I'm not a developer of Tor, but I like your idea about the possibility
to split up downloads into different circuits. And separating downloads
from other more important circuits. I like the idea. But in some cases,
the server where the downloaded zip/exe-file is stored, doesn't allow
splitted downloads. And in some other cases, the download source doesn't
allow another ip than the one you used during authentication/login.

If such a method would be programmed, it would also be good for the
tor-servers to be able to choose how high percentage of their bandwidth
should go to low-priority traffic like downloads, P2P, etc.
Because the communication is encrypted, there has to be two new "flags"
for the servers, and for the packets sent. Otherwise it wouldn't be
possible to separate low priority and high priority traffic.
Either these server-flags could be set by the server admin, or by the
tor-software based on server speed, and based on the port number the
server uses. If the server uses a very uncommon server port, that server
should concentrate on beeing an entry server, allowing traffic from
clients that can't connect to the common ports 9030, 9031, 80 and 443.
(See my suggestion about improving accessibility of Tor by allowing more
entry ports)
And if the traffic is encrypted from end to end, for example with SSL,
it wouldn't be possible for Tor clients and servers to distinguish
what's in the traffic. So then it's not possible to mark pakets as
low-priority.


Two things that slow down the Tor network are that DNS-requests are done
through the network (terribly slow?), and that some exit servers are
unresponsive (and/or block certain IP without configuring the blocked
ports in torrc).
The new tor 0.2.0.2alpha makes the network faster for combined servers
and clients with the new relay-settings.

Tor-developpers, if you read this, is there any spec. about all the
flags that every packet sent through tor can have? Are these packet
flags also encrypted between servers, or do they just have a crc?

/Viking


Michael_google gmail_Gersten wrote:
&gt; I would like to know what is the next step to take to make this
&gt; happen. According to the tor design document I read, the procedure for
&gt; making changes to Tor is to first write up a proposal, then have it
&gt; discussed on the developer list, and then when it's well-understood,
&gt; code it. Yet there's no discussion, no feedback. What should I do
&gt; next?
&gt;
&gt; On 6/1/07, Michael_google gmail_Gersten &lt;keybounce@gmail.com&gt; wrote:
&gt;&gt; Proposal for Tor.
&gt;&gt;
&gt;&gt; The goal of this proposal is to support the following goals:
&gt;&gt;
&gt;&gt; 1. An easy way to toggle between "At least speed X" (for
&gt;&gt; single-threaded web browsing) and "Any speed, many connections" (for
&gt;&gt; downloads).
&gt;&gt; 2. A way to keep nodes from being CPU starved from the encryption
&gt;&gt; processing (high bandwidth nodes)
&gt;&gt; 3. A way to keep nodes from being bandwidth starved (the main limit on
&gt;&gt; middle-speed nodes).
&gt;&gt;
&gt;&gt; Motivation: Speed up Tor.
&gt;&gt;
&gt;&gt; Design:
&gt;&gt; 1. Add in a control message for switching torrc's. Add support in
&gt;&gt; Vidiallia to toggle these.
&gt;&gt;         Flaw: Ideally the determination (high speed vs. high numbers)
&gt;&gt; would
&gt;&gt; be made based on who is making the request. For example, while the
&gt;&gt; downloader is fetching 10 slow parts at once, I still want to browse.
&gt;&gt;
&gt;&gt; 2. If the protocol for extending a circuit to a new node does not
&gt;&gt; permit the new node to reject the connection, then add this ability.
&gt;&gt; Otherwise, start using it. Nodes can prevent being CPU starved by
&gt;&gt; refusing new connections when they are "full".
&gt;&gt;
&gt;&gt; 3. When a circuit is being built, estimates of bandwidth needed are
&gt;&gt; transmitted as well. Similar to #2, nodes will reject new connections
&gt;&gt; if the bandwidth isn't there.
&gt;&gt;
&gt;&gt; Security implications: Absolutely no idea. How does having large
&gt;&gt; numbers of connections affect Tor's tracability?
&gt;&gt;
&gt;&gt; Specification (incomplete):
&gt;&gt; 1. New control message would either take a filename of the new torrc,
&gt;&gt; or the contents of the new torrc. I do not know Tor's inner workings,
&gt;&gt; and cannot tell which is "better".
&gt;&gt;
&gt;&gt; 2. Nodes can measure the CPU cost per circuit, and tell how many they
&gt;&gt; can afford CPU wise. There may be a configuration parameter to
&gt;&gt; indicate how much CPU it can use; maybe the output of "uptime" is read
&gt;&gt; to see what the CPU levels are (and Tor stops accepting when the load
&gt;&gt; is .8 or higher.)
&gt;&gt;
&gt;&gt; 3. The simplest way to handle this is to put numbers in the config
&gt;&gt; file, and pass them along. For example, if I'm in "single threaded
&gt;&gt; browsing", I'll have numbers specifying a max speed of 150 KB/s, a
&gt;&gt; burst speed of 100 KB/s, and an average speed of 10 KB/s. If I'm in
&gt;&gt; "multi-threaded download", I'll specify a max speed of 25 KB, an
&gt;&gt; average speed of 15 KB, and a burst speed of 18 KB.
&gt;&gt;
&gt;&gt; What to do with these numbers? Well, if the sum of the averages of all
&gt;&gt; incoming circuits exceed my actual bandwidth, I say "No" when someone
&gt;&gt; tries to connect. Similarly, if I cannot support the burst speed, I
&gt;&gt; saw "No", to avoid slowing them down (this becomes the minimum speed
&gt;&gt; needed). Finally, I know that the worst case for this circuit is the
&gt;&gt; max speed, and I can do ... ? with it.
&gt;&gt;
&gt;&gt; The idea here: On my DSL, I cannot get more than 150 KB/s. While I
&gt;&gt; want to get that full speed, I'll be happy to get 100 KB/s. On
&gt;&gt; average, while I'm surfing, I'm not fetching pages all the time --
&gt;&gt; hence, an average speed of 10 KB/s representing fetch, read, fetch,
&gt;&gt; read, fetch, read.
&gt;&gt;
&gt;&gt; Now, it's not perfect. I'm thinking that "Busy percentage" might make
&gt;&gt; more sense -- 10% busy for web surfing, 95% busy for downloaders. This
&gt;&gt; would also help CPU overhead calculations. It also helps tell when to
&gt;&gt; say "This circuit has been idle for a while. It isn't active at all,
&gt;&gt; and while it is inactive, we will regard it as having a speed demand
&gt;&gt; of 0". This will prevent a node from being filled up with "idle"
&gt;&gt; connections, and becoming wasted.
&gt;&gt;
&gt;&gt; I'm also realizing that my concept of "burst" isn't quite right, and
&gt;&gt; I'm hoping that someone else has a better idea. For downloading,
&gt;&gt; "burst" means that while the average demand for a 10 part download is
&gt;&gt; 15 KB/s per circuit, there will be variance, and a node might see a
&gt;&gt; higher burst. Yet I will be happy even if a node can only give me 10
&gt;&gt; KB/s, because I have 9 other circuits that will each get slightly more
&gt;&gt; speed. So I think we need "This is my minimum acceptable speed, reject
&gt;&gt; this circuit if you can't give me this much", "This is my average",
&gt;&gt; and "This is my worst case / initial burst" (a lot of circuits will be
&gt;&gt; busy at first, and idle afterwards), as well as "percentage of time I
&gt;&gt; expect the circuit to be used".
&gt;&gt;
&gt;&gt; Compatibility: The only change in how nodes talk to each other is in
&gt;&gt; circuit building. I am not familiar with the current system to know
&gt;&gt; how this will change things.
&gt;&gt;
&gt;

</body></email><email><emailId>20070614204833</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-06-14 20:48:33-0400</timestampReceived><subject>Re: Proposal: Speed up Tor</subject><body>


Hi!  I'm trying to write up some initial comments to Michael_google's
proposal now; please forgive the delay.  Stuff has been really busy.

Just one point:

On Thu, Jun 14, 2007 at 10:44:38PM +0200, vikingserver@gmail.com wrote:

&gt; Tor-developpers, if you read this, is there any spec. about all the
&gt; flags that every packet sent through tor can have? Are these packet
&gt; flags also encrypted between servers, or do they just have a crc?

All of the Tor protocol is documented in the specification documents.
They live in http://tor.eff.org/svn/trunk/doc/spec/

The one with documentation on packet format is
    http://tor.eff.org/svn/trunk/doc/spec/tor-spec.txt



yrs,
--=20
Nick Mathewson

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070614210932</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-06-14 21:09:32-0400</timestampReceived><subject>Re: Proposal: Speed up Tor</subject><body>


On Fri, Jun 01, 2007 at 10:30:32AM -0700, Michael_google gmail_Gersten wrote:
&gt; Proposal for Tor.

Hi, and sorry about the delay.  Stuff has been really busy.  I hope
Roger will have the time to chime in too.

First, this proposal needs a different name.  Generally, you want to
name proposals after the mechanism, not the goal: otherwise everybody
who has a proposal to make Tor faster writes something called "Speed
up Tor" or "Make Tor faster" or something.

Second, you should check out 111-local-traffic-priority.txt; that's
another proposal for speeding stuff up, based on creating incentives
for people to run more servers.

At the base, it looks like you want to do a few things:

    a) limit CPU usage on heavily loaded servers
    b) let servers turn down connections when they're already loaded.

I agree that a) is important.  I'm not sure that b) is the way to use
it; it seems to me that the end effect could easily be that mostly
people can't get on the network, but occasionally they get a really
fast circuit.  That's probably not an improvement.

Another danger here is that, if you're a greedy client, your logical
behavior under this proposal is to open as many circuits as you can
and use them forever.   This isn't so good for your anonymity though.
Hmmmm.

&gt; The goal of this proposal is to support the following goals:
&gt; 
&gt; 1. An easy way to toggle between "At least speed X" (for
&gt; single-threaded web browsing) and "Any speed, many connections" (for
&gt; downloads).

Hmmm.  I'm not sure I really like that part; it seems to leak pretty
trivially what you're doing by your node selection.  Also see below.

&gt; 2. A way to keep nodes from being CPU starved from the encryption
&gt; processing (high bandwidth nodes)
&gt; 3. A way to keep nodes from being bandwidth starved (the main limit on
&gt; middle-speed nodes).
&gt; 
&gt; Motivation: Speed up Tor.
&gt; 
&gt; Design:
&gt; 1. Add in a control message for switching torrc's. Add support in
&gt; Vidiallia to toggle these.
&gt; 	Flaw: Ideally the determination (high speed vs. high numbers) would
&gt; be made based on who is making the request. For example, while the
&gt; downloader is fetching 10 slow parts at once, I still want to
&gt; browse.

This sounds like an unrelated thing to what you actually want.  If
you'd like some circuits to be built with a different node selection
approach than others, you don't want to switch torrc files: you want
to apply a different set of circuit building rules to them.
Otherwise, there's no way for circuits of different types to coexist
on the same client.

&gt; 2. If the protocol for extending a circuit to a new node does not
&gt; permit the new node to reject the connection, then add this ability.
&gt; Otherwise, start using it. Nodes can prevent being CPU starved by
&gt; refusing new connections when they are "full".

Or they could could rate-limit connections or something.

This "turn away circuits when you're full" approach would seem to mean
that once you've got a circuit, you can use it as much CPU and
bandwidth as you want, but it can get hard to get a circuit.  Roger,
what do you think here?  This seems to be a step away from fairness.

&gt; 3. When a circuit is being built, estimates of bandwidth needed are
&gt; transmitted as well. Similar to #2, nodes will reject new connections
&gt; if the bandwidth isn't there.
&gt; 
&gt; Security implications: Absolutely no idea. How does having large
&gt; numbers of connections affect Tor's tracability?

Sorry; who sends bandwidth estimates to whom?

&gt; Specification (incomplete):
&gt; 1. New control message would either take a filename of the new torrc,
&gt; or the contents of the new torrc. I do not know Tor's inner workings,
&gt; and cannot tell which is "better".

There's already control commands to change config options.

&gt; 2. Nodes can measure the CPU cost per circuit, and tell how many they
&gt; can afford CPU wise. There may be a configuration parameter to
&gt; indicate how much CPU it can use; maybe the output of "uptime" is read
&gt; to see what the CPU levels are (and Tor stops accepting when the load
&gt; is .8 or higher.)

Seems like this would leak your CPU load.  Don't know if that's okay.

&gt; 3. The simplest way to handle this is to put numbers in the config
&gt; file, and pass them along. For example, if I'm in "single threaded
&gt; browsing", I'll have numbers specifying a max speed of 150 KB/s, a
&gt; burst speed of 100 KB/s, and an average speed of 10 KB/s. If I'm in
&gt; "multi-threaded download", I'll specify a max speed of 25 KB, an
&gt; average speed of 15 KB, and a burst speed of 18 KB.

We already specify numbers on the server side, and include them in
router descriptors, and never use more than we're configured to use.
Have you read dir-spec.txt (which says how we communicate about
routers) or path-spec.txt (which says how we choose circuit to build)?

&gt; What to do with these numbers? Well, if the sum of the averages of all
&gt; incoming circuits exceed my actual bandwidth, I say "No" when someone
&gt; tries to connect. Similarly, if I cannot support the burst speed, I
&gt; saw "No", to avoid slowing them down (this becomes the minimum speed
&gt; needed). Finally, I know that the worst case for this circuit is the
&gt; max speed, and I can do ... ? with it.

I don't know; is there a way to 

&gt; The idea here: On my DSL, I cannot get more than 150 KB/s. While I
&gt; want to get that full speed, I'll be happy to get 100 KB/s. On
&gt; average, while I'm surfing, I'm not fetching pages all the time --
&gt; hence, an average speed of 10 KB/s representing fetch, read, fetch,
&gt; read, fetch, read.
&gt; 
&gt; Now, it's not perfect. I'm thinking that "Busy percentage" might make
&gt; more sense -- 10% busy for web surfing, 95% busy for downloaders. This
&gt; would also help CPU overhead calculations. It also helps tell when to
&gt; say "This circuit has been idle for a while. It isn't active at all,
&gt; and while it is inactive, we will regard it as having a speed demand
&gt; of 0". This will prevent a node from being filled up with "idle"
&gt; connections, and becoming wasted.
&gt; 
&gt; I'm also realizing that my concept of "burst" isn't quite right, and
&gt; I'm hoping that someone else has a better idea. For downloading,
&gt; "burst" means that while the average demand for a 10 part download is
&gt; 15 KB/s per circuit, there will be variance, and a node might see a
&gt; higher burst. Yet I will be happy even if a node can only give me 10
&gt; KB/s, because I have 9 other circuits that will each get slightly more
&gt; speed. So I think we need "This is my minimum acceptable speed, reject
&gt; this circuit if you can't give me this much", "This is my average",
&gt; and "This is my worst case / initial burst" (a lot of circuits will be
&gt; busy at first, and idle afterwards), as well as "percentage of time I
&gt; expect the circuit to be used".
&gt; 
&gt; Compatibility: The only change in how nodes talk to each other is in
&gt; circuit building. I am not familiar with the current system to know
&gt; how this will change things.

You can learn how nodes talk to each other by reading tor-spec.txt.


On the whole, I think this is a good start; we need to think about how
this impacts performance overall.  I think limiting CPU use is a
decent idea (though my top CPU priority right now is figuring out how
to do a better job when we're on multi-core machines).  We already
limit bandwidth use.

Our current bandwidth approach is (more or less; please correct me,
Roger) "share equally among circuits on connections; share equally on
connections."  That's not so smart; proposal 111 is a little better.
This proposal amounts to "Show up early, get a circuit.  Show up late,
get nothing."  How can we investigate whether this would actually
improve matters?

There's also a DoS problem to consider here: it doesn't cost much to
make a bunch of connections (possibly anonymously) to a node and say
"I'll need a big chunk of bandwidth."  If nodes don't overcommit, it's
pretty easy to make a node useless by allocating all its bw without
actually using any.

There are already better fair queueing algorithms than the one Tor is
using; could we improve throughput by switching to one of those instead?

Anyway, just a first round of thoughts.  If you want to do another
revision of your proposal, I'll check that in.  If you'd prefer to
just rename it and have me slap a number on it, I'll put it into svn
as is.

Also, I should really go through my to-do folder and see what else is
waiting for a number.

man. so busy.

peace,
-- 
Nick Mathewson

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070612093102</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-06-12 09:31:02-0400</timestampReceived><subject>Re: Proposal: Distributed Storage for Tor Hidden Service Descriptors</subject><body>

On Thu, Jun 07, 2007 at 12:52:55PM -0400, Roger Dingledine wrote:
&gt; Not considered stable? But who is stable and who is not is a function of
&gt; who's in the network -- as the median uptime goes up or town, the routers
&gt; on the borderline will oscillate between being called stable and not.

Also, we should recognize that servers don't lose their stable flag
immediately -- many clients continue to use old network statuses for
perhaps hours after the node goes away / becomes unstable / etc.

So whatever design we choose needs to handle quite a bit of variance
in terms of who thinks who is stable.

Fun fun,
--Roger

</body></email><email><emailId>20070603060346</emailId><senderName>Mike Perry</senderName><senderEmail>mikeperry@fscked.org</senderEmail><timestampReceived>2007-06-03 06:03:46-0400</timestampReceived><subject>Re: Proposal: Two Hop Paths</subject><body>


Thus spake Fabian Keil (freebsd-listen@fabiankeil.de):

&gt; Mike Perry &lt;mikeperry@fscked.org&gt; wrote:
&gt; &gt;   The idea is that users should be able to choose if they would like
&gt; &gt;   to have either two or three hop paths through the tor network.
&gt; &gt; 
&gt; &gt;   This value should be modifiable from the controller, and should be
&gt; &gt;   available from Vidalia.
&gt; 
&gt; Did you consider (and reject) making the hop count also changeable
&gt; through special host names so HTTP users could change it depending
&gt; on the URL, or would that be an anonymity problem?

I had not considered this. It seems OK, though historically adding
suffixes to urls seems to not work very well in several cases if there
isn't something to scrub the suffix out (like privoxy ;).

I put it as Phase 6 of the proposal in SVN.

&gt; If different guards would be used for different hop counts,
&gt; fingerprinting based on the traffic might be easier for a
&gt; MITM between the user and most of the guard nodes, but if
&gt; the position of the user is constant, that's already
&gt; possible in cases like your [1] and the gathered information
&gt; ("this Tor user is the same Tor user I saw x days ago") is
&gt; probably not too threatening anyway.
&gt; 
&gt; Of course this should also only be an issue as long as the
&gt; proposed leaky-exit method isn't implemented.

Yeah, the plan would be to use the same guards, even before the
leaky-exit stuff is implemented.

-- 
Mike Perry
Mad Computer Scientist
fscked.org evil labs

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070604183638</emailId><senderName>Fabian Keil</senderName><senderEmail>freebsd-listen@fabiankeil.de</senderEmail><timestampReceived>2007-06-04 18:36:38-0400</timestampReceived><subject>Re: Proposal: Two Hop Paths</subject><body>


Mike Perry &lt;mikeperry@fscked.org&gt; wrote:

&gt; Thus spake Fabian Keil (freebsd-listen@fabiankeil.de):
&gt; 
&gt; &gt; Mike Perry &lt;mikeperry@fscked.org&gt; wrote:
&gt; &gt; &gt;   The idea is that users should be able to choose if they would like
&gt; &gt; &gt;   to have either two or three hop paths through the tor network.
&gt; &gt; &gt; 
&gt; &gt; &gt;   This value should be modifiable from the controller, and should be
&gt; &gt; &gt;   available from Vidalia.
&gt; &gt; 
&gt; &gt; Did you consider (and reject) making the hop count also changeable
&gt; &gt; through special host names so HTTP users could change it depending
&gt; &gt; on the URL, or would that be an anonymity problem?
&gt; 
&gt; I had not considered this. It seems OK, though historically adding
&gt; suffixes to urls seems to not work very well in several cases if there
&gt; isn't something to scrub the suffix out (like privoxy ;).

Somehow that's a limitation I can live with.

&gt; I put it as Phase 6 of the proposal in SVN.

Thanks.

Fabian

["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20070605201209</emailId><senderName>Paul Syverson</senderName><senderEmail>syverson@itd.nrl.navy.mil</senderEmail><timestampReceived>2007-06-05 20:12:09-0400</timestampReceived><subject>Re: Proposal: Two Hop Paths</subject><body>

I've been reading Mike's two-hop path alternative proposal.

What is good about it is it focuses on improving usability and
recognizing the potential anonymity implications of growing the user
base vs. protecting against some stronger potential adversary for 
a (n important) subset of the userbase.

There is lots of discussion of the security implications of the
proposal. I will mostly ignore that for now in light of bigger
concerns, viz. I cannot find any discussion or argument that the
proposal actually would provide the improvements that are its primary
goal: they seem to just be assumed. That is where I focus my remarks.

My guess is that two-hop-Tor-at-its-best is not perceptibly faster or
otherwise better than Tor-classic-at-its-best. Likewise for
two-hop-Tor-at-its-worst vs. Tor-classic-at-its-worst. Thus, the
entire question turns on the expected perceived performance, i.e., the
distribution of perceived-slow circuits across all circuits. Now I
will totally make up some numbers for purpose of illustration.  If,
e.g., 95 percent of circuits through two-hop Tor (2ht) are perceived
as acceptably fast, vs., e.g., 5 percent of circuits for Tor Classic
(3ht), then it seems at least reasonable that usage from perceived
better usability will increase significantly.  Even then there
probably needs to be some argument? But why should we expect such a
dramatic difference. My guess is that the limitations are mostly
caused by the slowest pipe or OR in the chain for any given circuit
(yes I know it's actually much more complicated than that). If even
very roughly correct, then the improvement in user perception is
not going to impress someone who find Tor unacceptably slow now.  Even
if that idea that circuits generally have a single bottleneck
is wrong but the effect of this change is rather to go from,
e.g., 60 percent of circuits for a given user being considered too
slow by that user to 35 percent of circuits, why do we think the user
will have any change of opinion about bad Tor performance at all?
It's possible that the usability improvements from this proposal will
be dramatic (though I personally doubt it). But for the moment there
is not even a handwavy argument to support that view. And a
much-more-than-handwavy argument should be given before consider so
dramatic a change.

Two more related points: Complaints about Tor performance are generally
anecdotal. Do we know the percentage of users that are on "broadband"?
Do we know if users on dialup have on average any perception of Tor
performance problems?

To date Tor has been advertised as: "Yes we know it's generally not
as fast as the raw internet, but you're getting something from that,
and we're trying to improve that." If the advertisement becomes, "Hey!
Now in two flavors! slow-Tor-for-paranoids and
fast-Tor-for-people-on-the-go", it may actually cost us users. If
people say, "Cool, finally a higher performance version." and they're
perception after trying it is "This is their idea of a fast
version!?!", the disappointment that when we got around to considering
performance for the regular Joe we failed miserably could be worse
than what we have now.

aloha,
Paul
</body></email><email><emailId>20070605205540</emailId><senderName>Steven Murdoch</senderName><senderEmail>tor+steven.murdoch@cl.cam.ac.uk</senderEmail><timestampReceived>2007-06-05 20:55:40-0400</timestampReceived><subject>Re: Proposal: Two Hop Paths</subject><body>

On Tue, Jun 05, 2007 at 04:12:09PM -0400, Paul Syverson wrote:
&gt; Two more related points: Complaints about Tor performance are generally
&gt; anecdotal. Do we know the percentage of users that are on "broadband"?
&gt; Do we know if users on dialup have on average any perception of Tor
&gt; performance problems?

The paper "Performance Comparison of low-latency Anonymisation
Services from a User Perspective", by Rolf Wendolsky, Dominik Herrmann
and Hannes Federrath, might answer some related questions.

It doesn't deal with performance problems caused by the user's
Internet connection; in fact they go out of their way to prevent this
effect interfering in their analysis. However, it still gives
quantifiable measures of Tor's performance.

The paper can be found here:
 http://www.petworkshop.org/2007/papers/PET2007_preproc_Performance_comparison.pdf
and will appear in PET 2007.

Thanks,
Steven.

-- 
w: http://www.cl.cam.ac.uk/users/sjm217/
</body></email><email><emailId>20070605212420</emailId><senderName>Paul Syverson</senderName><senderEmail>syverson@itd.nrl.navy.mil</senderEmail><timestampReceived>2007-06-05 21:24:20-0400</timestampReceived><subject>Re: Proposal: Two Hop Paths</subject><body>

On Tue, Jun 05, 2007 at 09:55:40PM +0100, Steven Murdoch wrote:
&gt; On Tue, Jun 05, 2007 at 04:12:09PM -0400, Paul Syverson wrote:
&gt; &gt; Two more related points: Complaints about Tor performance are generally
&gt; &gt; anecdotal. Do we know the percentage of users that are on "broadband"?
&gt; &gt; Do we know if users on dialup have on average any perception of Tor
&gt; &gt; performance problems?
&gt; 
&gt; The paper "Performance Comparison of low-latency Anonymisation
&gt; Services from a User Perspective", by Rolf Wendolsky, Dominik Herrmann
&gt; and Hannes Federrath, might answer some related questions.
&gt; 
&gt; It doesn't deal with performance problems caused by the user's
&gt; Internet connection; in fact they go out of their way to prevent this
&gt; effect interfering in their analysis. However, it still gives
&gt; quantifiable measures of Tor's performance.
&gt; 

Yes. This is an interesting paper that I should have cited when I mentioned
this point. But what I was asking about was the user perception. That
paper does examine performance from a user perspective in the sense
that they analyze performance for a client, but they don't say much
about how humans perceive performance differences. I think this paper
covers an important piece of the puzzle, but doesn't really answer the
questions I was asking.

-Paul
</body></email><email><emailId>20070607062735</emailId><senderName>coderman</senderName><senderEmail>coderman@gmail.com</senderEmail><timestampReceived>2007-06-07 06:27:35-0400</timestampReceived><subject>Re: pre-proposal for IPv6 exit support, questions</subject><body>

On 6/6/07, coderman &lt;coderman@gmail.com&gt; wrote:
&gt; i'd like some feedback on possible integration of IPv6 with Tor for
&gt; exit and DNS.

one thing i forgot to mention, which is likely a large amount of work,
is that representation of addresses in Tor should probably use a
generic sockaddr structure at the interface level, and handle distinct
types (IPv4, IPv6, UnixDomain) as indicated in the sa_family.

even if Tor doesn't intend to support IPv6 for all hops in a circuit,
it might make sense to do the sockaddr refactoring for all socket
handling pieces, as one day Tor may want to support IPv6 in this
fashion (and unix domain sockets for control or other ports).

could the IPv6 exit changes be done without such effort?  or is this
indeed somewhat of a prerequisite.

best regards,
</body></email><email><emailId>20070607165535</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-06-07 16:55:35-0400</timestampReceived><subject>Re: pre-proposal for IPv6 exit support, questions</subject><body>


On Wed, Jun 06, 2007 at 11:18:57PM -0700, coderman wrote:
&gt; i'd like some feedback on possible integration of IPv6 with Tor for
&gt; exit and DNS.  all of the following changes need not be implemented
&gt; for IPv6 exit to be useful, however, i think most of them will need to
&gt; be present for clients to use IPv6 easily.

Cool; I would like to get this feature into the 0.2.0.x series.

(Independently, I'm also interested in support for IPv6-only
_clients_, but that seems orthogonal.)

&gt; - transport:
&gt; this is perhaps the easiest layer.  the Tor specs already define IPv6
&gt; address types and formats which can finally be put to use.  is there a
&gt; good reason to keep IPv6 and IPv4 streams in different circuits?

No.  (I hope we don't do that now, do we?)

&gt; 
&gt; the OR's torrc should contain an explicit OutboundBindAddress with an
&gt; IPv6 address to enable IPv6 exit.  if no IPv6 address is bound the OR
&gt; should not consider itself IPv6 capable. (otherwise all of the routers
&gt; with link local IPv6 will suddenly default to supporting IPv6?)

Hmmm.  I understand the point of this, but I don't think
OutboundBindAddress is the way to go.  OutboundBindAddress is used
right now to say "Make sure that all outgoing connections use this
address."  I don't want to add an extra meaning.

If I understand correctly, link-local and site-local IPv6 addresses
are easy to detect.  Couldn't Tor do this automatically, as it detects
RFC 1918 addresses now?

&gt; - exit policy:
&gt; existing default exit policy contains *:* and *:$port directives.
&gt; this should be expanded to exclude internal/reserved IPv6 address
&gt; space as well for IPv6 capable ORs.  [i've included a sample exit
&gt; policy at the end of this msg]
&gt; 
&gt; should IPv6 capable ORs be required to include at least one IPv6
&gt; address or netmask in their exit policy, to signal IPv6 capability?

There are two issues here.  If we're we talking about "Does the
administrator need to set an IPv6 address in the exit policy in torrc
to say 'Hey, I do ipv6'," I'm not sure.  That would be quite unlike
the current IPv4 behavior, where there's a default exit policy unless
you change it.  But maybe it's okay for now.

But if we're talking about "Does the *node* need to _list_ an ipv6
address in the exit policy in its router to be considered
ipv6-capable", that's more reasonable.  I like that idea, in fact.

&gt; (likewise, should non-IPv6 capable OR's be forced to exclude any IPv6
&gt; addresses)

No; these ORs already exist, running older versions of Tor.  If not
mentioning IPv6 meant that you supported it, then all 0.1.1.x and
0.1.2.x routers would seem to support IPv6.

&gt; (for example, accept [2000::]/3:* used to signal IPv6 capability)
&gt; 
&gt; should some other method (extended descriptor information?) be used to
&gt; identify IPv6 capable OR's?

I like the idea of "If you list yourself as able to connect to ipv6
addresses in your exit policy, you are ipv6 capable".

&gt;  should public IPv6 connectivity be
&gt; verified (similar to OR IP/Port reachability for routers)?

Verifying the ability to _exit_ is outside of what Tor authorities do
now; this sounds like a fine job for Mike Perry's "Snakes on a Tor"
program.

&gt; 
&gt; - RESOLVE and RESOLVE_PTR:
&gt; DNS for IPv6 sucks [0].  how to limit this suckiness?  some options:
&gt; 
&gt; if an OR is IPv6 capable, it must return AAAA and A RR's to every
&gt; query.  this (should) keep both IPv4 and IPv6 clients happy, but has
&gt; the following drawbacks:
&gt; - some AAAA lookups may take forever to timeout, thus delaying the A
&gt; result.

Ugh.

&gt; - some AAAA lookups will fail in a way that may make a resolver
&gt; stub/library think a domain does not exit, rather than no IPv6 address
&gt; exists for this domain. (require eventdns for IPv6 resolution?)

Eventdns is already required in Tor 0.2.0.x-alpha; we don't do
dnsworkers any more.  (They sucked, and platform resolver libraries
sucked worse.)

&gt; - AAAA lookups and the IPv6 addresses returned are a waste of
&gt; time/bandwidth for IPv4 only clients, and may in fact confuse them.

Well, a RESOLVED cell is the same size no matter what's in it...

&gt; if a client wishes to use IPv6 exit, somehow signal to the exit that
&gt; IPv6 is preferred, and only use the AAAA lookups/responses when the
&gt; origin has declared IPv6 interest.  this should apply when doing
&gt; RESOLVE or CONNECT to named servers (that is to say, RESOLVE should
&gt; return IPv6 addresses, and CONNECT should attempt to connect to IPv6
&gt; addresses when a server is referred to by name, like
&gt; 'www.hexago.com')

Hmmm.  I'm okay saying "If there is an ipv4 address, I will connect to
the ipv4 address.  I'll only connect to the ipv6 address if I find
that there's no ipv4 address and there's only an ipv6 address, or if
you request the ipv6 address explicitly."

I think there's room for a flag in BEGIN and RESOLVE cells, though we
might need to make sure we only set the flag for newer Tors that
accept flags there. 

&gt; other ideas / suggestions?
&gt; 
&gt; 
&gt; - misc options:
&gt; the RedirectExit option should support IPv6 destinations?

Yes; or we should rip it out.  (Does anybody actually use it?)

&gt; the TransListenAddress should support IPv6 addresses.  this means
&gt; using IPV6_ORIGINAL_DST instead of SO_ORIGINAL_DST (and equivalent
&gt; flags for other OS'es).

Right, but this is an implementation issue.

&gt; 
&gt; the VirtualAddrNetwork setting will need a private netmask for IPv6
&gt; ranges used in MAPADDRESS.  something in link local unicast
&gt; (FE80::/10) should work.

Right.  I would prefer if there were a range of _host-local_ addresses
(like 127/8 in IPv4), though.

&gt; 
&gt; should clients have a "PreferIPv6" flag in their configuration to
&gt; signal OR exits that DNS and TCP connect should use IPv6 addresses
&gt; when possible?

Hmm. I'm not sure.  I'd go with "Not unless somebody turns out to need
it." for now.

&gt; - SOCKS5:
&gt; the torrc SOCKSBindAddress should accept an IPv6 address.  if this is
&gt; used for SOCKS5, then RESOLVE and CONNECT hostname should all prefer
&gt; an IPv6 address when possible.  (again, signal this upstream somehow?
&gt; assume that IPv6 capable exits will return IPv6 addresses?)

Hmmm.  Neat idea.

&gt; it would also be nice if somehow IPv4 clients could express an IPv6
&gt; preference via SOCKS5.  i'm not sure how this could be done easily
&gt; (another config option?).
&gt; 
&gt; 
&gt; - control interface:
&gt; i don't see a compelling reason to support a control port on IPv6.
&gt; as for the control spec, MAPADDRESS [::0]=hostname should work as
&gt; indicated in the spec.  the spec lists the address format as just
&gt; "::0" while accept / reject declarations need the brackets.  should
&gt; this be consistent?

It should be consistent; let's do the brackets.

&gt; 
&gt; what new control capabilities, if any, should be added?  the only one
&gt; that comes to mind is CHECKING_REACHABILITY like commands for IPv6
&gt; exit, or DNS lookup with AAAA responses (IPV6DNS_USELESS?, etc)
&gt; 
&gt; 
&gt; thanks in advance for any feedback and insight...
&gt; 
&gt; best regards,
&gt; 
&gt; 
&gt; 0. "The IPv6 mess"
&gt;   http://cr.yp.to/djbdns/ipv6mess.html
&gt; 
&gt; - sample IPv6 default exit policy:

Hm.  At the descriptor level, we can't do it like this.  Existing Tors
can't parse IPv6 addresses in exit policies, and so won't accept any
descriptor that has them.

I think we need to create new "accept6" and "reject6" items for
descriptors, and intermix them with existing accept and reject items.

&gt; reject 0.0.0.0/8
&gt; reject 169.254.0.0/16
&gt; reject 127.0.0.0/8
&gt; reject 192.168.0.0/16
&gt; reject 10.0.0.0/8
&gt; reject 172.16.0.0/12
&gt; reject [0000::]/8
&gt; reject [0100::]/8
&gt; reject [0200::]/7
&gt; reject [0400::]/6
&gt; reject [0800::]/5
&gt; reject [1000::]/4
&gt; reject [4000::]/3
&gt; reject [6000::]/3
&gt; reject [8000::]/3
&gt; reject [A000::]/3
&gt; reject [C000::]/3
&gt; reject [E000::]/4
&gt; reject [F000::]/5
&gt; reject [F800::]/6
&gt; reject [FC00::]/7
&gt; reject [FE00::]/9
&gt; reject [FE80::]/10
&gt; reject [FEC0::]/10
&gt; reject [FF00::]/8
&gt; reject *:25
&gt; reject *:119
&gt; reject *:135-139
&gt; reject *:445
&gt; reject *:1214
&gt; reject *:4661-4666
&gt; reject *:6346-6429
&gt; reject *:6699
&gt; reject *:6881-6999
&gt; # accept [2000::]/3:* is implied
&gt; accept *:*

Other semantic stuff you haven't specified:

  * it looks like you're assuming that "*" means "All IPv4 and all
    IPv6" addresses.  That's cool.  We can have "0.0.0.0/0" as our
    notation for "all IPv4 addresses" and "[::]/0" as our notation for
    "all IPv6 addresses".

  * Are we assuming that ::ffff:1.2.3.4 and 1.2.3.4 and the obsolete
    ::0:1.2.3.4 are all the same address for the purpose of exit
    policy?  I think we have IPv4 policies also apply to IPv4-mapped
    IPv6 addresses, so that "reject 10.0.0.0" also means "reject
    ::ffff:10.0.0.0".  Otherwise, everybody's exit policy will need to
    get twice as big.

peace,
-- 
Nick Mathewson

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070607165830</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-06-07 16:58:30-0400</timestampReceived><subject>Re: pre-proposal for IPv6 exit support, questions</subject><body>


On Wed, Jun 06, 2007 at 11:27:35PM -0700, coderman wrote:
&gt; On 6/6/07, coderman &lt;coderman@gmail.com&gt; wrote:
&gt; &gt;i'd like some feedback on possible integration of IPv6 with Tor for
&gt; &gt;exit and DNS.
&gt; 
&gt; one thing i forgot to mention, which is likely a large amount of work,
&gt; is that representation of addresses in Tor should probably use a
&gt; generic sockaddr structure

"struct sockaddr *" for pointers; "struct sockaddr_storage" for fields
in structs.

&gt;                               at the interface level, and handle distinct
&gt; types (IPv4, IPv6, UnixDomain) as indicated in the sa_family.
&gt; 
&gt; even if Tor doesn't intend to support IPv6 for all hops in a circuit,
&gt; it might make sense to do the sockaddr refactoring for all socket
&gt; handling pieces, as one day Tor may want to support IPv6 in this
&gt; fashion (and unix domain sockets for control or other ports).

Agreed, and I wouldn't worry about the coding effort.  This isn't a
hard change to do, and I think I've already marked all the places in
our structures where it needs to happen.  After all, "it's just a
simple matter of programming."

(Thanks to weasel, we already support Unix domain sockets for control
ports as of r10504.)


-- 
Nick Mathewson

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070606050041</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-06-06 05:00:41-0400</timestampReceived><subject>Re: cross build tor</subject><body>


On Tue, Jun 05, 2007 at 03:40:45PM +0800, Hao Jiajie wrote:
&gt; hi, all

Hi!

&gt; can i cross-build tor in linux?
&gt; I have already install cross-build enviroment follow by
&gt; http://www.libsdl.org/extras/win32/cross/
&gt; and i cross-complied libevent ok, but when i execute
&gt; cd tor-0.1.2.14

There are a lot of changes in the way 0.2.0.2-alpha handles searching
for libraries; does 0.2.0.2-alpha work any better for you?

If not, please sent me (not the list) the entire output of configure,
and the contents of the config.log file, as generated by the failing
0.2.0.2-alpha, and I'll see if I can fix it.

many thanks,
--=20
Nick Mathewson

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070606054439</emailId><senderName>"Hao Jiajie"</senderName><senderEmail>guorke@gmail.com</senderEmail><timestampReceived>2007-06-06 05:44:39-0400</timestampReceived><subject>Re: cross build tor</subject><body>

thanks for you help
&gt; There are a lot of changes in the way 0.2.0.2-alpha handles searching
&gt; for libraries; does 0.2.0.2-alpha work any better for you?

I did not try 0.2.0.2-alpha, but i tryied tor-0.1.2.14, first i meet some errors
about libevent, openssl(about cross-build), then i searched google,then
i can cross build tor in  my gentoo.

i have a qestion,what's the normal way to build tor.exe(and other related
lib, like zlib,openssl,libevent)  for windows?
it musted not cygwin,then msvc? mingw? or cross-build in linux?

some cross app have a cross build sh , like colinux, just run ./cross-build.sh,
then everything is ok. (you know sometimes msys can not work fine)

thanks again!
</body></email><email><emailId>20070609211829</emailId><senderName>Mike Perry</senderName><senderEmail>mikeperry@fscked.org</senderEmail><timestampReceived>2007-06-09 21:18:29-0400</timestampReceived><subject>Re: Proposal: Two Hop Paths</subject><body>


Thus spake Paul Syverson (syverson@itd.nrl.navy.mil):

&gt; My guess is that two-hop-Tor-at-its-best is not perceptibly faster or
&gt; otherwise better than Tor-classic-at-its-best. Likewise for
&gt; two-hop-Tor-at-its-worst vs. Tor-classic-at-its-worst. Thus, the
&gt; entire question turns on the expected perceived performance, i.e., the
&gt; distribution of perceived-slow circuits across all circuits. Now I
&gt; will totally make up some numbers for purpose of illustration.  If,
&gt; e.g., 95 percent of circuits through two-hop Tor (2ht) are perceived
&gt; as acceptably fast, vs., e.g., 5 percent of circuits for Tor Classic
&gt; (3ht), then it seems at least reasonable that usage from perceived
&gt; better usability will increase significantly.  Even then there
&gt; probably needs to be some argument? But why should we expect such a
&gt; dramatic difference. My guess is that the limitations are mostly
&gt; caused by the slowest pipe or OR in the chain for any given circuit
&gt; (yes I know it's actually much more complicated than that). If even
&gt; very roughly correct, then the improvement in user perception is
&gt; not going to impress someone who find Tor unacceptably slow now.  Even
&gt; if that idea that circuits generally have a single bottleneck
&gt; is wrong but the effect of this change is rather to go from,
&gt; e.g., 60 percent of circuits for a given user being considered too
&gt; slow by that user to 35 percent of circuits, why do we think the user
&gt; will have any change of opinion about bad Tor performance at all?
&gt; It's possible that the usability improvements from this proposal will
&gt; be dramatic (though I personally doubt it). But for the moment there
&gt; is not even a handwavy argument to support that view. And a
&gt; much-more-than-handwavy argument should be given before consider so
&gt; dramatic a change.

This is an excellent point. I will address this in a little more
detail in the proposal, and will eventually do a few speedracer runs
to back up the analysis empirically, but the general idea is that the
performance will come from 5 factors:

1. Decreased latency from less queuing from the extra hop
2. Decreased latency from less total distance from the extra hop
3. Decreased load on the network -&gt; increased capacity at slowest hops
4. Decreased probability of choosing a slow hop in a 2 hop circuit
5. Decreased probability of crossing slow peering links (oceans, etc) 

I think the bulk of the performance gain will come from points 1 and
2. Latency is a killer factor in user pereception of performance.
Johannes is also working on mechanisms to address points 1, 2 and 5
also, but there is nothing about either approach that prevents them
from both being used.

Unfortunately, the proposal is blocked on a backport of Bug #440*, and
its subsequent adoption, which I believe is also a significant
performance bottleneck and prevents me from taking accurate
measurments to determine the proper failure ratios to flag active
adversaries.

So it's possible that we will have time to determine if Johannes's
work improves latency+queuing enough to be sufficient before
implementing the proposal in full. But it's likely his work will also
have anonymity implicants that may require it to be only enabled for
the low-risk user class addressed by this proposal anyways.


* Bug 440 is an issue with load balancing guard nodes. Guard nodes in
Tor prior to svn r10493 were chosen uniformly:
http://bugs.noreply.org/flyspray/index.php?do=details&amp;id=440

I believe this bug is the reason why nodes in the 35-60 perentiles
exhibit higher failure rates and timeouts than both faster and slower
nodes, but obviously there is no proof for this until I run another
scan after the bug is backported to 0.1.2.x and adopted widely:
http://archives.seul.org/or/talk/Dec-2006/msg00123.html



-- 
Mike Perry
Mad Computer Scientist
fscked.org evil labs

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070611080839</emailId><senderName>Lasse_verlier</senderName><senderEmail>tor@zone.no</senderEmail><timestampReceived>2007-06-11 08:08:39-0400</timestampReceived><subject>Re: [or-cvs] r10493: When choosing a guard, weight by</subject><body>


Hi Roger,

I think approach A looks like the best option, but what about adding an
"EntryGuardBandwidth" in /var/lib/tor/state with the bandwidth the node
announced when chosen? This way a significant change in bandwidth can be
detected and the user may be warned/informed that (s)he can consider
"re-selecting" Entry Guards?

Just an idea...


 - Lasse

Roger Dingledine wrote:
&gt; On Mon, Jun 04, 2007 at 08:15:00PM -0400, nickm@seul.org wrote:
&gt;&gt;    tor/trunk/src/or/routerlist.c
&gt;&gt;  When choosing a guard, weight by bandwidth.  Resolves bug 440.
&gt; 
&gt; Hi Nick, Mike, folks,
&gt; 
&gt; I'm still not convinced that this is the best fix.
&gt; 
&gt; A recap for those following along at home:
&gt; http://bugs.noreply.org/flyspray/index.php?do=details&amp;id=440
&gt; The issue is that Tor clients were weighting every node that qualified
&gt; as a guard equally when choosing a new entry guard. So the guards that
&gt; had 60KB/s of bandwidth were getting as much action as the ones that had
&gt; 600KB/s of bandwidth. This meant that the "low end" guards were getting
&gt; hammered harder than they should be.
&gt; 
&gt; There are two places that we might want to fix:
&gt; 
&gt; A) When choosing a new entry guard, weight the options by bandwidth.
&gt; So we are ten times more likely to add the 600KB/s guard than the 60KB/s
&gt; guard to our guard list. But when building a circuit, choose a guard
&gt; uniformly from our list.
&gt; 
&gt; B) When adding a new guard, choose uniformly. But when choosing which
&gt; guard to use for a given circuit, weight each choice in our guard list
&gt; by its current bandwidth. So if one guard is 600KB/s right now and the
&gt; other is 60KB/s, we're ten times more likely to pick the first for a
&gt; given circuit.
&gt; 
&gt; (My first thought was that we should apply both approaches. But this
&gt; would be bad, because assuming the bandwidths are still the same as
&gt; they were when we first picked the guards, the slow ones will end up
&gt; being under-used in each given circuit (1/100 as often rather than 1/10
&gt; as often -- assuming we picked both the slow and the fast).
&gt; 
&gt; Nick chose approach "A" in his patch.
&gt; 
&gt; Approach A has the downside that if the bandwidths change dramatically
&gt; over time, we can't adapt. In this case, a whole lot of clients would
&gt; list the once-600KB/s-but-now-slow server in their guard lists, and it
&gt; would get more attention than it should.
&gt; 
&gt; Approach B adapts better to changes in guard bandwidth, but it has the
&gt; downside that if we're only picking a few guards uniformly at random, we
&gt; probably won't get the fast ones, so even if we load balance well over the
&gt; ones we've got we're still not going to produce globally good behavior.
&gt; 
&gt; Note that none of these options are *really* bad, because if a node
&gt; loses its guard flag then we stop using it as a guard. So nodes can't
&gt; get *really* crummy here; just sort of crummy.
&gt; 
&gt; Note also that Mike's hopes for current users to upgrade and suddenly
&gt; help the global load balancing won't work in approach A, since people
&gt; will still use their old (uniformly chosen) lists. It will only gradually
&gt; solve itself as new users join and as old guards lose their guard status
&gt; entirely.
&gt; 
&gt; If I had to choose right now, I'd pick approach A, because at least it
&gt; starts out being globally good, even if it degrades over time.
&gt; 
&gt; Anybody have a more creative option?
&gt; 
&gt; --Roger
&gt; 
</body></email><email><emailId>20070612211025</emailId><senderName>Mike Perry</senderName><senderEmail>mikeperry@fscked.org</senderEmail><timestampReceived>2007-06-12 21:10:25-0400</timestampReceived><subject>Re: [or-cvs] r10493: When choosing a guard, weight by bandwidth. Resolves bug 440 (in tor/trunk: . s</subject><body>


Thus spake Roger Dingledine (arma@mit.edu):

&gt; I'm still not convinced that this is the best fix.
&gt; 
&gt; There are two places that we might want to fix:
&gt; 
&gt; A) When choosing a new entry guard, weight the options by bandwidth.
&gt; So we are ten times more likely to add the 600KB/s guard than the 60KB/s
&gt; guard to our guard list. But when building a circuit, choose a guard
&gt; uniformly from our list.
&gt; 
&gt; B) When adding a new guard, choose uniformly. But when choosing which
&gt; guard to use for a given circuit, weight each choice in our guard list
&gt; by its current bandwidth. So if one guard is 600KB/s right now and the
&gt; other is 60KB/s, we're ten times more likely to pick the first for a
&gt; given circuit.
&gt; 
&gt; (My first thought was that we should apply both approaches. But this
&gt; would be bad, because assuming the bandwidths are still the same as
&gt; they were when we first picked the guards, the slow ones will end up
&gt; being under-used in each given circuit (1/100 as often rather than 1/10
&gt; as often -- assuming we picked both the slow and the fast).
&gt; 
&gt; Note also that Mike's hopes for current users to upgrade and suddenly
&gt; help the global load balancing won't work in approach A, since people
&gt; will still use their old (uniformly chosen) lists. It will only gradually
&gt; solve itself as new users join and as old guards lose their guard status
&gt; entirely

Ah shucks.. Forgot about this. Can we put some code to make users
re-choose guards for this upgrade? Or perhaps a general mechanism so
that we can decide in the future to expire guard selections chosen by 
a tor older than some given version?

It's not so much of a problem for mobile, transient and dialup users..
They get disconnected enough that the current guard selection stuff is
always picking new ones.. But perhaps we want to change this too.
Probably should, at some point... somehow..

Also, this brings up the point that older guard nodes are going to
tend to have more load than newer ones.. This is by design, but it may
get serious enough that really old nodes actually begin to suffer
reliability/congestion issues as a result, and may not be as stable as
their uptime would otherwise indicate? I suppose I can measure this
with speedracer at some point, but I think that the current balancing 
issue is going to mess with any runs I try to do..

&gt; If I had to choose right now, I'd pick approach A, because at least it
&gt; starts out being globally good, even if it degrades over time.
&gt; 
&gt; Anybody have a more creative option?

What about using the square root of the bandwidths for weighting for
guards? Then we could implement approach B by weighting based on this
value twice? 


-- 
Mike Perry
Mad Computer Scientist
fscked.org evil labs

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070612221944</emailId><senderName>Karsten Loesing</senderName><senderEmail>karsten.loesing@gmx.net</senderEmail><timestampReceived>2007-06-12 22:19:44-0400</timestampReceived><subject>Re: Proposal: Distributed Storage for Tor Hidden Service Descriptors</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Hi Roger,

thanks for your many comments! They really help to advance the project!

Let me start with answering the comment that caused (and still causes)
most of my headaches; the black-hole problem:

&gt; I still worry about an attacker generating keys until he gets n that
&gt; are very close to each other, and then putting resources into making
&gt; those n servers stable. There is suddenly a black hole in the 
&gt; descriptor space. He can't target a particular hidden service, but a)
&gt; he can be a nuisance, and b) for hidden services that require high 
&gt; availability, a one-period gap may still be significant.

I agree with you that this problem is not acceptable! I simply
overlooked it; thinking that if someone is not able to target an attack
to a certain service he wouldn't perform it. But why not attack the
whole system, just because it's possible?

The problem occurs when performing replication by identifier ranges,
rather than independently for every single descriptor as you propose:

&gt; It would be neat to have a design where each hidden service 
&gt; descriptor has its own set n of redundant locations. This approach 
&gt; would mean that there is no way to predict how to attack *any* piece 
&gt; of the keyspace.

Such a solution is possible. But there is another problem with your
approach: It might be too expensive. The advantage in replicating whole
identifier ranges is that all descriptors of that range can be
replicated in a single (maybe large) message. When descriptors are
(seemingly randomly) distributed among the whole ring, we need a message
exchange for every descriptor.

What do you think about combining both approaches?

- - The DHT nodes perform replication on the "ring level" to handle node
failures and single dishonest nodes. This should be limited to e.g. 1
additional copy for every descriptor, and replication could be performed
by the DHT nodes themselves.

- - Server and client (and maybe directory nodes) agree on a schema to
generate multiple descriptor IDs for the same descriptor. Replicas could
be maintained by the server, or (as you suggested) by the directory
nodes. I could imagine that 2 copies are enough for every descriptor.

This leads to 2x2=4 copies for one descriptor, or even more if more
conservative values are chosen for either replication level.

Headaches are still there, but I think I could live with such a
solution. Please correct me if I overlooked another thing!

&gt; Not considered stable? But who is stable and who is not is a function
&gt; of who's in the network -- as the median uptime goes up or town, the
&gt; routers on the borderline will oscillate between being called stable
&gt; and not.
&gt; 
&gt; (We're going to be working on more useful definitions of stable -- 
&gt; see proposal 108 -- but I don't think that will change the above 
&gt; note.)
&gt; 
&gt; So it might be that the HidServ flag, or whatever we call it, should
&gt; not simply be a copy of the Stable flag. One option is to demand
&gt; that the router has been considered Stable for the past n periods.
&gt; But does that still have the same flaw, just shifted? Or is it all a
&gt; matter of damping the oscillations adequately?

The idea is to require nodes to be in the Tor network for a certain time
before they can become part of the DHT. Of course, that should not
depend on the median uptime of nodes, but rather on a constant time,
e.g. one time-period. As pre-studies showed, churn is very small in the
Tor network (compared to applications for which DHTs are usually applied
to). And I expect it to be even smaller when we consider only nodes that
are up for 24+ hours.

&gt; Also, we should recognize that servers don't lose their stable flag 
&gt; immediately -- many clients continue to use old network statuses for 
&gt; perhaps hours after the node goes away / becomes unstable / etc.

But both, server and client would realize very quickly that a router is
gone and use the next best match in the routing table.

&gt; We should consider how to handle the situations when different users 
&gt; have different opinions of the list of valid authorities. This will 
&gt; happen each time we add a new authority and not everybody has 
&gt; upgraded, and it will also happen from time to time as authorities 
&gt; move locations (as happened recently with moria1 and moria2).

The list of valid authorities was something that I expected to be solved
somewhere else. Isn't there something like consensus on directories? How
do Tor clients achieve a consensus about Tor routers for common onion
routing? The idea was to simply rely on that list; and I expected that
this list should be similar at every node (or at least very close to that).

&gt;&gt;&gt; A HS directory node replicates descriptors for which it is 
&gt;&gt;&gt; responsible by downloading them from other HS directory nodes. 
&gt;&gt;&gt; Therefore, it checks its routing table periodically every 10 
&gt;&gt;&gt; minutes for changes.
&gt; 
&gt; a) Why 10 minutes?

No special reason. If it's cheap, we can do that every 60, 10, or 1
second(s).

&gt; b) Related to the above questions, how much overhead (again in terms
&gt; of storage waste and in increased expected number of requests til 
&gt; answer) do we see from a given level of churn based on the 
&gt; oscillation of who gets the HidServ flag?

This answer depends on the solutions we find for the problems above.

&gt;&gt;&gt; When setting up the hidden service at introduction points, a 
&gt;&gt;&gt; hidden service provider does not pass its own public key, but the
&gt;&gt;&gt; public key of a freshly generated key pair. It also includes 
&gt;&gt;&gt; this public key in the hidden service descriptor together with 
&gt;&gt;&gt; the other introduction point information. The reason is that the
&gt;&gt;&gt; introduction point does not need to know for which hidden
&gt;&gt;&gt; service it works, and should not know it to prevent it from
&gt;&gt;&gt; tracking the hidden service's activity.
&gt; 
&gt; Nice trick.

Thanks, but I have to give the credits to Lasse and Paul. They describe
something like that in their Valet Node paper.

&gt; But why a keypair? Why not just a secret cookie? Right now 
&gt; introduction points hear the hash of the public key as their cookie,
&gt; and clients tell the hash of the public key to identify which
&gt; service they want to be introduced to, and sign it with the
&gt; corresponding private key.

The idea was that a client needs to encrypt the INTRODUCE1 message to
the server with some key. And my concern was that someone could find out
that this encryption was done with the server's public key. But you may
be right, that there is no reason for this concern. So it should be
sufficient to use a fresh introduction cookie and encrypt the INTRODUCE1
message with the server's public key.

&gt;&gt;&gt; Instead of downloading descriptors from a hidden service 
&gt;&gt;&gt; authoritative directory, a hidden service client downloads it 
&gt;&gt;&gt; from a randomly chosen hidden service directory that is 
&gt;&gt;&gt; responsible for keeping replica for the descriptor ID.
&gt; 
&gt; And if it doesn't get one, it tries a new random one until it has 
&gt; tried all n?

Correct.

&gt;&gt;&gt; descriptor-id = h(permanent-id + h(time-period + cookie))
&gt;&gt;&gt; 
&gt;&gt;&gt; "permanent-id" is the hashed value of the public key of the 
&gt;&gt;&gt; hidden service provider, "time-period" is a periodically changing
&gt;&gt;&gt; value, e.g. the current date, and "cookie" is a shared secret 
&gt;&gt;&gt; between the hidden service provider and its clients. (The 
&gt;&gt;&gt; "time-period" should be constructed in a way that periods do not
&gt;&gt;&gt; change at the same moment for all descriptors by including the 
&gt;&gt;&gt; "permanent-id" in the construction.)
&gt; 
&gt; Huh? I don't understand the statement in parentheses.

What I meant is that descriptor-ids should not change all at once. There
would be much work to create new descriptor copies and distribute them,
e.g. every day at 4:00am, and then there is silence for 24 hours. In
order to circumvent this, I envisioned a way to make the switching from
one period to the next depend on the public key of the service. Then,
every server would have it's own switching time, and switchings of all
descriptors would be distributed among the whole day.

&gt; (Speaking of which, what period are we thinking of? An hour? A day?)

I always thought this to be one day for no special reason. Perhaps it's
quite expensive to let it be just one hour, because a service needs to
publish a new descriptor (and all of its copies) every hour then. Maybe
we need to maintain descriptors for more than one period (at least while
switching periods) in case that clients' clocks skew compared to the
server's clock.

&gt;&gt;&gt; 3  The network status format needs to be extended by a new status
&gt;&gt;&gt; flag to denote that a router is a hidden service directory.
&gt; 
&gt; We may want to call this flag HIDSERV1 or the like, so we can specify
&gt; that it is serving version 1 of the hidden service scheme. That way
&gt; we can transition to future schemes more easily.

Then, we sould rather call it HIDSERV2, because versions 0 and 1 are
already given to the existing hidden service schemes. But sure, we
should give it a number.

&gt; There. Those are enough questions for now.  :)

And I hope that I had some answers on those questions. Anyway, your
questions show to me that there are likely to be even more flaws in the
design. When was it that Google expects a stable implementation of this? ;)

- --Karsten
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFGbxwA0M+WPffBEmURAhFZAKCyeDhY2waWnSR60J9X2Mm/H3BPcgCffaOK
GPGFqv7AOCQFej2cp2RoEPQ=
=pibj
-----END PGP SIGNATURE-----
</body></email><email><emailId>20070614215534</emailId><senderName>"Michael_google gmail_Gersten"</senderName><senderEmail>keybounce@gmail.com</senderEmail><timestampReceived>2007-06-14 21:55:34-0400</timestampReceived><subject>Re: Proposal: Speed up Tor</subject><body>

I will definitely do another round this weekend. Thanks for this first feedback.

&gt; Anyway, just a first round of thoughts.  If you want to do another
&gt; revision of your proposal, I'll check that in.  If you'd prefer to
&gt; just rename it and have me slap a number on it, I'll put it into svn
&gt; as is.
</body></email><email><emailId>20070615144054</emailId><senderName>Paul Syverson</senderName><senderEmail>syverson@itd.nrl.navy.mil</senderEmail><timestampReceived>2007-06-15 14:40:54-0400</timestampReceived><subject>Re: Suggestion: Many OR-ports would improve the network</subject><body>

On Fri, Jun 15, 2007 at 10:01:52AM -0400, Cat Okita wrote:
&gt; 
&gt; I'd like to see some discussion around how privacy is preserved, and how
&gt; Tor continues to be a Good Thing (tm) for those of us that are in the
&gt; position of justifying why Tor should be allowed -for business reasons-,
&gt; rather than feel good reasons.
&gt; 

Amen to most of what you said about tradeoffs. An assumption that I
think is hidden behind this debate is the environment. There is a
difference between a country/an ISP user base/a research institution
and a corporation/a government enclave/etc. 

Designing Tor to get clients past restrictions (firewalls, etc.) that
keep them from the Tor network is not incompatible with its authorized
use in restricted environments.

One must decide what sort of environment one has however. Letting
people pretty much run whatever they want unless it is identified as
bad in a closed environment is a bit like using SSNs (SINs for Cat ;&gt;)
as authorization tokens. It's a fine to permit this if your job is to
generally give people access to the world, but if you are letting them
do that on systems that are meant to protect sensitive or critical
data and services then you are just asking for trouble irrespective
of Tor.

There are plenty of legit reasons to run Tor both from a desktop and
from a firewall (i.e., traffic runs over Tor outside the firewall and
is as visible as it would otherwise be to admins inside). These have
been extensively discussed before, but to name a few: Firewall
configurations protect corporate communications from competitive
intelligence and other surveillance, desktop configurations provide
compartmentalization of trust and defense in depth, either can help
protect road warriors from targeting for intelligence or worse.

aloha,
Paul
</body></email><email><emailId>20070617155539</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-06-17 15:55:39-0400</timestampReceived><subject>Re: STREAM_PORT Controller Event</subject><body>


On Sun, Jun 17, 2007 at 04:43:48PM +0100, Robert Hogan wrote:
&gt; On Sunday 17 June 2007 16:13:28 Nick Mathewson wrote:
&gt; &gt; On Sun, Jun 17, 2007 at 02:14:21PM +0100, Robert Hogan wrote:
&gt; &gt;  [...]
&gt; &gt;
&gt; &gt; &gt; Hi Nick,
&gt; &gt; &gt;
&gt; &gt; &gt; That's a much better idea. Patch attached. The extension format in the
&gt; &gt; &gt; control-spec hasn't been implemented yet (so far as I can tell) so I've
&gt; &gt; &gt; gone along with the current method. Am I right on this? If so, would you
&gt; &gt; &gt; like someone to do it?
&gt; &gt;
&gt; &gt; Applied; looks ok.  (The extension format in control-spec _is_ the one
&gt; &gt; that's implemented in control.c, as far as I can tell. Am I missing
&gt; &gt; something?)
&gt; &gt;
&gt; 
&gt; Reading the spec, I expected to see 'setevents extended' produce something 
&gt; like:
&gt; 
&gt;       650-CIRC 1000 EXTENDED moria1,moria2 0xBEEF
&gt;       650-EXTRAMAGIC=99
&gt;       650 ANONYMITY=high
&gt; 
&gt; rather than
&gt; 
&gt;       650 CIRC 1000 EXTENDED moria1,moria2 0xBEEF EXTRAMAGIC=99 ANONYMITY=high
&gt; 
&gt; Closer reading shows that both should be expected. Haven't checked
&gt; the code to see if both formats are implemented. But will do.

We only generate the second format right now, IIRC.  If you want to do
a patch for something, I wouldn't mind one to clarify how the format
works. :)


peace,
-- 
Nick Mathewson

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070617165631</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-06-17 16:56:31-0400</timestampReceived><subject>Re: Add remote addr/port to conn of dns request</subject><body>


On Sun, Jun 17, 2007 at 05:40:05PM +0100, Robert Hogan wrote:
&gt; On Sunday 17 June 2007 17:01:44 Nick Mathewson wrote:
&gt; &gt; On Sun, Jun 17, 2007 at 03:38:15PM +0100, Robert Hogan wrote:
&gt; &gt;[.]
&gt; &gt;
&gt; &gt; I've applied this patch too.  Thanks!
&gt; &gt;
&gt; &gt; Two points to note:
&gt; &gt;
&gt; &gt;   1) These requests are made by a Tor server to check for DNS
&gt; &gt;      hijacking.  (Some jerk DNS providers like to helpfully remap all
&gt; &gt;      NEXIST replies into advertising sites.  Tor detects this, works
&gt; &gt;      around it, and calls these providers mean names.)
&gt; &gt;
&gt; 
&gt; Sure, but I think a log message stating the 'domains' being queried
&gt; would help settle a few nerves. Bizarre-looking DNS queries are just
&gt; the sort of thing Tor users might expect from a snooper.

No argument there.  I was just explaining where those requests come
from.

&gt; 
&gt; &gt;   2) It isn't a good idea to have a Tor client be the DNS server for a
&gt; &gt;      Tor server.  I wonder what we can do to prevent this from
&gt; &gt;      happening.
&gt; &gt;
&gt; &gt; peace,
&gt; 
&gt; Do you mean that it is a bad idea to force a tor server's un-proxied dns 
&gt; requests through tor with all-encompassing netfilter rules such as
&gt; 
&gt; iptables -t nat -I OUTPUT 1 -o ! lo -p udp -m udp --dport 53 -j 
&gt; DNAT --to-destination 127.0.0.1:9999 -m comment --comment "Redirect UDP DNS 
&gt; Requests to Tor" ?
&gt; 
&gt; This does seem a bit stupid on the face of it, though I'm not clear whether 
&gt; it's actually dangerous or just wasteful.

Well, remember how it's _supposed_ to work.  A client wants the answer
to a DNS request, so it sends an anonymized request to a server.  The
server does a DNS lookup, and sends the reply back to the client.

But if the server's DNS lookup goes back into Tor (acting as a
client), then the request gets answered by _another_ server, which
tells the second Tor client, which tells the first server, which tells
the client.

The biggest problems here are:
   - Latency doubles (or worse, if the second Tor server is also
     configured like this.)
   - If everybody does it, DNS on Tor will fail completely.

yrs,
-- 
Nick Mathewson

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070620135715</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-06-20 13:57:15-0400</timestampReceived><subject>Re: Add STREAM_EVENT_NEW for dns requests and tunneled connect_dir</subject><body>


On Mon, Jun 18, 2007 at 09:58:27PM +0100, Robert Hogan wrote:
&gt; 
&gt; I think these are the only two remaining stream types without a 
&gt; STREAM_EVENT_NEW event.

Thanks, applying!

&gt; I also added a log_notice for the dns hijack tests.

I've tweaked this a little and turned this into an info message: we
check 12 bogus addresses every 12-24 hours, so I don't want to
generate a notice message for every one.

cheers,
-- 
Nick Mathewson

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070626213815</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-06-26 21:38:15-0400</timestampReceived><subject>Re: Proposal: Two hop paths from entry guards</subject><body>


On Tue, Jun 26, 2007 at 10:45:15AM -0700, Michael Lieberman wrote:
&gt; Title: Two hop paths from entry guards

Thanks!  I'll check this in as Proposal 116.

--=20
Nick Mathewson

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070627161124</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-06-27 16:11:24-0400</timestampReceived><subject>Re: check for conflicting *Port directives</subject><body>


On Sat, Jun 23, 2007 at 08:45:04PM +0100, Robert Hogan wrote:
&gt; 
&gt; if someone does something like:
&gt; 
&gt; ORPort 9031
&gt; SocksPort 9031
&gt; 
&gt; this will tell them where they've screwed up, rather than attempting
&gt; to bind to the port and fail for the second of the two options.
&gt; 
&gt; possibly a case of sledgehammer meets walnut (it's a large patch for
&gt; what it's fixing). If the idea is right it will need some cleaning
&gt; to be up to standard, but hopefully this will be less than the time
&gt; required to write from scratch.

Hi, Robert!  This is a good idea, but I think I see an issue with this
patch. It keeps you from doing stuff like the following, which _is_
legal:

        ORPort 9031
        SocksPort 9031
        ORListenAddress 1.2.3.4
        SocksListenAddress 127.0.0.1

And it doesn't stop you from doing stuff like this, which gives a port
conflict:

        ORPort 9031
        SocksPort 9032
        ORListenAddress 0.0.0.0:9031
        SocksListenAddress 127.0.0.1:9031

Minor issues to consider during the cleanup:

   1) It doesn't pass make check-spaces.
   2) It isn't indented like the rest of config.c.
   3) It doesn't even come close to building under ./configure
      --enable-gcc-warnings.
   4) Consider using the smartlist mechanism for dynamically growing
      arrays.
   5) Port_add is probably misnamed; it doesn't add a port.

peace,
-- 
Nick Mathewson

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070627162006</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-06-27 16:20:06-0400</timestampReceived><subject>Re: TODO: Add a way to request DNS resolves from the controller</subject><body>


On Wed, Jun 20, 2007 at 10:36:22PM +0100, Robert Hogan wrote:
&gt; 
&gt; I've implemented a rudimentary version of this.
&gt; 
&gt; I think I have the fundamentals right (it works) but I'm not sure about the 
&gt; interface. The controller requests resolves with:
&gt; 
&gt; RESOLVE hotmail.com
&gt; 250 OK
&gt; 
&gt; And tor responds with:
&gt; 
&gt; 650 RESOLVE hotmail.com:64.4.32.7

Nice!

&gt; Internally, performing a resolve request enables the RESOLVE event for that 
&gt; controller. But you only get a RESOLVE event whenever you request
&gt; one.
&gt;
&gt; I've implemented it as an event rather than a getinfo because of the
&gt; expected latency of the response.

Sensible.

&gt; This approach breaks the spec a bit, in that 650 events now occur when you 
&gt; perform a SETEVENTS or implicity enable a RESOLVE event by performing a 
&gt; RESOLVE.
&gt; 
&gt; Should I continue on the basis of this approach or is there a strong 
&gt; preference to make the requests something like getinfo resolve/hotmail.com ?

I think the approach you describe above is okay.  It shouldn't break
backward compatibility, since preexisting controllers will never issue
RESOLVE commands, and so will never get "650 RESOLVE" events.

peace,
-- 
Nick Mathewson

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070627201605</emailId><senderName>Robert Hogan</senderName><senderEmail>robert@roberthogan.net</senderEmail><timestampReceived>2007-06-27 20:16:05-0400</timestampReceived><subject>Re: prevent tor accepting dns requests on dnsport initiated by itself</subject><body>

On Wednesday 27 June 2007 17:18:22 Nick Mathewson wrote:
&lt;snip&gt;
&gt;
&gt; Hmmm. I really _don't_ like the idea of making good client DNS break
&gt; _ever_, even if it's hard to provoke on your machine.  After all, if
&gt; users see this in practice, it's not likely that they'll even know to
&gt; report it as a bug, since it would be intermittent and hard to prove.
&gt;
&gt; Could it be simpler just to add a function to eventdns.c to make sure
&gt; none of the nameservers are going to the addr:port of our dnsport?
&gt;

A lot simpler. Revised patch attached.


["rejecttordnsreqs.patch" (text/x-diff)]

Index: src/or/dnsserv.c
===================================================================
--- src/or/dnsserv.c	(revision 10664)
+++ src/or/dnsserv.c	(working copy)
@@ -103,6 +103,11 @@
   if (err == DNS_ERR_NONE &amp;&amp; strlen(q-&gt;name) &gt; MAX_SOCKS_ADDR_LEN-1)
     err = DNS_ERR_FORMAT;
 
+  if (evdns_find_nameserver(sin-&gt;sin_addr.s_addr, sin-&gt;sin_port)) {
+    log_warn(LD_APP, "Rejecting DNS Request received on DNSPort from Tor.");
+    err = DNS_ERR_REFUSED;
+  }
+
   if (err != DNS_ERR_NONE) {
     /* We got an error?  Then send back an answer immediately; we're done. */
     evdns_server_request_respond(req, err);
Index: src/or/eventdns.c
===================================================================
--- src/or/eventdns.c	(revision 10664)
+++ src/or/eventdns.c	(working copy)
@@ -1983,6 +1983,26 @@
 
 // exported function
 int
+evdns_find_nameserver(u32 addr, u16 port)
+{
+	const struct nameserver *server = server_head;
+    struct sockaddr_in my_addr;
+    socklen_t my_addr_len = sizeof(my_addr);
+
+	if (!server)
+		return 0;
+	do {
+        if (getsockname(server-&gt;socket, (struct sockaddr*)&amp;my_addr, &amp;my_addr_len)) 
+            continue;
+        if (my_addr.sin_port == port &amp;&amp; my_addr.sin_addr.s_addr == addr)
+            return 1;
+		server = server-&gt;next;
+	} while (server != server_head);
+	return 0;
+}
+
+// exported function
+int
 evdns_count_nameservers(void)
 {
 	const struct nameserver *server = server_head;
Index: src/or/eventdns.h
===================================================================
--- src/or/eventdns.h	(revision 10664)
+++ src/or/eventdns.h	(working copy)
@@ -260,6 +260,7 @@
 const char *evdns_err_to_string(int err);
 int evdns_nameserver_add(unsigned long int address);
 int evdns_count_nameservers(void);
+int evdns_find_nameserver(uint32_t addr, uint16_t port);
 int evdns_clear_nameservers_and_suspend(void);
 int evdns_resume(void);
 int evdns_nameserver_ip_add(const char *ip_as_string);


</body></email><email><emailId>20070507034225</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-05-07 03:42:25-0400</timestampReceived><subject>bridge and bridge authority proposal</subject><body>

Hi folks,

Here are some details on my plans for bridges and bridge authorities.
They're still fluid because I haven't actually built it, so it's hard
to know if they will turn out to be the right plans when it comes down
to coding, but it's at least a start.

If you don't know what I'm talking about, go take a look at the
blocking resistance draft design (and slides and video if you prefer)
at https://tor.eff.org/documentation#DesignDoc

There are three components that need to be added: bridge directory
authorities; bridges themselves; and the client side ("bridge users" or
"bridge clients"). (We need a better name than "bridge user" -- perhaps
a suitably ethnic but suitably inoffensive version of Alice? Or does a
name exist that matches those two constraints? :)

Piece one: bridge directory authorities.

  This part is easy. I've added a new config option
  BridgeAuthoritativeDir. I've also revamped the code so you can opt
  to be a V1 or V2 authority, or you can be a bridge authority, but you
  don't need to be both. (In fact, I suspect we will want to think harder
  about our logic ("what exactly do we serve") if some authority wants
  to be both -- but I don't see a need for that quite yet, so I'm leaving
  it for another time.)

  There's a new wrapper authdir_mode_bridge() that tells whether we are
  acting as a bridge directory authority. When we are, we decline to
  generate or serve v1 directories/running-routers or v2 network statuses.
  Otherwise we answer dir queries as normal, and we allow uploads of
  server descriptors as normal.

  One day we'll want some way to enumerate the bridges we hear about,
  rather than just listing them internally and never publishing the
  list. My first plan, once all the work described in this email
  is finished, is to have bridge authorities write a list of bridge
  descriptors to disk, and then the humans can manually tell the IP:ORPort
  of a few bridges to testers and to people in need. After that works
  we can produce a second plan.

Piece two: bridges.

  Bridges are just Tor servers that publish to a different location.

  My next step is to change the DirServer config syntax so it can
  hear that an authority is a 'bridge' flag too.

  Then we need a way to tell servers where they should publish. I was
  thinking of adapting the PublishServerDescriptor config option for
  that. Currently it's only used for controllers like Blossom, and
  it's a boolean, but we might make it more general and let it take
  "v1", "v2", and/or "bridge" arguments too.  We could retain "0"
  for "don't publish to anything" and "1" for "publish to whatever
  you think best" for backward compatibility. Or we could retain "0"
  for "don't publish to anything" and "1" for "a synonym for v2" for a
  different sort of backward compatibility that we mark as deprecated. Or
  if adapting this config option is dumb, we could add a separate
  PublishServerDescriptorToWhere config option, but that seems overkill.

  Bridges would likely want to set RelayBandwidthRate and
  RelayBandwidthBurst. Good thing they mostly work now.

Piece three: clients.

  This is the trickiest part. Users of bridges want to use a set of
  bridges as their first hops -- rather than entry guards. So the easy
  part is a new config option "UseBridges 0|1", and a new LINELIST
  config option
  "Bridge IP:Orport [fingerprint]".

  Now, when UseBridges is set, it is necessary that all circuits
  and dir fetches traverse a bridge as their first hop. In order to
  be able to bootstrap, users need to be able to learn networkstatus
  documents. They could do this by
    a) connecting to the bridge and sending it a begin_dir request. Not
    so good because now every bridge needs to be a dir cache.
    b) connecting to the bridge and sending a begin request to exit to
    a directory authority's port. Not so good because now bridges can't
    just have "reject *:*" as their exit policy.
    c) Doing a create-fast to the bridge, and then some sort of
    extend-fast to the directory authority, and querying the authority
    via begin_dir from there. Not so good because the Tor protocol
    doesn't support that (and it wouldn't get the full security that
    the Tor extend provides, because the bridge could bluff).

  For the first solution, I suggest we go with a) -- if the bridge has
  a defined dirport, then it mirrors dir info quickly and often, and if
  it doesn't, then it mirrors dir info just as a normal Tor client does,
  but in any case the bridge user can dip into the bridge's directory info
  and learn enough to bootstrap. So long as the bridge can make circuits,
  this means the bridge user should be able to make those circuits too.
  To make things simpler for the first go, we can just demand that for
  now bridges must define their dirport.

  (This choice has implications for future designs where Tor clients
  know different pieces of the directory -- it will be harder to keep
  secret which pieces you know if your bridge clients can just query you.)

  As a little bonus, if the bridge user fetches his dir info from the
  bridge, he'll be sure to ask for descriptors that he can get (since
  they're the ones the bridge is trying to get too), and he saves some
  bandwidth for the bridge (though only download bandwidth so that
  doesn't matter as much).

  I'm inclined to keep the "bridges" list on bridge clients separate
  from the "entry guards" list, on the theory that sometimes people will
  require bridges and sometimes they won't and we don't want to mingle
  things. But the parallel between "bridge users use a bridge as their
  first hop and do a begin-dir to it to learn dir info" and the future
  plans of "Tor users use an entry guard as their first hop and do a
  begin-dir to it to learn dir info" is eerie, and I expect that down
  the road we will evaluate whether to merge them somehow.

  So somebody watching a bridge will see it make connections to a fixed
  handful of nodes, and those are the circuits the bridge operator is
  generating, and the other circuits are probably for the relayed traffic
  from the bridge user. This introduces anonymity research questions
  ("what are the implications", "can we do better"), which I leave open
  for now in the interest of getting a first prototype up. Feel free to
  answer them, and we can change our mind down the road.

  The details of keeping state inside Tor, remembering that you need
  to build your circuits through a bridge, having "one-hop" circuits vs
  "three-hop circuits", etc are going to get messy, and that's where the
  bulk of the work will come in. A lot of that work is already underway
  with client-side support for begin_dir.

  We probably want a way to cache bridge descriptors in the datadir and
  keep them separate from "main" Tor server descriptors. Which leads to
  the next section.

Descriptor purposes: how to tell them apart.

  It turns out we've encountered a similar issue in the past, when
  controllers wanted to give us router descriptors that Tor shouldn't use
  when it's making its own paths. We solved it then by adding a 'purpose'
  to descriptors -- 'general' purpose is for normal descriptors, whereas
  'controller' purpose is for others. When Tor chooses nodes for its
  paths, it only chooses from the general-purpose descriptors.

  The controller specifies the purpose it has in mind when it invokes
  postdescriptor. The descriptor itself doesn't contain its purpose --
  after all, a Tor server is a Tor server, and different people can use
  it in different contexts.

  So how does this apply here? When we learn a bridge descriptor,
  e.g. from connecting to the IP:ORPort and using a begin_dir to ask for
  /tor/server/authority, or from asking a bridge authority for a new one,
  we tag it as a 'bridge' purpose so we can remember what to use it for.

  The specific problem we're solving is how to make sure that the first
  hop is a 'bridge' purpose when UseBridges is set. But the more general
  case is that we want a way to tell Tor to use certain purposes in
  certain positions in the path. When we have more purposes out there,
  I can imagine that onion_populate_cpath() and friends could assign a
  desired purpose in each step of the cpath, so when we choose a router
  for that step we choose from among the right pool of routers. This
  would let us handle N different Tor networks down the road, and we
  could build paths that traverse several of them. And we could put tags
  on dirserver lines to specify the purpose that should be assigned to
  all the descriptors we learn from it. And eventually we will need a
  better word than 'purpose' to describe what we're doing with it. But
  no need to solve this stuff until we get closer to it.

  Nick proposed that we add a little header section to each descriptor
  before we write it to disk, explaining its purpose and maybe other
  features about it. I think this is a great idea. Nick is better at
  choosing formats for these things than I am, so I will propose a proof
  of concept and let him improve it:
  "Add the following two lines above the 'router' line:
    local-status version-num
    purpose foo
  where version-num is the version of local-status we're using (always
  1 for now), and foo is the purpose we'd like to remember for this
  descriptor. Later we might add an 'origin' line or some other line. The
  local-status section is over when we reach a 'router' line."

  We also have need of writing other statistics about a given router,
  such as for directory authorities that collect stats about uptime
  periods -- but these stats will change significantly more often than
  the descriptor itself, so we should probably store them in some other
  file, so I'll ignore that topic here.

There. This should be enough to tackle for now.

--Roger

</body></email><email><emailId>20070507213142</emailId><senderName>Karsten Loesing</senderName><senderEmail>karsten.loesing@gmx.net</senderEmail><timestampReceived>2007-05-07 21:31:42-0400</timestampReceived><subject>Re: Encrypting content of hidden service descriptors</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Hi,

is this discussion still alive? ;) It took me some time to think about
the problem (and then to discuss it with a colleague of mine), but
finally I imagine that there could be a solution! :)

Roger Dingledine wrote:
&gt; On Sat, Apr 14, 2007 at 08:01:21PM +0200, Karsten Loesing wrote:
&gt;&gt; The reason why I asked the question is, that I am rethinking the format
&gt;&gt; of rendezvous service descriptors at the moment. And there still is this
&gt;&gt; idea around of encrypting the descriptor content which is, as you wrote,
&gt;&gt; not completely solved.
&gt; 
&gt; Right. [...]

Thinking about the problem did not change my mind that encrypting the
complete content of hidden service descriptors is *not* the solution.
The storing node needs to verify the publisher's authenticity. If it
cannot do that, everyone knowing a descriptor index can publish as many
random "descriptors" for that index as she likes. This prevents us from
simply implementing Lasse's and Paul's Valet Service approach in the
proposed form -- though it has many interesting parts which we can
adopt. If I am wrong with this, please correct me, especially Lasse and
Paul! :)

&gt; [...] I remember a discussion a couple years ago about how to encrypt
&gt; the hidden service descriptors. I wanted three things at once:
&gt; 
&gt; a) The places that store and serve the descriptors can't learn the
&gt; introduction points,
&gt; b) But they can make sure they're signed correctly and can pick out the
&gt; newest descriptor.
&gt; c) Select clients can learn them through some extra key or whatever
&gt; they're given.

These three things are absolutely reasonable! But I want more... :)

d) The places that store and serve the descriptors change periodically.

e) It is hard for such a storing and serving node to track the activity
   of a hidden service, even given that a set of such nodes colludes.

f) For all other nodes than 1) the subset of currently storing and
   serving nodes and 2) the clients it is impossible to track the
   activity of a hidden service.

&gt; Doing all three of these with just one key (or derivatives of that key)
&gt; seems hard. It probably requires crypto magic that I don't have.

Right, neither do I.

&gt; An easier option might be to use two keys. I haven't worked out the
&gt; details, which means all the hard work still remains ;), but the idea
&gt; would be that we'd have a signing key which is publicly known, and
&gt; the name, timestamp, signing key, and signing key signature would be
&gt; clearly visible to everybody. The rest of the descriptor would be the
&gt; introduction points, encrypted with the second (encryption) key. Then
&gt; the client would be given both keys (e.g. x-y.onion), whereas the public
&gt; only knows the signing key.

I agree with your arguments. What follows next is the "hard work"... :)

1. Bob registers his hidden service at some introduction points. In
contrast to the original approach he passes a private key from a fresh
key pair to the introduction point and does not pass his own onion key.
The reason is that the introduction point shall not be able to recognize
Bob and track his activity. Bob includes the corresponding public key in
the rendezvous service descriptor. This idea is copied 1:1 from the
Valet Service approach. Whatever I may have described incorrectly is
meant like it's written in Lasse's and Paul's paper.

2. Bob creates a rendezvous service descriptor with the following
contents and stores it at those nodes in the ID circle which are
"responsible" for storing or replicating the given ID:

1) ID = h(h(PK_B) + h(date + cookie_AB))
2)          PK_B
3)                  h(date + cookie_AB)
4) timestamp
5) {introduction point IP + port + public service key}_AB
6) signature of 1) to 5) using Bob's private key

The symbols are:
- - h: a cryptographically secure hash function
- - PK_B: Bob's public, permanent onion key
- - +: string concatenation
- - h(PK_B): Bob's permanent onion ID
- - date: a dynamically changing component, e.g. the current date or
  something changing more often (1/2 day, ...)
- - cookie_AB: a secret shared by Bob and all of Bob's clients A; though
  it is assumed that such a cookie is only given to a subset of
  authenticated clients, it could also be passed to all of them together
  with h(PK_B); the latter would then represent a situation of a hidden
  service without authentication
- - timestamp: Bob's current time in millis to ensure freshness
- - everything in 5): contact information encrypted using cookie_AB

This approach adopts some important ideas from Lasse's and Paul's paper,
but changes some parts to fulfill requirement b).

The ID is used to store and retrieve the descriptor. It needs to change
its position in the identifier circle, so this is why the date is
included. Its position needs to be unpredictable for everyone else than
Bob's clients, so it is based on cookie_AB. But the storing node needs
to be sure that it's Bob who stores something using this ID, so that
h(PK_B) is not included in the inner hash function, but separately, and
that PK_B is given in plain in 2). Hence, the storing node can use 3)
(which looks like random noise to it) and 2) to see that only the person
with the private key for PK_B could have created the descriptor, or to
be more precise the signature in 6). All of Bob's clients are able to
create the same ID, retrieve the descriptor for it, and decrypt the
contact information given in 5). But they are not able to create a valid
descriptor with this ID.

When thinking about attacks I found the following possible attackers and
their possibilities:

- - Evil node that is selected for storing a descriptor: It knows about
Bob's current activity but cannot decrypt the introduction point
information. However, chances are quite low to be picked as storing
node, so that it's nearly impossible to track Bob's activity all the
time -- or very expensive.

- - Evil node that is not selected for storing a descriptor: As long as it
does not collude with a node that has been selected, it does not know
anything. It cannot even predict which temporary ID Bob has calculated.

- - Evil introduction point: It does not know that it works for Bob. At
least as long as it isn't told by someone.

- - Evil client or former client: She knows everything. Bob needs to trust
his clients, if he wants them to contact him. But at least his clients
cannot publish false descriptors on behalf of Bob. If he distrusts a
client, he needs to change cookie_AB.

&gt; The next step would be fixing it up so knowing the encryption key doesn't
&gt; necessarily mean you can always decrypt things in the future. Rotating
&gt; the encryption key periodically might do it, or we could do something
&gt; more complex.

Why would you want to do that? To exclude some clients? However, this
would require Bob to tell the new encryption key to all of the remaining
clients which can be very expensive.

&gt; But of course, if the rest of the protocol remains the same, then
&gt; the adversary can still enumerate introduction points pretty easily
&gt; by attempting to introduce himself at each Tor server one by one
&gt; using the public onion name. Fixing that starts to make things more
&gt; complicated. Hm.

This should be fixed when using a fresh key pair for each introduction
point, or not?

&gt; When we originally designed this, we had no intention of keeping
&gt; descriptors private. Putting them on the dirservers was just a hack
&gt; because I didn't have anywhere better to put them. But the notion that the
&gt; dirservers give them more "secrecy" has gradually sprung up since then. So
&gt; the question is: so what? What happens if all descriptors are public?

In the face of the above proposal, we should rather discuss what happens
if descriptors are stored here and there on less trustworthy routers
than the directory nodes, but with an encrypted introduction-points
part. The question is whether we are more secure if all responsibility
lies in the hands of a few mostly trustworthy persons or if it is
distributed among a lot of more or less untrustworthy persons...

&gt; First, you can DoS the intro points of a hidden service, even if the
&gt; hidden service hasn't revealed itself to you. [...]

That's possible. But then Bob can simply change his introduction points.

&gt; [...] This is an issue, but if
&gt; you want to enumerate hidden services, you have other options -- a less
&gt; efficient approach would be to run a bunch of stable nodes and hope you
&gt; get picked as an intro point a lot.

Would be solved in the above setting with fresh keys.

&gt; Second, you can visit a hidden service, even if it hasn't revealed itself
&gt; to you. You won't know what ports it supports, but you can portscan the
&gt; whole thing, and besides it's probably just on port 80 anyway. [...]

How can I portscan the hidden service when I don't know its IP?

&gt; [...] Is the
&gt; answer that hidden services that want authorization should implement
&gt; it end-to-end (e.g. http auth) and not try to keep their address itself
&gt; a secret?

Sure, authentication is better than hiding the location. But in the
design above clients can only connect to a hidden service with the
correct key that is stored within the descriptor in encrypted form. This
is a kind of authentication, too.

&gt; What other issues are there if each hidden service descriptor is public?
&gt; Rather than postponing this mail another day while I sleep, I'm going to
&gt; send it and hope other people bring up the other issues. :)

Good question. What else can happen? Let's discuss it before we build it.

All in all, this is the idea. Now pick it to pieces. ;)

- --Karsten
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFGP5q+0M+WPffBEmURAht1AKDGbZayxBmxc0Ifm8R9NaeMJHbMAACgwmKB
1hWgCXgZGtl2zSD5fB3kBu0=
=VA70
-----END PGP SIGNATURE-----
</body></email><email><emailId>20070509122119</emailId><senderName>yousifnet</senderName><senderEmail>yousifnet@gmail.com</senderEmail><timestampReceived>2007-05-09 12:21:19-0400</timestampReceived><subject>comments on the blocking-resistant anonymity system draft</subject><body>

I read the draft paper "design of a blocking-resistant anonymity
system" and I have some comments that I would like to share with you
all.

First, I think a blocking-resistant design is perhaps the most
exciting development in the tor network since hidden-services
especially for those of us living in countries with regimes going to
great lengths to censor and inhibit the internet's power to spread
information. This design would act as a workaround to many
access-blocking vulnerabilities that Tor suffers from such as having a
central point of failure (namely the directory authority servers) or
iterating stable tor servers and blocking access to them.

In regards to section 5.1 on "Bridge relays", from reading the
section, it wasn't clear that bridge relays are basically entry nodes
that publish to a different directory authority in a rather "stealth"
mode. I got the impression that bridge relays were basically
forwarding data to the tor network with no processing involved (i.e.
they are not part of the circuit and act only as a mediator) but this
confusion was cleared when I read your last email to the  or-dev
mailing list and you explicitly stated that bridge relays are
basically entry nodes that publish to a different directory authority.

Also it was mentioned that Tor developers will be encouraging users to
turn bridging on in their Tor software. Instead of encouraging users
to turn bridging on, why doesn't Tor default to enabling it and give
the user the option to turn it off. Doing this will have a tremendous
effect on the number of users running bridges and even ordinary
routing nodes. From how I understood the design of the tor network,
guard nodes are usually servers that are stable and reliable enough to
act as the first point of entry into the network. When users start Tor
and the use of bridges is not enabled, they could announce themselves
automatically as bridges and as soon as they reach enough stability,
they can be moved from the bridge directory authority to the main
directory authority but they would never go back. Since the user-base
is not constant all the time, this would not have any significant
effect on the number of bridges available because they are after all
constantly changing. This would ensure that not only bridge users are
going to benefit from them but the whole tor network. Let me elaborate
on why this behavior should be the default.

Users usually tend not to turn off a feature that would eventually
hurt the network they are using. The less nodes we have, the greater
the chance of congestion to occur. Take popular p2p networks as an
excellent example. The developers turn uploading on by default and the
benefit to the network is greatly emphasized to the user. The result
is that users with uploading enabled outnumber those with special
circumstances that do not permit them to enable uploading. Emphasizing
that the health of the network is a community effort and the
responsibility of the community results in the user feeling morally
inclined to contribute rather than leech off of the network.

Moreover, users usually tend to assume that any option turned off by
the developers requires expert knowledge. Especially applicable to
beginners, they feel uncertain and fearful of the consequences and so
they just leave it off. However, if the option was on the user would
assume that it is safe to leave it on and this is probably true in the
case of bridge relays and perhaps even entry nodes as long as they
don't act as exit nodes. Perhaps the only consequence is bandwidth and
the user can be notified about this in the readme file, help
documents, the manual etc.

In regards to section 5.2 "bridge directory authority", I second your
suggestion that bridge relays should at least try to use port 443 as
ORPort mainly due to the fact that this port is almost guaranteed to
be open in the most restrictive firewall situations.

In regards to section 7.4 "public bridges with central discovery", we
run into the same limitation that the current tor network is suffering
from. For instance, the first, second, and third strategies is limited
to the user's ability to connect to a central directory authority.
Though, if the user managed to connect to the tor networks through a
previously known bridge this limitation would cease to exist. However,
the forth, fifth, and sixth strategies seem not to suffer from this
limitation. I am particularly fond of the mailing list strategy that
requires email addresses from reputable free email providers. Perhaps
an enhancement to this strategy would be to send bridge addresses as
an encrypted file attachment that the user copies to the directory
that has torrc "~/.tor" or "/etc/tor".

In regards to section 7.6 "assessing whether bridges are useful", the
only comment I have on this section is that the requirement for
stability ought to be more lenient than guard nodes mostly because a
more lenient requirement would reduce the chance that an adversary
could find the bridge and block access to it. Secondly, if ordinary
users start running bridges we could certainly leverage the excess
bandwidth/processing power for the tor network. I understand that
stability is needed if we are to provide high quality connections.
Perhaps reaching a compromise between quality and security is the
optimal solution but since users of bridges are already at a greater
risk,  more emphasis ought to be directed towards security

can't wait to see the implementation!

Best,
  Yousif Al Saif
</body></email><email><emailId>20070513174050</emailId><senderName>Karsten Loesing</senderName><senderEmail>karsten.loesing@gmx.net</senderEmail><timestampReceived>2007-05-13 17:40:50-0400</timestampReceived><subject>Proposal: Distributed Storage for Tor Hidden Service Descriptors</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Finally I finished the design for distributing the storage of hidden
service descriptors among the onion routers.

Overview:

The basic idea of this proposal is to distribute the tasks of storing
and serving hidden service descriptors from currently three
authoritative directory nodes among a large subset of all onion routers.
The two reasons to do this are better scalability and improved security
properties. Further, this proposal suggests changes to the hidden
service descriptor format to prevent from new security threads coming
from decentralization and to gain even better security properties.

The full text can be viewed here:

  http://88.84.144.63/114-distributed-storage.txt

For everyone who is interested, please feel free to comment on it!

- --Karsten
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFGR02i0M+WPffBEmURAoXbAJ47QzZBtNFwau8lmj5P3ynHA0XIzACgp3KU
9i3g5U8LPKAYU+8u5zKEO/U=
=McR2
-----END PGP SIGNATURE-----
</body></email><email><emailId>20070523064533</emailId><senderName>Mike Perry</senderName><senderEmail>mikeperry@fscked.org</senderEmail><timestampReceived>2007-05-23 06:45:33-0400</timestampReceived><subject>Re: bw-informer</subject><body>


Thus spake Johannes Renner (hannesrenner@gmx.de):

&gt; 1.  - Search in descriptors for supporting routers (X-tra info) --&gt;
&gt; n routers - Choose one of them randomly (to use as middle node in a
&gt; circuit) - Get its bandwidth-document via Tor - Use the chosen node
&gt; as middle node and select 2 'high-bandwidth-available' links from
&gt; its list, which then define entry and exit (one endpoint must
&gt; support exit). This selection can be done randomly considering a
&gt; subset of the links from the list, having available &gt; x bytes/sec.
&gt; 
&gt; 2.  - Get bandwidth documents from all n supporting routers via Tor
&gt; - Save and merge all of the received information - Find 3 adjacent
&gt; links with available bandwidths in the same class - Put them
&gt; together to a circuit
&gt; 
&gt; 3.  - Just consider (global) MAX and AVG to gain information about
&gt; the current load on the queried router
&gt; 
&gt; 4.  - Any suggestions/ideas?
&gt; 
&gt; Further, if we had an alternate directory, it could gather and merge
&gt; bw-information from every supporting router while trying to prove
&gt; for correctness and even functionality to report lyers could be
&gt; integrated. Another possibility to detect lyers would be to use a
&gt; newly created circuit, measure bandwidth and see if the expected
&gt; results are reached.

As I pointed out in my previous posts,

http://archives.seul.org/or/dev/Apr-2007/msg00031.html
http://archives.seul.org/or/dev/Apr-2007/msg00041.html

I really think you're introducing a lot of problems for liar detection
here. All liars will say that they have super fast connection to their
colluding peers, and slow connections to everyone else, to influence
path selection towards their peers when they are chosen. This can be
very hard to detect if they add arbitrary noise to it. And who's to
say their ISPs don't just have peering agreements with their colluding
peers to begin with?

In addition (and even more importantly), you are leaking a large deal
of information about node activity. Say I'm the adversary, and someone
transfers a whole truckload full of data I don't want out there to
some site I become aware of. I note the time this happened at via that
website's http headers for the data, then go through the logs of the
bandwidth capacities of all the nodes that report this information.
Those nodes will display a spike in traffic during the transmission of
this data to the peers they transfered it to, for about the duration
the data transfer would take. This is very bad, and there's not much
you can do about it once you are reporting data this accurately.

I think you are much better served measuring total capacity of nodes
via a trusted third party and publishing those results. My
speedracer.pl script does this already in conjunction with the
metatroller's statistics engine. Essentially, the script measures the
stream bandwidth throughput through nodes, takes this average, and
then divides the node's current reported bandwidth by this stream
bandwidth. Nodes with a high resulting number have an excessively
large number of connections passing through them, and are either
overloaded or lying about their bandwidth. This is probably the main
cause of slowness on the network (though it is possible
transcontenental voyages and poor peering are another).

If you really want peerwise data, you can extend the information this
3rd party scanner gathers by creating these statistics for node to
node links, but again, be mindful of the fact that there are O(N^2) of
these links on the network: currently 1 million edges to measure and
transfer to clients. That is a lot of data. And the network is
growing...





-- 
Mike Perry
Mad Computer Scientist
fscked.org evil labs

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070523185536</emailId><senderName>Karsten Loesing</senderName><senderEmail>karsten.loesing@gmx.net</senderEmail><timestampReceived>2007-05-23 18:55:36-0400</timestampReceived><subject>Tunneling to directory authorities and mirrors</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Hi,

after some hours of trying and the confirmation of weasel, I realized
that tunneling of connections to directories does not work, yet.
However, I discovered some reasons that could be responsible for that
which I want to share with you. I tried to fix it by myself, but failed
for the moment. Maybe the guy that envisioned the concepts would have an
easier job to fix it -- or tell me about the status of the
implementation, so that I can have another try?

In directory_initiate_command() there is a variable want_to_tunnel that
should be true if the connection should be tunneled over Tor. But it
always evaluates to false, because some expressions on the right side
never evaluate to true:

- - supports_begindir: For which Tor version is this supposed to be true?
Even the current SVN trunk evaluates to false. (This could be on
purpose, because it is really _not_ supported at the moment.)

- - !private_connection: Shouldn't it be the opposite, so that private
connections _are_ tunneled over Tor?

- - or_port: This is always 0, though the directory authority has an open
and functioning OR port. Maybe the value has not been set? On the other
hand, dir_port has been set correctly.

But even overriding want_to_tunnel with 1 for private_connections does
not get it working -- probably because it is not completely implemented.

Any suggestions or implementation status reports are welcome! :)

- --Karsten
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFGVI4o0M+WPffBEmURAgGBAJ9BrMcWWnt1olOtpLYHW5wBwtERhwCgzoly
SONiMevC6fq0XKQiO7V/Jrg=
=2iHV
-----END PGP SIGNATURE-----
</body></email><email><emailId>20070525195313</emailId><senderName>Steven Murdoch</senderName><senderEmail>tor+steven.murdoch@cl.cam.ac.uk</senderEmail><timestampReceived>2007-05-25 19:53:13-0400</timestampReceived><subject>Re: [or-cvs] r10232: Eased up geoip-configuration by introducing a GeoIPConfig-cl (torflow/trunk/Tor</subject><body>


On Mon, May 21, 2007 at 07:32:19AM -0400, Roger Dingledine wrote:
&gt; Also, Steven Murdoch has a follow-on paper at this year's PET, pointing
&gt; out some other issues with the underlying routing between Tor servers,
&gt; but to my knowledge he hasn't posted a draft yet.

The paper, as should appear in the PET pre-proceedings, can be found
here (I just finished this today):

 http://www.cl.cam.ac.uk/~sjm217/papers/pet07ixanalysis.pdf

I'll post a summary to my blog on Monday, and probably mention it on
or-talk too.

Steven.

--=20
w: http://www.cl.cam.ac.uk/users/sjm217/

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070531184709</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-05-31 18:47:09-0400</timestampReceived><subject>Plan: dropping support for v1 directory protocol.</subject><body>


Hi, all!

As you probably know, Tor has had a few different directory protocols
in its lifetime.  The oldest one (the "v1 protocol") was pretty bad:
it took up a lot of bandwidth, and it made every authority into a
single point of failure.  The more recent protocol (the "v2 protocol") has
been fully supported since 0.1.1.8-alpha.

Unfortunately, there are still some tools that use v1 directories, and
there are still some clients (and even a few servers!) running
0.1.0.x.  This is bad for a number of reasons: The 0.1.0.x series has
not been supported for a while.  Tor 0.1.1.x has been stable for more
than a year now, and it has a lot of important security features that
are not supported in 0.1.0.x.  (These are features, not bugfixes, and
they can't be backported without basically replacing 0.1.0.x with
0.1.1.x.)

IMO, we are _not_ doing people a favor by keeping support for 0.1.0.x:
it is insecure, buggy, and old.

Thus, in a few months (say, on 1 August or 1 September), I propose
that we drop support for v1 directories.  The authorities, instead of
generating full v1 directories, will serve empty directories instead,
so that caches will not propagate stale information.  This will make
0.1.0.x clients download empty directories, and fail to build circuits
until their users upgrade to 0.1.1.x.

At the same time, there's another transition to make in directory
information: Check out proposal 104.  We're going to move the fields
"read-history" and "write-history" (which currently are only used by
some tools, and are not used by Tor iteself) into a separate
"extra-info" document that not everybody downloads.  This will cut
down on directory bandwidth, _a lot_, since those fields are very
expensive.

If you are maintaining a tool that uses v1 directories or the
*-history fields, you'll need to switch to use v2 directories and
extra-info documents.  I'll try to ease the transition as much as I
can, possibly by writing a script to cobble the contents of a Tor's
cache into some semblance of a v1 directory.

I'm not proposing this lightly; I really hate dropping support for old
versions.  Nevertheless, I think we need to do this soon: to limit the
bandwidth demands on directory servers; to continue to improve the
network's security; to avoid bloating our code with backward
compatibility hacks indefinitely; and to ensure that users running
ancient insecure software don't get hurt by it.

Please let me know if for some reason August 1 is too late for you; if
you've got compelling reasons, I'll push the date back to September 1.
Please also let me know if I'm being totally insane here.  :)

yrs,
--=20
Nick Mathewson

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070531185713</emailId><senderName>Nick Mathewson</senderName><senderEmail>nickm@freehaven.net</senderEmail><timestampReceived>2007-05-31 18:57:13-0400</timestampReceived><subject>Re: [or-cvs] r10422: Fix patch r10411; fix from robert hogan.  (in tor/trunk: . src/or)</subject><body>


On Thu, May 31, 2007 at 02:53:18PM -0400, Roger Dingledine wrote:
&gt; On Thu, May 31, 2007 at 02:48:31PM -0400, nickm@seul.org wrote:
&gt; &gt;  Fix patch r10411; fix from robert hogan.
&gt; &gt; 
&gt; &gt; Property changes on: tor/trunk
&gt; &gt; ___________________________________________________________________
&gt; &gt;  svk:merge ticket from /tor/trunk [r13103] on 8246c3cf-6607-4228-993b-4d95d33730f1
&gt; &gt; 
&gt; &gt; Modified: tor/trunk/src/or/config.c
&gt; &gt; ===================================================================
&gt; &gt; --- tor/trunk/src/or/config.c	2007-05-31 18:48:28 UTC (rev 10421)
&gt; &gt; +++ tor/trunk/src/or/config.c	2007-05-31 18:48:31 UTC (rev 10422)
&gt; &gt; @@ -2326,7 +2326,7 @@
&gt; &gt;  {
&gt; &gt;    int r;
&gt; &gt;    char buf[1024];
&gt; &gt; -  if (*value == ROUTER_MAX_DECLARED_BANDWIDTH) {
&gt; &gt; +  if (*value &gt; ROUTER_MAX_DECLARED_BANDWIDTH) {
&gt; &gt;      /* This handles an understandable special case where somebody says "2gb"
&gt; &gt;       * whereas our actual maximum is 2gb-1 (INT_MAX) */
&gt; &gt;      --*value;
&gt; 
&gt; Don't we need to fix the --*value part too, or most values will
&gt; end up causing value to exceed our intended cap?

No.  At least, not for what I wanted to do here.

The goal was to make "2gb" (which is easy to type) into an alias for
"2147483647" (2gb-1), which is hard to type, but which is the max
allowed declared bandwidth.  The goal was _not_ to make e.g. 3gb into
an alias for 2gb-1, since exceeding the limit silently was not
something we wanted to allow.

yrs,
-- 
Nick Mathewson

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070531193658</emailId><senderName>Fabian Keil</senderName><senderEmail>freebsd-listen@fabiankeil.de</senderEmail><timestampReceived>2007-05-31 19:36:58-0400</timestampReceived><subject>Re: Proposal: Two Hop Paths</subject><body>


Mike Perry &lt;mikeperry@fscked.org&gt; wrote:

&gt; Title: Two Hop Paths
&gt; Version:
&gt; Last-Modified:
&gt; Author: Mike Perry
&gt; Created:
&gt; Obsoletes: 112
&gt; Status:
&gt; 
&gt; 
&gt; Overview:
&gt; 
&gt;   The idea is that users should be able to choose if they would like
&gt;   to have either two or three hop paths through the tor network.
&gt; 
&gt;   This value should be modifiable from the controller, and should be
&gt;   available from Vidalia.

Did you consider (and reject) making the hop count also changeable
through special host names so HTTP users could change it depending
on the URL, or would that be an anonymity problem?

If different guards would be used for different hop counts,
fingerprinting based on the traffic might be easier for a
MITM between the user and most of the guard nodes, but if
the position of the user is constant, that's already
possible in cases like your [1] and the gathered information
("this Tor user is the same Tor user I saw x days ago") is
probably not too threatening anyway.

Of course this should also only be an issue as long as the
proposed leaky-exit method isn't implemented.

Is that correct or did I miss something?

Fabian

["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20070516175030</emailId><senderName>Johannes Renner</senderName><senderEmail>hannesrenner@gmx.de</senderEmail><timestampReceived>2007-05-16 17:50:30-0400</timestampReceived><subject>bw-informer</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Hello,

I just initially commited the second part of my project, which is a controller for ORs
that is listening to bw and orconn-bw events (needs orconn-bw.patch). While doing this
it counts and adds up all the bytes read and written for each single TLS-connection, as
well as for the complete node. From these an average throughput value for each link and
the whole node gets computed every n seconds (my currently used value is 30 sec).
Additionally a maximum reached value gets stored that can be used to compute an 'estimated
available bandwidth' for each link as well as for the whole node. As a first step this will
be done simply by computing the difference of max and the avg of the last interval:

  available = max-avg

Clients (op-addon.py) can connect to a specified port and request a bandwidth document.
This document should better be served by Tor itself via http on some URL as soon as I
know exactly how to do this technically. The current format of the document is:

AVAILABLE MAX AVG
- --------------------
x available max avg
y available max avg
z available max avg
...

The values in the first line (AVAILABLE, MAX, AVG) are total node's stats computed
from bw-events. After that there is a separator and then a list of stats about the
single TLS-connections is following: In each line the x/y/z is the nickname or idhex
of the endpoint while the values are those computed from orconn-bw events. This list
is sorted by 'available' and it also could be cut off to include only links with at
least n measured bytes/sec available (configurable). A client (op-addon.py), while
searching for links to build up high bandwidth circuits, can read this list and then
compute 'currently estimated available bandwidths' for each link with

  available_x = min(MAX-AVG, max_x-avg_x)

Note that the available-value actually is computed using the other two values, so
clients could also get delivered max and avg only to compute the difference on their
own. But since I plan to use mainly (max_x-avg_x) and (MAX-AVG) I rather think about
_only_ delivering AVAILABLE plus an available for each link.

Clients (op-addon.py) could do route selection based on this in at least three ways:

1.
  - Search in descriptors for supporting routers (X-tra info) --&gt; n routers
  - Choose one of them randomly (to use as middle node in a circuit)
  - Get its bandwidth-document via Tor
  - Use the chosen node as middle node and select 2 'high-bandwidth-available'
    links from its list, which then define entry and exit (one endpoint must
    support exit). This selection can be done randomly considering a subset of
    the links from the list, having available &gt; x bytes/sec.

2.
  - Get bandwidth documents from all n supporting routers via Tor
  - Save and merge all of the received information
  - Find 3 adjacent links with available bandwidths in the same class
  - Put them together to a circuit

3.
  - Just consider (global) MAX and AVG to gain information about the
    current load on the queried router

4.
  - Any suggestions/ideas?

Further, if we had an alternate directory, it could gather and merge bw-information from
every supporting router while trying to prove for correctness and even functionality to
report lyers could be integrated. Another possibility to detect lyers would be to use a
newly created circuit, measure bandwidth and see if the expected results are reached.

What do you think?

Greetings,
Johannes
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFGS0Rm1TFW0/n+aNgRAu4iAKCUVYX8zIZGTMqSls8X6pN4L0kKQQCfVCi4
2kOf8ZkZJ7kZreym8GPfNxA=
=Yw95
-----END PGP SIGNATURE-----
</body></email><email><emailId>20070521113219</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-05-21 11:32:19-0400</timestampReceived><subject>Re: [or-cvs] r10232: Eased up geoip-configuration by introducing a GeoIPConfig-cl (torflow/trunk/Tor</subject><body>

Hi Johannes,

A few thoughts below:

On Sun, May 20, 2007 at 06:20:15PM -0400, renner@seul.org wrote:
&gt; Author: renner
&gt; Date: 2007-05-20 18:20:09 -0400 (Sun, 20 May 2007)
&gt; New Revision: 10232
&gt; 
&gt; Modified:
&gt;    torflow/trunk/TorCtl/GeoIPSupport.py
&gt;    torflow/trunk/TorCtl/PathSupport.py
&gt; Log:
&gt; 
&gt;   Eased up geoip-configuration by introducing a GeoIPConfig-class and added ExcludeCountriesRestriction
&gt;   to exclude a list of countries from route selection.
&gt; 
&gt; 
&gt; 
&gt; Modified: torflow/trunk/TorCtl/GeoIPSupport.py
&gt; ===================================================================
&gt; --- torflow/trunk/TorCtl/GeoIPSupport.py	2007-05-20 20:16:45 UTC (rev 10231)
&gt; +++ torflow/trunk/TorCtl/GeoIPSupport.py	2007-05-20 22:20:09 UTC (rev 10232)
&gt; +# Class to configure GeoIP-based path building
&gt; +class GeoIPConfig:
&gt; +  def __init__(self, unique_countries, src_country, crossings, excludes):    
&gt; +    # Do not use a country twice in a route
&gt; +    self.unique_countries = unique_countries

Make sure you've looked through the routing-zones paper:
http://freehaven.net/anonbib/#feamster:wpes2004

Also, Steven Murdoch has a follow-on paper at this year's PET, pointing
out some other issues with the underlying routing between Tor servers,
but to my knowledge he hasn't posted a draft yet.

More generally, is there a write-up somewhere of what properties we're
aiming to provide, or know we don't provide, etc with respect to this
geolocation stuff?

(It's fine to play around and decide what you want and then write it up
once you have a better intuition of what you want... I'm just asking in
case there is something written up, in which case maybe we should check
it in somewhere. :)

&gt; Modified: torflow/trunk/TorCtl/PathSupport.py
&gt; ===================================================================
&gt; --- torflow/trunk/TorCtl/PathSupport.py	2007-05-20 20:16:45 UTC (rev 10231)
&gt; +++ torflow/trunk/TorCtl/PathSupport.py	2007-05-20 22:20:09 UTC (rev 10232)
&gt;  # Ensure every router to have distinct country
&gt;  class UniqueCountryRestriction(PathRestriction):
&gt;    def r_is_ok(self, path, router):
&gt;      for r in path:
&gt;        if router.country_code == r.country_code:
&gt; +        # Exceptionally allow US because of so many states
&gt; +        if router.country_code == "US": return True	  
&gt;          return False
&gt;      return True

This is an interesting exception. Are you thinking that going through
two difference US states is the same level of jurisdictional arbitrage
as going through two different countries elsewhere? Because in many cases
that's probably not true. We're one big country over here, not a bunch of
different states, despite what you may have read in our constitution. :)

This also brings up the question of how organized various EU countries
are at coordinating and sharing snooping information.

Which leads to the question of what we're actually trying to accomplish
with the UniqueCountryRestriction idea.

Fun stuff,
--Roger

</body></email><email><emailId>20070531185318</emailId><senderName>Roger Dingledine</senderName><senderEmail>arma@mit.edu</senderEmail><timestampReceived>2007-05-31 18:53:18-0400</timestampReceived><subject>Re: [or-cvs] r10422: Fix patch r10411; fix from robert hogan.  (in tor/trunk: . src/or)</subject><body>

On Thu, May 31, 2007 at 02:48:31PM -0400, nickm@seul.org wrote:
&gt;  Fix patch r10411; fix from robert hogan.
&gt; 
&gt; Property changes on: tor/trunk
&gt; ___________________________________________________________________
&gt;  svk:merge ticket from /tor/trunk [r13103] on 8246c3cf-6607-4228-993b-4d95d33730f1
&gt; 
&gt; Modified: tor/trunk/src/or/config.c
&gt; ===================================================================
&gt; --- tor/trunk/src/or/config.c	2007-05-31 18:48:28 UTC (rev 10421)
&gt; +++ tor/trunk/src/or/config.c	2007-05-31 18:48:31 UTC (rev 10422)
&gt; @@ -2326,7 +2326,7 @@
&gt;  {
&gt;    int r;
&gt;    char buf[1024];
&gt; -  if (*value == ROUTER_MAX_DECLARED_BANDWIDTH) {
&gt; +  if (*value &gt; ROUTER_MAX_DECLARED_BANDWIDTH) {
&gt;      /* This handles an understandable special case where somebody says "2gb"
&gt;       * whereas our actual maximum is 2gb-1 (INT_MAX) */
&gt;      --*value;

Don't we need to fix the --*value part too, or most values will
end up causing value to exceed our intended cap?

--Roger

</body></email><email><emailId>20070521164922</emailId><senderName>Johannes Renner</senderName><senderEmail>hannesrenner@gmx.de</senderEmail><timestampReceived>2007-05-21 16:49:22-0400</timestampReceived><subject>Re: [or-cvs] r10232: Eased up geoip-configuration by introducing</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1


Roger Dingledine wrote:
&gt; More generally, is there a write-up somewhere of what properties we're
&gt; aiming to provide, or know we don't provide, etc with respect to this
&gt; geolocation stuff?

No, the first things I implemented were the two security options that are
included in OnionCoffee and based on geoip, that are:

1. Exclude a list of countries, if there are any legal problems
2. Use countries in a unique style to include as many different
   jurisdictions in a single path as possible

The other ideas are from torflow's todo-list.

&gt; Which leads to the question of what we're actually trying to accomplish
&gt; with the UniqueCountryRestriction idea.

As I wrote, the original purpose of this restriction, as it was included in
OnionCoffee as a security configuration option, was simply to include as many
different jurisdictions as possible in one path. This exception was actually
not intended to be comitted, since this of course is not the consistent way
(I will remove it on the next commit).

I included it when I was testing the restriction in conjunction with the
ContinentRestriction (with 1 continent-hop at max) and the src-country
option: When choosing the first hop in my src-country, which is Germany and
second hop randomly was in the US, the third hop had to be in North-America,
but _not_ in the US. So PathBuilder bravely was finding routers for me in
Canada and Mexico, but I thought "Hey, it's ok for me, the US is so big
and there are so many of the routers in the US, give me just one on the
east coast and one on the westcoast...", but if you are sitting in the US
you could then easily end up with US-US-US, which should maybe be avoided?

Anybody any ideas what else to do with geolocation-info?

Greetings,
Johannes
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFGUc2S1TFW0/n+aNgRApwrAJ9coP2v8HF+HHhrBoK+PbE7BFGcYwCeMGmp
g8jB5E3nocvAVReEHDqK+WU=
=fOh8
-----END PGP SIGNATURE-----
</body></email><email><emailId>20070523084112</emailId><senderName>Mike Perry</senderName><senderEmail>mikeperry@fscked.org</senderEmail><timestampReceived>2007-05-23 08:41:12-0400</timestampReceived><subject>Re: [or-cvs] r10232: Eased up geoip-configuration by introducing a GeoIPConfig-cl (torflow/trunk/Tor</subject><body>


Thus spake Roger Dingledine (arma@mit.edu):

&gt; Make sure you've looked through the routing-zones paper:
&gt; http://freehaven.net/anonbib/#feamster:wpes2004
&gt; 
&gt; Also, Steven Murdoch has a follow-on paper at this year's PET, pointing
&gt; out some other issues with the underlying routing between Tor servers,
&gt; but to my knowledge he hasn't posted a draft yet.
&gt; 
&gt; More generally, is there a write-up somewhere of what properties we're
&gt; aiming to provide, or know we don't provide, etc with respect to this
&gt; geolocation stuff?
&gt; 
&gt; (It's fine to play around and decide what you want and then write it up
&gt; once you have a better intuition of what you want... I'm just asking in
&gt; case there is something written up, in which case maybe we should check
&gt; it in somewhere. :)

Yeah, this is mostly where we are. I put the geolocation items in the
TODO with the idea that they would be used for performance, pending
the analysis described in the TODO file to ensure they do not degrade
anonymity overmuch.

I threw down the EchelonPhobicRestrictor as a lark, based on the idea
that since international surveillance is quasi-legal, if Tor clients
were to choose routes such that they did not cross international
boundaries for entry or exit, they would not (legally) be subject to
mass surveillance. The premise is that mass external surveilance of
the node to node connections is acceptable because it is non-trivial
to differentiate individual internal circuits from outside the TLS
link, where as the client to node connection is much more revealing to
an external adversary.

I believe the EchelonPhobicRestrictor is the only restrictor mentioned
in the TODO file with primary goal of improving anonymity, as opposed
to speed. But it may actually help speed too, since low latency
first+last hops make it easier for TCP's congestion windows to grow to
fill the BDP. 

-- 
Mike Perry
Mad Computer Scientist
fscked.org evil labs

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20070516184030</emailId><senderName>Karsten Loesing</senderName><senderEmail>karsten.loesing@gmx.net</senderEmail><timestampReceived>2007-05-16 18:40:30-0400</timestampReceived><subject>Re: bw-informer</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Hi Johannes,

just some early thoughts...

&gt; Further, if we had an alternate directory, it could gather and merge
&gt; bw-information from every supporting router while trying to prove for
&gt; correctness and even functionality to report lyers could be
&gt; integrated. Another possibility to detect lyers would be to use a 
&gt; newly created circuit, measure bandwidth and see if the expected
&gt; results are reached.

The alternative directory, or the usual directory with extended
functionality sounds like the better solution to me. The dissemination
of router information is a task of the directory. Contacting a
"supported" router over Tor and requesting bandwidth information seems
like an unnecessary overhead.

What is that lyer detection about? Who is detecting lyers? And who is
reporting such incidents? Who can you trust? Do you only trust the
directories who do the checks, or can other (non-trusted) nodes report
lyers, too? Maybe you need a clear specification of what you want to do,
because all this trust stuff can become very nasty. But I think that
lyer detection is a vital part of your approach. Or to put it another
way, I could imagine some attacks on an approach that assumes that all
nodes always tell the truth about their bandwidth.

Looks like you have fun! :)

- --Karsten
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFGS1Ae0M+WPffBEmURAmk5AJ412QVsCHBXS4wRaz3QYFKiqTliQwCeK3Xn
hlq1g/qQg+Yxugp4pZ6G89Q=
=Ybpo
-----END PGP SIGNATURE-----
</body></email></emails>