<?xml version="1.0" encoding="utf-8"?>
<emails><email><emailId>20030920171137</emailId><senderName>"tommy"</senderName><senderEmail>tommy.2003@gmx.net</senderEmail><timestampReceived>2003-09-20 17:11:37-0400</timestampReceived><subject>Coding a plugin/module</subject><body>

Hello

I am coding some plugin/module, I have used the source from that IDEA plugin
Unfort. its very big, and I dont understand it all, also there is no documentation
for plugin API...

I need to know how to use the "message own_*" signals properly, I want to
catch users input, modify it, and send it to the person/channel it was meant to.



Thanx alot

bye



</body></email><email><emailId>20031029183956</emailId><senderName>Dario Freni</senderName><senderEmail>saturnero@gufi.org</senderEmail><timestampReceived>2003-10-29 18:39:56-0400</timestampReceived><subject>Hiding channel key from statusbar?</subject><body>


Hi guys,
it seems there is no way to hide a channel key from the statusbar
(without hiding entire statusbar, obviously). I'm not a paranoid, but it
sounds quite annoying when chatting from a public place such as
university... I was asking if it's possible to implement a variable to
toggle the viewing of the key. I never seen irssi's code, with some
advice from you maybe I can write a little patch.

Let me know! :)

Bye and thanks,
Dario

--=20
Dario Freni (saturnero@gufi.org) - SaturNero on IRCNet, Azzurra
Gruppo Utenti FreeBSD Italia (http://www.gufi.org)
GPG Public key at http://www.saturnero.net/saturnero.asc

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20031107064943</emailId><senderName>"Stephen Gill"</senderName><senderEmail>gillsr@yahoo.com</senderEmail><timestampReceived>2003-11-07 06:49:43-0400</timestampReceived><subject>irssi logging and commandline options</subject><body>

Hi All,

I've been using irssi for a while now and enjoy it immensely.  However,
there are a few things I'm trying to work around at the moment which I was
hoping someone could help with with.

1. When I issue certain logging file parameters, IRSSI neglects to log
server data including /who output, server messages, etc.  I like to keep
channel data in it's own file like so:

    autolog_path = "~/irclogs/%Y/$tag/$0.%m-%d.log";

But this keeps me from being able to log data that apparently doesn't fit
into a channel category.  Is this a bug?  Can someone think of 
   A) a better way to accomplish the same task as the above, or 
   B) a way to modify the irssi source code to actually log the server data
to a bogos channel name like: server.%m-%d.log.

2.  I'd like to have the ability to run commands from the CLI after irssi
joins the specified server.  One example is that I want it to autojoin a
channel after I start irssi from the CLI.  I've written a perl module to
load up individual commands from a flat text file so I can do this once I
start up IRSSI, but I'd like to call that script, or at least be able to ask
irssi to join a single channel from the CLI instead.  I'm not entirely sure
where the best place would be to modify the source code to add this
functionality.  

3.  I'm also looking for the ability to set the source hostname and target
hostname on the CLI to change the USER parameters sent across when the
client connects to a server.  I've managed to do this with the source
hostname and some tweaks, since the default -h parameter seems to be
designed more towards choosing an interface to bind to rather than setting
the parameter.  I'd like to do something similar for the destination, though
I don't need to store this in the config file as an added setting.  It's a
one time only thing per connection, where the default "target" should be the
host the client is connecting to.

Thanks in advance for any assistance.

Cheers,
-- steve


</body></email><email><emailId>20031202005956</emailId><senderName>Robbie Vanbrabant</senderName><senderEmail>robbie.vanbrabant@pandora.be</senderEmail><timestampReceived>2003-12-02 00:59:56-0400</timestampReceived><subject>core dump</subject><body>

Hi,


I have a problem with a script I made today. The script works, but when I /quit after using it,
irssi dumps core. I can't find the problem. I am not a Perl programmer (this is one of my first
scripts) so that could be the problem.. but then again, it works nice when used from the cli,
and even works nice in Irssi (except for the core dumping on /quit).
Suggestions are welcome.

thanks.


Robbie.


the script:
-----------
http://users.pandora.be/vanbrabant/robbie/soft/tmeter.pl

actions (the script works but I get a 'core dumped' after /quit):
-----------------------------------------------------------------
irssi
/script load /path/to/tmeter.pl
/tmeter
/quit 

some info:
----------
irssi 0.8.6 (20021117 1611)
This is perl, v5.8.0 built for i686-linux

this is the gdb backtrace:
--------------------------
http://users.pandora.be/vanbrabant/robbie/files/gdb.log

-- 
Robbie Vanbrabant -- &lt;robbie.vanbrabant@pandora.be&gt;
Unix enthousiast. -- http://users.pandora.be/vanbrabant/robbie

</body></email><email><emailId>20031107110431</emailId><senderName>Marcus Rueckert</senderName><senderEmail>darix@web.de</senderEmail><timestampReceived>2003-11-07 11:04:31-0400</timestampReceived><subject>Re: irssi logging and commandline options</subject><body>

On 2003-11-07 00:49:43 -0600, Stephen Gill wrote:
&gt; 1. When I issue certain logging file parameters, IRSSI neglects to log
&gt; server data including /who output, server messages, etc.  I like to keep
&gt; channel data in it's own file like so:
&gt; 
&gt;     autolog_path = "~/irclogs/%Y/$tag/$0.%m-%d.log";
&gt; 
&gt; But this keeps me from being able to log data that apparently doesn't fit
&gt; into a channel category.  Is this a bug?  Can someone think of 
&gt;    A) a better way to accomplish the same task as the above, or 
&gt;    B) a way to modify the irssi source code to actually log the server data
&gt; to a bogos channel name like: server.%m-%d.log.

did you check this setting?
11:55:13 autolog_level = all -crap -clientcrap -ctcps

i have to check at the weekend about logging of the server stuff.
 
&gt; 2.  I'd like to have the ability to run commands from the CLI after irssi
&gt; joins the specified server.  One example is that I want it to autojoin a
&gt; channel after I start irssi from the CLI.  I've written a perl module to
&gt; load up individual commands from a flat text file so I can do this once I
&gt; start up IRSSI, but I'd like to call that script, or at least be able to ask
&gt; irssi to join a single channel from the CLI instead.  I'm not entirely sure
&gt; where the best place would be to modify the source code to add this
&gt; functionality.  

"/ircnet add -autosendcmd"
"/help ircnet" for more.
you can run multiple commmands there. e.g.:
'/ircnet add -autosendcmd "squery noteserv login darix myleetpw; query noteserv notify" IRCnet'

for autojoin use "/channel add -auto". e.g.:
'/channel add -auto #foobar IRCnet myleetchannelkey'

about your perl module: there is already file.pl from dg (you can find
it via http://scripts.irssi.org/)
 
&gt; 3.  I'm also looking for the ability to set the source hostname and target
&gt; hostname on the CLI to change the USER parameters sent across when the
&gt; client connects to a server.  I've managed to do this with the source
&gt; hostname and some tweaks, since the default -h parameter seems to be
&gt; designed more towards choosing an interface to bind to rather than setting
&gt; the parameter.  I'd like to do something similar for the destination, though
&gt; I don't need to store this in the config file as an added setting.  It's a
&gt; one time only thing per connection, where the default "target" should be the
&gt; host the client is connecting to.

why do you want to patch irssi all the time? :)

'/ircnet add -hostname foo.bar.org -nick foobar -realname "foo bar!" IRCnet'

isnt this sufficient enough?:)
&gt; 
&gt; Thanks in advance for any assistance.

no problem.

darix

-- 
irssi - the client of the smart and beautiful people

              http://www.irssi.de/


</body></email><email><emailId>20031107141832</emailId><senderName>Stephen Gill</senderName><senderEmail>gillsr@yahoo.com</senderEmail><timestampReceived>2003-11-07 14:18:32-0400</timestampReceived><subject>Re: irssi logging and commandline options</subject><body>

Hi Marc,

&gt; did you check this setting?
&gt; 11:55:13 autolog_level = all -crap -clientcrap -ctcps

Yep, I've already tried.  Doesn't work :|.

&gt; "/ircnet add -autosendcmd"
&gt; "/help ircnet" for more.
&gt; you can run multiple commmands there. e.g.:
&gt; '/ircnet add -autosendcmd "squery noteserv login darix myleetpw;
&gt; query noteserv notify" IRCnet'

I connect to _several_ different servers and I want to run the same
copy and same config file for IRSSI. This doesn't work for me because I
want to have this done from the CLI.  

&gt; 
&gt; for autojoin use "/channel add -auto". e.g.:
&gt; '/channel add -auto #foobar IRCnet myleetchannelkey'

This doesn't scale for me... I need an option that I can call from the
CLI or some other convenient way.

&gt; '/ircnet add -hostname foo.bar.org -nick foobar -realname "foo bar!"
&gt; IRCnet'
&gt; 
&gt; isnt this sufficient enough?:)

I dont think you understood the request... I don't want to change the
target itself, only the source host and dest host send across in the
USER line when connecting to IRC.  I don't need this stored in the
config - I want to change it dynamically via the CLI.

Thanks for the initial feedback!
-- steve

__________________________________
Do you Yahoo!?
Protect your identity with Yahoo! Mail AddressGuard
http://antispam.yahoo.com/whatsnewfree

</body></email><email><emailId>20031107153408</emailId><senderName>Marcus Rueckert</senderName><senderEmail>darix@web.de</senderEmail><timestampReceived>2003-11-07 15:34:08-0400</timestampReceived><subject>Re: irssi logging and commandline options</subject><body>

On 2003-11-07 06:18:32 -0800, Stephen Gill wrote:
&gt; &gt; 11:55:13 autolog_level = all -crap -clientcrap -ctcps
&gt; 
&gt; Yep, I've already tried.  Doesn't work :|.

of course not. remove the "-crap -clientcrap" from the line.
 
&gt; I connect to _several_ different servers and I want to run the same
&gt; copy and same config file for IRSSI. This doesn't work for me because I
&gt; want to have this done from the CLI.  

just to make that sure. you run x copies of irssi parallel? and connect
to different ircnets?
 
&gt; &gt; for autojoin use "/channel add -auto". e.g.:
&gt; &gt; '/channel add -auto #foobar IRCnet myleetchannelkey'
&gt; 
&gt; This doesn't scale for me... I need an option that I can call from the
&gt; CLI or some other convenient way.

hm? explain please!

&gt; I dont think you understood the request... I don't want to change the
&gt; target itself, only the source host and dest host send across in the
&gt; USER line when connecting to IRC.  I don't need this stored in the
&gt; config - I want to change it dynamically via the CLI.

-h/--hostname on the cmdline/as parameter change your local source host.
e.g.

you have 2 interfaces
192.168.0.1
192.168.0.2

now you can run irssi with
irssi -h 192.168.0.1 -c irc.yourserver.com -n foobar

and a second connect with
irssi -h 192.168.0.2 -c irc.otherserver.com -n barfoo

for the autorun stuff. i dont think you can do that from the cmdline.
but inside irssi it would work quite fine:

/ircnet add -autosendcmd "msg devel praise you; msg god you suck" yours
/ircnet add -autosendcmd "msg mom im back; msg dad back to the front" others

/server add -ircnet yours irc.yourserver.com
/server add -ircnet others irc.otherserver.com

/channel add -auto #hell yours
/channel add -auto #home others

if you now run irssi with the 2 command lines from above, it will run
the autosend cmds for each network.

of course you can use file.pl to use a longer list of commands.

/ircnet add -autosendcmds "file -raw thisnet.txt" thisnet


just my pi cents

darix 


-- 
irssi - the client of the smart and beautiful people

              http://www.irssi.de/


</body></email><email><emailId>20031029200003</emailId><senderName>Jochen Eisinger</senderName><senderEmail>jochen@penguin-breeder.org</senderEmail><timestampReceived>2003-10-29 20:00:03-0400</timestampReceived><subject>Re: Hiding channel key from statusbar?</subject><body>

Hi,

attached a patch that gives you a setting chanmode_verbose (defaults to
ON). if you set it to OFF everything from the first " " will be cut of
the channel mode, like

 +knls 1234 key -&gt; +knls

maybe you need to repaint the window (either switch it or press ^L)

Telling ppl to piss off when they become noisy is the other solution...
http://bash.org/?8814

regards
-- jochen (aka c0ffee)

Dario Freni wrote:
&gt; Hi guys,
&gt; it seems there is no way to hide a channel key from the statusbar
&gt; (without hiding entire statusbar, obviously). I'm not a paranoid, but it
&gt; sounds quite annoying when chatting from a public place such as
&gt; university... I was asking if it's possible to implement a variable to
&gt; toggle the viewing of the key. I never seen irssi's code, with some
&gt; advice from you maybe I can write a little patch.
&gt; 
&gt; Let me know! :)
&gt; 
&gt; Bye and thanks,
&gt; Dario
&gt; 

["src.core.expandos.c.orig" (text/plain)]

--- ./src/core/expandos.c.orig	2003-10-29 19:48:12.000000000 +0100
+++ ./src/core/expandos.c	2003-10-29 19:52:09.000000000 +0100
@@ -333,8 +333,23 @@
 
 /* modes of current channel, if any */
 static char *expando_chanmode(SERVER_REC *server, void *item, int *free_ret)
-{
-	return !IS_CHANNEL(item) ? NULL : CHANNEL(item)-&gt;mode;
+{ 
+	char *cmode;
+
+	*free_ret = FALSE;
+
+	if (!IS_CHANNEL(item))
+		return NULL;
+
+        if (settings_get_bool("chanmode_verbose"))
+		return CHANNEL(item)-&gt;mode;
+
+	*free_ret = TRUE;
+	cmode = g_strdup(CHANNEL(item)-&gt;mode);
+	if (strchr(cmode, ' ') != NULL)
+		*(strchr(cmode, ' ')) = 0;
+
+	return cmode;
 }
 
 /* current nickname */
@@ -559,6 +574,7 @@
 #endif
 	settings_add_str("misc", "STATUS_OPER", "*");
 	settings_add_str("lookandfeel", "timestamp_format", "%H:%M");
+	settings_add_bool("lookandfeel", "chanmode_verbose", TRUE);
 
 	client_start_time = time(NULL);
 	last_sent_msg = NULL; last_sent_msg_body = NULL;


</body></email><email><emailId>20031029201219</emailId><senderName>Jochen Eisinger</senderName><senderEmail>jochen@penguin-breeder.org</senderEmail><timestampReceived>2003-10-29 20:12:19-0400</timestampReceived><subject>Re: Hiding channel key from statusbar?</subject><body>

Jochen Eisinger wrote:
&gt; Telling ppl to piss off when they become noisy is the other solution...
&gt; http://bash.org/?8814
I meant "nosy"

regards
-- jochen


</body></email><email><emailId>20031030050534</emailId><senderName>Marcus Rueckert</senderName><senderEmail>darix@web.de</senderEmail><timestampReceived>2003-10-30 05:05:34-0400</timestampReceived><subject>Re: Hiding channel key from statusbar?</subject><body>

On 2003-10-29 19:39:56 +0100, Dario Freni wrote:
&gt; it seems there is no way to hide a channel key from the statusbar
&gt; (without hiding entire statusbar, obviously). I'm not a paranoid, but it
&gt; sounds quite annoying when chatting from a public place such as
&gt; university... I was asking if it's possible to implement a variable to
&gt; toggle the viewing of the key. I never seen irssi's code, with some
&gt; advice from you maybe I can write a little patch.

file:
	~/.irssi/config
section:
	statusbar -&gt; items 
find:
	window = "{sb $winref:$itemname{sbmode $M}}";
replace with:
	window = "{sb $winref:$itemname}";

and /reload after changing it with an text editor.


to easily change them you can make 2 items:

windowmode = "{sb $winref:$itemname{sbmode $M}}";

window = "{sb $winref:$itemname}";

and 2 aliases

disable mode item:
/alias dmi statusbar window remove windowmode; statusbar window add -before window_empty window 

enable mode item:
/alias emi statusbar window remove window; statusbar windowmode add -before window_empty window 

hope this helps

darix

p.s.: all untested. ;) but should work. :)

-- 
irssi - the client of the smart and beautiful people

              http://www.irssi.de/


</body></email><email><emailId>20031030083250</emailId><senderName>Athanasius</senderName><senderEmail>irssi@miggy.org</senderEmail><timestampReceived>2003-10-30 08:32:50-0400</timestampReceived><subject>Re: Hiding channel key from statusbar?</subject><body>


On Thu, Oct 30, 2003 at 06:05:34AM +0100, Marcus Rueckert wrote:
&gt; On 2003-10-29 19:39:56 +0100, Dario Freni wrote:
&gt; &gt; it seems there is no way to hide a channel key from the statusbar
                                ^^^^^^^^^^^^^^^^^^
&gt; &gt; (without hiding entire statusbar, obviously). I'm not a paranoid, but it
&gt; find:
&gt; 	window = "{sb $winref:$itemname{sbmode $M}}";
&gt; replace with:
&gt; 	window = "{sb $winref:$itemname}";

  Whilst this will indeed hide the channel key, as it's part of the
channel modes, it's going to be hiding *ALL* the modes, correct ?  It
would be nice if things were changed so $M gave just the +ABCDE stuff,
probably including the limit if set, but there had to be a seperate
identifier for the key.

-Ath
-- 
- Athanasius = Athanasius(at)miggy.org / http://www.miggy.org/
                  Finger athan(at)fysh.org for PGP key
	   "And it's me who is my enemy. Me who beats me up.
Me who makes the monsters. Me who strips my confidence." Paula Cole - ME

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20031030091645</emailId><senderName>Dario Freni</senderName><senderEmail>saturnero@gufi.org</senderEmail><timestampReceived>2003-10-30 09:16:45-0400</timestampReceived><subject>Re: Hiding channel key from statusbar?</subject><body>


(sorry Athanasius, damned automatic reply)

On Thu, 2003-10-30 at 09:32, Athanasius wrote:
&gt;   Whilst this will indeed hide the channel key, as it's part of the
&gt; channel modes, it's going to be hiding *ALL* the modes, correct ?  It
&gt; would be nice if things were changed so $M gave just the +ABCDE stuff,
&gt; probably including the limit if set, but there had to be a seperate
&gt; identifier for the key.

Yes, it would be better. AFAIK, the only channel modes (except +e,+I,+b
...) with arguments are limit and key. There could be an identifier for
channel modes' arguments, or two separate for limit and key.

Bye and thank you all again,
Dario

--=20
Dario Freni (saturnero@gufi.org) - SaturNero on IRCNet, Azzurra
Gruppo Utenti FreeBSD Italia (http://www.gufi.org)
GPG Public key at http://www.saturnero.net/saturnero.asc

["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20031030095505</emailId><senderName>Jochen Eisinger</senderName><senderEmail>jochen@penguin-breeder.org</senderEmail><timestampReceived>2003-10-30 09:55:05-0400</timestampReceived><subject>Re: Hiding channel key from statusbar?</subject><body>

Hi,

irssi is a chat client, not an IRCNet client. There are chat networks
featuring other modes with arguments.

Having two expandos isn't a good idea, because a) a very basic data
structure (CHANNEL_REC) would need to be modified, b) tons of places in
different chat network modules need to be modified.

regards
-- jochen


</body></email><email><emailId>20031202161035</emailId><senderName>Joost Vunderink</senderName><senderEmail>joost@carnique.nl</senderEmail><timestampReceived>2003-12-02 16:10:35-0400</timestampReceived><subject>Re: core dump</subject><body>

Robbie Vanbrabant wrote:

&gt; I have a problem with a script I made today. The script works, but when I /quit after using it,
&gt; irssi dumps core.

This probably has to do with a combination of using modules and irssi's not cleaning up
entirely properly.

&gt; http://users.pandora.be/vanbrabant/robbie/soft/tmeter.pl

use LWP::UserAgent;
use HTTP::Cookies;

It's probably one of these causing the core dump.
I had the same problem when I put the line "use Storable;" in a script. As soon as that module
was used, irssi would segfault on quit.

&gt; http://users.pandora.be/vanbrabant/robbie/files/gdb.log

From your trace I see it crashes in scripts_deinit which indicates the same thing I had.
So, patch irssi, or live with it :)

Regards,
Joost.

-- 
Joost Vunderink - http://www.garion.org/
A: Because it messes up the order in which people normally read text.
Q: Why is top-posting such a bad thing?
A: Top-posting.
Q: What is the most annoying thing on usenet and in email?

</body></email><email><emailId>20031204154851</emailId><senderName>Jean-Yves Lefort</senderName><senderEmail>jylefort@brutele.be</senderEmail><timestampReceived>2003-12-04 15:48:51-0400</timestampReceived><subject>formats+UTF-8 patch</subject><body>

[Attachment #2 (multipart/mixed)]


Hi all,

The attached patch adds UTF-8 support to format_get_length() and
format_real_length().

It's needed to, amongst others, properly compute the prompt length when
the channel name is encoded in UTF-8.

Greetings,
Jean-Yves Lefort

--=20
Jean-Yves Lefort

jylefort@brutele.be
http://lefort.be.eu.org/

["irssi-0.8.8-utf8-formats.diff" (irssi-0.8.8-utf8-formats.diff)]

--- src/fe-common/core/formats.c.orig	Thu Dec  4 16:02:48 2003
+++ src/fe-common/core/formats.c	Thu Dec  4 16:36:52 2003
@@ -297,14 +297,44 @@
 		window_find_closest(server, target, level);
 }
 
+static gboolean term_is_utf8 (void)
+{
+  const char *charset;
+  
+  charset = settings_get_str("term_type");
+  if (*charset)
+    return ! g_strcasecmp(charset, "utf-8");
+
+  return g_get_charset(&amp;charset);
+}
+
+static int advance (char const **str, gboolean utf8)
+{
+	if (utf8) {
+		gunichar c;
+      
+		c = g_utf8_get_char(*str);
+		*str = g_utf8_next_char(*str);
+
+		return g_unichar_iswide(c) ? 2 : 1;
+	} else {
+		*str += 1;
+
+		return 1;
+	}
+}
+
 /* Return length of text part in string (ie. without % codes) */
 int format_get_length(const char *str)
 {
         GString *tmp;
 	int len;
+	gboolean utf8;
 
         g_return_val_if_fail(str != NULL, 0);
 
+	utf8 = term_is_utf8() &amp;&amp; g_utf8_validate(str, -1, NULL);
+
         tmp = g_string_new(NULL);
 	len = 0;
 	while (*str != '\0') {
@@ -321,8 +351,7 @@
 				len++;
 		}
 
-                len++;
-		str++;
+		len += advance(&amp;str, utf8);
 	}
 
 	g_string_free(tmp, TRUE);
@@ -336,10 +365,13 @@
 {
 	GString *tmp;
 	const char *start;
+	gboolean utf8;
 
         g_return_val_if_fail(str != NULL, 0);
         g_return_val_if_fail(len &gt;= 0, 0);
 
+	utf8 = term_is_utf8() &amp;&amp; g_utf8_validate(str, -1, NULL);
+
         start = str;
         tmp = g_string_new(NULL);
 	while (*str != '\0' &amp;&amp; len &gt; 0) {
@@ -358,8 +390,7 @@
 			}
 		}
 
-                len--;
-		str++;
+		len -= advance(&amp;str, utf8);
 	}
 
 	g_string_free(tmp, TRUE);

["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20031217192701</emailId><senderName>Valentin Batz</senderName><senderEmail>vb@g-23.org</senderEmail><timestampReceived>2003-12-17 19:27:01-0400</timestampReceived><subject>proxy fix</subject><body>

Hi all,

I found a bug in my own patch,
that i submitted some time ago.
The proxy forgets about ctcp forwarding
if the server disconnects the proxy
and the proxy reconnects to it again.

patch included.

Greetings

Valentin Batz
(senneth on IRCnet)



["proxy_ctcp_forwarding_loss_fix.diff" (application/octet-stream)]

--- src/irc/proxy/listen.c.org	2003-12-17 20:20:04.000000000 +0100
+++ src/irc/proxy/listen.c	2003-12-17 20:20:33.000000000 +0100
@@ -457,7 +457,6 @@
 			proxy_outdata(rec, ":%s NOTICE %s :Connected to server\n",
 				      rec-&gt;proxy_address, rec-&gt;nick);
 			rec-&gt;server = server;
-			rec-&gt;want_ctcp = 0;
 			proxy_client_reset_nick(rec);
 		}
 	}


</body></email><email><emailId>20031107155819</emailId><senderName>"Stephen Gill"</senderName><senderEmail>gillsr@yahoo.com</senderEmail><timestampReceived>2003-11-07 15:58:19-0400</timestampReceived><subject>RE: irssi logging and commandline options</subject><body>

Hi Marcus,

] of course not. remove the "-crap -clientcrap" from the line.

You're right... the setting shouldn't have been set to that.  I've tried it
both ways to no avail.  Have you had any success with that?  I've already
tried it and it doesn't work (with the autolog setting that I mentioned).

] just to make that sure. you run x copies of irssi parallel? and connect
] to different ircnets?

That's correct.  I have too many servers so I don't want the management
hassle of an IRCNet (when using several servers within one client) or loads
of config files (when using a different copy for different servers).  That's
why a CLI parameter to do this would be very nice.  In any case... I have my
reasons, I just want to know how it can be done :).

Having to manage autojoins is too much hassle.  All I need is something
simple that I can call from the CLI.  I don't mind coding it, I just thought
someone might have a good pointer into where it should be done.  I've looked
through the code a fair bit and can't find an easy way of tying in the CLI
arguments to an autojoin/autoexecute on the server I called from the CLI.
Autoexecute would be preferred, but I'd settle for an autojoin at this
point.

] -h/--hostname on the cmdline/as parameter change your local source host.
] e.g.

Yes, but this doesn't actually do what it sounds like.  If you issue the -h
command it doesn't change the line that the IRC client sends when it
connects to a server.  The USER &lt;USER&gt; &lt;SOURCE&gt; &lt;DEST&gt; :&lt;REAL&gt; line does not
appear to be affected.  I want to affect the &lt;SOURCE&gt; and &lt;DEST&gt; parameters
form the CLI.  I've already coded the &lt;SOURCE&gt; with some hacks, but the
&lt;DEST&gt; is a bit more of a pain...  just looking for pointers here.

] /ircnet add -autosendcmd "msg devel praise you; msg god you suck" yours
] /ircnet add -autosendcmd "msg mom im back; msg dad back to the front"
others

] /server add -ircnet yours irc.yourserver.com
] /server add -ircnet others irc.otherserver.com

] /channel add -auto #hell yours
] /channel add -auto #home others

I'm looking for a convenient way of doing this from the CLI.  Having to
manage this will take more time than it's worth unfortunately in a dynamic
environment.  The reasons are there, I just need a way to accomplish this in
an easier fashion.

Cheers,
-- steve


</body></email><email><emailId>20031121114323</emailId><senderName>"Snowy Angelique Maslov aka 'Snowpony'"</senderName><senderEmail>snowy@snowy.org</senderEmail><timestampReceived>2003-11-21 11:43:23-0400</timestampReceived><subject>Patch for Enhancements to BNC/Bouncer proxy code</subject><body>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Hi All,
  This is a quick patch against 0.8.6.CVS which adds the following support to
the proxy_string and proxy_string_after settings.  It removed the %s %d
requirement and instead adds the following labels for use in generating a
proxy string:

  %ADDRESS%  - Server Address
  %PORT%     - Server Port
  %PASSWORD% - Server Password
  %USERNAME% - Connection user name.
  %VHOST%    - Special:  If user name is specified as &lt;user&gt;@&lt;vhost&gt; then
               %USERNAME% will be set to &lt;user&gt; and %VHOST% will be set to 
               &lt;vhost&gt;

  An example string_proxy_after for a BNC proxy would be:
  "VIP %VHOST%\nIDENT %USERNAME%\nCONN %ADDRESS% %PORT% %PASSWORD%"

  Any or all the labels can be left out as needed.


This patch is pretty crude, mainly because I got annoyed with the settings 
today so through it together but figured there may be some interest in it.  
It's only been tested again a BNC proxy at the moment.  Comments appreciated.

- -- 
Snowy "Snowpony" Angelique Cerise Maslov -- http://snowy.org/email.signature
PGP (GnuPG) fingerprint = 5280 6EBC D281 A9D2 564B  E274 B2EC 54C3 8325 CECD
Email not addressed/CCd to snowy@snowy.org BOUNCE.  READ URL for disclaimer!
   "Ignorance killed the cat, sir. Curiosity was framed." ---C.J. Cherryh
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.2.1 (GNU/Linux)
Comment: For info see http://quantumlab.net/pine_privacy_guard/

iD8DBQE/vfpbsuxUw4Mlzs0RAhuLAKCAQ8CzJUW14vrOLOc3kI7SISCseQCffAjs
x78tL82J7IsRy9OMuOTTJpE=
=g3TF
-----END PGP SIGNATURE-----

["irssi.proxy.patch" (TEXT/PLAIN)]

diff -ur irssi-0.8.6.CVS/src/core/servers-setup.c \
                irssi-snowy/src/core/servers-setup.c
--- irssi-0.8.6.CVS/src/core/servers-setup.c	2002-08-27 09:00:07.000000000 +1000
+++ irssi-snowy/src/core/servers-setup.c	2003-11-21 21:23:41.000000000 +1000
@@ -520,8 +520,8 @@
 	settings_add_bool("proxy", "use_proxy", FALSE);
 	settings_add_str("proxy", "proxy_address", "");
 	settings_add_int("proxy", "proxy_port", 6667);
-	settings_add_str("proxy", "proxy_string", "CONNECT %s %d");
-	settings_add_str("proxy", "proxy_string_after", "");
+	settings_add_str("proxy", "proxy_string", "");
+	settings_add_str("proxy", "proxy_string_after", "VIP %VHOST%\nIDENT \
%USERNAME%\nCONN %ADDRESS% %PORT% %PASSWORD%");  settings_add_str("proxy", \
"proxy_password", "");  
         setupservers = NULL;
diff -ur irssi-0.8.6.CVS/src/irc/core/irc-servers.c \
                irssi-snowy/src/irc/core/irc-servers.c
--- irssi-0.8.6.CVS/src/irc/core/irc-servers.c	2003-06-26 05:45:02.000000000 +1000
+++ irssi-snowy/src/irc/core/irc-servers.c	2003-11-21 18:15:08.000000000 +1000
@@ -40,6 +40,8 @@
 
 #include "settings.h"
 
+#include &lt;string.h&gt;
+
 #define DEFAULT_MAX_KICKS 1
 #define DEFAULT_MAX_MODES 3
 #define DEFAULT_MAX_WHOIS 4
@@ -95,10 +97,118 @@
 	g_free(str);
 }
 
+int replace_string(char *source, char *dest, char *search, char *replace)
+{
+    char *position; // Current position
+    char *occurances; // Position of next Occurance in search
+    int number = 0; // Number of Occurances replaced
+
+    // Validity Check on input, hopefully we really are pointing to
+    // something otherwise we are going to SEGV badly ;)
+    if (!source || !dest || !search || !replace) {
+        return -1;
+    }
+    // Clear the destination buffer
+    dest[0] = '\0';
+    // Start from the beginning
+    position = source;
+    // Find the first occurance of search
+    occurances = strstr(position, search);
+    // Loop through all instances in source
+    while (occurances) {
+        // Copy the text preceeding the current occurance or search
+        strncat(dest, position, occurances - position);
+        // Append replace to the end of the destination buffer
+        strcat(dest, replace); 
+        // Increase the starting point so we don't find the same occurance over
+        // and over again
+        position = occurances + strlen(search);
+        // Find the next occurance if it exists
+        occurances = strstr(position, search);
+        // Increment the occurance count
+        number++;
+     }
+
+     // finally append anything after the last occurance to the destination buffer
+     strcat(dest, position);
+     // return the occurance count
+     return number;
+}
+
+int make_proxy_string(IRC_SERVER_CONNECT_REC *conn, char *string) {
+    // This is ugly - probably should dynamically allocate this
+    // stuff.  Then again sending more than 1k on a proxy_string
+    // would probably be overkill anyways.
+    char value[101];    // 100 + NULL
+    char temp[101];     // 100 + NULL
+    char input[1025];   // 1024 + NULL
+    char output[1025];  // 1024 + NULL
+    char *pointer;
+    int sz;
+
+    // Let's make sure we have some parameters at least
+    if(!string || !conn) {
+        return -1;
+    }
+
+    // Make sure everything is reset to defaults.
+    value[0] = '\0';
+    temp[0] = '\0';
+    input[0] = '\0';
+    output[0] = '\0';
+    pointer = (char *) NULL;
+    sz = 0;
+
+    // Initialise Input
+    strncpy(&amp;input[0],string,1024);
+                                                                    
+    // Search and Replace : Server Address
+    snprintf(&amp;value[0],100,"%%ADDRESS%%");
+    replace_string(&amp;input[0],&amp;output[0],&amp;value[0],conn-&gt;address);
+    strncpy(&amp;input[0],&amp;output[0],1024);
+                                                                                     \
 +    // Search and Replace : Server Port
+    snprintf(&amp;value[0],100,"%%PORT%%");
+    snprintf(&amp;temp[0],100,"%i",conn-&gt;port);
+    replace_string(&amp;input[0],&amp;output[0],&amp;value[0],&amp;temp[0]);
+    strncpy(&amp;input[0],&amp;output[0],1024);
+
+    // Search and Replace : Server Password
+    snprintf(&amp;value[0],100,"%%PASSWORD%%");
+    replace_string(&amp;input[0],&amp;output[0],&amp;value[0],conn-&gt;password);
+    strncpy(&amp;input[0],&amp;output[0],1024);
+                                                                                     \
 +    // Search and Replace : Username (special case)
+    if(!strstr(conn-&gt;username,"@")) {
+        snprintf(&amp;value[0],100,"%%USERNAME%%");
+        replace_string(&amp;input[0],&amp;output[0],&amp;value[0],conn-&gt;username);
+        strncpy(&amp;input[0],&amp;output[0],1024);
+    }
+    else {
+        pointer = strstr(conn-&gt;username,"@");
+        sz = strlen(conn-&gt;username) - strlen(pointer);
+        if(sz &gt; 100) {
+            sz=100;
+        }
+        strncpy(&amp;temp[0],conn-&gt;username,sz);
+        snprintf(&amp;value[0],100,"%%USERNAME%%");
+        replace_string(&amp;input[0],&amp;output[0],&amp;value[0],&amp;temp[0]);
+        strncpy(&amp;input[0],&amp;output[0],1024);
+        strncpy(&amp;temp[0],++pointer,100);
+        snprintf(&amp;value[0],100,"%%VHOST%%");
+        replace_string(&amp;input[0],&amp;output[0],&amp;value[0],&amp;temp[0]);
+        strncpy(&amp;input[0],&amp;output[0],1024);
+    }
+    // Copy result out.
+    strncpy(string,&amp;output[0],1024);
+    return 0;
+}
+
 static void server_init(IRC_SERVER_REC *server)
 {
 	IRC_SERVER_CONNECT_REC *conn;
 	char hostname[100], *address, *ptr, *username;
+    char finalstring[1025];
 
 	g_return_if_fail(server != NULL);
 
@@ -108,9 +218,11 @@
 	    *conn-&gt;proxy_password != '\0')
 		irc_send_cmdv(server, "PASS %s", conn-&gt;proxy_password);
 
-	if (conn-&gt;proxy != NULL &amp;&amp; conn-&gt;proxy_string != NULL)
-		irc_send_cmdv(server, conn-&gt;proxy_string, conn-&gt;address, conn-&gt;port);
-
+	if (conn-&gt;proxy != NULL &amp;&amp; conn-&gt;proxy_string != NULL) {
+        snprintf(&amp;finalstring[0],1024,"%s",conn-&gt;proxy_string);
+        make_proxy_string(conn,&amp;finalstring[0]);
+		irc_send_cmdv(server, &amp;finalstring[0]);
+    };
 	if (conn-&gt;password != NULL &amp;&amp; *conn-&gt;password != '\0') {
                 /* send password */
 		server-&gt;cmdcount = 0;
@@ -153,8 +265,9 @@
 	server-&gt;cmdcount = 0;
 
 	if (conn-&gt;proxy != NULL &amp;&amp; conn-&gt;proxy_string_after != NULL) {
-		irc_send_cmdv(server, conn-&gt;proxy_string_after,
-			      conn-&gt;address, conn-&gt;port);
+        snprintf(&amp;finalstring[0],1024,"%s",conn-&gt;proxy_string_after);
+        make_proxy_string(conn,&amp;finalstring[0]);
+		irc_send_cmdv(server, &amp;finalstring[0]);
 	}
 
 	server-&gt;cmdcount = 0;
diff -ur irssi-0.8.6.CVS/src/irc/core/irc-servers.h \
                irssi-snowy/src/irc/core/irc-servers.h
--- irssi-0.8.6.CVS/src/irc/core/irc-servers.h	2002-10-10 12:00:03.000000000 +1000
+++ irssi-snowy/src/irc/core/irc-servers.h	2003-11-21 16:07:29.000000000 +1000
@@ -108,6 +108,9 @@
    like "#a,#b,#c,#d x,b_chan_key,x,x" or just "#e,#f,#g" */
 char *irc_server_get_channels(IRC_SERVER_REC *server);
 
+/* String Replace for Proxy String */
+int replace_string(char *source, char *dest, char *search, char *replace);
+
 /* INTERNAL: */
 void irc_server_send_data(IRC_SERVER_REC *server, const char *data, int len);
 



</body></email><email><emailId>20031130192110</emailId><senderName>Joost Vunderink</senderName><senderEmail>joost@carnique.nl</senderEmail><timestampReceived>2003-11-30 19:21:10-0400</timestampReceived><subject>wiki irssi documentation project</subject><body>

Hi all,

a wiki has been "opened" for irssi documentation.
It can be found on http://wiki.irssi.org/

Enjoy wikiing :)

Joost / Garion and Wouter / coekie.

-- 
Joost Vunderink - http://www.garion.org/
A: Because it messes up the order in which people normally read text.
Q: Why is top-posting such a bad thing?
A: Top-posting.
Q: What is the most annoying thing on usenet and in email?

</body></email><email><emailId>20031005165443</emailId><senderName>Wang WenRui</senderName><senderEmail>wangwr@mail.ustc.edu.cn</senderEmail><timestampReceived>2003-10-05 16:54:43-0400</timestampReceived><subject>[Patch] fixed Chinese characters input in the text mode</subject><body>

Hi,

   I'd like to file a patch against the existing bug related to Chinese
   inputing. The multibyte 8bit Chinese characters was lost on the input
   line. That is, When you type them, the cursor on the input line
   doesn't move and nothing is echoed there, but they will be send to server correctly after you
   press enter.
   
   I've tried  the irssi-snapshot (debian sid package, cvs 200307
   version) and qvr's unstable packages(cvs 20031001). They all have
   that problem.

   So I made some search and found that there are already a patch for
   this in the FreeBSD ports[1]. After applying it, the problem is
   solved and it has been tested working.

   So would you please accepted this patch and commit it into the CVS?
   The patch is in the attachment.

   Thanks in advance.


Best regards
Wang WenRui

[1] http://www.freshports.org/chinese/irssi/

["irssi-snapshot_0.8.6+cvs.20030712-3+zh.diff" (text/plain)]

--- irssi-snapshot-0.8.6+cvs.20030712.orig/src/fe-text/gui-entry.c
+++ irssi-snapshot-0.8.6+cvs.20030712/src/fe-text/gui-entry.c
@@ -68,6 +68,27 @@
         g_free(entry);
 }
 
+/* Fixes the cursor position if it at big5_lo .
+   Direct: -1    ,  left shift 1 byte.
+   Direct: 0, +1 ,  right shift 1 byte.
+*/
+static int _fix_big5_pos(unichar *p, int pos, int direct)
+{
+	int newpos;
+
+	for (newpos=0; newpos&lt;pos &amp;&amp; p[newpos] != 0; ) {
+		if (is_big5(p[newpos], p[newpos+1]))
+			newpos += 2;
+		else
+			newpos ++;
+	}
+
+	if (newpos != pos)
+		pos += direct &gt; 0 ? 1 : -1;
+
+	return pos;
+}
+
 /* Fixes the cursor position in screen */
 static void gui_entry_fix_cursor(GUI_ENTRY_REC *entry)
 {
@@ -85,6 +106,8 @@
 		entry-&gt;scrstart = entry-&gt;pos - entry-&gt;scrpos;
 	}
 
+	entry-&gt;scrstart = _fix_big5_pos(entry-&gt;text, entry-&gt;scrstart, -1);
+
 	if (old_scrstart != entry-&gt;scrstart)
                 entry-&gt;redraw_needed_from = 0;
 }
@@ -200,7 +223,7 @@
 	}
 }
 
-void gui_entry_set_prompt(GUI_ENTRY_REC *entry, const char *str)
+void gui_entry_set_prompt(GUI_ENTRY_REC *entry, const unsigned char *str)
 {
 	int oldlen;
 
@@ -236,7 +259,7 @@
         entry-&gt;utf8 = utf8;
 }
 
-void gui_entry_set_text(GUI_ENTRY_REC *entry, const char *str)
+void gui_entry_set_text(GUI_ENTRY_REC *entry, const unsigned char *str)
 {
 	g_return_if_fail(entry != NULL);
 	g_return_if_fail(str != NULL);
@@ -265,7 +288,7 @@
 	return buf;
 }
 
-void gui_entry_insert_text(GUI_ENTRY_REC *entry, const char *str)
+void gui_entry_insert_text(GUI_ENTRY_REC *entry, const unsigned char *str)
 {
         unichar chr;
 	int i, len;
@@ -341,13 +364,30 @@
 	return buf;
 }
 
+void gui_entry_erase_to(GUI_ENTRY_REC *entry, int pos, int update_cutbuffer)
+{
+  int newpos, size = 0;
+  
+  g_return_if_fail(entry != NULL);
+  for(newpos = gui_entry_get_pos(entry); newpos &gt; pos; size ++)
+    newpos = _fix_big5_pos(entry-&gt;text, newpos - 1, -1);
+  gui_entry_erase(entry, size, update_cutbuffer);
+}
+
 void gui_entry_erase(GUI_ENTRY_REC *entry, int size, int update_cutbuffer)
 {
+	int newpos;
+
         g_return_if_fail(entry != NULL);
 
 	if (entry-&gt;pos &lt; size)
 		return;
 
+	/* recount the erase size with big5 charsets */
+	for (newpos = entry-&gt;pos; newpos &gt; 0 &amp;&amp; size &gt; 0; size--)
+		newpos = _fix_big5_pos(entry-&gt;text, newpos-1, -1);
+	size = entry-&gt;pos - newpos;
+
 	if (update_cutbuffer) {
 		/* put erased text to cutbuffer */
 		if (entry-&gt;cutbuffer == NULL || entry-&gt;cutbuffer_len &lt; size) {
@@ -471,10 +511,24 @@
 
 void gui_entry_move_pos(GUI_ENTRY_REC *entry, int pos)
 {
+	int newpos;
+
         g_return_if_fail(entry != NULL);
 
-	if (entry-&gt;pos+pos &gt;= 0 &amp;&amp; entry-&gt;pos+pos &lt;= entry-&gt;text_len)
-		entry-&gt;pos += pos;
+	/* move cursor with big5 charset */
+	newpos = _fix_big5_pos(entry-&gt;text, entry-&gt;pos, -1);
+	if (pos &gt; 0) {
+		while (pos &gt; 0 &amp;&amp; newpos &lt; entry-&gt;text_len) {
+			newpos = _fix_big5_pos(entry-&gt;text, newpos+1, 1);
+			pos --;
+		}
+	} else {
+		while (pos &lt; 0 &amp;&amp; newpos &gt; 0) {
+			newpos = _fix_big5_pos(entry-&gt;text, newpos-1, -1);
+			pos ++;
+		}
+	}
+	entry-&gt;pos = newpos;
 
 	gui_entry_fix_cursor(entry);
 	gui_entry_draw(entry);
--- irssi-snapshot-0.8.6+cvs.20030712.orig/src/fe-text/gui-entry.h
+++ irssi-snapshot-0.8.6+cvs.20030712/src/fe-text/gui-entry.h
@@ -28,17 +28,18 @@
 void gui_entry_move(GUI_ENTRY_REC *entry, int xpos, int ypos, int width);
 void gui_entry_set_active(GUI_ENTRY_REC *entry);
 
-void gui_entry_set_prompt(GUI_ENTRY_REC *entry, const char *str);
+void gui_entry_set_prompt(GUI_ENTRY_REC *entry, const unsigned char *str);
 void gui_entry_set_hidden(GUI_ENTRY_REC *entry, int hidden);
 void gui_entry_set_utf8(GUI_ENTRY_REC *entry, int utf8);
 
-void gui_entry_set_text(GUI_ENTRY_REC *entry, const char *str);
+void gui_entry_set_text(GUI_ENTRY_REC *entry, const unsigned char *str);
 char *gui_entry_get_text(GUI_ENTRY_REC *entry);
 
-void gui_entry_insert_text(GUI_ENTRY_REC *entry, const char *str);
+void gui_entry_insert_text(GUI_ENTRY_REC *entry, const unsigned char *str);
 void gui_entry_insert_char(GUI_ENTRY_REC *entry, unichar chr);
 
 char *gui_entry_get_cutbuffer(GUI_ENTRY_REC *entry);
+void gui_entry_erase_to(GUI_ENTRY_REC *entry, int pos, int update_cutbuffer);
 void gui_entry_erase(GUI_ENTRY_REC *entry, int size, int update_cutbuffer);
 void gui_entry_erase_word(GUI_ENTRY_REC *entry, int to_space);
 void gui_entry_erase_next_word(GUI_ENTRY_REC *entry, int to_space);
--- irssi-snapshot-0.8.6+cvs.20030712.orig/src/fe-text/gui-readline.c
+++ irssi-snapshot-0.8.6+cvs.20030712/src/fe-text/gui-readline.c
@@ -50,6 +50,10 @@
 static ENTRY_REDIRECT_REC *redir;
 static int escape_next_key;
 
+static int big5high = FALSE;
+static unichar prekey = '\0';
+
+
 static int readtag;
 static time_t idle_time;
 
@@ -148,7 +152,25 @@
 
 	idle_time = time(NULL);
 
-	if (key &lt; 32) {
+        if(big5high || is_big5_hi(key))
+        {
+          if(big5high)
+          {
+            big5high = FALSE;
+            str[0] = prekey;
+            str[1] = key;
+            str[2] = '\0';
+            gui_entry_insert_text(active_entry, str);
+            return;
+          }
+          else
+          {
+            big5high = TRUE;
+            prekey = key;
+            return;
+          }
+        }
+	else if (key &lt; 32) {
 		/* control key */
                 str[0] = '^';
 		str[1] = (char)key+'@';
--- irssi-snapshot-0.8.6+cvs.20030712.orig/src/fe-text/term-terminfo.c
+++ irssi-snapshot-0.8.6+cvs.20030712/src/fe-text/term-terminfo.c
@@ -564,12 +564,6 @@
 	}
 }
 
-/* XXX I didn't check the encoding range of big5+. This is standard big5. */
-#define is_big5_los(lo) (0x40 &lt;= (lo) &amp;&amp; (lo) &lt;= 0x7E) /* standard */
-#define is_big5_lox(lo) (0x80 &lt;= (lo) &amp;&amp; (lo) &lt;= 0xFE) /* extended */
-#define is_big5_hi(hi)  (0x81 &lt;= (hi) &amp;&amp; (hi) &lt;= 0xFE)
-#define is_big5(hi,lo) (is_big5_hi(hi) &amp;&amp; (is_big5_los(lo) || is_big5_lox(lo)))
-
 static int input_big5(const unsigned char *buffer, int size, unichar *result)
 {
 	if (is_big5_hi(*buffer)) {
--- irssi-snapshot-0.8.6+cvs.20030712.orig/src/fe-text/textbuffer-view.c
+++ irssi-snapshot-0.8.6+cvs.20030712/src/fe-text/textbuffer-view.c
@@ -199,8 +199,14 @@
 		}
 
 		if (!view-&gt;utf8) {
-			next_ptr = ptr+1;
+			/* MH */
 			char_len = 1;
+			if(ptr[1] != '\0' &amp;&amp; is_big5(ptr[0], ptr[1]))
+			{
+			  char_len = 2;
+			}
+			next_ptr = ptr+char_len;
+			/*    */
 		} else {
 			char_len = 1;
 			while (ptr[char_len] != '\0' &amp;&amp; char_len &lt; 6)
@@ -251,7 +257,15 @@
 			continue;
 		}
 
-		if (*ptr == ' ') {
+		/* MH */
+		if (!view-&gt;utf8 &amp;&amp; char_len &gt; 1)
+		{
+			last_space = xpos;
+			last_space_ptr = next_ptr;
+			last_color = color;
+		}
+		/*    */
+		else if (*ptr == ' ') {
 			last_space = xpos;
 			last_space_ptr = ptr;
 			last_color = color;
--- irssi-snapshot-0.8.6+cvs.20030712.orig/src/fe-text/utf8.h
+++ irssi-snapshot-0.8.6+cvs.20030712/src/fe-text/utf8.h
@@ -18,6 +18,13 @@
    Make sure out is at least 6 x length of str. */
 void utf16_to_utf8(const unichar *str, char *out);
 
+/* XXX I didn't check the encoding range of big5+. This is standard big5. */
+#define is_big5_los(lo) (0x40 &lt;= (lo) &amp;&amp; (lo) &lt;= 0x7E) /* standard */
+#define is_big5_lox(lo) (0x80 &lt;= (lo) &amp;&amp; (lo) &lt;= 0xFE) /* extended */
+#define is_big5_lo(lo)	((is_big5_los(lo) || is_big5_lox(lo)))
+#define is_big5_hi(hi)  (0x81 &lt;= (hi) &amp;&amp; (hi) &lt;= 0xFE)
+#define is_big5(hi,lo) (is_big5_hi(hi) &amp;&amp; is_big5_lo(lo))
+
 /* Returns width for character (0-2). */
 int utf8_width(unichar c);
 


</body></email><email><emailId>20031030102321</emailId><senderName>Dario Freni</senderName><senderEmail>saturnero@gufi.org</senderEmail><timestampReceived>2003-10-30 10:23:21-0400</timestampReceived><subject>Re: Hiding channel key from statusbar?</subject><body>


On Thu, 2003-10-30 at 10:55, Jochen Eisinger wrote:
&gt; Hi,
&gt; 
&gt; irssi is a chat client, not an IRCNet client. There are chat networks
&gt; featuring other modes with arguments.

I know. And a patch like yours is really enough for me. No difference
for me a variable to be set and/or a trigger available for the
statusbar. IMHO, the +k mode, in an IRC client (then not in a chat
client, but maybe in its irc module) has to be managed differently.

Bye,
Dario

-- 
Dario Freni (saturnero@gufi.org) - SaturNero on IRCNet, Azzurra
Gruppo Utenti FreeBSD Italia (http://www.gufi.org)
GPG Public key at http://www.saturnero.net/saturnero.asc

["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20031030232321</emailId><senderName></senderName><senderEmail>dekket</senderEmail><timestampReceived>2003-10-30 23:23:21-0400</timestampReceived><subject>alignment = "center";</subject><body>

Hi!

first off, thanks for an awesome and highly configurable irc client... I still
wonder how i managed to stick with mI*c even when i was still a windows geek...
hmm... =)

Anyways, I was theming and configging irssi yesterday, and I really miss one
feature, and thats a center option for alignment with items in statusbars...

like on my screenshot (found at http://fu.gouryella.net/misc/irssi.png
I wanted to have the current topic centered, but thats not possible... Is this
something you plan on adding to the features later on? If not, I'm hereby asking
for it... =)

Greets, dekket @ EFnet #irc.addicts
dekket@bowl nu






</body></email><email><emailId>20030905212809</emailId><senderName>Nils Hjelte</senderName><senderEmail>c01nhe@cs.umu.se</senderEmail><timestampReceived>2003-09-05 21:28:09-0400</timestampReceived><subject>Announcement of MacIrssi</subject><body>

Hello, I have been working on an Mac OS X IRC client based on irssi. 
The program is called MacIrssi and I have now released the first beta 
version. I would like to start by thanking Andrew de los Reyes for 
doing the initial Mac OS X GUI port, and also thank the fink team, 
whose buildfiles helped me in compiling irssi. The program is written 
using Apple's Cocoa API, and har an aqua GUI with a channel list and a 
nick list.

I have set up an temporary website at http://www.g1m0.se/macirssi/
A screenshot can be found at http://www.g1m0.se/macirssi/pics/screen.png
A downloadable diskimage is at 
http://www.cs.umu.se/~c01nhe/MacIrssi.dmg and a mirror at 
http://www.g1m0.se/macirssi/MacIrssi.dmg
Sourcecode can be fetched from 
http://www.g1m0.se/macirssi/MacIrssi%20source.dmg

If you are running Mac OS X, please let me know your oppinions.

I still have one problem though, /exec doesn't seem to be working 
properly. Could this be because it detects that it's not connected to a 
tty? The output is correct if used with -interactive, but -out isn't 
working 100%. I have not looked into the exec code yet, but if someone 
knows what the problem is right away, please tell me.

// Nils Hjelte - c01nhe@cs.umu.se


</body></email><email><emailId>20030921041305</emailId><senderName>Marcus Rueckert</senderName><senderEmail>darix@web.de</senderEmail><timestampReceived>2003-09-21 04:13:05-0400</timestampReceived><subject>Re: Coding a plugin/module</subject><body>

On 2003-09-20 19:11:37 +0200, tommy wrote:
&gt; I am coding some plugin/module, I have used the source from that IDEA plugin
&gt; Unfort. its very big, and I dont understand it all, also there is no documentation
&gt; for plugin API...
&gt; 
&gt; I need to know how to use the "message own_*" signals properly, I want to
&gt; catch users input, modify it, and send it to the person/channel it was meant to.

how about use a script? splitlong is a nice example for modifying msgs
on send.

darix

-- 
irssi - the client of the smart and beautiful people

              http://www.irssi.de/


</body></email><email><emailId>20030922225701</emailId><senderName>"tommy"</senderName><senderEmail>tommy.2003@gmx.net</senderEmail><timestampReceived>2003-09-22 22:57:01-0400</timestampReceived><subject>irssi kills parts of a library</subject><body>

Hello

As soon as I use MIRACL (http://indigo.ie/~mscott/) in a module,
irssi (or whatever) kills its cinstr function (and probably more).

I have used latest MIRACL lib, it compiled great. All example
programs work aswell. I am very sure its not a MIRACL issue.

The problem with cinstr will show up ONLY when using it in a
plugin. I have tried latest CVS build aswell as latest official build.
Therefore I suspect irssi to have some problem with using
libraries in plugins.

I have also used 2 different linux machines to test it.


It looks like that:

#include "miracl.h"

void west_init(void)
{
        unsigned char raw[130], key1[1000]={0}, key2[1000]={0};
        unsigned long seed, i;  
        csprng RNG;
        miracl *mip;
        big keyA, prime, keyB;
        
        mip=mirsys(1000,16);
        mip-&gt;TRACER=TRUE;
        mip-&gt;IOBASE=16;

        keyA=mirvar(0);
        keyB=mirvar(0);
        prime=mirvar(0);
        
        strong_init(&amp;RNG, sizeof(raw), raw, seed);
        strong_bigdig(&amp;RNG, 1024, 2, keyA);  &lt;== usually kills cinstr, but
// sometimes cinstr is not working no matter if any strong_* function was used
        strong_kill(&amp;RNG);

        cinstr(prime, "12345"); &lt;= result prime = 0 :(

....


Maybe someone could look into irssi's module handling, thank you.


bye



</body></email><email><emailId>20030925183505</emailId><senderName>Marcus Rueckert</senderName><senderEmail>rueckert@informatik.uni-rostock.de</senderEmail><timestampReceived>2003-09-25 18:35:05-0400</timestampReceived><subject>Re: Prompting for input</subject><body>

hi,

i just copy some pieces from my unreleased ho_challenge.pl

i open my own window. if its already open we switch to it.

sub get_passphrase_window {
    my ( $server ) = @_;
    my ( $win ) = Irssi::window_find_name ( $win_name );
    if ( ref( $win ) ) {
        $win-&gt;change_server ( $server );
        $win-&gt;set_active ();
    } else {
        $win = Irssi::Windowitem::window_create( $win_name, 0 );
        $win = Irssi::active_win ();
        $win-&gt;set_name ( $win_name );
        $win-&gt;set_history ( $win_name );
        $win-&gt;change_server ( $server );
        $win-&gt;set_active ();
    }
    return $win;
}               


this signal handler does the prompt handling. it catches any input from
my own window.

signal_add_first 'send command', =&gt;sub {
    my ( $command, $server, $witem ) = @_;
    my ( $win ) = Irssi::active_win();

    if ( $win-&gt;{name} eq $win_name ) {

        signal_stop ();
		
		#
		# do your stuff here.
		#

    }
};              


i create the window on some signal handler. of course you can do it from
some command aswell. friends-peder.pl shows it. ;) oh yeah... some of
the code is borrowed from peder's script. :)

signal_add 'event 386' =&gt; sub {
    my ( $server, $args, $sender_nick, $sender_address ) = @_;
    my $win = get_passphrase_window( $server );
    my $ph = $win-&gt;create_handle(['CRAP']);
    print ( $ph "dont worry of leading command chars (".  Irssi::parse_special ('$K') \
."). the whole string is used as passphrase.  even if it starts with your command \
chars. if you have an empty pass just press enter.");  print ( $ph "%9%R%7press \
return to get to the password prompt%9" ); };       

you can catch me on ircnet/quakenet/efnet/freenode as darix, if you have
any questions.

darix

-- 
irssi - the client of the smart and beautiful people

              http://www.irssi.de/


</body></email><email><emailId>20030926005608</emailId><senderName>Marcus Rueckert</senderName><senderEmail>rueckert@informatik.uni-rostock.de</senderEmail><timestampReceived>2003-09-26 00:56:08-0400</timestampReceived><subject>Re: Theme'ing in irssi.</subject><body>

On 2003-09-26 02:23:42 +0200, dekket@bowl.nu wrote:
&gt; Colors should be definable, like; black = "#000000" ; white = "#FFFFFF" -- thus,
&gt; using hex instead. When using colors, the %black would be the obvious choice of
&gt; syntax.

there is a little problem. most terminals support only 16 colors. the
look and feel is depending on the terminal. irssi cant change them
without breaking other stuff. but you can change the meaning of %b in
your terminal config. all those color entries just in formats.txt just
refer to the ANSI colors.
 
&gt; All of these "pubmsgnick", "ownnick" etc, etc really gets to my eyes after a
&gt; while.. They could really use a freshening up to make them easier to spot, just
&gt; putting a dot in between "own" and "nick" making it "own.nick" would save my
&gt; eyes some sheer agony ;)

thats no real point. i think there are much more people who got used to
the current way ;)
and for us coders it would be some kind of hierarchy.

so it would be better to use 
nick.own or nick.pubmsg ;)

but i would stick to the current system ;)

&gt; Again, I'm no coder so I dont know whats doable and whats not, but sure hoping
&gt; it is...

see above ;)

&gt; Regards, dekket @ EFnet #irc.addicts

darix @ too many nets to mention here ;) 

-- 
irssi - the client of the smart and beautiful people

              http://www.irssi.de/


</body></email><email><emailId>20030925180240</emailId><senderName>Kim Norgaard</senderName><senderEmail>jasen@jasen.dk</senderEmail><timestampReceived>2003-09-25 18:02:40-0400</timestampReceived><subject>Prompting for input</subject><body>

Hi,

Being an oper on QuakeNet it's important to me that my passwords and
other authentication doesn't get logged or snooped by someone standing
behind my back. Therefore I turned to #irssi on QuakeNet today to ask if
there was a feature that'd let me input text in the prompt and store it
in variables, kindof like the way /oper works if you don't specify a
password.

Here's a summary of the log:

1329 &lt; jasen&gt; anyone here knows howto make irssi prompt the user for a
              string (preferably without echo'ing it back for use with password) ?
1329 &lt; jasen&gt; just like the internal /oper commands does it
1932 &lt;@Geert&gt; jasen: You can't get such a promt from a Irssi script
              (Perl), but that's possible from a Irssi plugin (C)
1945 &lt; jasen&gt; Geert: ok then
1945 &lt; jasen&gt; Geert: might that be a good suggestion for a feature ?
1946 &lt;@Geert&gt; Yes, it's just a minor change. Just the posibility to
              Irssi::print(); something to the prompt
1949 &lt; jasen&gt; More like the possibility to my $password =
              Irssi::Prompt(const ATTRIBUTE(eg. HIDDEN), string);
1949 &lt; jasen&gt; userfull for authenticating with Q etc. if you don't want passwords logged
1950 &lt;@Geert&gt; jasen: Could you post that to the Irssi-dev mailinglist?

The ATTRIBUTE would work like ENTRY_REDIRECT_FLAG_HIDDEN does in in the
irssi source. Example from the oper function:

keyboard_entry_redirect((SIGNAL_FUNC) cmd_oper_got_pass,
                        format,
                        ENTRY_REDIRECT_FLAG_HIDDEN, rec);

I know it's possible to /^msg (thanks ali) in order to not log text, but
still I think this feature could be usefull in many situations, also
others than security (setup scripts, etc.).

So, there ya go. A mail as promissed.

-- 
Kim Norgaard

</body></email><email><emailId>20030926002342</emailId><senderName></senderName><senderEmail>dekket</senderEmail><timestampReceived>2003-09-26 00:23:42-0400</timestampReceived><subject>Theme'ing in irssi.</subject><body>

Hi.
First off, I should mention that I'm not a coder, and if my ideas are totally
useless and/or a pain to debug, lemme know...
I recently begun theming irssi after a while of downloading and never finding
anything that I liked. I've made a few themes and its making me eat my shoe
soon, the syntax is just such a pain up the ass, especially colors. Before I saw
the light and switched every computer I own to various distributions of
Gnu/Linux and started using irssi, I used that god-awful client called m*rc. I
never liked it, but I liked the way *some script name* enabled an easier way to
theme everything. It was all named really nicely and almost human-readable... So
anyways... here's my ideas;

Colors should be definable, like; black = "#000000" ; white = "#FFFFFF" -- thus,
using hex instead. When using colors, the %black would be the obvious choice of
syntax.

All of these "pubmsgnick", "ownnick" etc, etc really gets to my eyes after a
while.. They could really use a freshening up to make them easier to spot, just
putting a dot in between "own" and "nick" making it "own.nick" would save my
eyes some sheer agony ;)

Again, I'm no coder so I dont know whats doable and whats not, but sure hoping
it is...

Regards, dekket @ EFnet #irc.addicts





</body></email><email><emailId>20030306074113</emailId><senderName>"Ted Goodridge, Jr"</senderName><senderEmail>tedgoodridgejr@acm.org</senderEmail><timestampReceived>2003-03-06 07:41:13-0400</timestampReceived><subject>Re: Irssi redesign / rewrite</subject><body>



&gt; perhaps try to make as much of stuff a part of the Perl scripting 
&gt; language. Don't keep /notify command in irssi, but move to a perl script? 
&gt; look at XiRCON: has never crashed on me, and i've used it since the first 
&gt; release... there aren't many commands that actually need to be kept in 
&gt; irssi (and C) even for added speed. Make the interfacing clean, simple, 
&gt; and correct and you probably solve a lot of issues, and make the design 
&gt; cleaner.
&gt;
&gt; And how about using some other language (hint: Ruby)? Perl seems to be a 
&gt; mess to interface with.

--I agree that scripts should hold as much of the features as possible, 
replybut I also think that irssi should be fully --functioning for most 
people without external scripting language. --You already note the worst 
problem, people want to use different scripting languages. People also 
install irssi in computers --that don't have some specific language 
installed, Perl is quite safe nowadays since it's been around for ages. I'm 
IRCing --from a computer that doesn't have Ruby installed, and likely will 
not be unless I install it into homedir. --Supporting multiple scripting 
languages is good for giving script coders a choice, but annoying for users 
who want to use --script done with multiple languages, possibly requiring 
them to install the language and at the very least use more memory. I -- 
won't be writing support for more than one language (very likely Perl), but 
that doesn't mean others can't write it. Irssi's --core doesn't make any 
assumptions what scripting language you may be using.

I know I'm full quoting, but as this is older mail I wanted to keep the 
context.  I personally think having an internal scripting language is a 
very BAD idea.  If anyone has used MIRC and its insane scripting language I 
would not like to see yet another client-specific scripting language.  Perl 
is great, but I know it has many detractors.  Would it be so difficult to 
have loadable modules that were interpreters for various scripting 
languages?  Pick one for the base, ie Perl, then produce an API (or even 
write modules with the project) that support various other major languages. 
 The most annoying thing to me about switching clients is having to learn a 
new language each time.  I would be thrilled (and I'm sure others would be 
too) if we could script in the language(s) we prefer?

The modules could be loaded at runtime, or statically built in depending on 
the users needs/wants.  Yes you would have scripts floating around in 
differnet languages, but choices mean your user base would grow.  Making 
the major scripting languages official modules would ensure QA, but you 
could also make the API easy to access so any language under the sun could 
theoretically be supported.

Just my $0.02.

Ted



</body></email><email><emailId>20030604031334</emailId><senderName></senderName><senderEmail>derek</senderEmail><timestampReceived>2003-06-04 03:13:34-0400</timestampReceived><subject>misc silc-plugin/scripting questions</subject><body>

hello all,

i've recently become enamored with irssi as my irssi/silc client of
choice, and use it daily at work, as well as my "free" time.. besides
which i'm currently being paid to work on a silc-based bot script which
will end up being a fairly complex beast.  hopefully i'm posting to the
right place(s) here, but kindly redirect me if not ;)

especially with silc, i've noticed some funny things happening that
confuse me, so i've attempted to collect them here in hopes of finding
some help.  

i should say as well that i'm exploring the possibility that my
silc-plugin/irssi build are broken, and will be submitting a bugreport to
bugs@irssi.org to that end (just need to get a backtrace).

a) "message (silc) action" signal?

i've registered the "message irc action" signal with a subroutine of my
own crafting (similar to the "message public/private" signals i'm
handling with no problem.  but it never gets called in a silc channel.
digging around a bit in the docs/src, i notice that while there are
generic signal handlers for message private/public, but the action
message is specific to the irc messages.c file.

further, i noticed that the silc code defines handlers for "signed
message public" and "signed message private" signals to be fired, and i
assume it is some variation on these i'm catching with my 

add_signal_last("message public",\&amp;silcChannelHandler);

type call.  so would it be possible for someone (maybe me?) to extend
action signals into the realm of the silc protocol?

b) Server::command() output?

again, this is sort of a silc-specific question, i think, but it relates
back to irssi in this way: my script needs to keep track of the
different servers/channels it connects to, as well as the users in each.

the silc protocol helpfully provides a public/private key and unique
client fingerprint for every user connected to a channel, and (as a
human), running the commands: /getkey or /whois allow me to make use of
this information.

i've tried a couple different scripted ways to connect to a server, join
some channels, and identify all users we can see.  the following bunch
of questions relate to this overall idea.  so perl.txt mentions the
Server::command() function as being able to run /commands via a script.
thinking this was a simple way to achieve what i wanted, i wrote:

my $names = $Server::command('names');
foreach (@{$names}) {
 ... 
}

and ran it from a client connected to a silc channel.  the $names var
never gets any info.  i've confirmed with folks in #irssi that the
command() function in fact never returns any of the output from running
the command.  if this is the case, how can i get access to such output?

c) "server connected" signal: silc delay

thinking i could get the information i needed another way, i tried this:
register a signal handler for the "server connected" signal that calls
$server-&gt;channels(), and then get a list of 

see attached script server-connected.pl which i ran and then connected
to a silc server, receiving this output:

01:31 -!- Irssi: Loaded script server_connected
01:31 -!- Irssi: Looking up silc.example.org
01:31 -!- Irssi: Connecting to silc.example.org [ip address] port 706
01:31 -!- Irssi: Connection to silc.example.org established
01:31 -!- Irssi: server connected signal received
01:31 -!- Welcome to the SILC Network 
01:31 -!- Your host is gis.example.org, running version 0.9.13

the "server connected signal received" message is from the test script,
and occurs immediately after the line above.  the "Welcome to the SILC
Network" line, however, takes a few moments to connect, and 

d) again.pm?

the script i'm writing is fairly complex and currently uses one .pm
module, where most of the functionality resides.  i've noticed in my
testing that i can't reload the contents of the .pm while irssi is
running, presumably because of the embedded perl environment.  i'd been
hunting for some perl magic to allow irssi/the script to notice when
this .pm changed and reload it's contents on-the-fly (at the moment, i
have to /quit the client and start everything up again).

naturally, i was very excited when i found juerd's again.pm
(http://search.cpan.org/author/JUERD/again/) module, but i was unable to
get it to work with my code, for some reason:

23:04 Not enough arguments for use again at (eval 18) line 1

is all i get when i try to load my script (even the first time) with a
'use again' instead of the normal 'use' line.  anybody have ideas what's
going on here?  some other workaround, perhaps?


thanks a lot!
derek




</body></email><email><emailId>20030609142551</emailId><senderName>Jean-Yves Lefort</senderName><senderEmail>jylefort@brutele.be</senderEmail><timestampReceived>2003-06-09 14:25:51-0400</timestampReceived><subject>new irssi plugins</subject><body>


Hi,

Here are two new irssi plugins:

http://lefort.be.eu.org/irssi-tray-notification/
	Provides a GNOME status icon

http://lefort.be.eu.org/files/uri.c
	An URI grabber

Greetings,
Jean-Yves Lefort

--=20
Jean-Yves Lefort

jylefort@brutele.be
http://lefort.be.eu.org/

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20030625153815</emailId><senderName>Wouter Coekaerts</senderName><senderEmail>coekie@irssi.org</senderEmail><timestampReceived>2003-06-25 15:38:15-0400</timestampReceived><subject>Re: irssi-proxy portbinds</subject><body>

Op woensdag 25 juni 2003 14:43, schreef Christian Axelsson:
&gt; Let's say that I have two clients running.
&gt; Client1 is connected to Net1 and Net2.
&gt; Client2 is connected to Net3.
&gt;
&gt; I /set irssiproxy_ports Net1=10001 Net2=10002 Net3=10003
&gt;
&gt; Now i load the proxymodule on Client1. Cool, no visible errors :)
&gt; Now i lood it on Client2.
&gt;
&gt; Irssi: Proxy: Listen in port 10001 failed: Address already in use
&gt; Irssi: Proxy: Listen in port 10002 failed: Address already in use
&gt; Irssi: Proxy: Listen in port 10003 failed: Address already in use
&gt; Irssi: Loaded module proxy/irc

Then do /set irssiproxy_ports Net1=10001 Net2=10002 on client 1
and /set irssiproxy_ports Net3=10003 on client 2
Yes, if it would only bind the ones you're connected to, that might seem 
simpler for you, but that causes other problems, for example the ones you 
pointed out:
&gt; A problem with this
&gt; approach is what is going to happen when I connect to Net3 in two
&gt; clients (but thats a problem now aswell).
&gt; Also what will happen when I disconnect from a net? Should the socket
&gt; stay connected or should we disconnect the client using the proxy (if
&gt; any)?
And those problems are imo worse (and will effect more people, i don't think a 
lot of people run 2 irssi-proxies with the same config) than just setting the 
correct settings in your 2 clients running irssi-proxy.

Greets,

Wouter.


</body></email><email><emailId>20030503210731</emailId><senderName>Piotr Krukowiecki</senderName><senderEmail>piotr@pingu.ii.uj.edu.pl</senderEmail><timestampReceived>2003-05-03 21:07:31-0400</timestampReceived><subject>Bug in 0.8.6 - not changing nick in dcc send</subject><body>

Hi

Maybe this is already fixed in cvs, but when user changes his nick
the dcc send nick is not updated:

22:54 DCC SEND request sent to on: rg.ogm
22:54 -!- Irssi: &lt;DBG&gt; NICK CHANGE: on -&gt; I_ty@IRCNet on #testc
22:55 DCC connections
22:55  I_ty CHAT
22:55  on SEND: 0k of 171147k (0%) - 0.00kB/s - rg.ogm

(The chat nick was updated)

-- 
Piotrek  (@ ~)
Mors Drosophilis melanogastribus!

</body></email><email><emailId>20030509132015</emailId><senderName>Kevin Sonney</senderName><senderEmail>ksonney@redhat.com</senderEmail><timestampReceived>2003-05-09 13:20:15-0400</timestampReceived><subject>[Patch] ssl support with pkgconfig</subject><body>

[Attachment #2 (multipart/mixed)]


Hello all -

On Red Hat Linux 9, OpenSSL is linked against kerberos. Unfortunately,
the default flags (-lssl -lcrypto) aren't complete enough to pull in all
the other needed libraries for this.

pkgconfig addresses this by supplying the proper include paths and link
libraries for openssl. 

The attached patch will attempt to get this information from pkgconfig,
and failing that, default to -lssl -lcrypto. 

I've incorporated this patch into the RPM package I have at
ftp://people.redhat.com/ksonney/SRPMS

Enjoy!

-- 
------------------------------------------
-- Kevin Sonney - Inside Sales Engineer --
--  Red Hat, Inc - 919.754.3700 x44112  --
--  ksonney@redhat.com - AIM: ksonney   --
------------------------------------------
1024D/EB74 3C54 0260 6A01 705A  6F3F CD3B BAF1 4EB9 55BC
 It's not stupid...it's ADVANCED -- All Mighty Tallest Red (Invader Zim
 Ep 1)

["irssi-sslfix.patch" (irssi-sslfix.patch)]

--- irssi-0.8.6.CVS/configure.in	2003-01-24 22:30:02.000000000 -0500
+++ irssi-0.8.6.CVS-fixed/configure.in	2003-02-28 12:19:29.000000000 -0500
@@ -420,7 +420,9 @@
     if test $try = 1 -o $try = 2; then
       AM_PATH_GLIB(1.2.0,,, $glib_modules)
     else
-      AM_PATH_GLIB_2_0(2.0.0,,, $glib_modules)
+      if test $try = 3 -o $try = 4; then
+        AM_PATH_GLIB_2_0(2.0.0,,, $glib_modules)
+      fi
     fi
     if test "$GLIB_LIBS"; then
       if test $glib_modules = gmodule; then
@@ -479,26 +481,34 @@
 	###
 	### Check for OpenSSL
 	###
-	save_CFLAGS=$CFLAGS;
-	CFLAGS="-lcrypto";
-
+	save_CFLAGS="$CFLAGS";
+    save_LIBS="$LIBS"
 	enable_openssl="no"; 
-	OPENSSL_LDFLAGS="";
-	AC_CHECK_LIB(ssl, SSL_read, [
-	  AC_CHECK_LIB(crypto, X509_new, [
-	    AC_CHECK_HEADERS(openssl/ssl.h openssl/err.h, [
-	      enable_openssl="yes";
-	      OPENSSL_LDFLAGS="-lssl -lcrypto"
+    OPENSSL_LDFLAGS="-lssl -lcrypto" 
+    OPENSSL_CFLAGS="$openssl_inc_prefix"	
+    PKG_CHECK_MODULES(OPENSSL, openssl, 
+      [ AC_MSG_RESULT(["found via pkgconfig"])
+        enable_openssl="yes" 
+      ],
+      [	AC_CHECK_LIB(ssl, SSL_read, [
+	      AC_CHECK_LIB(crypto, X509_new, [
+	        AC_CHECK_HEADERS(openssl/ssl.h openssl/err.h, [
+	          enable_openssl="yes";
+	          OPENSSL_LDFLAGS="-lssl -lcrypto"
+              OPENSSL_CFLAGS="$openssl_inc_prefix"
+	        ])
+	      ])
 	    ])
-	  ])
-	])
-	CFLAGS=$save_CFLAGS
-
+      ]
+    )
 	if test "x$enable_openssl" = xyes; then
 		AC_DEFINE(HAVE_OPENSSL)
-
-		LIBS="$LIBS -L$openssl_prefix $OPENSSL_LDFLAGS"
-		CFLAGS="$CFLAGS $openssl_inc_prefix"
+		LIBS="$LIBS  $OPENSSL_LDFLAGS"
+		CFLAGS="$CFLAGS $OPENSSL_CFLAGS"
+    else 
+  	    CFLAGS=$save_CFLAGS
+        LIBS=$save_LIBS
+        enable_ssl="no"
 	fi
 else
 	enable_openssl="no"
@@ -748,7 +758,7 @@
 		if test "x$want_perl" = "xstatic"; then
 			dnl * building with static perl support
 			dnl * all PERL_LDFLAGS linking is done in fe-text
-			PERL_LINK_FLAGS="$PERL_LDFLAGS"
+			PERL_LINK_FLAGS="$PERL_LDFLAGS $LDFLAGS"
 			PERL_LINK_LIBS="../perl/libperl_core_static.la"
 			PERL_FE_LINK_LIBS="../perl/libfe_perl_static.la"
 			PERL_LDFLAGS=
@@ -794,7 +804,7 @@
 
 		AC_SUBST(PERL_LINK_FLAGS)
 		AC_SUBST(PERL_LINK_LIBS)
-                AC_SUBST(PERL_FE_LINK_LIBS)
+        AC_SUBST(PERL_FE_LINK_LIBS)
 
 		AC_SUBST(PERL_LDFLAGS)
 		AC_SUBST(PERL_CFLAGS)

["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20030103135658</emailId><senderName>Athanasius</senderName><senderEmail>irssi@miggy.org</senderEmail><timestampReceived>2003-01-03 13:56:58-0400</timestampReceived><subject>mIRC style /dccserver command</subject><body>


Hi,
  I use a few channels where they serve files with the style of
/dccserver +sc &lt;port&gt;, i.e. where the client has to be already listening
on that port, and triggers the start of DCC chat by sending a /CTCP
command to the server (NOT a /dcc chat request).

  Snooping things with ethereal it looks like it's otherwise the same as
a DCC chat, the client just needs to be expecting connection(S) on the
given port for DCC stuff.

  So, how would we go around hacking support for this into irssi?  Bear
in mind the port probably has to listen for ALL DCC requests, certainly
CHAT and SEND from the other end.

  I've found cmd_dcc_chat() in irssi/irc/dcc/dcc-chat.c which is what
/dcc chat &lt;nick&gt; calls.  For the chat side of thing we'd want to do
something similar to this I suspect.  cmd_dcc_get() in dcc-get.c would
seem to handle the same kind of thing for /dcc get &lt;nick&gt; &lt;file&gt;.  We
kind of need to combine the two.

  I'm looking at hacking this support in myself but it would probably be
quicker for someone more familiar with the code to do it, any takers?

-Ath
-- 
- Athanasius = Athanasius(at)miggy.org / http://www.miggy.org/
                  Finger athan(at)fysh.org for PGP key
	   "And it's me who is my enemy. Me who beats me up.
Me who makes the monsters. Me who strips my confidence." Paula Cole - ME

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20030213094255</emailId><senderName>Athanasius</senderName><senderEmail>athanasius@miggy.org</senderEmail><timestampReceived>2003-02-13 09:42:55-0400</timestampReceived><subject>Re: irssi and dccserv</subject><body>


On Wed, Feb 12, 2003 at 10:04:51PM +0100, Tomasz Bryja wrote:
&gt; Hello!
&gt; 
&gt;   I've read you post about incorporating the /dccserver function in irssi.
&gt; I have the same problem and was wondering, have you found a solution? :)

  I've hacked together support for it, yes.  Right now it works fine on
the few-months old CVS copy I started from.  diff'ing and patching
against current CVS yields a few bits of weirdness though, which I'm not
sure are my code or the current CVS being screwed.

  The patch is INCREDIBLY hacky due to the nature of what's needed:

	1) Open and listen on a TCP port
	2) When you receive a connection, parse commands, make a
	possible reply, then:
	3) USE THE SAME TCP CONNECTIOn for the chat or get.

Point 3 is what makes it incrediby hacky.  I've had to munge a current
connection around to become a DCC CHAT or DCC GET on the fly.  This
means duplicating some code, but without changing a lot of how normal
dcc-chat.c and dcc-get.c work I can't see any other way to do this.
I've also had to un-static a few functions elsewhere to allow me to NOT
duplicate even more code.

  I've only just gotten the DCC GET working yesterday and haven't had
chance to test vanilla CVS to see if the same problem is there.  I'll
try and get to that today and post a patch whatever by the end of the
day.

-Ath
-- 
- Athanasius = Athanasius(at)miggy.org / http://www.miggy.org/
                  Finger athan(at)fysh.org for PGP key
	   "And it's me who is my enemy. Me who beats me up.
Me who makes the monsters. Me who strips my confidence." Paula Cole - ME

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20030413115200</emailId><senderName>Florian Geiges</senderName><senderEmail>florian.geiges@t-online.de</senderEmail><timestampReceived>2003-04-13 11:52:00-0400</timestampReceived><subject>possible problem with chanmode +w</subject><body>

hey *!*@*, 

looks like irssi is having some problems with chanmode +w.
i.e.: i set 
/mode #fuq +w test 
(that is adding a bad word in euircnet) irssi does this: 
13:41:44 -!- #fuq r You need more privileges to change this mode.
which doesnt equal +w at all ;)

just wanted to report that - sorry if already posted or etc.

mfg
florian

</body></email><email><emailId>20030526132633</emailId><senderName>Lucio Maciel</senderName><senderEmail>gcc@gcc.com.br</senderEmail><timestampReceived>2003-05-26 13:26:33-0400</timestampReceived><subject>[PATCH]Halfop</subject><body>

Hi..

this little patch add a halfop entry in the channel rec structure. this
way is more easy to use an autovoice, autokick scripts halfoped in a
channel just checking 

return unless ($channel-&gt;{chanop} || $channel-&gt;{halfop});


regards.
-- 

"Se nao tivessemos defeitos, nao teriamos tanto prazer em nota-los
nos outros" (La Rochefoucauld)

::: Lucio Maciel
::: gcc @ gcc . com . br
::: http://www.gcc.com.br


</body></email><email><emailId>20030624115643</emailId><senderName>Christian Axelsson</senderName><senderEmail>smiler@lanil.mine.nu</senderEmail><timestampReceived>2003-06-24 11:56:43-0400</timestampReceived><subject>irssi-proxy portbinds</subject><body>


Hi!

I run multiple irssi-sessions and I want to use the proxy function but
Ive noticed that when you load proxy it binds port directly even if the
net isnt connected in the client. This causes bind errors in the other
client (ofcourse) and makes it disfunctional.

My suggestion is that the proxymodule should only bind a port when it
sees that it is connected in the current client to the network in
question.

Regards

--=20
Christian Axelsson
smiler@lanil.mine.nu

["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20030625124311</emailId><senderName>Christian Axelsson</senderName><senderEmail>smiler@lanil.mine.nu</senderEmail><timestampReceived>2003-06-25 12:43:11-0400</timestampReceived><subject>Re: irssi-proxy portbinds</subject><body>


On Wed, 2003-06-25 at 14:14, bd@bc-bd.org wrote:
&gt; I am sorry, but I have no idea what you are talking about. Can you
&gt; please try to explain your problem with a little more detail, or add
&gt; examples? Thank You

Ok.
Let's say that I have two clients running.
Client1 is connected to Net1 and Net2.
Client2 is connected to Net3.

I /set irssiproxy_ports Net1=10001 Net2=10002 Net3=10003

Now i load the proxymodule on Client1. Cool, no visible errors :)
Now i lood it on Client2.

Irssi: Proxy: Listen in port 10001 failed: Address already in use
Irssi: Proxy: Listen in port 10002 failed: Address already in use
Irssi: Proxy: Listen in port 10003 failed: Address already in use
Irssi: Loaded module proxy/irc

Ouch. Logical because Client1 binds all 3 ports to itself.
When I try to connect on 10001 it goes fine (ofcource). Same with 10002.
When I try to connect to 10003 it will connect to Client1 (that ins't
connected to Net3) and I will get something like:

!Net3.proxy Not connected to server

Kinda logical aswell but bogus.
Now a solution would be to bind the proxyport to Net3 (and the others)
when I actually connect to Net3 in the client. A problem with this
approach is what is going to happen when I connect to Net3 in two
clients (but thats a problem now aswell).
Also what will happen when I disconnect from a net? Should the socket
stay connected or should we disconnect the client using the proxy (if
any)?

I hope this will help.. I find this to be a very annoying problem in
this very nice module.

Kindly regards

-- 
Christian Axelsson
smiler@lanil.mine.nu

["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20030526155430</emailId><senderName>"Adam Wiggles"</senderName><senderEmail>techdude@societynet.net</senderEmail><timestampReceived>2003-05-26 15:54:30-0400</timestampReceived><subject>Re: [PATCH]Halfop</subject><body>

and umm what file does that go in?

----- Original Message ----- 
From: Lucio Maciel &lt;gcc@gcc.com.br&gt;
To: &lt;irssi-dev@dragoncat.net&gt;
Sent: Monday, May 26, 2003 9:26 AM
Subject: [PATCH]Halfop


&gt; Hi..
&gt; 
&gt; this little patch add a halfop entry in the channel rec structure. this
&gt; way is more easy to use an autovoice, autokick scripts halfoped in a
&gt; channel just checking 
&gt; 
&gt; return unless ($channel-&gt;{chanop} || $channel-&gt;{halfop});
&gt; 
&gt; 
&gt; regards.
&gt; -- 
&gt; 
&gt; "Se nao tivessemos defeitos, nao teriamos tanto prazer em nota-los
&gt; nos outros" (La Rochefoucauld)
&gt; 
&gt; ::: Lucio Maciel
&gt; ::: gcc @ gcc . com . br
&gt; ::: http://www.gcc.com.br
&gt; 
&gt; 
&gt; 



</body></email><email><emailId>20030509132358</emailId><senderName>Kevin Sonney</senderName><senderEmail>ksonney@redhat.com</senderEmail><timestampReceived>2003-05-09 13:23:58-0400</timestampReceived><subject>[patch] Using elinks to generate docs</subject><body>

[Attachment #2 (multipart/mixed)]


lynx is no longer included in Red Hat Linux distributions. It has been
superseded by links. The attached patch will test for links, and use
that for documentation generation. If links i not found, lynx will be
used instead.

This is also used in the SRPM available at
ftp://people.redhat.com/ksonney/SRPMS

--=20
------------------------------------------
-- Kevin Sonney - Inside Sales Engineer --
--  Red Hat, Inc - 919.754.3700 x44112  --
--  ksonney@redhat.com - AIM: ksonney   --
------------------------------------------
1024D/EB74 3C54 0260 6A01 705A  6F3F CD3B BAF1 4EB9 55BC
 Reality is that which, when you stop believing in it, doesn't go away
 -- Philip K. Dick

["irssi-browserfix.patch" (irssi-browserfix.patch)]

--- irssi-0.8.6.CVS/autogen.sh	2002-08-14 15:10:02.000000000 -0400
+++ irssi-0.8.6.CVS-fixed/autogen.sh	2003-02-27 12:40:05.000000000 -0500
@@ -37,7 +37,12 @@
 
 # .html -&gt; .txt with lynx
 echo "Documentation: html -&gt; txt..."
-lynx -dump -nolist docs/faq.html|perl -pe 's/^ *//; if ($_ eq "\n" &amp;&amp; $state eq "Q") \
{ $_ = ""; } elsif (/^([QA]):/) { $state = $1 } elsif ($_ ne "\n") { $_ = "   $_"; \
};' &gt; docs/faq.txt +textbrowser="links"
+if test ! -f $(which $textbrowser); then
+   textbrowser="lynx"
+fi
+
+$textbrowser -dump -nolist docs/faq.html|perl -pe 's/^ *//; if ($_ eq "\n" &amp;&amp; $state \
eq "Q") { $_ = ""; } elsif (/^([QA]):/) { $state = $1 } elsif ($_ ne "\n") { $_ = "   \
$_"; };' &gt; docs/faq.txt  
 echo "Checking auto* tools..."
 


["signature.asc" (application/pgp-signature)]

</body></email><email><emailId>20030526164459</emailId><senderName>Lucio Maciel</senderName><senderEmail>gcc@gcc.com.br</senderEmail><timestampReceived>2003-05-26 16:44:59-0400</timestampReceived><subject>Re: [PATCH]Halfop</subject><body>

sorry, now with the attachment... i'm allways foegetting it...

regards

On Mon, 2003-05-26 at 12:54, Adam Wiggles wrote:
&gt; and umm what file does that go in?
&gt; 
&gt; ----- Original Message ----- 
&gt; From: Lucio Maciel &lt;gcc@gcc.com.br&gt;
&gt; To: &lt;irssi-dev@dragoncat.net&gt;
&gt; Sent: Monday, May 26, 2003 9:26 AM
&gt; Subject: [PATCH]Halfop
&gt; 
&gt; 
&gt; &gt; Hi..
&gt; &gt; 
&gt; &gt; this little patch add a halfop entry in the channel rec structure. this
&gt; &gt; way is more easy to use an autovoice, autokick scripts halfoped in a
&gt; &gt; channel just checking 
&gt; &gt; 
&gt; &gt; return unless ($channel-&gt;{chanop} || $channel-&gt;{halfop});
&gt; &gt; 
&gt; &gt; 
&gt; &gt; regards.
&gt; &gt; -- 
&gt; &gt; 
&gt; &gt; "Se nao tivessemos defeitos, nao teriamos tanto prazer em nota-los
&gt; &gt; nos outros" (La Rochefoucauld)
&gt; &gt; 
&gt; &gt; ::: Lucio Maciel
&gt; &gt; ::: gcc @ gcc . com . br
&gt; &gt; ::: http://www.gcc.com.br
&gt; &gt; 
&gt; &gt; 
&gt; &gt; 
&gt; 
-- 

"Se nao tivessemos defeitos, nao teriamos tanto prazer em nota-los
nos outros" (La Rochefoucauld)

::: Lucio Maciel
::: gcc @ gcc . com . br
::: http://www.gcc.com.br

["halfop.diff" (halfop.diff)]

diff -ur ../irssi-0.8.6/src/core/channel-rec.h ./src/core/channel-rec.h
--- ../irssi-0.8.6/src/core/channel-rec.h	2002-05-15 21:34:31.000000000 -0300
+++ ./src/core/channel-rec.h	2003-05-26 10:06:05.000000000 -0300
@@ -16,6 +16,7 @@
 char *key; /* password key */
 
 unsigned int chanop:1; /* You're a channel operator */
+unsigned int halfop:1;
 unsigned int names_got:1; /* Received /NAMES list */
 unsigned int wholist:1; /* WHO list got */
 unsigned int synced:1; /* Channel synced - all queries done */
diff -ur ../irssi-0.8.6/src/irc/core/irc-nicklist.c ./src/irc/core/irc-nicklist.c
--- ../irssi-0.8.6/src/irc/core/irc-nicklist.c	2002-08-27 16:45:07.000000000 -0300
+++ ./src/irc/core/irc-nicklist.c	2003-05-26 10:07:03.000000000 -0300
@@ -162,7 +162,8 @@
 						      FALSE, FALSE);
 		}
 		nicklist_set_own(CHANNEL(chanrec), ownnick);
-                chanrec-&gt;chanop = chanrec-&gt;ownnick-&gt;op;
+		chanrec-&gt;chanop = chanrec-&gt;ownnick-&gt;op;
+		chanrec-&gt;halfop = chanrec-&gt;ownnick-&gt;halfop;
 		chanrec-&gt;names_got = TRUE;
 		signal_emit("channel joined", 1, chanrec);
 	}
diff -ur ../irssi-0.8.6/src/perl/perl-common.c ./src/perl/perl-common.c
--- ../irssi-0.8.6/src/perl/perl-common.c	2002-10-28 00:00:03.000000000 -0200
+++ ./src/perl/perl-common.c	2003-05-26 10:08:22.000000000 -0300
@@ -354,6 +354,7 @@
 	hv_store(hv, "key", 3, new_pv(channel-&gt;key), 0);
 
 	hv_store(hv, "chanop", 6, newSViv(channel-&gt;chanop), 0);
+	hv_store(hv, "halfop", 6, newSViv(channel-&gt;halfop), 0);
 	hv_store(hv, "names_got", 9, newSViv(channel-&gt;names_got), 0);
 	hv_store(hv, "wholist", 7, newSViv(channel-&gt;wholist), 0);
 	hv_store(hv, "synced", 6, newSViv(channel-&gt;synced), 0);


</body></email><email><emailId>20030406010845</emailId><senderName>Robert Bragg</senderName><senderEmail>rbragg@essex.ac.uk</senderEmail><timestampReceived>2003-04-06 01:08:45-0400</timestampReceived><subject>[PATCH] /hilight code</subject><body>

Hi,

This is what the patch would change...

changes to /hilight
-------------------
+ more than one hilight rule can now match against the same message.
        + rules are prioritised by their "stack" level
                + this means if more than one -nick rule matches against
                  the same message, the newest one (highest in stack) is
                  used.
                + if two different matches overlap, the highest one will
                  be drawn last to ensure it is visible.

e.g. if someone sent a public message "test" with the folowing rules...
/hilight -color %g test
/hilight -color %R s
't', 'e', 't' would be in green but the 's' would be in red.
if you were to swap the rules then "test" would be completly green.

- no longer limited to only having one rule with a particular mask...
one rule might be limited to serching nick names with -mask, but the other might be \
intended for searching the whole message text. currently the second will overwrite \
                the first.
- _No_ limits on having duplicate rules...
since the meaning of rule is ultimatly determined by its poition within the stack, it \
might be usefull to have multiple rules that are exactly the same but are at \
different stack positions.

e.g. the following long winded, completly unbelieveable scenario...

* set up a default hilight rule for all nicks to be colored green *
/hilight -mask -color %g *
* start tracking the use of the word blah *
/hilight blah
* start tracking the use of the word foo *
/hilight foo
&gt; &gt; 
&gt; &gt; 
etc

* argh.. i want to track another really important word but these
  other hilights are confusing me :) *
/hilight -mask -color %g * (notice its the same as the first rule :)
/hilight flibble

* finished tracking flibble, now want to carry on with the old tracking *
/dehilight -pop 2

changes to /dehilight
---------------------
+ added a -pop parameter
        + this allows you to "pop" &lt;count&gt; rules off of the stack
+ added a -clear parameter to remove all hilight rules
+ changed default behaviour with no parameters to == -pop

These changes seem to work well for me, so I thought you might like to
see if you want them aswell?

If you have any difficulties with it I will try and help, though I must
warn I have only been using irssi for a week and playing with the code
for about 3 days, so I'm not _that_ familier with it. :)

Regards,
- Rob


["hilight.patch" (text/plain)]

Only in /var/tmp/portage/irssi-0.8.6-r2/work/irssi-0.8.6/src/fe-common/core/: \
.hilight-text.c.swp Only in \
                /var/tmp/portage/irssi-0.8.6-r2/work/irssi-0.8.6/src/fe-common/core/: \
                Makefile
diff -bur irssi-0.8.6/src/fe-common/core/fe-messages.c \
                /var/tmp/portage/irssi-0.8.6-r2/work/irssi-0.8.6/src/fe-common/core/fe-messages.c
                
--- irssi-0.8.6/src/fe-common/core/fe-messages.c	2002-05-31 18:00:08.000000000 +0100
+++ /var/tmp/portage/irssi-0.8.6-r2/work/irssi-0.8.6/src/fe-common/core/fe-messages.c	2003-04-05 \
00:50:51.000000000 +0100 @@ -152,11 +152,18 @@
 	if (nickrec == NULL &amp;&amp; chanrec != NULL)
                 nickrec = nicklist_find(chanrec, nick);
 
+    /* DEBUG 
+     * identify any public messages intended for me.
+     * identify if we should hilight a senders nick name.
+     */
 	for_me = !settings_get_bool("hilight_nick_matches") ? FALSE :
 		nick_match_msg(chanrec, msg, server-&gt;nick);
 	color = for_me ? NULL :
 		hilight_match_nick(server, target, nick, address, MSGLEVEL_PUBLIC, msg);
 
+    /* DEBUG
+     * should the current active channel be displayed? 
+     */
 	print_channel = chanrec == NULL ||
 		!window_item_is_active((WI_ITEM_REC *) chanrec);
 	if (!print_channel &amp;&amp; settings_get_bool("print_active_channel") &amp;&amp;
@@ -164,7 +171,9 @@
 		print_channel = TRUE;
 
 	level = MSGLEVEL_PUBLIC;
-	if (for_me || color != NULL)
+
+    /* if nick is being hilighted then up the level */
+    if (for_me)
 		level |= MSGLEVEL_HILIGHT;
 
 	if (settings_get_bool("emphasis"))
@@ -181,11 +190,14 @@
 	if (!print_channel) {
 		/* message to active channel in window */
 		if (color != NULL) {
-			/* highlighted nick */
+			/* current channel - with highlighted nick */
 			printformat(server, target, level,
 				    TXT_PUBMSG_HILIGHT,
 				    color, printnick, msg, nickmode);
 		} else {
+            /* current channel - without hilighted nick 
+             * (except if message directed to you)
+             */
 			printformat(server, target, level,
 				    for_me ? TXT_PUBMSG_ME : TXT_PUBMSG,
 				    printnick, msg, nickmode);
@@ -198,6 +210,8 @@
 				    TXT_PUBMSG_HILIGHT_CHANNEL,
 				    color, printnick, target, msg, nickmode);
 		} else {
+
+            /* non active channel messages */
 			printformat(server, target, level,
 				    for_me ? TXT_PUBMSG_ME_CHANNEL :
 				    TXT_PUBMSG_CHANNEL,
diff -bur irssi-0.8.6/src/fe-common/core/hilight-text.c \
                /var/tmp/portage/irssi-0.8.6-r2/work/irssi-0.8.6/src/fe-common/core/hilight-text.c
                
--- irssi-0.8.6/src/fe-common/core/hilight-text.c	2002-10-14 13:10:02.000000000 +0100
+++ /var/tmp/portage/irssi-0.8.6-r2/work/irssi-0.8.6/src/fe-common/core/hilight-text.c	2003-04-05 \
22:38:05.000000000 +0100 @@ -38,11 +38,11 @@
 
 static NICKMATCH_REC *nickmatch;
 static int never_hilight_level, default_hilight_level;
-GSList *hilights;
+GList *hilights;
 
 static void reset_cache(void)
 {
-	GSList *tmp;
+	GList *tmp;
 
         never_hilight_level = MSGLEVEL_ALL &amp; ~default_hilight_level;
 	for (tmp = hilights; tmp != NULL; tmp = tmp-&gt;next) {
@@ -55,6 +55,7 @@
 	nickmatch_rebuild(nickmatch);
 }
 
+/* add a hilight record to config */
 static void hilight_add_config(HILIGHT_REC *rec)
 {
 	CONFIG_NODE *node;
@@ -81,6 +82,7 @@
 	}
 }
 
+/* remove a hilight record from config */
 static void hilight_remove_config(HILIGHT_REC *rec)
 {
 	CONFIG_NODE *node;
@@ -88,9 +90,10 @@
 	g_return_if_fail(rec != NULL);
 
 	node = iconfig_node_traverse("hilights", FALSE);
-	if (node != NULL) iconfig_node_list_remove(node, g_slist_index(hilights, rec));
+    if (node != NULL) iconfig_node_list_remove(node, g_list_index(hilights, rec));
 }
 
+/* free() data asociated with a hilight record*/
 static void hilight_destroy(HILIGHT_REC *rec)
 {
 	g_return_if_fail(rec != NULL);
@@ -105,91 +108,74 @@
 	g_free(rec);
 }
 
+/* remove and free() _ALL_ hilight records */
 static void hilights_destroy_all(void)
 {
-	g_slist_foreach(hilights, (GFunc) hilight_destroy, NULL);
-	g_slist_free(hilights);
+    g_list_foreach(hilights, (GFunc) hilight_destroy, NULL);
+    g_list_free(hilights);
 	hilights = NULL;
 }
 
+/* init hilight record by compiling the regexp if neccisary */
 static void hilight_init_rec(HILIGHT_REC *rec)
 {
 #ifdef HAVE_REGEX_H
 	if (rec-&gt;regexp_compiled) regfree(&amp;rec-&gt;preg);
-	rec-&gt;regexp_compiled = !rec-&gt;regexp ? FALSE :
-		regcomp(&amp;rec-&gt;preg, rec-&gt;text, REG_EXTENDED|REG_ICASE) == 0;
+    rec-&gt;regexp_compiled = !rec-&gt;regexp ? FALSE :regcomp(&amp;rec-&gt;preg, rec-&gt;text, \
REG_EXTENDED|REG_ICASE) == 0;  #endif
 }
 
+/* record the new hilight record into the 
+ * hilight list and add config 
+ */
 void hilight_create(HILIGHT_REC *rec)
 {
-	if (g_slist_find(hilights, rec) != NULL) {
-		hilights = g_slist_remove(hilights, rec);
-		hilight_remove_config(rec);
-	}
-
-	hilights = g_slist_append(hilights, rec);
+    /* CHANGED
+     * No longer tryes to replace duplicate records
+     * two identical records still have different priorities
+     * and it is possible that a user might want
+     * to take advantage of that.
+     */
+
+    /* append the record to the hilights list */
+    hilights = g_list_append(hilights, rec);
+    /* add config */
 	hilight_add_config(rec);
-
+    /* compile regexp if neccisary */
 	hilight_init_rec(rec);
 
 	signal_emit("hilight created", 1, rec);
 }
 
+
+/* delete a hilight record and associated config data */
 void hilight_remove(HILIGHT_REC *rec)
 {
 	g_return_if_fail(rec != NULL);
 
 	hilight_remove_config(rec);
-	hilights = g_slist_remove(hilights, rec);
+    hilights = g_list_remove(hilights, rec);
 
 	signal_emit("hilight destroyed", 1, rec);
 	hilight_destroy(rec);
 }
 
-static HILIGHT_REC *hilight_find(const char *text, char **channels)
-{
-	GSList *tmp;
-	char **chan;
-
-	g_return_val_if_fail(text != NULL, NULL);
-
-	for (tmp = hilights; tmp != NULL; tmp = tmp-&gt;next) {
-		HILIGHT_REC *rec = tmp-&gt;data;
-
-		if (g_strcasecmp(rec-&gt;text, text) != 0)
-			continue;
-
-		if ((channels == NULL &amp;&amp; rec-&gt;channels == NULL))
-			return rec; /* no channels - ok */
-
-		if (channels != NULL &amp;&amp; strcmp(*channels, "*") == 0)
-			return rec; /* ignore channels */
-
-		if (channels == NULL || rec-&gt;channels == NULL)
-			continue; /* other doesn't have channels */
-
-		if (strarray_length(channels) != strarray_length(rec-&gt;channels))
-			continue; /* different amount of channels */
-
-		/* check that channels match */
-		for (chan = channels; *chan != NULL; chan++) {
-			if (strarray_find(rec-&gt;channels, *chan) == -1)
-                                break;
-		}
-
-		if (*chan == NULL)
-			return rec; /* channels ok */
-	}
-
-	return NULL;
-}
-
+/* take an input TEXT and try to match the hilight REC to it and
+ * locate a substring that needs to be hilighted.
+ * The substring boundary is returned by a start/end index into 
+ * the TEXT
+ * false is returned if no match found else true.
+ */
 static int hilight_match_text(HILIGHT_REC *rec, const char *text,
 			      int *match_beg, int *match_end)
 {
 	char *match;
 
+    /* TODO if match_beg !- NULL then only search the text after that char 
+     * this could allow hilighting of multiple match occurences within one message
+     */
+
+    /* if -regexp used */
 	if (rec-&gt;regexp) {
 #ifdef HAVE_REGEX_H
 		regmatch_t rmatch[1];
@@ -204,6 +190,7 @@
 			return TRUE;
 		}
 #endif
+    /* if -full used */ 
 	} else {
 		match = rec-&gt;fullword ?
 			stristr_full(text, rec-&gt;text) :
@@ -220,55 +207,13 @@
         return FALSE;
 }
 
-#define hilight_match_level(rec, level) \
-	(level &amp; (((rec)-&gt;level != 0 ? rec-&gt;level : default_hilight_level)))
+/* return true if record matches the specified level */
+#define hilight_match_level(rec, lev) \
+    (lev &amp; (((rec)-&gt;level != 0 ? rec-&gt;level : default_hilight_level)))
 
+/* return true if record matches the specified channel */
 #define hilight_match_channel(rec, channel) \
-	((rec)-&gt;channels == NULL || ((channel) != NULL &amp;&amp; \
-		strarray_find((rec)-&gt;channels, (channel)) != -1))
-
-HILIGHT_REC *hilight_match(SERVER_REC *server, const char *channel,
-			   const char *nick, const char *address,
-			   int level, const char *str,
-                           int *match_beg, int *match_end)
-{
-	GSList *tmp;
-        CHANNEL_REC *chanrec;
-	NICK_REC *nickrec;
-
-	g_return_val_if_fail(str != NULL, NULL);
-
-	if ((never_hilight_level &amp; level) == level)
-		return NULL;
-
-	if (nick != NULL) {
-                /* check nick mask hilights */
-		chanrec = channel_find(server, channel);
-		nickrec = chanrec == NULL ? NULL :
-			nicklist_find(chanrec, nick);
-		if (nickrec != NULL) {
-                        HILIGHT_REC *rec;
-
-			if (nickrec-&gt;host == NULL)
-				nicklist_set_host(chanrec, nickrec, address);
-
-			rec = nickmatch_find(nickmatch, nickrec);
-			if (rec != NULL &amp;&amp; hilight_match_level(rec, level))
-				return rec;
-		}
-	}
-
-	for (tmp = hilights; tmp != NULL; tmp = tmp-&gt;next) {
-		HILIGHT_REC *rec = tmp-&gt;data;
-
-		if (!rec-&gt;nickmask &amp;&amp; hilight_match_level(rec, level) &amp;&amp;
-		    hilight_match_channel(rec, channel) &amp;&amp;
-		    hilight_match_text(rec, str, match_beg, match_end))
-			return rec;
-	}
-
-        return NULL;
-}
+    ((rec)-&gt;channels == NULL || ((channel) != NULL &amp;&amp; strarray_find((rec)-&gt;channels, \
(channel)) != -1))  
 static char *hilight_get_act_color(HILIGHT_REC *rec)
 {
@@ -291,6 +236,9 @@
 	return format_string_expand(color, NULL);
 }
 
+/* This alters the message level to include HILIGHT 
+ * it also alters the priority?
+ */
 static void hilight_update_text_dest(TEXT_DEST_REC *dest, HILIGHT_REC *rec)
 {
 	dest-&gt;level |= MSGLEVEL_HILIGHT;
@@ -305,50 +253,74 @@
 		dest-&gt;hilight_color = hilight_get_act_color(rec);
 }
 
-static void sig_print_text(TEXT_DEST_REC *dest, const char *text,
+/* CHANGED!! will now apply _all_ hilight records that can be matched 
+ * instead of only applying the first one
+ */
+static void sig_print_text(TEXT_DEST_REC *dest, 
+        const char *text,
 			   const char *stripped)
 {
 	HILIGHT_REC *hilight;
-	char *color, *newstr;
-	int old_level, hilight_start, hilight_end, hilight_len;
-	int nick_match;
+    char *color=NULL, *newstr=NULL;
+    int old_level, hilight_start=0, hilight_end, hilight_len;
+
+    int n=0;
+    GList *hlist;
+    newstr=g_strdup(text);
 
 	if (dest-&gt;level &amp; MSGLEVEL_NOHILIGHT)
 		return;
 
-        hilight_start = hilight_end = 0;
-	hilight = hilight_match(dest-&gt;server, dest-&gt;target,
-				NULL, NULL, dest-&gt;level, stripped,
-				&amp;hilight_start,
-				&amp;hilight_end);
-	if (hilight == NULL)
+    /* CHECK 
+     * not sure if I need this? 
+     * it was used in the hilight_match() function which is no
+     * longer used here, so I thought I should replace it's 
+     * functionality by moving it here?
+     */
+    if ((never_hilight_level &amp; dest-&gt;level) == dest-&gt;level)
 		return;
 
-	nick_match = hilight-&gt;nick &amp;&amp; (dest-&gt;level &amp; (MSGLEVEL_PUBLIC|MSGLEVEL_ACTIONS)) == \
                MSGLEVEL_PUBLIC;
-
 	old_level = dest-&gt;level;
-	if (!nick_match || (dest-&gt;level &amp; MSGLEVEL_HILIGHT)) {
-		/* update the level / hilight info */
-		hilight_update_text_dest(dest, hilight);
-	}
 
-	if (nick_match)
-		return; /* fe-messages.c should have taken care of this */
+    hilight_start = hilight_end = 0;
 
-	if (old_level &amp; MSGLEVEL_HILIGHT) {
-		/* nick is highlighted, just set priority */
-		return;
+    n=0;/* reset hilight-rec-match counter */
+
+    for (hlist = hilights; hlist != NULL; hlist = hlist-&gt;next) {
+        hilight = hlist-&gt;data;
+
+        /* TODO could make hilight_start and hilight_end into lists 
+         * incase there are multiple occurences within one message 
+         */
+        /* NOTE that this code completly ignores -mask records since
+         * we cant determining where the nick is at this stage?
+         * -mask is handled by fe-messages, but that means you can't use -line
+         * or -word with -mask.
+         */
+        /* if this hilight record does _not_ match this message */
+        if ((hilight-&gt;nick &amp;&amp; !hilight-&gt;word) ||/* (fe-messages hilights the -nick \
rules) */ +            hilight-&gt;nickmask ||/* no way to determin where the nick is at \
this stage */ +            !hilight_match_level(hilight, dest-&gt;level) ||
+            !hilight_match_channel(hilight, dest-&gt;target) ||
+            !hilight_match_text(hilight, stripped, &amp;hilight_start, &amp;hilight_end))
+        {
+            continue;
 	}
 
+        n++;/* inc count of hilights matched for this message */
+
+        /* update message level (mark as hilighted + set priority.) */
+        hilight_update_text_dest(dest, hilight);
+
 	color = hilight_get_color(hilight);
 	hilight_len = hilight_end-hilight_start;
 
-	if (!hilight-&gt;word) {
-		/* hilight whole line */
-		char *tmp = strip_codes(text);
-		newstr = g_strconcat(color, tmp, NULL);
-                g_free(tmp);
-	} else {
+        /* if used -line */
+        if (!hilight-&gt;word &amp;&amp; !hilight-&gt;nick) {
+            hilight_len = hilight_end = strlen(stripped);
+            hilight_start=0;
+        }
+
 		/* hilight part of the line */
                 GString *tmp;
                 char *middle, *lastcolor;
@@ -357,25 +329,25 @@
                 tmp = g_string_new(NULL);
 
                 /* start of the line */
-		pos = strip_real_length(text, hilight_start, NULL, NULL);
-		g_string_append(tmp, text);
+        pos = strip_real_length(newstr, hilight_start, NULL, NULL);
+        g_string_append(tmp, newstr);
                 g_string_truncate(tmp, pos);
 
 		/* color */
                 g_string_append(tmp, color);
 
 		/* middle of the line, stripped */
-		middle = strip_codes(text+pos);
+        middle = strip_codes(newstr+pos);
                 pos = tmp-&gt;len;
 		g_string_append(tmp, middle);
                 g_string_truncate(tmp, pos+hilight_len);
                 g_free(middle);
 
 		/* end of the line */
-		pos = strip_real_length(text, hilight_end,
+        pos = strip_real_length(newstr, hilight_end,
 					&amp;color_pos, &amp;color_len);
 		if (color_pos &gt; 0)
-			lastcolor = g_strndup(text+color_pos, color_len);
+            lastcolor = g_strndup(newstr+color_pos, color_len);
                 else {
                         /* no colors in line, change back to default */
 			lastcolor = g_malloc0(3);
@@ -383,11 +355,27 @@
                         lastcolor[1] = FORMAT_STYLE_DEFAULTS;
 		}
 		g_string_append(tmp, lastcolor);
-		g_string_append(tmp, text+pos);
+        g_string_append(tmp, newstr+pos);
 		g_free(lastcolor);
 
                 newstr = tmp-&gt;str;
                 g_string_free(tmp, FALSE);
+
+        /* TODO repeat this but only search after the end of this current match
+         * to check for multiple occurences of the same record
+         * Note: only do this if -word is used!!
+         */
+        /* TODO another option is only matching against the last part of the string \
after  +         * this match. (somthing recursive may be..?)
+         */
+    }
+
+    if(!n)/* if no hilight rules were matched */
+        return;
+
+    if (old_level &amp; MSGLEVEL_HILIGHT) {
+        /* if this message is already hilighted? */
+        return;
 	}
 
 	signal_emit("print text", 3, dest, newstr, stripped);
@@ -398,19 +386,62 @@
 	signal_stop();
 }
 
+
+/* if you used -nick then fe-messages consults here to
+ * see if a particular message should have the sender nick hilighted.
+ *
+ * look through all -nick hilight records and try to
+ * find if the specified nick should be colored?
+ *
+ * Note: this searches is reverse order so that records highest on
+ * the "stack"? i.e. most recent have a higher priority.
+ */
+
+/* CHECK!!
+ * I didn't really follow the way -mask was handled before and
+ * think I am missing out some of the checks you had before??
+ * this seems to work in the same was as far as I have been able to tell
+ * but suspect it doesn't really. :) ?
+ */
 char *hilight_match_nick(SERVER_REC *server, const char *channel,
 			 const char *nick, const char *address,
 			 int level, const char *msg)
 {
         HILIGHT_REC *rec;
-	char *color;
+    GList *tmp;
+    int match_beg, match_end;
 
-	rec = hilight_match(server, channel, nick, address,
-			    level, msg, NULL, NULL);
-	color = rec == NULL || !rec-&gt;nick ? NULL :
-		hilight_get_color(rec);
+    g_return_val_if_fail(msg != NULL, NULL);
+
+    if ((never_hilight_level &amp; level) == level)
+        return NULL;
+   
+    /* loop through all hilight records */
+    for (tmp = g_list_last(hilights); tmp != NULL; tmp = tmp-&gt;prev) {
+        rec = tmp-&gt;data;
+
+        /* only interested in -nick records */
+        if(!rec-&gt;nick)continue;
+
+        if (hilight_match_level(rec, level) &amp;&amp;
+            hilight_match_channel(rec, channel))
+            {
+                /* if this record should only match against the nickname */
+                if(rec-&gt;nickmask){
+                    if((rec-&gt;regexp || rec-&gt;fullword) ? 
+                        hilight_match_text(rec, nick, &amp;match_beg, &amp;match_end) 
+                      : 
+                        match_wildcards(rec-&gt;text, nick)
+                      )
+                        return hilight_get_color(rec);
+                }else{
+                    if(hilight_match_text(rec, msg, &amp;match_beg, &amp;match_end))
+                        return hilight_get_color(rec);
+                }
+            }
+    }
 
-	return color;
+    return NULL;
 }
 
 static void read_hilight_config(void)
@@ -440,7 +471,7 @@
 			continue;
 
 		rec = g_new0(HILIGHT_REC, 1);
-		hilights = g_slist_append(hilights, rec);
+        hilights = g_list_append(hilights, rec);
 
 		rec-&gt;text = g_strdup(text);
 
@@ -470,6 +501,8 @@
         reset_cache();
 }
 
+
+/* output current list of hilight records to user */
 static void hilight_print(int index, HILIGHT_REC *rec)
 {
 	char *chans, *levelstr;
@@ -516,7 +549,7 @@
 
 static void cmd_hilight_show(void)
 {
-	GSList *tmp;
+    GList *tmp;
 	int index;
 
 	printformat(NULL, NULL, MSGLEVEL_CLIENTCRAP, TXT_HILIGHT_HEADER);
@@ -529,9 +562,13 @@
 	printformat(NULL, NULL, MSGLEVEL_CLIENTCRAP, TXT_HILIGHT_FOOTER);
 }
 
-/* SYNTAX: HILIGHT [-nick | -word | -line] [-mask | -full | -regexp]
+/* SYNTAX: HILIGHT [-nick | -word | -line] [-full | -regexp]
                    [-color &lt;color&gt;] [-actcolor &lt;color&gt;] [-level &lt;level&gt;]
-		   [-channels &lt;channels&gt;] &lt;text&gt; */
+   [-channels &lt;channels&gt;] [-mask] &lt;text&gt; */
+
+/* if you use the /hilight cmd to enter a new rule, 
+ * then the text you enter comes here...
+ */
 static void cmd_hilight(const char *data)
 {
         GHashTable *optlist;
@@ -553,8 +590,16 @@
 
 	chanarg = g_hash_table_lookup(optlist, "channels");
 	levelarg = g_hash_table_lookup(optlist, "level");
-	priorityarg = g_hash_table_lookup(optlist, "priority");
+    priorityarg = g_hash_table_lookup(optlist, "priority"); /* DEBUG ?? */
 	colorarg = g_hash_table_lookup(optlist, "color");
+    /* TODO it would be nice of the color parameter could accept 
+     * somthing like %U,%u and %a
+     * to say 'choose a unique hilight color'
+     * %u = unique non bright color
+     * %U = unique bright color
+     * %a = any unique color
+     * if a unique color can't be found then choose a random one?
+     */
 	actcolorarg = g_hash_table_lookup(optlist, "actcolor");
 
 	if (*text == '\0') cmd_param_error(CMDERR_NOT_ENOUGH_PARAMS);
@@ -562,24 +607,28 @@
 	channels = (chanarg == NULL || *chanarg == '\0') ? NULL :
 		g_strsplit(replace_chars(chanarg, ',', ' '), " ", -1);
 
-	rec = hilight_find(text, channels);
-	if (rec == NULL) {
+    /* CHANGED
+     * so multiple records can have the same match pattern
+     */
 		rec = g_new0(HILIGHT_REC, 1);
 
-		/* default to nick/word hilighting */
-                rec-&gt;nick = TRUE;
-		rec-&gt;word = TRUE;
+    /* should matching be limmited to just nick names? */
+    rec-&gt;nickmask = g_hash_table_lookup(optlist, "mask") != NULL;
 
 		rec-&gt;text = g_strdup(text);
 		rec-&gt;channels = channels;
-	} else {
-		g_strfreev(channels);
-	}
 
 	rec-&gt;level = (levelarg == NULL || *levelarg == '\0') ? 0 :
 		level2bits(replace_chars(levelarg, ',', ' '));
 	rec-&gt;priority = priorityarg == NULL ? 0 : atoi(priorityarg);
 
+    /* default to nick/word hilighting
+     * unless -mask is used in which case default to -nick hilighting 
+     */
+    rec-&gt;nick = TRUE; 
+    rec-&gt;word = rec-&gt;nickmask ? FALSE : TRUE;
+
+    /* how should messages that match be hilighted? */
 	if (g_hash_table_lookup(optlist, "line") != NULL) {
 		rec-&gt;word = FALSE;
 		rec-&gt;nick = FALSE;
@@ -590,10 +639,12 @@
                 rec-&gt;nick = FALSE;
 	}
 
-	if (g_hash_table_lookup(optlist, "nick") != NULL)
+    if (g_hash_table_lookup(optlist, "nick") != NULL) {
+        rec-&gt;word = FALSE;
                 rec-&gt;nick = TRUE;
+    }
 
-	rec-&gt;nickmask = g_hash_table_lookup(optlist, "mask") != NULL;
+    /* how should matching be performed? */
 	rec-&gt;fullword = g_hash_table_lookup(optlist, "full") != NULL;
 	rec-&gt;regexp = g_hash_table_lookup(optlist, "regexp") != NULL;
 
@@ -608,23 +659,113 @@
 			rec-&gt;act_color = g_strdup(actcolorarg);
 	}
 
+    /* NOTE shouldn't check if this is a duplicate record!
+     * because its position in the list changes how it
+     * actually matches.
+     */
+
 	hilight_create(rec);
 
-	hilight_print(g_slist_index(hilights, rec)+1, rec);
+    hilight_print(g_list_index(hilights, rec)+1, rec);
         cmd_params_free(free_arg);
 
 	reset_cache();
 }
 
-/* SYNTAX: DEHILIGHT &lt;id&gt;|&lt;mask&gt; */
+
+/* CHANGED!! this now only used by dehilight for trying to match records
+ * by their text mask
+ */
+static HILIGHT_REC *hilight_find(const char *text, char **channels)
+{
+    GList *tmp;
+    char **chan;
+
+    g_return_val_if_fail(text != NULL, NULL);
+
+    for (tmp = hilights; tmp != NULL; tmp = tmp-&gt;next) {
+        HILIGHT_REC *rec = tmp-&gt;data;
+
+        if (g_strcasecmp(rec-&gt;text, text) != 0)
+            continue;
+
+        if ((channels == NULL &amp;&amp; rec-&gt;channels == NULL))
+            return rec; /* no channels - ok */
+
+        if (channels != NULL &amp;&amp; strcmp(*channels, "*") == 0)
+            return rec; /* ignore channels */
+
+        if (channels == NULL || rec-&gt;channels == NULL)
+            continue; /* other doesn't have channels */
+
+        if (strarray_length(channels) != strarray_length(rec-&gt;channels))
+            continue; /* different amount of channels */
+
+        /* check that channels match */
+        for (chan = channels; *chan != NULL; chan++) {
+            if (strarray_find(rec-&gt;channels, *chan) == -1)
+                break;
+        }
+
+        if (*chan == NULL)
+            return rec; /* channels ok */
+    }
+
+    return NULL;
+}
+
+
+/* CHANGE -pop option will simply remove the last hilight record you added */
+/* SYNTAX: DEHILIGHT [-pop &lt;count&gt;| -clear] &lt;id&gt;|&lt;mask&gt; */
 static void cmd_dehilight(const char *data)
 {
+    GHashTable *optlist;
 	HILIGHT_REC *rec;
-	GSList *tmp;
+    GList *tmp;
+    void *free_arg;
+    char *text;
+    char *poparg;
+    int popcount=0;
 
-	if (is_numeric(data, ' ')) {
+    if (!cmd_get_params(data, &amp;free_arg, 1 | PARAM_FLAG_OPTIONS |
+                PARAM_FLAG_GETREST, "dehilight", &amp;optlist, &amp;text))
+        return;
+
+    /* if -pop used then remove the last &lt;count&gt; hilight records added */
+    if((poparg = g_hash_table_lookup(optlist, "pop")) != NULL){
+        popcount = *poparg == '\0' ? 1 : atoi(poparg);
+        popcount = popcount == 0 ? -1 : popcount;
+    }
+
+    /* if -clear used then remove all hilight records */
+    if(g_hash_table_lookup(optlist, "clear") != NULL){
+        popcount = g_list_length(hilights);
+        popcount = popcount == 0 ? -1 : popcount;
+    }
+
+    /* _The Popper!_ */
+    if(popcount){
+        while(popcount--&gt;0)
+        {
+            tmp = g_list_last(hilights);
+            rec = tmp == NULL ? NULL : tmp-&gt;data;
+            if(rec != NULL){
+                printformat(NULL, NULL, MSGLEVEL_CLIENTNOTICE, TXT_HILIGHT_REMOVED, \
rec-&gt;text); +                hilight_remove(rec);
+                reset_cache();
+            }
+        }
+        /* ignore any other options */
+        return;
+    }
+    
+    /* if no parameters give then simple pop the last record */
+    if(*data == '\0'){
+        tmp = g_list_last(hilights);
+        rec = tmp == NULL ? NULL : tmp-&gt;data;
+    }else if (is_numeric(data, ' ')) {
 		/* with index number */
-		tmp = g_slist_nth(hilights, atoi(data)-1);
+        tmp = g_list_nth(hilights, atoi(data)-1);
 		rec = tmp == NULL ? NULL : tmp-&gt;data;
 	} else {
 		/* with mask */
@@ -639,12 +780,14 @@
 		hilight_remove(rec);
                 reset_cache();
 	}
+    
+    cmd_params_free(free_arg);
 }
 
 static void hilight_nick_cache(GHashTable *list, CHANNEL_REC *channel,
 			       NICK_REC *nick)
 {
-	GSList *tmp;
+    GList *tmp;
 	HILIGHT_REC *match;
         char *nickmask;
 	int len, best_match;
@@ -696,6 +839,7 @@
 
 	command_bind("hilight", NULL, (SIGNAL_FUNC) cmd_hilight);
 	command_bind("dehilight", NULL, (SIGNAL_FUNC) cmd_dehilight);
+    command_set_options("dehilight", "-pop -clear");
 	command_set_options("hilight", "-color -actcolor -level -priority -channels nick \
word line mask full regexp");  }
 
diff -bur irssi-0.8.6/src/fe-common/core/hilight-text.h \
                /var/tmp/portage/irssi-0.8.6-r2/work/irssi-0.8.6/src/fe-common/core/hilight-text.h
                
--- irssi-0.8.6/src/fe-common/core/hilight-text.h	2002-05-19 07:50:50.000000000 +0100
+++ /var/tmp/portage/irssi-0.8.6-r2/work/irssi-0.8.6/src/fe-common/core/hilight-text.h	2003-04-05 \
22:15:48.000000000 +0100 @@ -7,6 +7,8 @@
 
 typedef struct _HILIGHT_REC HILIGHT_REC;
 
+
+/* this structure desribes a hilight rule, made using the /hilight cmd */
 struct _HILIGHT_REC {
 	char *text;
 
@@ -17,24 +19,37 @@
         char *act_color; /* color for window activity */
 	int priority;
 
-	unsigned int nick:1; /* hilight only nick if possible */
-	unsigned int word:1; /* hilight only word, not full line */
-
-	unsigned int nickmask:1; /* `text' is a nick mask */
+    /* how to hilight matches..
+        tt=nick and word(default)
+        tf=only nick
+        ft=only word
+        ff=whole line
+    */
+	unsigned int nick:1;
+	unsigned int word:1; 
+
+	unsigned int nickmask:1; /* `text' is a nick mask (only matching against nicks \
done)*/ +    
+    /* how to match 
+     * tt=nothing
+     * tf=fullword
+     * ft=regexp
+     * ff=wild
+     */
 	unsigned int fullword:1; /* match `text' only for full words */
 	unsigned int regexp:1; /* `text' is a regular expression */
+
 #ifdef HAVE_REGEX_H
 	unsigned int regexp_compiled:1; /* should always be TRUE, unless regexp is invalid \
*/  regex_t preg;
 #endif
 };
 
-extern GSList *hilights;
+extern GList *hilights;
 
 HILIGHT_REC *hilight_match(SERVER_REC *server, const char *channel,
 			   const char *nick, const char *address,
-			   int level, const char *str,
-			   int *match_beg, int *match_end);
+			   int level, const char *str);
 
 char *hilight_match_nick(SERVER_REC *server, const char *channel,
 			 const char *nick, const char *address,
Only in /var/tmp/portage/irssi-0.8.6-r2/work/irssi-0.8.6/src/fe-common/core/: tags


["hilight_help.patch" (text/plain)]

Only in /var/tmp/portage/irssi-0.8.6-r2/work/irssi-0.8.6/docs/help/: Makefile
diff -bur irssi-0.8.6/docs/help/dehilight \
                /var/tmp/portage/irssi-0.8.6-r2/work/irssi-0.8.6/docs/help/dehilight
--- irssi-0.8.6/docs/help/dehilight	2002-11-19 10:13:57.000000000 +0000
+++ /var/tmp/portage/irssi-0.8.6-r2/work/irssi-0.8.6/docs/help/dehilight	2003-04-06 \
00:24:01.000000000 +0100 @@ -1,5 +1,11 @@
 
-DEHILIGHT %|&lt;id&gt;|&lt;mask&gt;
+DEHILIGHT %|-pop &lt;count&gt; | -clear | &lt;id&gt; | &lt;mask&gt;
+
+  -pop: remove the last &lt;count&gt; hilight rules that you added.
+  -clear: remove all hilight rules.
+  &lt;id&gt;: remove a rule using it's unique id.
+        (/hilight gives you a list)
+  &lt;mask&gt;: remove a rule that uses this mask.
 
 Removes the specified item from highlight list.
 
diff -bur irssi-0.8.6/docs/help/hilight \
                /var/tmp/portage/irssi-0.8.6-r2/work/irssi-0.8.6/docs/help/hilight
--- irssi-0.8.6/docs/help/hilight	2002-11-19 10:13:57.000000000 +0000
+++ /var/tmp/portage/irssi-0.8.6-r2/work/irssi-0.8.6/docs/help/hilight	2003-04-06 \
00:52:26.000000000 +0100 @@ -1,23 +1,35 @@
 
 HILIGHT %|[-nick | -word | -line] [-mask | -full | -regexp] [-color &lt;color&gt;] \
[-actcolor &lt;color&gt;] [-level &lt;level&gt;] [-channels &lt;channels&gt;] &lt;text&gt;  
-   -mask: Match only for nick, &lt;text&gt; is a nick mask
+How to match:
    -regexp: &lt;text&gt; is a regular expression
    -full: &lt;text&gt; must match to full words
-   -nick: Hilight only the nick, not the whole line (default)
+        (default is simple substring matching, except
+        when using -mask, wildcard matching is used)
+
+Limits on matching:
+   -mask: Match only for nick, &lt;text&gt; is a nick mask 
+           (if you use this it will always hilight -nick
+           i.e you can't use -line or -word with it)
+   -level: Match only for &lt;level&gt; messages, default is
+           publics,msgs,notices,actions
+   -channels: Match only in &lt;channels&gt;
+
+How to hilight matches:
+   -nick: Hilight only the nick, not the whole line
    -word: Hilight only the word (default with non-public messages)
    -line: Hilight the whole line with the hilight color.
-   -color: Print the message with &lt;color&gt;. color is in %%code format
+          (default is -nick and -word)
+
+   -color: Hilight with &lt;color&gt;. color is in %%code format
            (see docs/formats.txt)
    -actcolor: Color to show in statusbar activity, or don't change if %%n.
-   -level: Match only for &lt;level&gt; messages, default is
-           publics,msgs,notices,actions
-   -channels: Match only in &lt;channels&gt;
 
 Examples:
 
-Hilight lines that have "mynick" word:
-  /HILIGHT mynick
+Hilight lines that contain "word" 
+  /HILIGHT word
+  (will hilight nick and "word")
 
 Hilight lines that were written by nicks from *.fi with bold green
   /HILIGHT -color %%G -mask *!*@*.fi
Only in /var/tmp/portage/irssi-0.8.6-r2/work/irssi-0.8.6/docs/help/in: Makefile



</body></email><email><emailId>20030413115859</emailId><senderName>Florian Geiges</senderName><senderEmail>florian.geiges@t-online.de</senderEmail><timestampReceived>2003-04-13 11:58:59-0400</timestampReceived><subject>Re: possible problem with chanmode +w</subject><body>

sorry, left out my version, 13:58:08 -!- Irssi: Client: irssi 0.8.6 (20021117 1611)

mfg again, 
florian

</body></email><email><emailId>20030416153237</emailId><senderName>Marcus Rueckert</senderName><senderEmail>darix@web.de</senderEmail><timestampReceived>2003-04-16 15:32:37-0400</timestampReceived><subject>Re: highlight on dcc?</subject><body>

On 2003-04-16 13:14:35 +0200, Joakim Kolsj wrote:
&gt; This is sort of an feature request.
&gt; 
&gt; DCC file requests don't appear as messages targeted directly to me (red),
&gt; but as uninteresting info(gray), and because of that i never notice them
&gt; until someone tells me to recive what they are sending.
&gt; 
&gt; Would it be a good thing to change this in the official irssi?, i guess it is
&gt; easy to fix but would someone complain?

/set activity_hilight_level MSGS DCCMSGS DCCS

try this.

darix

-- 
irssi - the client of the smart and beautiful people

              http://www.irssi.de/


</body></email><email><emailId>20030419125027</emailId><senderName>Wouter Coekaerts</senderName><senderEmail>wouter@coekaerts.be</senderEmail><timestampReceived>2003-04-19 12:50:27-0400</timestampReceived><subject>Re: irssi and channel mode +d</subject><body>

Op zaterdag 19 april 2003 04:12, schreef splidge:
&gt; I've noticed that irssi will ignore channel mode +d if it's set on a
&gt; channel (i.e. not display it in the channel status).  From the source code
&gt; this looks intentional, placing +d in the same category as +e, +I etc.
&gt; (modes which are complex but the client doesn't really know about).
&gt;
&gt; This presents a problem for me as I'd like to add a +d channelmode to
&gt; QuakeNet's ircd, and being a large network we have a non-trivial number of
&gt; irssi users.  The mode would be a "simple" mode (i.e. set or cleared, with
&gt; no parameters)[1].
&gt;
&gt; Myself and others have looked and haven't found any major network which
&gt; uses +d as a more complex channel mode (i.e. unsuitable for displaying in
&gt; the status bar).  Would it be possible to change the behaviour in irssi for
&gt; future releases?

From changelog:

2001-12-17 19:47  Timo Sirainen &lt;tss@iki.fi&gt;

        * src/irc/core/modes.h: mode +d is now also treated as having
        argument (hybrid 7 / dancer realname ban)

2002-04-26 13:04  Timo Sirainen &lt;tss@iki.fi&gt;

        * src/irc/core/modes.c: Don't treat +d as regular channel mode.

Greets,

Wouter.


</body></email><email><emailId>20030426110139</emailId><senderName>David Leadbeater</senderName><senderEmail>dgl@otherwize.co.uk</senderEmail><timestampReceived>2003-04-26 11:01:39-0400</timestampReceived><subject>005 support (was Re: irssi and channel mode +d)</subject><body>

On Sat, Apr 19, 2003 at 10:47:15AM +0100, David Leadbeater wrote:
&gt; 005 numeric support would be nice and solve many problems like this but I
&gt; don't think it's trival to add to Irssi either.

Well, I decided to do it anyway. I know cras said he was planning to
do it for 0.9, but I want it *now* not some time in the future ;-).

I've got a patch that adds support for the 005 numeric, puts the
data it sends into a glib hash and makes use of CHANMODES, PREFIX,
CASEMAPPING and MODES. Other values are usable from the glib hash
in C or the $server-&gt;isupport method in perl scripts.

Please note that I cut lots of corners doing this with the rationale
that if this was planned for 0.9 bits of Irssi's internals could be
changed to suit more dynamic support for things like this.

Hopefully this also makes some patches such asthe ones to add support
for other prefixes obselete..

The patch is a bit big for a mailing list so it is at
http://babylon.otherwize.co.uk/irssi-isupport.diff

It was based on the internet draft at:
http://www.ietf.org/internet-drafts/draft-brocklesby-irc-isupport-01.txt
But hopefully most of the stuff it deals with is consistant across
servers anyway.


</body></email><email><emailId>20030315133623</emailId><senderName>Joost Vunderink</senderName><senderEmail>joost@carnique.nl</senderEmail><timestampReceived>2003-03-15 13:36:23-0400</timestampReceived><subject>The Irssi Documentation Project</subject><body>

[Attachment #2 (multipart/mixed)]


Hi,

as you all know the one thing that's seriously lagging behind in irssi
is its documentation. reffie (from #irssi/IRCNet) and I have therefore
started a small project to fix this.

Attached you will find a document about this project. The goal, the
means, the reasons, everything.

Please read the document and tell us what you think. We hope that this
way we can soon have a framework for irssi documentation so that anyone
who wants to, can easily contribute to the documentation by writing a
part, no matter how small.

Greetings,
reffie and Garion.

--=20
Joost Vunderink
http://www.garion.org/

["irssidoc.txt" (text/plain)]

Project for irssi documentation.

Project start: 2003-02-26
Project members: reffie, Garion
Last update: 2003-03-04 by Garion

20030314 [Garion] Added info about templates and submitting.
20030314 [Garion] Added some more global properties for the docs.
20030314 [Garion] Added "scripts" and "config files" sections.
20030304 [Garion] Added pod as possible language alternative.


# ---------------------------------------------------------------------

What is the goal of this document?

As you might have noticed, there is no good and/or complete documentation
for irssi at this point in time.

This document shall determine a framework for irssi documentation, so
multiple people can start contributing to documentation for irssi.

# ---------------------------------------------------------------------

What is going to happen with this document?

First, it shall reside in the topic of #irssi for a while, to get as
much feedback as possible. When the document is nearing its final
first phase stages, it shall be sent to irssi-dev and irssi-users.

# ---------------------------------------------------------------------

Who is responsible for this document?

At the moment, reffie and Garion.

# ---------------------------------------------------------------------

How can I best comment on this document?

Emailing garion@irssi.org with your comments is the preferred way.
Or join #irssi @ IRCnet and comment there.

Most importantly, we'd like to have your opinion on:
1) docbook
2) code commenting
See below for explanation.

Another way for you to help with this project is to collect FAQ questions,
with or without answers, and send them to faq@irssi.org. This way, we
can already begin building a large collection of FAQ items and think
of a proper way to divide them into (sub)sections.

# ---------------------------------------------------------------------

What properties should irssi documentation have?

- It must be accessible through at least http, irssi, and command-line.
  (not _all_ the docs from below need be accessible inside irssi).
  
- It must all be in the same style/format.

- It must be searchable.

- It must be divided in logical sections, subsections and sub-sub-sections.

- It must be easy for someone to create help for a (sub)section.
  This means that anyone must be able to write help for a (sub)section
  without having to know what others have already written.

- In some way, the available link tags must be published somewhere. This
  way anyone who is writing help for a section can easily find out the
  names of links in other sections, so he/she can link to other sections
  without having to read them.

- It must be in some repository for easy version maintenance and
  moderation.


# ---------------------------------------------------------------------

Sections and subsections

* How to use the online documentation, and how/where to ask for further help

* Introduction - basic tasks in irssi
  * your first steps
  * joining/parting channels
  * creating queries/dcc chats
  * switching windows
  * showing and changing settings
  * creating and using aliases
  * creating and using keybindings
  * saving your settings and window layout

* Windowing - all help about window management
  * the statuswindow
  * creation, destruction
  * automatic creation and destruction
  * switching windows
  * moving around window items between windows
  * statusbars - creation and configuration
      [should statusbars be a separate section?]
  * split windows vs hidden windows
  * setting/changing window levels

* Advanced commands in irssi
  * hilight
  * ignore
  * upgrade
  * logging
  * using &lt;tab&gt; completion
  * completion
  * notify
  * executing shell commands
  * executing perl script commands
  * Irssi-proxy - explanation and tutorial

* Servers, channels, queries
  * proper ircnet/server/channel config
  
* Using Scripts - installing, upgrading, (auto)running scripts
  * introduction
  * getting scripts
  * (auto)running scripts
  * scriptassist

* Formats, themes, levels - a section with some leftovers
  * colors
  * existing formats
  * message levels

* Settings
  * list and explanation of all settings
  * list of all keybindings

* Config files
  * ~/.irssi/config
  * ~/.irssi/default.theme
  * runnig multiple irssis with different configuration files

* Scripting - all help about writing scripts
  * introduction (plus Your First Script)
  * headers
  * classes with members and member functions
  * signals with description and arguments
  * use Irssi::&lt;whatever&gt; descriptions
  * interaction between scripts
  * timers and delays
  * getting data from a server (/whois, /who)
  * getting properties of channels/clients
  * window functions (create, move, send text to)
  * message levels usage (MSGLEVEL_*)
  * creating and using new formats
  * theme functions
  * special variables
  * using numerics
  * statusbar items
  * finishing up your script - good practices
  * submitting your script to the scripts archive

* Command reference
  * all commands, alphabetically ordered
    [this is what you will get when you do /help &lt;function&gt; in irssi]

* FAQ - Frequently Asked Questions

* Installing irssi
  * per OS
  * in your homedir, if you don't have root privileges

* Switching - switching from a different client to irssi: why and how?
  * from BitchX
  * from ircii
  * from EPIC
  * from ScrollZ
  * from xchat
  * from mIRC or other windows GUI clients

* Troubleshooting - what to do when you encounter problems
  * what to do when you can't get your script working
  * error messages during startup


* About irssi - copyright, credits, etc

* Glossary - terms and abbreviations

# ---------------------------------------------------------------------

The Language of the documentation.

Obviously, to save effort, this documentation should be written in
some language that can easily be converted to other 'languages', like
HTML, manpages, irssi help files, whatever.

Also, it must allow formatting, linking, keyword definition, etc.

It seems that docbook is a good choice for this.

Creating docbook documents is apparently not easy to do in a text
editor, unless it is capable of docbook syntax highlighting. One of the
tools that could be used to create docbook documents is LyX, which is
available for both *nix and windows.

A possible alternative seems to be wiki, which is a way to make shared
documents via a browser. But, is this also a viable way to get indexed
and searchable docs?

Another alternative is pod. This is a bit like doc++ and javadoc, but
then for perl.


Comments? Alternatives? Argumentation?

# ---------------------------------------------------------------------

Templates and acceptance of submitted documentation

As soon as the language for the documentation has been chosen, one of
the first things that needs to be done is the creation of documentation
templates. This will ensure that all (sub)sections of the documentation
will have the same look and layout, and that someone who wants to write
some documentation will have an easy start.

Additionally, a document on "how to create irssi documentation for a 
(sub)section" needs to be made.

And finally, some process of moderation (everything submitted to the
documentation should be reviewed, of course) and then storage of the
submitted (sub)section into the irssi documentation storage area needs
to be done.

# ---------------------------------------------------------------------

Problems

One of the main problems there will probably arise is keeping the API 
documentation in sync with irssi's code.
If cras (the author of irssi) changes the arguments of a certain
event, this must be updated in the documentation as well.

This points towards code-comments generated documentation, for a part
of the documentation at least.

# ---------------------------------------------------------------------



[Attachment #6 (application/pgp-signature)]

</body></email><email><emailId>20030204013104</emailId><senderName>GrayWolf</senderName><senderEmail>graywolf@i-differ.net</senderEmail><timestampReceived>2003-02-04 01:31:04-0400</timestampReceived><subject>Getting internal Irssi variables in a script</subject><body>

All,

I am wondering how I can pull variables such as $F and $Z into a perl
script for Irssi. As things stand I can pull in the actual time with
either `date` or time() but seem to be up against a wall getting $F pulled
in to calculate client uptime.

-GW


</body></email><email><emailId>20030213113100</emailId><senderName>Athan</senderName><senderEmail>irssi@miggy.org</senderEmail><timestampReceived>2003-02-13 11:31:00-0400</timestampReceived><subject>Re: irssi and dccserv</subject><body>

[Attachment #2 (multipart/mixed)]


On Thu, Feb 13, 2003 at 09:42:55AM +0000, Athanasius wrote:
&gt;   I've only just gotten the DCC GET working yesterday and haven't had
&gt; chance to test vanilla CVS to see if the same problem is there.  I'll
&gt; try and get to that today and post a patch whatever by the end of the
&gt; day.

  OK, it didn't like the changes in fe-common/irc/dcc/module-formats.h
I'd made but actually never used, looks to be working now.  Patch
attached.

  This defines 5 new variables:

11:19 [dcc]
11:19 dcc_server_port = 9008
11:19 dcc_server_send = ON
11:19 dcc_server_fserve = OFF
11:19 dcc_server_chat = ON
11:19 dcc_server = ON

dcc_server turns the whole thing on or off.
dcc_server_port sets the port you listen on locally.  Either change this
to suit the fserve you're using, or you can do as I do if you have root
and simply redirect requisite ip:port's to this port which also means I
can make use of servers using port 59, for example.
dcc_server_chat controls whether or not the client accepts chats done
this way.
dcc_server_send controls whether or not the client accepts file
transfers done this way.
dcc_server_fserve is there but currently unsupported (I've not seen
anything using it).

As for the patch itself, as I said before it's HACKY.  Anyone more
familiar with the irssi DCC code can feel free to rework it to be less
hacky.  Possibly re-working all of the DCC CHAT/SEND to split into parts
that accept connection and then another that finishes setting things up
once you have the open connection.
  src/irc/dcc/dcc-server.c is the heart of things (and the mess ;), with
a few changes to other files in that directory, plus core/network.c to
support the changes.  Normal DCC CHAT/GEt should be entirely unaffected
by these changes.
  It's POSSIBLE I've still got a race condition or two in there between
reading a command on the initial TCP connection and converting it into a
chat/get, but I think I finally got that sorted out.
  dcc_server_nick_resolve() is a horrible hack to match up an incoming
connection to a server:nick we can currently see.
  convert_dcc_server_to_chat() and convert_dcc_server_to_send() are the
bits that munge the extant TCP connection into a DCC CHAT or GET as
required.

  I've actually only tested this locally so far, using mirc/sysreset
under wine and a local ircd, so if there are any race conditions or bugs
lurking in there using it on a full network will probably show them up.

-Ath
-- 
- Athanasius = Athanasius(at)miggy.org / http://www.miggy.org/
                  Finger athan(at)fysh.org for PGP key
	   "And it's me who is my enemy. Me who beats me up.
Me who makes the monsters. Me who strips my confidence." Paula Cole - ME

["irssi-dccserver.diff" (text/plain)]

diff -r -u -N --exclude-from=irssi-dontdiff irssi-CVS-200302131108/src/core/network.c \
                irssi-CVS/src/core/network.c
--- irssi-CVS-200302131108/src/core/network.c	Tue Dec 10 16:36:26 2002
+++ irssi-CVS/src/core/network.c	Thu Feb 13 10:28:42 2003
@@ -410,6 +410,26 @@
 	return 0;
 }
 
+/* Get socket peer address/port */
+int net_getpeername(GIOChannel *handle, IPADDR *addr, int *port)
+{
+	union sockaddr_union so;
+	socklen_t addrlen;
+
+	g_return_val_if_fail(handle != NULL, -1);
+	g_return_val_if_fail(addr != NULL, -1);
+
+	addrlen = sizeof(so);
+	if (getpeername(g_io_channel_unix_get_fd(handle),
+			(struct sockaddr *) &amp;so, &amp;addrlen) == -1)
+		return -1;
+
+        sin_get_ip(&amp;so, addr);
+	if (port) *port = sin_get_port(&amp;so);
+
+	return 0;
+}
+
 /* Get IP addresses for host, both IPv4 and IPv6 if possible.
    If ip-&gt;family is 0, the address wasn't found.
    Returns 0 = ok, others = error code for net_gethosterror() */
diff -r -u -N --exclude-from=irssi-dontdiff \
                irssi-CVS-200302131108/src/irc/dcc/Makefile \
                irssi-CVS/src/irc/dcc/Makefile
--- irssi-CVS-200302131108/src/irc/dcc/Makefile	Thu Feb 13 11:10:43 2003
+++ irssi-CVS/src/irc/dcc/Makefile	Thu Feb 13 10:55:15 2003
@@ -116,7 +116,7 @@
 INCLUDES =  	-I$(top_srcdir)/src 	-I$(top_srcdir)/src/core/ \
-I$(top_srcdir)/src/irc/core/ 	$(GLIB_CFLAGS)  
 
-libirc_dcc_a_SOURCES =  	dcc.c 	dcc-chat.c 	dcc-get.c 	dcc-send.c 	dcc-resume.c \
dcc-autoget.c 	dcc-queue.c +libirc_dcc_a_SOURCES =  	dcc.c 	dcc-chat.c 	dcc-get.c \
dcc-send.c 	dcc-resume.c 	dcc-autoget.c 	dcc-queue.c 	dcc-server.c  
 
 noinst_HEADERS =  	dcc-rec.h 	dcc-file-rec.h 	dcc.h 	dcc-file.h 	dcc-chat.h \
dcc-get.h 	dcc-send.h 	dcc-queue.h 	module.h @@ -134,7 +134,7 @@
 libirc_dcc_a_LIBADD = 
 libirc_dcc_a_OBJECTS =  dcc.$(OBJEXT) dcc-chat.$(OBJEXT) \
 dcc-get.$(OBJEXT) dcc-send.$(OBJEXT) dcc-resume.$(OBJEXT) \
-dcc-autoget.$(OBJEXT) dcc-queue.$(OBJEXT)
+dcc-autoget.$(OBJEXT) dcc-queue.$(OBJEXT) dcc-server.$(OBJEXT)
 AR = ar
 CFLAGS =  
 COMPILE = $(CC) $(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) \
$(CFLAGS) @@ -151,7 +151,8 @@
 TAR = tar
 GZIP_ENV = --best
 DEP_FILES =  .deps/dcc-autoget.P .deps/dcc-chat.P .deps/dcc-get.P \
-.deps/dcc-queue.P .deps/dcc-resume.P .deps/dcc-send.P .deps/dcc.P
+.deps/dcc-queue.P .deps/dcc-resume.P .deps/dcc-send.P \
+.deps/dcc-server.P .deps/dcc.P
 SOURCES = $(libirc_dcc_a_SOURCES)
 OBJECTS = $(libirc_dcc_a_OBJECTS)
 
diff -r -u -N --exclude-from=irssi-dontdiff \
                irssi-CVS-200302131108/src/irc/dcc/Makefile.am \
                irssi-CVS/src/irc/dcc/Makefile.am
--- irssi-CVS-200302131108/src/irc/dcc/Makefile.am	Mon Nov 11 06:35:12 2002
+++ irssi-CVS/src/irc/dcc/Makefile.am	Thu Feb 13 10:28:42 2003
@@ -13,7 +13,8 @@
 	dcc-send.c \
 	dcc-resume.c \
 	dcc-autoget.c \
-	dcc-queue.c
+	dcc-queue.c \
+	dcc-server.c
 
 noinst_HEADERS = \
 	dcc-rec.h \
diff -r -u -N --exclude-from=irssi-dontdiff \
                irssi-CVS-200302131108/src/irc/dcc/Makefile.in \
                irssi-CVS/src/irc/dcc/Makefile.in
--- irssi-CVS-200302131108/src/irc/dcc/Makefile.in	Thu Feb 13 11:10:38 2003
+++ irssi-CVS/src/irc/dcc/Makefile.in	Thu Feb 13 10:28:42 2003
@@ -116,7 +116,7 @@
 INCLUDES =  	-I$(top_srcdir)/src 	-I$(top_srcdir)/src/core/ \
-I$(top_srcdir)/src/irc/core/ 	$(GLIB_CFLAGS)  
 
-libirc_dcc_a_SOURCES =  	dcc.c 	dcc-chat.c 	dcc-get.c 	dcc-send.c 	dcc-resume.c \
dcc-autoget.c 	dcc-queue.c +libirc_dcc_a_SOURCES =  	dcc.c 	dcc-chat.c 	dcc-get.c \
dcc-send.c 	dcc-resume.c 	dcc-autoget.c 	dcc-queue.c 	dcc-server.c  
 
 noinst_HEADERS =  	dcc-rec.h 	dcc-file-rec.h 	dcc.h 	dcc-file.h 	dcc-chat.h \
dcc-get.h 	dcc-send.h 	dcc-queue.h 	module.h @@ -134,7 +134,7 @@
 libirc_dcc_a_LIBADD = 
 libirc_dcc_a_OBJECTS =  dcc.$(OBJEXT) dcc-chat.$(OBJEXT) \
 dcc-get.$(OBJEXT) dcc-send.$(OBJEXT) dcc-resume.$(OBJEXT) \
-dcc-autoget.$(OBJEXT) dcc-queue.$(OBJEXT)
+dcc-autoget.$(OBJEXT) dcc-queue.$(OBJEXT) dcc-server.$(OBJEXT)
 AR = ar
 CFLAGS = @CFLAGS@
 COMPILE = $(CC) $(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) \
$(CFLAGS) @@ -151,7 +151,8 @@
 TAR = tar
 GZIP_ENV = --best
 DEP_FILES =  .deps/dcc-autoget.P .deps/dcc-chat.P .deps/dcc-get.P \
-.deps/dcc-queue.P .deps/dcc-resume.P .deps/dcc-send.P .deps/dcc.P
+.deps/dcc-queue.P .deps/dcc-resume.P .deps/dcc-send.P \
+.deps/dcc-server.P .deps/dcc.P
 SOURCES = $(libirc_dcc_a_SOURCES)
 OBJECTS = $(libirc_dcc_a_OBJECTS)
 
diff -r -u -N --exclude-from=irssi-dontdiff \
                irssi-CVS-200302131108/src/irc/dcc/dcc-chat.c \
                irssi-CVS/src/irc/dcc/dcc-chat.c
--- irssi-CVS-200302131108/src/irc/dcc/dcc-chat.c	Sun May 26 18:39:35 2002
+++ irssi-CVS/src/irc/dcc/dcc-chat.c	Thu Feb 13 10:28:42 2003
@@ -34,7 +34,7 @@
 
 #include "dcc-chat.h"
 
-static char *dcc_chat_get_new_id(const char *nick)
+char *dcc_chat_get_new_id(const char *nick)
 {
         char *id;
 	int num;
@@ -285,7 +285,7 @@
 }
 
 /* input function: DCC CHAT received some data.. */
-static void dcc_chat_input(CHAT_DCC_REC *dcc)
+void dcc_chat_input(CHAT_DCC_REC *dcc)
 {
         char tmpbuf[512], *str;
 	int recvlen, ret;
diff -r -u -N --exclude-from=irssi-dontdiff \
                irssi-CVS-200302131108/src/irc/dcc/dcc-get.c \
                irssi-CVS/src/irc/dcc/dcc-get.c
--- irssi-CVS-200302131108/src/irc/dcc/dcc-get.c	Thu Nov 21 17:48:40 2002
+++ irssi-CVS/src/irc/dcc/dcc-get.c	Thu Feb 13 10:28:42 2003
@@ -172,7 +172,7 @@
 }
 
 /* callback: net_connect() finished for DCC GET */
-static void sig_dccget_connected(GET_DCC_REC *dcc)
+void sig_dccget_connected(GET_DCC_REC *dcc)
 {
 	struct stat statbuf;
 	char *fname, *tempfname;
diff -r -u -N --exclude-from=irssi-dontdiff \
                irssi-CVS-200302131108/src/irc/dcc/dcc-resume.c \
                irssi-CVS/src/irc/dcc/dcc-resume.c
--- irssi-CVS-200302131108/src/irc/dcc/dcc-resume.c	Thu Nov 21 17:48:40 2002
+++ irssi-CVS/src/irc/dcc/dcc-resume.c	Thu Feb 13 10:28:42 2003
@@ -123,7 +123,7 @@
 }
 
 /* Resume a DCC GET */
-static void dcc_send_resume(GET_DCC_REC *dcc)
+void dcc_send_resume(GET_DCC_REC *dcc)
 {
         off_t pos;
 	char *str;
diff -r -u -N --exclude-from=irssi-dontdiff \
                irssi-CVS-200302131108/src/irc/dcc/dcc-server.c \
                irssi-CVS/src/irc/dcc/dcc-server.c
--- irssi-CVS-200302131108/src/irc/dcc/dcc-server.c	Thu Jan  1 01:00:00 1970
+++ irssi-CVS/src/irc/dcc/dcc-server.c	Thu Feb 13 10:13:42 2003
@@ -0,0 +1,536 @@
+/*
+ dcc-server.c : irssi
+
+    Copyright (C) 1999-2001 Timo Sirainen
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#include &lt;ctype.h&gt;
+
+#include "module.h"
+#include "signals.h"
+#include "commands.h"
+#include "network.h"
+#include "net-nonblock.h"
+#include "net-sendbuffer.h"
+#include "line-split.h"
+#include "misc.h"
+#include "settings.h"
+
+#include "irc-servers.h"
+#include "irc-queries.h"
+#include "masks.h"
+#include "nicklist.h"
+
+#include "dcc-server.h"
+#include "dcc-chat.h"
+#include "dcc-get.h"
+
+/* extern functions */
+extern char *dcc_chat_get_new_id(const char *nick);
+extern void dcc_chat_input(CHAT_DCC_REC *dcc);
+extern void sig_dccget_connected(GET_DCC_REC *dcc);
+
+/* Prototype local functions */
+
+void dcc_server_stop(void);
+static void sig_dcc_server_listen(void *data);
+static void dcc_server_input(DCC_SERVER_REC *rec);
+void dcc_server_destroy(DCC_SERVER_REC *rec);
+void convert_dcc_server_to_chat(DCC_SERVER_REC *rec);
+void convert_dcc_server_to_fserve(DCC_SERVER_REC *rec);
+void convert_dcc_server_to_send(DCC_SERVER_REC *rec, char *filesize,
+                                char *filename);
+
+static int dcc_server;
+static u_int16_t dcc_server_port;
+static int dcc_server_chat;
+static int dcc_server_fserve;
+static int dcc_server_send;
+static int running = FALSE;
+static u_int16_t running_port = 0;
+GIOChannel *dcc_server_listen_handle = NULL;
+int dcc_server_listen_tag;
+
+void dcc_server_start(void)
+{
+	int port;
+
+	if (running)
+	{
+	/* Already running, might be able to leave it as-is, may need
+	 * to make changes
+	 */
+		if (running_port != dcc_server_port)
+		{
+		/* Need to restart on new port */
+			dcc_server_stop();
+		} else
+		{
+			return;
+		}
+	}
+
+	running = FALSE;
+	if (dcc_server_port &lt; IPPORT_RESERVED)
+	{
+		g_warning("dcc_server_port must be at least %d\n", IPPORT_RESERVED);
+		return;
+	}
+	port = dcc_server_port;
+	dcc_server_listen_handle = net_listen(NULL, &amp;port);
+	if (dcc_server_listen_handle == NULL)
+	{
+		g_warning("Couldn't start listening dcc server\n");
+		return;
+	}
+
+	running = TRUE;
+	running_port = dcc_server_port;
+	dcc_server_listen_tag = g_input_add(dcc_server_listen_handle,
+	                         G_INPUT_READ,
+	                         (GInputFunction) sig_dcc_server_listen, NULL);
+}
+
+void dcc_server_stop(void)
+{
+	if (!running)
+	{
+		return;
+	}
+
+	net_disconnect(dcc_server_listen_handle);
+	running = FALSE;
+	running_port = 0;
+}
+
+static void sig_dcc_server_listen(void *data)
+{
+	DCC_SERVER_REC *rec;
+	IPADDR ip;
+	GIOChannel *handle;
+	int ret;
+
+	handle = net_accept(dcc_server_listen_handle, &amp;ip, NULL);
+	if (handle == NULL)
+	{
+		return;
+	}
+
+	rec = g_new0(DCC_SERVER_REC, 1);
+	rec-&gt;handle = handle;
+	rec-&gt;created = time(NULL);
+	rec-&gt;addr = ip;
+	net_ip2host(&amp;rec-&gt;addr, rec-&gt;ipaddrstr);
+	if ((ret = net_gethostbyaddr(&amp;rec-&gt;addr, &amp;rec-&gt;addrstr)))
+	{
+		g_error("DCC Server: accepting connection, error - %s\n", net_gethosterror(ret));
+	}
+	net_getsockname(handle, &amp;rec-&gt;addr, &amp;rec-&gt;port);
+	rec-&gt;sendbuf = net_sendbuffer_create(handle, 0);
+	rec-&gt;tagread = g_input_add(handle, G_INPUT_READ,
+	                           (GInputFunction) dcc_server_input, rec);
+
+	signal_emit("dcc server connected", 1, rec);
+}
+
+static void dcc_server_input(DCC_SERVER_REC *rec)
+{
+	char tmpbuf[1024], *str;
+	int ret, recvlen;
+
+	recvlen = rec-&gt;handle == NULL ? -1 :
+		net_receive(rec-&gt;handle, tmpbuf, sizeof(tmpbuf));
+	if (recvlen == -1)
+	{
+		return;
+	}
+	ret = line_split(tmpbuf, recvlen, &amp;str, &amp;rec-&gt;readbuf);
+
+	if (ret != 0)
+	{
+		if (ret == -1)
+		{
+			/* connection lost */
+			dcc_server_destroy(rec);
+		} else
+		{
+			signal_emit("dcc server event", 2, rec, str);
+			memset(tmpbuf, 0, 1024);
+		}
+	}
+}
+
+void dcc_server_destroy(DCC_SERVER_REC *rec)
+{
+	line_split_free(rec-&gt;readbuf);
+	net_sendbuffer_destroy(rec-&gt;sendbuf, 0);
+	net_disconnect(rec-&gt;handle);
+}
+
+extern GSList *servers;
+
+int dcc_server_nick_resolve(DCC_SERVER_REC *rec, char *nick)
+{
+	GSList *s, *nicklist;
+	char *h;
+
+	g_return_val_if_fail(rec != NULL, FALSE);
+	rec-&gt;nickname = g_strdup(nick); /* some limit on nick length */
+	rec-&gt;id = g_strdup(nick);
+
+	/* Walk the list of servers */
+	for (s = servers ; s != NULL ; s = s-&gt;next)
+	{
+		/* Lookup rec-&gt;nick on this server */
+		SERVER_REC *server = s-&gt;data;
+		if (NULL != (nicklist = nicklist_get_same(server, rec-&gt;nickname)))
+		{
+			GSList *n;
+			NICK_REC *nick;
+			for (n = nicklist ; n != NULL ; n = n-&gt;next)
+			{
+			/* Does the nick's host match what's in rec-&gt;addr */
+				nick = n-&gt;data;
+				if (NULL == (h = strchr(nick-&gt;host, '@')))
+				{
+					continue;
+				}
+				h++;
+				if (strstr(rec-&gt;addrstr, h)
+				    || strstr(rec-&gt;ipaddrstr, h))
+				{
+					rec-&gt;server = IRC_SERVER(server);
+					rec-&gt;nick = nick;
+					return TRUE;
+				}
+			}
+		}
+	}
+
+	return FALSE;
+}
+
+/* The heart of the /dccserver protocol handling:
+ *
+ * Chat Protocol
+ * Client connects to Server and sends:
+ * 100 &lt;client nickname&gt;
+ * When Server receives this, it sends:
+ * 101 &lt;server nickname&gt;
+ * Connection is established, users can now chat.
+ *
+ * Fserve Protocol
+ * Client connects to Server and sends:
+ * 110 &lt;client nickname&gt;
+ * When Server receives this, it sends:
+ * 111 &lt;server nickname&gt;
+ * Connection is established, user can now access fserve.
+ *
+ * Send Protocol
+ * Client connects to Server and sends:
+ * 120 &lt;client nickname&gt; &lt;file size&gt; &lt;filename&gt;
+ * When Server receives this, it sends:
+ * 121 &lt;server nickname&gt; &lt;resume position&gt;
+ *
+ * Where resume position is between 0 and file size, and is required.
+ * Connection is established, and Server dcc gets the file.
+ *
+ * Get Protocol
+ * Client connects to Server and sends:
+ * 130 &lt;client nickname&gt; &lt;filename&gt;
+ * When Server receives this, it sends:
+ * 131 &lt;server nickname&gt; &lt;file size&gt;
+ * When Client receives this, it sends:
+ * 132 &lt;client nickname&gt; &lt;resume position&gt;
+ * Where resume position is between 0 and file size, and is required.
+ * Connection is established, and Server dcc sends the file.
+ *
+ * Other
+ * If server receives unexpected information, or doesn't receive info 15
+ * seconds after initial connection, it closes the connection.
+ *
+ * If service is unavailable, server sends:
+ * 150 unavailable
+ *
+ * If server rejects connection, it sends:
+ * 151 rejected 
+ *
+ * Note the 'str' passed here has been through line_split() which strips
+ *  any \n on the end, so we don't have to worry about that here.
+ */
+static void dcc_server_event(DCC_SERVER_REC *rec, char *str)
+{
+	char reply[1024];
+
+	if (!isdigit(str[0]))
+	{
+	/* Messages start with a numeric */
+		dcc_server_destroy(rec);
+		return;
+	}
+	if (!strncmp(str, "100 ", 4))
+	{
+	/* Chat request */
+		if (!settings_get_bool("dcc_server_chat"))
+		{
+		/* We're not accepting CHATs this way */
+			strncpy(reply, "150 unavailable\n", sizeof(reply) - 1);
+			net_transmit(rec-&gt;handle, reply, strlen(reply));
+			dcc_server_destroy(rec);
+			return;
+		}
+		str += 4;	/* Now pointing to the nick they claim */
+		if (!dcc_server_nick_resolve(rec, str))
+		{
+			strncpy(reply, "151 rejected\n", sizeof(reply) - 1);
+			net_transmit(rec-&gt;handle, reply, strlen(reply));
+			dcc_server_destroy(rec);
+			return;
+		}
+		convert_dcc_server_to_chat(rec);
+	} else if (!strncmp(str, "110 ", 4))
+	{
+	/* Fserve request */
+		/* We don't support this */
+		strncpy(reply, "150 unavailable\n", sizeof(reply) - 1);
+		net_transmit(rec-&gt;handle, reply, strlen(reply));
+		dcc_server_destroy(rec);
+		return;
+#if 0
+		if (!settings_get_bool("dcc_server_fserve"))
+		{
+		/* We're not accepting CHATs this way */
+			strncpy(reply, "150 unavailable\n", sizeof(reply) - 1);
+			net_transmit(rec-&gt;handle, reply, strlen(reply));
+			dcc_server_destroy(rec);
+			return;
+		}
+		str += 4;
+		convert_dcc_server_to_fserve(rec);
+#endif
+	} else if (!strncmp(str, "120 ", 4))
+	{
+	/* Send request */
+		char *nick;
+		char *filesize;
+		char *filename;
+		if (!settings_get_bool("dcc_server_send"))
+		{
+		/* We're not accepting SENDs this way */
+			strncpy(reply, "150 unavailable\n", sizeof(reply) - 1);
+			net_transmit(rec-&gt;handle, reply, strlen(reply));
+			dcc_server_destroy(rec);
+			return;
+		}
+		str += 4;	/* Now pointing to the nick they claim */
+		/* 120 &lt;client nickname&gt; &lt;file size&gt; &lt;filename&gt; */
+		nick = str;
+		if (NULL == (filesize = strchr(nick, ' ')))
+		{
+			strncpy(reply, "151 rejected\n", sizeof(reply) - 1);
+			net_transmit(rec-&gt;handle, reply, strlen(reply));
+			dcc_server_destroy(rec);
+			return;
+		}
+		*filesize++ = '\0';
+		if (NULL == (filename = strchr(filesize, ' ')))
+		{
+			strncpy(reply, "151 rejected\n", sizeof(reply) - 1);
+			net_transmit(rec-&gt;handle, reply, strlen(reply));
+			dcc_server_destroy(rec);
+			return;
+		}
+		*filename++ = '\0';
+		if (!dcc_server_nick_resolve(rec, nick))
+		{
+			strncpy(reply, "151 rejected\n", sizeof(reply) - 1);
+			net_transmit(rec-&gt;handle, reply, strlen(reply));
+			dcc_server_destroy(rec);
+			return;
+		}
+		convert_dcc_server_to_send(rec, filesize, filename);
+	} else if (!strncmp(str, "130 ", 4))
+	{
+	/* Get request */
+		/* We don't support this */
+		strncpy(reply, "150 unavailable\n", sizeof(reply) - 1);
+		net_transmit(rec-&gt;handle, reply, strlen(reply));
+		dcc_server_destroy(rec);
+		return;
+		/*
+		str += 4;
+		convert_dcc_server_to_get(rec);
+		*/
+	} else
+	{
+	/* Unknown message */
+		strncpy(reply, "150 unavailable\n", sizeof(reply) - 1);
+		net_transmit(rec-&gt;handle, reply, strlen(reply));
+		dcc_server_destroy(rec);
+	}
+}
+
+/* The magical morphing functions, turn our DCC_SERVER_REC into
+ * one of the 'real' DCC types, without disconnecting or starting from
+ * scratch
+ */
+void convert_dcc_server_to_chat(DCC_SERVER_REC *rec)
+{
+	char reply[1024];
+	CHAT_DCC_REC *dcc;
+
+	dcc = g_new0(CHAT_DCC_REC, 1);
+	dcc-&gt;orig_type = dcc-&gt;type = DCC_CHAT_TYPE;
+	dcc-&gt;mirc_ctcp = settings_get_bool("dcc_mirc_ctcp");
+	dcc-&gt;id = dcc_chat_get_new_id(rec-&gt;nickname);
+
+	dcc_init_rec(DCC(dcc), rec-&gt;server, NULL, rec-&gt;nickname, "chat");
+
+	dcc-&gt;starttime = time(NULL);
+	dcc-&gt;handle = rec-&gt;handle;
+	dcc-&gt;sendbuf = net_sendbuffer_create(dcc-&gt;handle, 0);
+	memcpy(&amp;dcc-&gt;addr, &amp;rec-&gt;addr, sizeof(IPADDR));
+	net_ip2host(&amp;dcc-&gt;addr, dcc-&gt;addrstr);
+	dcc-&gt;port = settings_get_int("dcc_server_port");
+	dcc-&gt;tagread = g_input_add(dcc-&gt;handle, G_INPUT_READ,
+	                           (GInputFunction) dcc_chat_input, dcc);
+	signal_emit("dcc connected", 1, dcc);
+
+	/* Done with the DCC_SERVER_REC *rec now */
+	g_source_remove(rec-&gt;tagread);
+	g_source_remove_by_user_data(rec);
+	line_split_free(rec-&gt;readbuf);
+	rec-&gt;readbuf = NULL;
+	net_sendbuffer_destroy(rec-&gt;sendbuf, 0);
+	rec-&gt;sendbuf = NULL;
+	g_free(rec);
+
+	/* Safe to send our response */
+	g_snprintf(reply, sizeof(reply), "101 %s\n", dcc-&gt;server-&gt;nick);
+	net_transmit(dcc-&gt;handle, reply, strlen(reply));
+}
+
+void convert_dcc_server_to_fserve(DCC_SERVER_REC *rec)
+{
+}
+
+void convert_dcc_server_to_send(DCC_SERVER_REC *rec, char *filesize, char *filename)
+{
+	char reply[1024];
+	GET_DCC_REC *dcc;
+	IPADDR ipaddr;
+	size_t fsize = atoi(filesize);
+	int len, quoted = FALSE;
+
+	len = strlen(filename);
+	if (len &gt; 1 &amp;&amp; *filename == '"' &amp;&amp; filename[len-1] == '"') {
+		/* "file name" - MIRC sends filenames with spaces like
+		 * this */
+		filename[len-1] = '\0';
+		g_memmove(filename, filename+1, len);
+		quoted = TRUE;
+	}
+	/* dcc_get_create() equivalent BEGIN */
+	dcc = g_new0(GET_DCC_REC, 1);
+	dcc-&gt;orig_type = module_get_uniq_id_str("DCC", "SEND");
+	dcc-&gt;type = module_get_uniq_id_str("DCC", "GET");
+	dcc-&gt;fhandle = -1;
+
+	dcc_init_rec(DCC(dcc), rec-&gt;server, NULL, rec-&gt;nickname, filename);
+
+	dcc-&gt;starttime = time(NULL);
+	dcc-&gt;handle = rec-&gt;handle;
+	/* dcc_get_create() equivalent END */
+
+	dcc-&gt;target = g_strdup(rec-&gt;nickname);
+	memcpy(&amp;dcc-&gt;addr, &amp;rec-&gt;addr, sizeof(IPADDR));
+	if (dcc-&gt;addr.family == AF_INET)
+	{
+		net_ip2host(&amp;dcc-&gt;addr, dcc-&gt;addrstr);
+	} 
+#if 0
+	else
+	{
+		/* with IPv6, show it to us as it was sent */
+		strncpy(dcc-&gt;addrstr, address, sizeof(dcc-&gt;addrstr)-1);
+		dcc-&gt;addrstr[sizeof(dcc-&gt;addrstr)-1] = '\0';
+	}
+#endif
+	net_getpeername(dcc-&gt;handle, &amp;ipaddr, &amp;dcc-&gt;port);
+	dcc-&gt;size = str_to_uofft(filesize);
+	dcc-&gt;file_quoted = quoted;
+
+	/* Done with the DCC_SERVER_REC *rec now */
+	g_source_remove(rec-&gt;tagread);
+	g_source_remove_by_user_data(rec);
+	line_split_free(rec-&gt;readbuf);
+	rec-&gt;readbuf = NULL;
+	net_sendbuffer_destroy(rec-&gt;sendbuf, 0);
+	rec-&gt;sendbuf = NULL;
+	g_free(rec);
+
+	/* Start the actual GET to receive it */
+	if (settings_get_bool("dcc_autoresume")) {
+		dcc_send_resume(dcc);
+	}
+	dcc-&gt;tagconn = g_input_add(dcc-&gt;handle,
+	                           G_INPUT_WRITE | G_INPUT_READ,
+	                           (GInputFunction) sig_dccget_connected,
+	                           dcc);
+	/* Safe to send our response
+	 * 121 &lt;server nickname&gt; &lt;resume position&gt;
+	 */
+	g_snprintf(reply, sizeof(reply), "121 %s %d\n", dcc-&gt;server-&gt;nick,
+	           dcc-&gt;skipped);
+	net_transmit(dcc-&gt;handle, reply, strlen(reply));
+}
+
+static void read_settings(void)
+{
+	dcc_server = settings_get_bool("dcc_server");
+	dcc_server_port = settings_get_int("dcc_server_port");
+	dcc_server_chat = settings_get_bool("dcc_server_chat");
+	dcc_server_fserve = settings_get_bool("dcc_server_fserve");
+	dcc_server_send = settings_get_bool("dcc_server_send");
+
+	if (dcc_server)
+	{
+		dcc_server_start();
+	} else
+	{
+		dcc_server_stop();
+	}
+}
+
+void dcc_server_init(void)
+{
+	settings_add_int("dcc", "dcc_server_port", 9007);
+	settings_add_bool("dcc", "dcc_server_chat", FALSE);
+	settings_add_bool("dcc", "dcc_server_fserve", FALSE);
+	settings_add_bool("dcc", "dcc_server_send", FALSE);
+
+	read_settings();
+
+	signal_add("setup changed", (SIGNAL_FUNC) read_settings);
+	signal_add("dcc server event", (SIGNAL_FUNC) dcc_server_event);
+}
+
+void dcc_server_deinit(void)
+{
+	signal_remove("setup changed", (SIGNAL_FUNC) read_settings);
+	signal_remove("dcc server event", (SIGNAL_FUNC) dcc_server_event);
+}
diff -r -u -N --exclude-from=irssi-dontdiff \
                irssi-CVS-200302131108/src/irc/dcc/dcc-server.h \
                irssi-CVS/src/irc/dcc/dcc-server.h
--- irssi-CVS-200302131108/src/irc/dcc/dcc-server.h	Thu Jan  1 01:00:00 1970
+++ irssi-CVS/src/irc/dcc/dcc-server.h	Thu Feb 13 10:13:42 2003
@@ -0,0 +1,34 @@
+#ifndef __DCC_SERVER_H
+#define __DCC_SERVER_H
+
+#include "dcc.h"
+
+struct DCC_SERVER_REC {
+	char *id; /* unique identifier - usually same as nick. */
+
+	/* To pass through to DCC CHAT/SEND */
+	time_t created;
+	IRC_SERVER_REC *server;
+	NICK_REC *nick;
+	char *nickname;
+	IPADDR addr; /* address we're connected in */
+	char *addrstr; /* in readable form */
+	char ipaddrstr[MAX_IP_LEN]; /* in readable form */
+	int port; /* port we're connected in */
+	GIOChannel *handle; /* socket handle */
+
+        LINEBUF_REC *readbuf;
+	int tagread;
+	NET_SENDBUF_REC *sendbuf;
+
+	unsigned int connection_lost:1; /* other side closed connection */
+};
+
+#define DCC_SERVER_TYPE module_get_uniq_id_str("DCC", "SERVER")
+
+CHAT_DCC_REC *dcc_server_find_id(const char *id);
+
+void dcc_server_init(void);
+void dcc_server_deinit(void);
+
+#endif
diff -r -u -N --exclude-from=irssi-dontdiff irssi-CVS-200302131108/src/irc/dcc/dcc.c \
                irssi-CVS/src/irc/dcc/dcc.c
--- irssi-CVS-200302131108/src/irc/dcc/dcc.c	Sat Dec 28 17:54:13 2002
+++ irssi-CVS/src/irc/dcc/dcc.c	Thu Feb 13 10:28:42 2003
@@ -41,6 +41,9 @@
 void dcc_autoget_init(void);
 void dcc_autoget_deinit(void);
 
+void dcc_server_init(void);
+void dcc_server_deinit(void);
+
 GSList *dcc_conns;
 
 static GSList *dcc_types;
@@ -516,6 +519,7 @@
 	settings_add_str("dcc", "dcc_port", "0");
 	settings_add_time("dcc", "dcc_timeout", "5min");
 	settings_add_str("dcc", "dcc_own_ip", "");
+	settings_add_bool("dcc", "dcc_server", FALSE);
 
 	signal_add("event connected", (SIGNAL_FUNC) sig_connected);
 	signal_add("server disconnected", (SIGNAL_FUNC) sig_server_disconnected);
@@ -534,6 +538,7 @@
 	dcc_send_init();
 	dcc_resume_init();
 	dcc_autoget_init();
+	dcc_server_init();
 
 	module_register("dcc", "irc");
 }
@@ -548,6 +553,7 @@
 	dcc_send_deinit();
 	dcc_resume_deinit();
 	dcc_autoget_deinit();
+	dcc_server_deinit();
 
 	signal_remove("event connected", (SIGNAL_FUNC) sig_connected);
 	signal_remove("server disconnected", (SIGNAL_FUNC) sig_server_disconnected);
diff -r -u -N --exclude-from=irssi-dontdiff irssi-CVS-200302131108/src/irc/dcc/dcc.h \
                irssi-CVS/src/irc/dcc/dcc.h
--- irssi-CVS-200302131108/src/irc/dcc/dcc.h	Sun Nov 25 17:35:47 2001
+++ irssi-CVS/src/irc/dcc/dcc.h	Thu Feb 13 10:28:42 2003
@@ -7,6 +7,7 @@
 #define DCC(dcc) ((DCC_REC *) (dcc))
 
 typedef struct CHAT_DCC_REC CHAT_DCC_REC;
+typedef struct DCC_SERVER_REC DCC_SERVER_REC;
 
 typedef struct {
 #include "dcc-rec.h"


[Attachment #6 (application/pgp-signature)]

</body></email><email><emailId>20030219205421</emailId><senderName>David Pashley</senderName><senderEmail>david@parguild.co.uk</senderEmail><timestampReceived>2003-02-19 20:54:21-0400</timestampReceived><subject>Some makefile.am clean ups</subject><body>

[Attachment #2 (multipart/mixed)]


The attached patch will delete those files which get build, but did not
get deleted before. Can you please apply.

--=20
David Pashley
david@davidpashley.com
Nihil curo de ista tua stulta superstitione.

["irssi.diff" (text/plain)]

diff -ru --exclude debian --exclude Makefile.in --exclude help --exclude CVS \
                irssi/Makefile.am irssi-build/Makefile.am
--- irssi/Makefile.am	2002-05-09 03:48:22.000000000 +0100
+++ irssi-build/Makefile.am	2003-02-18 13:13:07.000000000 +0000
@@ -12,6 +12,8 @@
 
 SUBDIRS = src docs scripts
 
+CLEANFILES=default-config.h default-theme.h
+
 confdir = $(sysconfdir)
 conf_DATA = irssi.conf
 
diff -ru --exclude debian --exclude Makefile.in --exclude help --exclude CVS \
                irssi/src/perl/Makefile.am irssi-build/src/perl/Makefile.am
--- irssi/src/perl/Makefile.am	2002-11-17 16:05:32.000000000 +0000
+++ irssi-build/src/perl/Makefile.am	2003-02-19 20:51:03.000000000 +0000
@@ -73,6 +73,8 @@
 irssi-core.pl.h: irssi-core.pl
 	$(top_srcdir)/file2header.sh $(srcdir)/irssi-core.pl irssi_core_code &gt; \
irssi-core.pl.h  
+CLEANFILES=perl-signals-list.h irssi-core.pl.h
+
 common_sources = \
 	common/Irssi.xs \
 	common/Irssi.pm \


[Attachment #6 (application/pgp-signature)]

</body></email><email><emailId>20030220075926</emailId><senderName>Piotr Krukowiecki</senderName><senderEmail>piotr@pingu.ii.uj.edu.pl</senderEmail><timestampReceived>2003-02-20 07:59:26-0400</timestampReceived><subject>Re: dcc-send-limiter.c patch again</subject><body>

On Wed, 19 Feb 2003, Piotr Krukowiecki wrote:

&gt; Attaching patch for dcc-send-limiter plugin again.

Yes. As usuall forgot to attach the patch.


-- 
Piotrek
irc: #debian.pl
Mors Drosophilis melanogastribus!

["dcc-send-limiter.c.diff" (text/plain)]

--- dcc-send-limiter.c	Sat Jan  4 21:50:05 2003
+++ dcc-send-limiter.c.moj	Wed Feb 19 18:11:39 2003
@@ -12,6 +12,11 @@
 
     Copyright (C) 2001 Timo Sirainen
 
+    Modified 2002/12/31 by Piotr Krukowiecki (Happy New Year! ;))
+    	* fixed unnecesary lag in sending data when send is resume
+    	* sends that were started before the module was loaded 
+    	  now are being limited as well
+
     Modified 2001/07/04 by Martin Persson
     	* updated to only keep track of the last 30 sec
 
@@ -162,7 +167,7 @@
 	mdcc = g_new0(MODULE_SEND_DCC_REC, 1);
 	MODULE_DATA_SET(dcc, mdcc);
 	mdcc-&gt;timeout_tag = -1;
-	mdcc-&gt;skip_bytes = 0;
+	mdcc-&gt;skip_bytes = dcc-&gt;transfd; /* now it works correct with dcc resume - doesn't \
wait 30s with sending data */  mdcc-&gt;max_speed = \
settings_get_int("dcc_send_top_speed");  
 	/* get starttime in milliseconds */
@@ -192,10 +197,20 @@
 
 void dcc_send_limiter_init(void)
 {
+	GSList *tmp;
 	settings_add_int("dcc", "dcc_send_top_speed", 30);
 
 	signal_add_last("dcc connected", (SIGNAL_FUNC) sig_dcc_connected);
 	signal_add_first("dcc destroyed", (SIGNAL_FUNC) sig_dcc_destroyed);
+	
+	/* Limit already existing sends */
+	for (tmp = dcc_conns; tmp != NULL; tmp = tmp-&gt;next) {
+		SEND_DCC_REC *dcc = tmp-&gt;data;
+		if (!IS_DCC_SEND(dcc)) continue;
+		if (!dcc_is_connected(dcc)) continue;
+		
+		sig_dcc_connected(dcc);
+	}
 
         module_register("dcc_send_limiter", "core");
 }



</body></email><email><emailId>20030224064626</emailId><senderName>Manoj Kasichainula</senderName><senderEmail>manojk+irssi.org@io.com</senderEmail><timestampReceived>2003-02-24 06:46:26-0400</timestampReceived><subject>Re: Irssi redesign / rewrite</subject><body>

On Mon, Jan 20, 2003 at 11:57:09AM +0200, Einar Karttunen wrote:
&gt; An another important point would be to make the scripting features
&gt; language independent i.e. not tie irssi with perl in any special way.
&gt; Just define a clean interface to which languages can easily attach
&gt; themselves.

Actually, I had started on an irssi-python module. I figured out the
conceptually difficult parts of embedding the interpreter, and
wrapped one of the object types (SERVER) in a Python class. With some
ideas from Timo, I got signal passing working as well, and got the
python refcounting to mesh with irssi refcounting as well, I think :)

What's left is better error handling, filling out more of the irssi
object types (including figuring out how exactly to represent a type
like SERVER-CONNECT which is entangled with SERVER, but isn't exactly a
super- or sub-class), and some other less interesting but necessary
feature decisions, like whether to attempt to provide a module unload
function in irssi or just require scripts to know how to do it.

I haven't done much with the module in the last several months, though.

&gt; Maybe using SWIG (http://www.swig.org) is an option for
&gt; this...

I briefly played with SWIG. It didn't seem to be very easy to map
the irssi API to objects as SWIG imagines them, and I wanted the Python
interface not to just be a bunch of C-like functions. It'd be nice if a
rewrite made this easier. :)

What I'd like to see most after a rewrite is some C API documentation.
:)

</body></email><email><emailId>20030225173004</emailId><senderName>"Geert Hauwaerts"</senderName><senderEmail>geert@safeweb.be</senderEmail><timestampReceived>2003-02-25 17:30:04-0400</timestampReceived><subject>Little patch by David Pashley.</subject><body>

Dear Sir,

Here is a patch by David Pashley for removing files auto-generated by the
configure script.
The auto-generated files are: default-config.h, default-theme.h,
perl-signals-list.h, irssi-core.pl.h

There seems to be something wrong with this mailinglist, he said he had
already posted it on this list, but was never sent to us.

Mvg, Geert Hauwaerts.
Certified Unix/Linux Administrator

/*
* Geert Hauwaerts geert@safeweb.be &amp; geert@irssi.org
* -----------------------------------------------------
*   Linux: The choice of a GNU generation.
*          Because rebooting is for adding new hardware.
*          Windows: Just another pain in the glass.
*          RTFM: Not just an acronym, it's the LAW!
*/

["irssi.patch" (application/octet-stream)]

diff -ru --exclude Makefile.in --exclude help --exclude debian \
                irssi-snapshot-0.8.6+cvs.20030218/Makefile.am irssi-build/Makefile.am
--- irssi-snapshot-0.8.6+cvs.20030218/Makefile.am	2002-05-09 03:48:22.000000000 +0100
+++ irssi-build/Makefile.am	2003-02-18 13:13:07.000000000 +0000
@@ -12,6 +12,8 @@
 
 SUBDIRS = src docs scripts
 
+CLEANFILES=default-config.h default-theme.h
+
 confdir = $(sysconfdir)
 conf_DATA = irssi.conf
 
diff -ru --exclude Makefile.in --exclude help --exclude debian \
irssi-snapshot-0.8.6+cvs.20030218/src/perl/Makefile.am \
                irssi-build/src/perl/Makefile.am
--- irssi-snapshot-0.8.6+cvs.20030218/src/perl/Makefile.am	2002-11-17 \
                16:05:32.000000000 +0000
+++ irssi-build/src/perl/Makefile.am	2003-02-19 20:51:04.000000000 +0000
@@ -73,6 +73,8 @@
 irssi-core.pl.h: irssi-core.pl
 	$(top_srcdir)/file2header.sh $(srcdir)/irssi-core.pl irssi_core_code &gt; \
irssi-core.pl.h  
+CLEANFILES=perl-signals-list.h irssi-core.pl.h
+
 common_sources = \
 	common/Irssi.xs \
 	common/Irssi.pm \



</body></email><email><emailId>20030227044151</emailId><senderName>Gleb</senderName><senderEmail>gleb@belg88.com</senderEmail><timestampReceived>2003-02-27 04:41:51-0400</timestampReceived><subject>Mandrake RPMs</subject><body>

Hey,

I'm sorry if this is in the wrong list, but I just wanted to mention I
build the Mandrake RPMs and am hosting them... I know it took me some
time to rebuild the RPMs, and thought that it may not be a bad idea to
make them publicly released so others won't have to wait as much as I
did. The build was done on Mandrake 9, on an i586 machine. Again, I
apologize if this is in the wrong list!


</body></email><email><emailId>20030104232221</emailId><senderName>Athan</senderName><senderEmail>irssi@miggy.org</senderEmail><timestampReceived>2003-01-04 23:22:21-0400</timestampReceived><subject>Re: mIRC style /dccserver command</subject><body>


On Fri, Jan 03, 2003 at 01:56:58PM +0000, Athanasius wrote:
&gt; Hi,
&gt;   I use a few channels where they serve files with the style of
&gt; /dccserver +sc &lt;port&gt;, i.e. where the client has to be already listening
&gt; on that port, and triggers the start of DCC chat by sending a /CTCP
&gt; command to the server (NOT a /dcc chat request).
&gt; 
&gt;   Snooping things with ethereal it looks like it's otherwise the same as
&gt; a DCC chat, the client just needs to be expecting connection(S) on the
&gt; given port for DCC stuff.

   I was wrong, it's probably simpler:

	http://lordwolf.com/mirchelp/dcc_server.htm

I'm going to start seeing what I can do to hack in support for this.

-Ath
-- 
- Athanasius = Athanasius(at)miggy.org / http://www.miggy.org/
                  Finger athan(at)fysh.org for PGP key
	   "And it's me who is my enemy. Me who beats me up.
Me who makes the monsters. Me who strips my confidence." Paula Cole - ME

[Attachment #3 (application/pgp-signature)]

</body></email><email><emailId>20030416111435</emailId><senderName>Joakim =?ISO-8859-1?Q?Kolsj=F6?=</senderName><senderEmail>joakim.kolsjo@home.se</senderEmail><timestampReceived>2003-04-16 11:14:35-0400</timestampReceived><subject>highlight on dcc?</subject><body>

Hi

This is sort of an feature request.

DCC file requests don't appear as messages targeted directly to me (red),
but as uninteresting info(gray), and because of that i never notice them
until someone tells me to recive what they are sending.

Would it be a good thing to change this in the official irssi?, i guess it is
easy to fix but would someone complain?

-- 
Joakim Kolsj

"A person is getting along the road to wisdom when they begin to realise that
their opinion is just another opinion."


</body></email><email><emailId>20030416143036</emailId><senderName>"Matthias Meyr"</senderName><senderEmail>matthiasmeyr@web.de</senderEmail><timestampReceived>2003-04-16 14:30:36-0400</timestampReceived><subject>Re: highlight on dcc?</subject><body>

Joakim Kolsj &lt;joakim.kolsjo@home.se&gt; wrote:

&gt; Would it be a good thing to change this in the official irssi?, i guess it is
&gt; easy to fix but would someone complain?

This is a very good idea in my opinion!

Matthias
______________________________________________________________________________
UNICEF bittet um Spenden fr die Kinder im Irak! Hier online an
UNICEF spenden: https://spenden.web.de/unicef/special/?mc=021101



</body></email><email><emailId>20030110140320</emailId><senderName>Piotr Krukowiecki</senderName><senderEmail>piotr@pingu.ii.uj.edu.pl</senderEmail><timestampReceived>2003-01-10 14:03:20-0400</timestampReceived><subject>[PATCH] dcc-send-limiter.c fixes</subject><body>

Hi

Fixed a little bit the plugin:

+       * fixed unnecesary lag in sending data when send is resume
+       * sends that were started before the module was loaded
+         now are being limited as well

I've been using it for about a week with avg 2 sends at once, and have no
problems with it. It would be nice if you could apply the patch


-- 
Piotrek
irc: #debian.pl
Mors Drosophilis melanogastribus!

["dcc-send-limiter.c.diff" (text/plain)]

--- dcc-send-limiter-orig.c	Sat Jan  4 13:44:18 2003
+++ dcc-send-limiter.c	Sat Jan  4 14:06:56 2003
@@ -21,6 +21,10 @@
     	  that didn't contain any module data
     	* fixed crash when initiating dcc send
 
+    Modified 2002/12/31 by Piotr Krukowiecki (Happy New Year! ;))
+    	* fixed unnecesary lag in sending data when send is resume
+	* sends that were started before the module was loaded 
+	  now are being limited as well
 
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
@@ -37,6 +41,7 @@
     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
 
+
 #define MODULE_NAME "irc/dcc/limiter"
 #define HAVE_CONFIG_H
 
@@ -162,7 +167,7 @@ static void sig_dcc_connected(SEND_DCC_R
 	mdcc = g_new0(MODULE_SEND_DCC_REC, 1);
 	MODULE_DATA_SET(dcc, mdcc);
 	mdcc-&gt;timeout_tag = -1;
-	mdcc-&gt;skip_bytes = 0;
+	mdcc-&gt;skip_bytes = dcc-&gt;transfd; /* now it works correct with dcc resume - doesn't \
wait 30s with sending data */  mdcc-&gt;max_speed = \
settings_get_int("dcc_send_top_speed");  
 	/* get starttime in milliseconds */
@@ -192,10 +197,20 @@ static void sig_dcc_destroyed(SEND_DCC_R
 
 void dcc_send_limiter_init(void)
 {
+	GSList *tmp;
 	settings_add_int("dcc", "dcc_send_top_speed", 30);
 
 	signal_add_last("dcc connected", (SIGNAL_FUNC) sig_dcc_connected);
 	signal_add_first("dcc destroyed", (SIGNAL_FUNC) sig_dcc_destroyed);
+	
+	/* Limit already existing sends */
+	for (tmp = dcc_conns; tmp != NULL; tmp = tmp-&gt;next) {
+		SEND_DCC_REC *dcc = tmp-&gt;data;
+		if (!IS_DCC_SEND(dcc)) continue;
+		if (!dcc_is_connected(dcc)) continue;
+		
+		sig_dcc_connected(dcc);
+	}
 
         module_register("dcc_send_limiter", "core");
 }



</body></email><email><emailId>20030419021209</emailId><senderName>splidge</senderName><senderEmail>splidge@quakenet.org</senderEmail><timestampReceived>2003-04-19 02:12:09-0400</timestampReceived><subject>irssi and channel mode +d</subject><body>

Hi all,

I've noticed that irssi will ignore channel mode +d if it's set on a channel
(i.e. not display it in the channel status).  From the source code this
looks intentional, placing +d in the same category as +e, +I etc. (modes
which are complex but the client doesn't really know about).

This presents a problem for me as I'd like to add a +d channelmode to
QuakeNet's ircd, and being a large network we have a non-trivial number of
irssi users.  The mode would be a "simple" mode (i.e. set or cleared, with
no parameters)[1].

Myself and others have looked and haven't found any major network which uses
+d as a more complex channel mode (i.e. unsuitable for displaying in the
status bar).  Would it be possible to change the behaviour in irssi for
future releases?

Cheers,

splidge (David Mansell)
QuakeNet person

[1] In case anyone is interested, the precise use for +d would be as a
companion to the recently introduced +D "delayed join" channel mode.  +D
makes joining users "invisible" until they actually do or say something;
it's intended to cut down on join/part spam on large channels[2].  However,
"invisible" users are not made visible when +D is removed, which means the
mode can be abused to hide clients from unsuspecting channel users.  Whilst
the identity of "invisible" users can be revealed (with /names -d #channel),
it's not necessarily obvious that they are there in the first place.  The +d
channel mode would be used to indicate that such invisible users were
present on the channel despite +D not being set (the user setting -D would
automatically set +d, and the server would set -d later when the last
"invisible" user either left the channel or became visible).

[2] This is to reduce the pressure on sendq's and network resources rather
than to make users clients look tidier (which can of course be done with
client-side ignores).

</body></email><email><emailId>20030419094715</emailId><senderName>David Leadbeater</senderName><senderEmail>dgl@otherwize.co.uk</senderEmail><timestampReceived>2003-04-19 09:47:15-0400</timestampReceived><subject>Re: irssi and channel mode +d</subject><body>

splidge wrote:
&gt; Hi all,
&gt; 
&gt; I've noticed that irssi will ignore channel mode +d if it's set on a channel
&gt; (i.e. not display it in the channel status).  From the source code this
&gt; looks intentional, placing +d in the same category as +e, +I etc. (modes
&gt; which are complex but the client doesn't really know about).
&gt; 
&gt; This presents a problem for me as I'd like to add a +d channelmode to
&gt; QuakeNet's ircd, and being a large network we have a non-trivial number of
&gt; irssi users.  The mode would be a "simple" mode (i.e. set or cleared, with
&gt; no parameters)[1].
&gt; 
&gt; Myself and others have looked and haven't found any major network which uses
&gt; +d as a more complex channel mode (i.e. unsuitable for displaying in the
&gt; status bar).  Would it be possible to change the behaviour in irssi for
&gt; future releases?

Hybrid supports it as a gecos ban mode, the only network I know it is used on
is freenode (although I have never actually seen it used). I guess that is why
irssi treats it as a list mode.

005 numeric support would be nice and solve many problems like this but I
don't think it's trival to add to Irssi either.


</body></email><email><emailId>20030120102113</emailId><senderName>Timo Sirainen</senderName><senderEmail>tss@iki.fi</senderEmail><timestampReceived>2003-01-20 10:21:13-0400</timestampReceived><subject>Re: Irssi redesign / rewrite</subject><body>

On Mon, 2003-01-20 at 12:17, bd@bc-bd.org wrote:
&gt; Hi,
&gt; 
&gt; &gt; "Fully functioning for most people without external scripting" is a
&gt; &gt; must. Notify lists, ignores, hilights etc. are basic functionality and
&gt; &gt; will be implemented with either C or internal scripting. I think most of
&gt; &gt; the irssi's current functionality falls there .. not everything though.
&gt; 
&gt; what about a two step approach? Like libcras.so and irssi. With the
&gt; _very_ core stuff inside libcras (like the signal framework) and then
&gt; built from that heavily modularized.

That's a bit how it works currently. Or how I planned on doing it
anyway, not that much was put into separate "modules" (dcc and modify
list mostly) but they could be without much trouble.

I don't think I'll try to separate everything from each others too
visibly, but avoiding cyclic dependencies is a good thing :)


</body></email><email><emailId>20030131095035</emailId><senderName>Wez Furlong</senderName><senderEmail>wez@thebrainroom.com</senderEmail><timestampReceived>2003-01-31 09:50:35-0400</timestampReceived><subject>Re: [PATCH] removal of unused execute() function</subject><body>

Thanks!

At the moment, it can source/sink signals and wraps the SERVER_REC,
CHANNEL_REC and NICK_REC objects; output (from echo/print) is captured
and output at the CLIENTCRAP level.

So, you can actually do a limited amount of scripting (the server
object exposes functions to send commands).

It's getting better every day :)

--Wez.

On 31 Jan 2003, Timo Sirainen wrote:

&gt; On Fri, 2003-01-31 at 02:33, Wez Furlong wrote:
&gt; &gt; The attached patch #ifdefs the irssi execute function out of the main
&gt; &gt; irssi executeable.
&gt;
&gt; I removed it entirely now.
&gt;
&gt; &gt; PS: I did post an announcement of the PHP irssi module, but can't see it
&gt; &gt; on the mailing list archives.
&gt;
&gt; Oh? I haven't seen the announcement either. Does it really work? :)
&gt;
&gt;
&gt;
&gt;


</body></email><email><emailId>20030219171431</emailId><senderName>Piotr Krukowiecki</senderName><senderEmail>piotr@pingu.ii.uj.edu.pl</senderEmail><timestampReceived>2003-02-19 17:14:31-0400</timestampReceived><subject>dcc-send-limiter.c patch again</subject><body>

Hello

Attaching patch for dcc-send-limiter plugin again.
I've been using it since new year without problems.
Changes:
+       * fixed unnecesary lag in sending data when send is resume
+       * sends that were started before the module was loaded
+         now are being limited as well


-- 
Piotrek
irc: #debian.pl
Mors Drosophilis melanogastribus!

</body></email><email><emailId>20030117172701</emailId><senderName>Timo Sirainen</senderName><senderEmail>tss@iki.fi</senderEmail><timestampReceived>2003-01-17 17:27:01-0400</timestampReceived><subject>Irssi redesign / rewrite</subject><body>

I've had at least a few rewrite plans before, but they've pretty much
sucked. Now, I think I'm finally enlightened enough and could actually
design a good new irssi.

Rewrites are usually bad idea with large projects, they mostly just get
started and get never finished, or not at least for a long time. But I think
rewrite is pretty much the only solution for irssi now, crash reports that I
get nowadays are rarely usable, I just know that "something" happened
"somewhere" which caused this crash later (heap corruption). I'd guess it's
usually a script.

So, new plan is basically: Write code that doesn't crash. Ever. 

Well, maybe not that strict. Crashing isn't too bad if it's predictable.
Asserts and NULL pointer accesses are fine, heap corruption is not. ie. if
it crashes, the core dump must show exactly the reason why it crashed, so it
can be fixed without guessing.

I'd hope some other people also would write code to this, it would take
quite a long time before I can get anything usable out of it alone. Design
ideas are also welcome, especially (simple) generalized features that make a
whole set of other features unnecessary (eg. /match below).

So, here's some of my thoughts, both from code and feature point of view,
comments welcome:

Code
----

coding style:
 - still C. it's the language I know well and like :)
 - must not crash, ever, no matter what you did
    - asserts and NULL pointer accesses are somewhat acceptable
    - anything else - especially heap corruption - means the
      design is flawed and must be fixed
 - type safety
    - void pointers lose type safety, avoid them
       - callback functions usually want them -&gt; avoid them
    - casts are dangerous, avoid them
 - unions are dangerous, don't access them directly but rather
   through macros/functions which checks that you're accessing
   the correct element (eg. union { int i; char *s; } u;
   u.i = user_input(); .... *s = 0; -&gt; security hole)
 - char* means it's NUL terminated, unsigned char* means it's not.
 - don't modify buffers directly unless you really have to.
   use string and buffer APIs.
 - any part of code where it takes more than a glance to verify
   that there's no buffer overflows, mark it with /* @UNSAFE */
   ie. foo(buffer, sizeof(buffer)) is OK, almost everything else
   is not.
 - don't overdesign
 - minimize the code, make everything simple to use
 - C doesn't set limitations on what you can do. If it seems
   difficult to implement or hard to use, rethink it better.
 - if it requires coder to be careful, it's usually badly 
   designed

memory management:
 - heap allocations aren't exactly fast and it gets fragmented
 - free() is dangerous, avoid it when possible
    - garbage collectors would help, but they don't work well
      with Perl (leaks a lot)
 - use allocate-only memory pools and data stack for temporary
   memory allocations. fast and safe.
 - possibly create a string memory pool which allows
   defragmenting by moving the data (special pstring_t type)

objects:
 - inheritance is annoying with C, probably do it like:
   struct irc_server { struct server server; ... }; to keep type
   safety. A bit annoying to access server struct though.
 - reference counting is needed, especially for Perl interface
 - there aren't many objects, so they could contain extra data
   set by plugins/scripts (especially the perl plugin itself)
     - except for nick object. should it be special case?..

signals:
 - requires better type safety. at the very least change the
   signals to emit a single parameters-structure instead of
   a number of C pointers, and check that the parameters are
   what the signal expects.
 - that could still lead to runtime errors. maybe we should have
   a separate signal_emit() function for each signal? .. would
   generate more code though, but much less chance for runtime
   errors.

perl:
 - keep the perl objects permanently in memory, attach it with
   the extra object data. it's created when object is first used
   in perl, it's destroyed when object itself is destroyed
 - update object's reference counter while perl object's refcount
   is updated. so it's possible to store object permanently to
   perl's memory and access it even when C code has already
   forgotten it -&gt; scripts can't crash irssi

Tags
----

Message levels will be replaced by tags. New tags can be
dynamically registered and their amount is not limited. They're
internally stored in variable width bitmask. Tags may have
parameters.,for example HILIGHT tag could have priority parameter.
Tags may automatically set/unset other tags.

Tags will play a big role in how things will interoperate, mostly
by making signals tagged. For example signal can be marked with
IGNORE, HILIGHT and/or LOG tags.

/MATCH
------

Ignores, hilights, /set activity_*, etc. will be replaced by /MATCH
command. /IGNORE and /HILIGHT may be left as wrappers to /MATCH. It
works in very similiar way to IP packet filters and such. You
describe the events you wish to match against and action what to do
then. Usually the action would be to set a tag for the signal, or
maybe to remove a tag.

Examples:
/match from *!*@*.fi to #channel join part -&gt; +hilight
/match from *!foo@bar.com ctcp -&gt; +ignore
/match from *!annoying@user.com all -&gt; +ignore +log

Ignore-tag would automatically do -log, so the last example would
still log the user.

The matches should probably be saved in own file which would look
like the above examples without /match. That way it'd be easy to
edit it with text editor, again very much like firewall rules.

/MATCH could possibly be also used like ircII /ON.

Logging
-------

Needs rethinking. Currently we log what gets shown in screen, using
whatever theme happens to be set (well, there's /set log_theme).
That's anyway wrong way to do it. We want to log different things
than what we want in screen. Logs should look the same by default,
no matter what theme you were using.

I'm thinking of creating a seprate /match ruleset against what to
log .. That should be separate from the list shown with /match not
to confuse users.. Needs more thinking.

Anyway, things that should be possible:
 - --&gt; nick!user@host -&gt; you!your@host:
   --&gt; Nick is Real Name (from /whois reply)
   &lt;nick&gt; foo
   &lt;you&gt; bar
   --&gt; nick!user@host2 -&gt; you!your@host:
   --&gt; Nick is Real Name
   &lt;nick&gt; dialup reconnection
 - &lt;nick:#channel&gt; ...
 - .. what else ..

Screen filter
-------------

It should be possible to hide/remove data from window buffers. So
you could have some key to toggle between showing joins, parts,
ignored people, etc.

Command line
------------

Commands will contain information what their parameters are, so irssi
actually knows what should be tab completed. For example
/server add -network &lt;tab&gt; knows that it should start completing
IRC networks.

All completed word positions should be marked, so that if you modify
the line elsewhere, go over the completed word and hit tab, it would
continue the old completion list. Completed words could be marked
with different color or underlining.

Different colorings would allow other things to be done, like spell
checker underlining invalid words, hitting tab over them would try to
fix the word.

The completed text would be marked using some tag .. possibly from
entirely different tagset as described above. The text anyway that
gets executed could be different than what's shown in screen. For
example we could redefine people to use different nicks, tab
completion would show us redefined nick, but what actually gets sent
to server would be the real nick.

There could possibly be also automatic modifications to some
command parameters. For example script creating random
kick/quit/part reason if a command parameter with REASON-tag
is empty.

Settings
--------

Several settings should be channel/server/network specific. Make it
so that all settings actually are, if possible. In code this would
be done like: settings_get_channel(channel, "sync") which would try
first channel specific settings, then server, then network and finally
fallback to globals.

I'm not sure how user would change them. Maybe
/set -channel #foo -network ircnet sync ...

Misc
----

Not being able to write to screen shouldn't block the whole program.
So if ^S was pressed, irssi should continue on the background
until ^Q was pressed, when it would just redraw the screen.

Support uTF-8 using terminal's UTF-8 on/off feature. Support
terminal's "alternate character set" on/off feature to allow drawing
lines and such.

Good internal iconv() support, to allow very simple to use UTF-8
support.

Statusbar? It's actually quite good now, I think. Could be easier to
setup of course.

Internal scripting? The current $vars are quite near scripting
themselves. Maybe we should have some very simple language to use in
themes, statusbars and such.


</body></email><email><emailId>20030117181334</emailId><senderName>Alexander Demenshin</senderName><senderEmail>aldem-irssi@aldem.net</senderEmail><timestampReceived>2003-01-17 18:13:34-0400</timestampReceived><subject>Re: Irssi redesign / rewrite</subject><body>

On Fri, Jan 17, 2003 at 07:27:01PM +0200, Timo Sirainen wrote:

&gt; I've had at least a few rewrite plans before, but they've pretty much
&gt; sucked. Now, I think I'm finally enlightened enough and could actually
&gt; design a good new irssi.

  Does it mean that development of current vesrion will be discontinued
  completely?

&gt; get nowadays are rarely usable, I just know that "something" happened
&gt; "somewhere" which caused this crash later (heap corruption). I'd guess it's

  Did you ever tried valgrind to track the sources of the problems? :)
  
&gt; So, new plan is basically: Write code that doesn't crash. Ever. 

  You have to use some interperted language to write such code (or spent
  infinite amout of time writing this in C - large C projects are never
  crash-safe).
  
&gt; - still C. it's the language I know well and like :)

  Why not C++? May be it worth to study C++ a bit more and use it? :)

&gt; - anything else - especially heap corruption - means the
&gt; design is flawed and must be fixed

  Not necessary. Even if design is perfect you can never be sure that
  you didn't forget that comma sign somewhere :)

&gt; - void pointers lose type safety, avoid them

  Prefix every allocated data structure with type tag and make a macro
  instead of direct casting. Something like:
  
  struct object {
  	int		__tag;
  	void		*self;	// Assigned upon allocation
  	... declarations here ...
  }
  
  Then every time when you cast (void *) to this structure:
  
  objp = CAST(T_OBJECT,voidp);
  
  where:

#define	OP(ptr)		((struct object *)ptr)
#define	CAST(type,ptr)	(OP(ptr)-&gt;__tag == type &amp;&amp; OP(ptr)-&gt;self == ptr ? ptr : \
__bug("Panic!", __FILE__, __LINE__))

  Every object must be initialized properly upon allocation, of course,
  and cleared upon deallocation. Adding linked list of all objects will
  help to find leaks and to check data integrity. Well, you got the idea :)

&gt; - char* means it's NUL terminated, unsigned char* means it's not.

  Better not. Better to use something different like typedef. IMHO :)

&gt; use string and buffer APIs.

  This may also be used to access regular strings, so you will avoid any
  problems including NUL.

&gt; - minimize the code, make everything simple to use

  "Everything should be made as simple as possible, but not simpler." -- A. Einstein \
:)

&gt; - if it requires coder to be careful, it's usually badly 
&gt; designed

  Did you forget about unexperienced coders? Nothing is safe in C for them :)

&gt; - heap allocations aren't exactly fast and it gets fragmented

  They are still quick enough. Use memory pools to avoid excessive fragmentation.

&gt; - free() is dangerous, avoid it when possible

  Alternatives?

&gt; - garbage collectors would help, but they don't work well
&gt; with Perl (leaks a lot)

  True. So make your own :)

&gt; - possibly create a string memory pool which allows
&gt; defragmenting by moving the data (special pstring_t type)

  This it what you call "overdesign" :) Fragmentation is not always so bad.

&gt; - inheritance is annoying with C, probably do it like:
&gt; struct irc_server { struct server server; ... }; to keep type
&gt; safety. A bit annoying to access server struct though.

   Another argument for C++ :)

&gt; - reference counting is needed, especially for Perl interface

  One step close to your own GC :)

&gt; So if ^S was pressed, irssi should continue on the background
&gt; until ^Q was pressed, when it would just redraw the screen.

  Virtual terminal emulation, a-la screen? So when output is blocked, it
  still gets filled, and once unblocked it will redisplay the content.

&gt; Good internal iconv() support, to allow very simple to use UTF-8
&gt; support.

  Would be nice to have embedded charset conversions too...

&gt; Internal scripting? The current $vars are quite near scripting
&gt; themselves. Maybe we should have some very simple language to use in
&gt; themes, statusbars and such.

  Small, simple but powerful? There are two options - the one used in jed
  and ICI (this one also has C-like syntax, powerful data structures and
  core is small enough to embed; easily callable from C). But please, please,
  anything but Python :)
  
  This scripting language (whatever you choose) may be also used for regular
  scripting whenever Perl is not available or is too much. C like syntax is
  well-known so it shouldn't cause any problems even to beginners :)

Regards,
/Al


</body></email><email><emailId>20030117194429</emailId><senderName>Timo Sirainen</senderName><senderEmail>tss@iki.fi</senderEmail><timestampReceived>2003-01-17 19:44:29-0400</timestampReceived><subject>Re: Irssi redesign / rewrite</subject><body>

On Fri, Jan 17, 2003 at 07:13:34PM +0100, Alexander Demenshin wrote:
&gt; &gt; I've had at least a few rewrite plans before, but they've pretty much
&gt; &gt; sucked. Now, I think I'm finally enlightened enough and could actually
&gt; &gt; design a good new irssi.
&gt; 
&gt;   Does it mean that development of current vesrion will be discontinued
&gt;   completely?

Well, it hasn't had much development anyway for some time.

&gt; &gt; get nowadays are rarely usable, I just know that "something" happened
&gt; &gt; "somewhere" which caused this crash later (heap corruption). I'd guess it's
&gt; 
&gt;   Did you ever tried valgrind to track the sources of the problems? :)

Yes. It's usually the scripts. There's a lot of different ways buggy scripts
can crash irssi. For example sending signals with wrong parameters types or
accessing structures that have already been free'd from C code.

&gt; &gt; So, new plan is basically: Write code that doesn't crash. Ever. 
&gt; 
&gt;   You have to use some interperted language to write such code (or spent
&gt;   infinite amout of time writing this in C - large C projects are never
&gt;   crash-safe).

I think they could be :) I've some experience now with my IMAP server
(dovecot.procontrol.fi), it hardly ever crashes and it's always been to some
assert or NULL pointer access. I've yet to see a single crash in it that I
couldn't explain immediately. Of course, IMAP server is easier than IRC
client since it doesn't require much permanent data.

&gt; &gt;  - still C. it's the language I know well and like :)
&gt; 
&gt;   Why not C++? May be it worth to study C++ a bit more and use it? :)

I don't see that much advantages in C++. And I tried for a while to design
irssi in OO-style with C++, but I didn't like at all what it looked like. So
if I used only a couple of C++ features but mostly C-style coding, it'd just
annoy all the C++ programmers ;)

&gt; &gt;     - void pointers lose type safety, avoid them
&gt; 
&gt;   Prefix every allocated data structure with type tag and make a macro
&gt;   instead of direct casting. Something like:

Yes. Something similiar is already in irssi, it assumes that the pointer
begins with "int type" and uses it to check what object the pointer actually
points to. 

&gt;   struct object {
&gt;   	int		__tag;
&gt;   	void		*self;	// Assigned upon allocation
&gt;   	... declarations here ...
&gt;   }

This would be safer of course.

&gt; &gt;    use string and buffer APIs.
&gt; 
&gt;   This may also be used to access regular strings, so you will avoid any
&gt;   problems including NUL.

Possibly. That'd just require to rewrite/wrap many of the libc functions. I
don't see char*s as that bad :)

&gt; &gt;  - if it requires coder to be careful, it's usually badly 
&gt; &gt;    designed
&gt; 
&gt;   Did you forget about unexperienced coders? Nothing is safe in C for them :)

Yeah, they can do a lot of things wrong. The above comment was meant for
people who actually know the language, but might design difficult or unsafe
APIs.

&gt; &gt;  - free() is dangerous, avoid it when possible
&gt; 
&gt;   Alternatives?

For permanently stored data, not really. "when possible" are the keywords :)

&gt; &gt;     - garbage collectors would help, but they don't work well
&gt; &gt;       with Perl (leaks a lot)
&gt; 
&gt;   True. So make your own :)

Too difficult I'd think. Especially if it should be somewhat easy to use and
portable. Hmm. Maybe it could be made to work better with Perl. I think the
problem with current irssi code is that the Perl objects contain pointers to
C objects, but they're never cleared. That could be done..

&gt; &gt;  - possibly create a string memory pool which allows
&gt; &gt;    defragmenting by moving the data (special pstring_t type)
&gt; 
&gt;   This it what you call "overdesign" :) Fragmentation is not always so bad.

Yeah, it has "possibly" there :) I'm not sure how bad the fragmentation
would be, maybe not too bad. That could anyway be added later easily, so I
won't begin with it.

&gt; &gt; So if ^S was pressed, irssi should continue on the background
&gt; &gt; until ^Q was pressed, when it would just redraw the screen.
&gt; 
&gt;   Virtual terminal emulation, a-la screen? So when output is blocked, it
&gt;   still gets filled, and once unblocked it will redisplay the content.

No, a simple irssi_redraw() function that gets called. You can already do
that with ^L.

&gt; &gt; Good internal iconv() support, to allow very simple to use UTF-8
&gt; &gt; support.
&gt; 
&gt;   Would be nice to have embedded charset conversions too...

Embedded? I'm not sure what you mean.

&gt; &gt; Internal scripting? The current $vars are quite near scripting
&gt; &gt; themselves. Maybe we should have some very simple language to use in
&gt; &gt; themes, statusbars and such.
&gt; 
&gt;   Small, simple but powerful?

Not necessarily powerful. For more powerful there would be Perl and maybe
others.

&gt; There are two options - the one used in jed
&gt;   and ICI (this one also has C-like syntax, powerful data structures and
&gt;   core is small enough to embed; easily callable from C).

Have to look at that. I'm not really sure what the scripting should actually
look like. At least it'd have to be easy to use within themes and statusbar
items, something like nick = "$indent(&lt;$0$1&gt;, 10)"


</body></email><email><emailId>20030117223708</emailId><senderName>Jakub Jankowski</senderName><senderEmail>shasta@atn.pl</senderEmail><timestampReceived>2003-01-17 22:37:08-0400</timestampReceived><subject>Re: Irssi redesign / rewrite</subject><body>

On Fri, 17 Jan 2003, Timo Sirainen wrote:

[...]
&gt; - there aren't many objects, so they could contain extra data
&gt;   set by plugins/scripts (especially the perl plugin itself)
&gt;     - except for nick object. should it be special case?..
[...]

Why you're excluding the nick object? It's the first one I'd like to
have ,,scriptable''. At least few bits/bytes should be available to
scripters. It would help _a_lot_ with person-oriented scripts
(userslists for example). I'm sure it's not only my opinion.

s.

&gt;Internal scripting? The current $vars are quite near scripting
&gt;themselves. Maybe we should have some very simple language to use in
&gt;themes, statusbars and such.

Yeah, at least basical mathematical operations :-) But it shouldn't be
as powerful as the current perl implementation. IMVHO.


s.

-- 
(0&gt;  Jakub Jankowski  [url]: s.atn.pl  "Nawet w Krainie Czarow
//\   shasta@IRCnet   [rlu]: 174516     latwiej jest spotkac
V_/_  shasta@atn.pl   [ekg]: 921514     Babe Jage niz Alicje"
Fingerprint: FCBF F03D 9ADB B768 8B92 BB52 0341 9037 A875 942D

</body></email><email><emailId>20030118005733</emailId><senderName>"Nikolai :: lone-star :: Weibull"</senderName><senderEmail>lone-star@home.se</senderEmail><timestampReceived>2003-01-18 00:57:33-0400</timestampReceived><subject>Re: Irssi redesign / rewrite</subject><body>

On Fri, 17 Jan 2003 19:27:01 +0000, Timo Sirainen wrote:
&gt; memory management:
&gt;  - heap allocations aren't exactly fast and it gets fragmented
&gt;  - free() is dangerous, avoid it when possible
&gt;     - garbage collectors would help, but they don't work well
&gt;       with Perl (leaks a lot)
&gt;  - use allocate-only memory pools and data stack for temporary
&gt;    memory allocations. fast and safe.
&gt;  - possibly create a string memory pool which allows
&gt;    defragmenting by moving the data (special pstring_t type)

isn't there lots of GLib code for things like this?
&gt;
&gt; objects:
&gt;  - inheritance is annoying with C, probably do it like:
&gt;    struct irc_server { struct server server; ... }; to keep type
&gt;    safety. A bit annoying to access server struct though.
&gt;  - reference counting is needed, especially for Perl interface
&gt;  - there aren't many objects, so they could contain extra data
&gt;    set by plugins/scripts (especially the perl plugin itself)
&gt;      - except for nick object. should it be special case?..
&gt;
again, GLib.  why not use GObject?
&gt; signals:
&gt;  - requires better type safety. at the very least change the
&gt;    signals to emit a single parameters-structure instead of
&gt;    a number of C pointers, and check that the parameters are
&gt;    what the signal expects.
&gt;  - that could still lead to runtime errors. maybe we should have
&gt;    a separate signal_emit() function for each signal? .. would
&gt;    generate more code though, but much less chance for runtime
&gt;    errors.
&gt;
yet again, GLib has signals.  I don't know how they work or what they
are for, never used GLibs signal facilities, but they could perhaps be
used.
&gt; perl:
&gt;  - keep the perl objects permanently in memory, attach it with
&gt;    the extra object data. it's created when object is first used
&gt;    in perl, it's destroyed when object itself is destroyed
&gt;  - update object's reference counter while perl object's refcount
&gt;    is updated. so it's possible to store object permanently to
&gt;    perl's memory and access it even when C code has already
&gt;    forgotten it -&gt; scripts can't crash irssi
&gt;
perhaps try to make as much of stuff a part of the Perl scripting
language.  Don't keep /notify command in irssi, but move to a perl
script?  look at XiRCON: has never crashed on me, and i've used it since
the first release...
there aren't many commands that actually need to be kept in irssi (and
C) even for added speed.  Make the interfacing clean, simple, and
correct and you probably solve a lot of issues, and make the design
cleaner.

And how about using some other language (hint: Ruby)?  Perl seems to be
a mess to interface with.

anyway,
	nikolai

--
::: name: Nikolai Weibull    :: aliases: pcp / lone-star       :::
::: born: Chicago, IL USA    :: loc atm: Gothenburg, Sweden    :::
::: page: www.pcppopper.org  :: fun atm: gf,lps,ruby,php,war3  :::
main(){printf(&amp;linux["\021%six\012\0"],(linux)["have"]+"fun"-97);}

</body></email><email><emailId>20030118014424</emailId><senderName>Timo Sirainen</senderName><senderEmail>tss@iki.fi</senderEmail><timestampReceived>2003-01-18 01:44:24-0400</timestampReceived><subject>Re: Irssi redesign / rewrite</subject><body>

On Sat, 2003-01-18 at 02:57, Nikolai :: lone-star :: Weibull wrote:
&gt; On Fri, 17 Jan 2003 19:27:01 +0000, Timo Sirainen wrote:
&gt; &gt; memory management:
&gt; &gt;  - heap allocations aren't exactly fast and it gets fragmented
&gt; &gt;  - free() is dangerous, avoid it when possible
&gt; &gt;     - garbage collectors would help, but they don't work well
&gt; &gt;       with Perl (leaks a lot)
&gt; &gt;  - use allocate-only memory pools and data stack for temporary
&gt; &gt;    memory allocations. fast and safe.
&gt; &gt;  - possibly create a string memory pool which allows
&gt; &gt;    defragmenting by moving the data (special pstring_t type)
&gt; 
&gt; isn't there lots of GLib code for things like this?

Not really. There's some kind of memory pool for allocating multiple
objects with same size.

&gt; again, GLib.  why not use GObject?
..
&gt; yet again, GLib has signals.  I don't know how they work or what they
&gt; are for, never used GLibs signal facilities, but they could perhaps be
&gt; used.

Irssi has always been based quite heavily on GLIB. xirssi and original
gtk irssi was also based on GTK, which is based on GObject and GSignals.

GLIB is heavily based on dynamic memory allocations. Without relying on
garbage collector that's a real pain to free all the memory you've
allocated.

GObject and GSignals aren't type safe. They check errors at runtime
(assuming used properly), but it's much better to be able to find errors
at compile time before they even happen.

GSignals don't really fit into irssi's usage, they're more about
emitting and catching a signal for a single object, while irssi likes to
catch a signal for all objects.

I've used GLIB for maybe 4 years now. It's much better than using libc
directly, but using the library I've been writing for the past year has
been a _lot_ easier (as well as faster and less memory intensive). And
since I already have most of the required library code written, there's
not much need to use GLIB anyway :)

&gt; perhaps try to make as much of stuff a part of the Perl scripting
&gt; language.  Don't keep /notify command in irssi, but move to a perl
&gt; script?  look at XiRCON: has never crashed on me, and i've used it since
&gt; the first release...
&gt; there aren't many commands that actually need to be kept in irssi (and
&gt; C) even for added speed.  Make the interfacing clean, simple, and
&gt; correct and you probably solve a lot of issues, and make the design
&gt; cleaner.
&gt; 
&gt; And how about using some other language (hint: Ruby)?  Perl seems to be
&gt; a mess to interface with.

I agree that scripts should hold as much of the features as possible,
but I also think that irssi should be fully functioning for most people
without external scripting language.

You already note the worst problem, people want to use different
scripting languages. People also install irssi in computers that don't
have some specific language installed, Perl is quite safe nowadays since
it's been around for ages. I'm IRCing from a computer that doesn't have
Ruby installed, and likely will not be unless I install it into homedir.

Supporting multiple scripting languages is good for giving script coders
a choice, but annoying for users who want to use script done with
multiple languages, possibly requiring them to install the language and
at the very least use more memory. I won't be writing support for more
than one language (very likely Perl), but that doesn't mean others can't
write it. Irssi's core doesn't make any assumptions what scripting
language you may be using.


</body></email><email><emailId>20030119162123</emailId><senderName></senderName><senderEmail>bd</senderEmail><timestampReceived>2003-01-19 16:21:23-0400</timestampReceived><subject>Re: Irssi redesign / rewrite</subject><body>

Hi,

&gt; Screen filter
&gt; -------------
&gt; 
&gt; It should be possible to hide/remove data from window buffers. So
&gt; you could have some key to toggle between showing joins, parts,
&gt; ignored people, etc.

Some thoughts about that....

  - Store the data independently from the view/theme
	   * enables changing of text ex post (typofix)
	   * enables re-hilighting text (type /mark-conversation &lt;nick&gt; to
		     highlight all stuff &lt;nick&gt; said an other people said with
				 &lt;nick&gt;:).
		 * on the fly theme changing
		 * eases up the log problem

by
	bd

</body></email><email><emailId>20030119234524</emailId><senderName>Alexander Demenshin</senderName><senderEmail>aldem-irssi@aldem.net</senderEmail><timestampReceived>2003-01-19 23:45:24-0400</timestampReceived><subject>Re: Irssi redesign / rewrite</subject><body>

On Sat, Jan 18, 2003 at 03:44:24AM +0200, Timo Sirainen wrote:

&gt; been a _lot_ easier (as well as faster and less memory intensive). And
&gt; since I already have most of the required library code written, there's
&gt; not much need to use GLIB anyway :)

  Is it (your library) portable? Can it be used on Win32? To be honest, I
  really dislike glib, and I like when there are no external dependencies
  exists (except for standard C library and anything else which works well
  on Win32 as good as on *ix) :)

&gt; but I also think that irssi should be fully functioning for most people
&gt; without external scripting language.

  Unless there will be some embedded scripting language :) I think this idea
  is not bad - make everything which needs optimization in C, but everything
  else in interpreted language - this will help to avoid a lot of problems
  related to buffer overflows etc.
  
Regards,
/Al

</body></email><email><emailId>20030119235225</emailId><senderName>Alexander Demenshin</senderName><senderEmail>aldem-irssi@aldem.net</senderEmail><timestampReceived>2003-01-19 23:52:25-0400</timestampReceived><subject>Re: Irssi redesign / rewrite</subject><body>

On Fri, Jan 17, 2003 at 09:44:29PM +0200, Timo Sirainen wrote:

&gt; if I used only a couple of C++ features but mostly C-style coding, it'd just
&gt; annoy all the C++ programmers ;)

  Even C++ objects only are good reason to use C++ :) Well, sure it is up to you,
  it was just a though :)

&gt; &gt;   Would be nice to have embedded charset conversions too...
&gt; 
&gt; Embedded? I'm not sure what you mean.

  Well... I mean some support for conversions in core, so everybody can specify
  which charset his terminal uses and which charset in IRC channel is, without
  need of some special scripts.

&gt; Have to look at that. I'm not really sure what the scripting should actually
&gt; look like. At least it'd have to be easy to use within themes and statusbar
&gt; items, something like nick = "$indent(&lt;$0$1&gt;, 10)"
&gt; 

  IMHO, scripting language should be more or less understandeable. It should
  be simple (for beginners), of course, but not too simple - on the other
  hand.

Regards,
/Al

</body></email><email><emailId>20030119235922</emailId><senderName>Timo Sirainen</senderName><senderEmail>tss@iki.fi</senderEmail><timestampReceived>2003-01-19 23:59:22-0400</timestampReceived><subject>Re: Irssi redesign / rewrite</subject><body>

On Sat, 2003-01-18 at 00:37, Jakub Jankowski wrote:
&gt; On Fri, 17 Jan 2003, Timo Sirainen wrote:
&gt; 
&gt; [...]
&gt; &gt; - there aren't many objects, so they could contain extra data
&gt; &gt;   set by plugins/scripts (especially the perl plugin itself)
&gt; &gt;     - except for nick object. should it be special case?..
&gt; [...]
&gt; 
&gt; Why you're excluding the nick object? It's the first one I'd like to
&gt; have ,,scriptable''. At least few bits/bytes should be available to
&gt; scripters. It would help _a_lot_ with person-oriented scripts
&gt; (userslists for example). I'm sure it's not only my opinion.

I was mostly thinking that reference counting could be done per-channel
rather than per-nick, but I guess that's not really possible unless nick
also had a pointer to channel (which would take just as much or more
memory than refcounter).

&gt; &gt;Internal scripting? The current $vars are quite near scripting
&gt; &gt;themselves. Maybe we should have some very simple language to use in
&gt; &gt;themes, statusbars and such.
&gt; 
&gt; Yeah, at least basical mathematical operations :-) But it shouldn't be
&gt; as powerful as the current perl implementation. IMVHO.

Maybe not even math operations. String related operations are the
important ones.

</body></email><email><emailId>20030120000817</emailId><senderName>Timo Sirainen</senderName><senderEmail>tss@iki.fi</senderEmail><timestampReceived>2003-01-20 00:08:17-0400</timestampReceived><subject>Re: Irssi redesign / rewrite</subject><body>

On Mon, 2003-01-20 at 01:45, Alexander Demenshin wrote:
&gt; &gt; been a _lot_ easier (as well as faster and less memory intensive). And
&gt; &gt; since I already have most of the required library code written, there's
&gt; &gt; not much need to use GLIB anyway :)
&gt; 
&gt;   Is it (your library) portable? Can it be used on Win32? To be honest, I
&gt;   really dislike glib, and I like when there are no external dependencies
&gt;   exists (except for standard C library and anything else which works well
&gt;   on Win32 as good as on *ix) :)

My library is portable across UNIX systems. The parts that I'd use with
irssi would mostly be ANSI-C. Handling sockets would be the only tricky
part, there's no code for that yet. But I never got GLIB 1.2 or early
1.3 to work well with winsock either, maybe they've fixed it though.

&gt; &gt; but I also think that irssi should be fully functioning for most people
&gt; &gt; without external scripting language.
&gt; 
&gt;   Unless there will be some embedded scripting language :) I think this idea
&gt;   is not bad - make everything which needs optimization in C, but everything
&gt;   else in interpreted language - this will help to avoid a lot of problems
&gt;   related to buffer overflows etc.

"Fully functioning for most people without external scripting" is a
must. Notify lists, ignores, hilights etc. are basic functionality and
will be implemented with either C or internal scripting. I think most of
the irssi's current functionality falls there .. not everything though.


</body></email><email><emailId>20030131003346</emailId><senderName>Wez Furlong</senderName><senderEmail>wez@thebrainroom.com</senderEmail><timestampReceived>2003-01-31 00:33:46-0400</timestampReceived><subject>[PATCH] removal of unused execute() function</subject><body>

Hi there,

The execute function define in src/core/misc.[ch] causes a symbol
conflict when building the php module for irssi (the Zend Engine uses an
execute function to run the compiled scripts).

The attached patch #ifdefs the irssi execute function out of the main
irssi executeable.

If this function really is used somewhere (I couldn't find any reference
withing the code), then I would propose renaming it to something less
likely to conflict.

--Wez.
aka: wez@php.net

PS: I did post an announcement of the PHP irssi module, but can't see it
on the mailing list archives.

The PHP module requires a development version of PHP 5, so it is not
recommended for non-PHP developers to experiment with at this time.
However, the brave among you can check it out from the PHP CVS
repository; see http://www.php.net/anoncvs.php and checkout the
embed/php-irssi module.

There are bugs and I cannot offer support; use at your own risk!


["irssi-exec.diff" (TEXT/PLAIN)]

Index: src/core/misc.c
===================================================================
RCS file: /home/cvs/irssi/src/core/misc.c,v
retrieving revision 1.43
diff -u -p -r1.43 misc.c
--- src/core/misc.c	8 Jan 2003 20:54:36 -0000	1.43
+++ src/core/misc.c	31 Jan 2003 00:13:04 -0000
@@ -173,6 +173,7 @@ int strarray_find(char **array, const ch
 	return -1;
 }
 
+#if 0
 int execute(const char *cmd)
 {
 	char **args;
@@ -203,6 +204,7 @@ int execute(const char *cmd)
 	return 0;
 #endif
 }
+#endif
 
 GSList *gslist_find_string(GSList *list, const char *key)
 {
Index: src/core/misc.h
===================================================================
RCS file: /home/cvs/irssi/src/core/misc.h,v
retrieving revision 1.19
diff -u -p -r1.19 misc.h
--- src/core/misc.h	28 Dec 2002 17:54:13 -0000	1.19
+++ src/core/misc.h	31 Jan 2003 00:13:04 -0000
@@ -21,7 +21,9 @@ int strarray_length(char **array);
 /* return index of `item' in `array' or -1 if not found */
 int strarray_find(char **array, const char *item);
 
+#if 0
 int execute(const char *cmd); /* returns pid or -1 = error */
+#endif
 
 GSList *gslist_find_string(GSList *list, const char *key);
 GSList *gslist_find_icase_string(GSList *list, const char *key);


</body></email><email><emailId>20030131040442</emailId><senderName>Timo Sirainen</senderName><senderEmail>tss@iki.fi</senderEmail><timestampReceived>2003-01-31 04:04:42-0400</timestampReceived><subject>Re: [PATCH] removal of unused execute() function</subject><body>

On Fri, 2003-01-31 at 02:33, Wez Furlong wrote:
&gt; The attached patch #ifdefs the irssi execute function out of the main
&gt; irssi executeable.

I removed it entirely now.

&gt; PS: I did post an announcement of the PHP irssi module, but can't see it
&gt; on the mailing list archives.

Oh? I haven't seen the announcement either. Does it really work? :)


</body></email><email><emailId>20030120001353</emailId><senderName>Timo Sirainen</senderName><senderEmail>tss@iki.fi</senderEmail><timestampReceived>2003-01-20 00:13:53-0400</timestampReceived><subject>Re: Irssi redesign / rewrite</subject><body>

On Mon, 2003-01-20 at 01:52, Alexander Demenshin wrote:
&gt; &gt; &gt;   Would be nice to have embedded charset conversions too...
&gt; &gt; 
&gt; &gt; Embedded? I'm not sure what you mean.
&gt; 
&gt;   Well... I mean some support for conversions in core, so everybody can specify
&gt;   which charset his terminal uses and which charset in IRC channel is, without
&gt;   need of some special scripts.

Yes, that was my plan.

&gt; &gt; Have to look at that. I'm not really sure what the scripting should actually
&gt; &gt; look like. At least it'd have to be easy to use within themes and statusbar
&gt; &gt; items, something like nick = "$indent(&lt;$0$1&gt;, 10)"
&gt; &gt; 
&gt; 
&gt;   IMHO, scripting language should be more or less understandeable. It should
&gt;   be simple (for beginners), of course, but not too simple - on the other
&gt;   hand.

Yes, understandability is good :) Hmm. I had thought this a bit before,
mostly related to themes.

http://irssi.org/files/misc/themes.txt

I'm not sure if I should restrict it for simple string manipulation
operations, or something bit more featureful. It wouldn't really need
much, especially if /MATCH were to work like ircII /ON. Just being able
to do some string modifying, basic math operations and if/for/while
structures should take care of almost all basic needs.


</body></email><email><emailId>20030120001810</emailId><senderName>Timo Sirainen</senderName><senderEmail>tss@iki.fi</senderEmail><timestampReceived>2003-01-20 00:18:10-0400</timestampReceived><subject>Re: Irssi redesign / rewrite</subject><body>

On Sun, 2003-01-19 at 19:20, bd@bc-bd.org wrote:
&gt; &gt; Screen filter
&gt; Some thoughts about that....
&gt; 
&gt;   - Store the data independently from the view/theme
&gt; 	   * enables changing of text ex post (typofix)
&gt; 	   * enables re-hilighting text (type /mark-conversation &lt;nick&gt; to
&gt; 		     highlight all stuff &lt;nick&gt; said an other people said with
&gt; 				 &lt;nick&gt;:).
&gt; 		 * on the fly theme changing
&gt; 		 * eases up the log problem

Irssi already does something similiar optionally. /SET
scrollback_save_formats ON, /SET theme xxx, /SB REDRAW would redraw the
window with new theme.

Storing all the data for that at least doubles the memory usage, so I
don't think it should be enabled by default or especially required.

/mark-conversion would be nice though :)


</body></email><email><emailId>20030120091802</emailId><senderName></senderName><senderEmail>bd</senderEmail><timestampReceived>2003-01-20 09:18:02-0400</timestampReceived><subject>Re: Irssi redesign / rewrite</subject><body>

Hi,

&gt; "Fully functioning for most people without external scripting" is a
&gt; must. Notify lists, ignores, hilights etc. are basic functionality and
&gt; will be implemented with either C or internal scripting. I think most of
&gt; the irssi's current functionality falls there .. not everything though.

what about a two step approach? Like libcras.so and irssi. With the
_very_ core stuff inside libcras (like the signal framework) and then
built from that heavily modularized.

Through that one might be able to decouple some internal subsystems,
which could improve stability (well defined interfaces,
subsystem-failure tolerant whole, ...). 

... and yes I mostly code c++, bear with me :).

by
	bd
-- 
PGP/GPG Key at http://bc-bd.org/pgp/bd@bc-bd.org.asc
----------------------------------------------------
They can't stop us... we're on a mission from God!
		-- The Blues Brothers

</body></email><email><emailId>20030120095709</emailId><senderName>Einar Karttunen</senderName><senderEmail>ekarttun@cs.helsinki.fi</senderEmail><timestampReceived>2003-01-20 09:57:09-0400</timestampReceived><subject>Re: Irssi redesign / rewrite</subject><body>

On 20.01 01:59, Timo Sirainen wrote:
&gt; I was mostly thinking that reference counting could be done per-channel
&gt; rather than per-nick, but I guess that's not really possible unless nick
&gt; also had a pointer to channel (which would take just as much or more
&gt; memory than refcounter).

Are you aware of the problems associated with reference counting?
- usually slower than proper garbage collector
- cyclic references cause memory leaks

An another important point would be to make the scripting features
language independent i.e. not tie irssi with perl in any special way.
Just define a clean interface to which languages can easily attach
themselves. Maybe using SWIG (http://www.swig.org) is an option for
this...

- Einar Karttunen

</body></email><email><emailId>20030120101504</emailId><senderName>Timo Sirainen</senderName><senderEmail>tss@iki.fi</senderEmail><timestampReceived>2003-01-20 10:15:04-0400</timestampReceived><subject>Re: Irssi redesign / rewrite</subject><body>

On Mon, 2003-01-20 at 11:57, Einar Karttunen wrote:
&gt; Are you aware of the problems associated with reference counting?
&gt; - usually slower than proper garbage collector
&gt; - cyclic references cause memory leaks

If I knew GC would work well, I'd use it. With plain C code the Boehm GC
seems to work fine enough, but I have doubts how well it would work with
Perl or other scripting languages. Last I tried it kept leaking memory
all the time, but maybe it would be possible to fix it. 

That could be tested with current irssi code actually. What would have
to be done is erase perl objects' _irssi variable after Perl is
destroying the object.

I'm planning on keeping the number of refcounted objects rather low
though, so I'd think a GC scanning through the heap (especially the
memory allocated by perl, which would be refcounted in any case) would
be a lot slower than keeping track of around 100-1000 objects,
especially if the refcounter wouldn't be updated very often (mostly just
Perl I think).

&gt; An another important point would be to make the scripting features
&gt; language independent i.e. not tie irssi with perl in any special way.
&gt; Just define a clean interface to which languages can easily attach
&gt; themselves. Maybe using SWIG (http://www.swig.org) is an option for
&gt; this...

I'll have to look at that. But Irssi isn't tied into Perl in any way
even now, and will not in future versions.


</body></email><email><emailId>20030207011052</emailId><senderName>EML</senderName><senderEmail>porponnuk@menta.net</senderEmail><timestampReceived>2003-02-07 01:10:52-0400</timestampReceived><subject>Re: Irssi redesign / rewrite</subject><body>

Regarding scripting langauges, have you considered using lua? It has an
extremely elegant interface for using within C code.  And the language
itself is really simple.

I would *love* to use an irc-client that was lua-scriptable.

And I'm not related in any way with lua, just have been using it for a
football playing program.

E.

</body></email><email><emailId>20030705152306</emailId><senderName>Andrew de los Reyes</senderName><senderEmail>adlr@umich.edu</senderEmail><timestampReceived>2003-07-05 15:23:06-0400</timestampReceived><subject>Mac OS X port of Irssi (Cocoa)</subject><body>

Hi,

I want to let you guys (Timo Sirainen and the other developers) that I
have come pretty far in making a Cocoa front-end for Irssi. My goal
with the project is to make a very userfriendly graphical IRC client
for Mac OS X. The reason I went with Irssi is because of all the
opensource IRC clients I looked at, Irssi had the cleanest code base.

Thanks for writing such a great IRC client. :)

For the curious, a screenshot of the Cocoa frontend is at
http://gizmolabs.org/~andrew/irssix2.png

A disk image of the binary is at
http://gizmolabs.org/~andrew/irssibeta2.dmg.gz

And the source + binary is at
http://gizmolabs.org/~andrew/fe-aqua2.tar.gz

If you have any questions or concerns, please let me know. I don't
subscribe to this mailing list, so please make sure replies get
emailed to me.

Thanks again for the great client.

-andrew

</body></email><email><emailId>20030824213834</emailId><senderName>Wilfried Goesgens</senderName><senderEmail>w.goesgens@chaosindustries.de</senderEmail><timestampReceived>2003-08-24 21:38:34-0400</timestampReceived><subject>Did some work on the irssi-icq-plugin...</subject><body>

Hya, I did some coding on the icq plugin, to make it more usefull to
me...
New Features:
~~~~~~~~~~~~~
* save buddy list. Be careful, its only a nick uin list, so don't
overwrite your old one. uses /save command of irssi.
* Ignore cases in opening queries
* don't print Newline-characters anymore.

Wilfried Goesgens, Mit Aug  6 16:03:04 CEST 2003
Contact me in #irssi in ircnet, nick dothebart

Willi

</body></email><email><emailId>20030705163337</emailId><senderName>Timo Sirainen</senderName><senderEmail>tss@iki.fi</senderEmail><timestampReceived>2003-07-05 16:33:37-0400</timestampReceived><subject>Re: Mac OS X port of Irssi (Cocoa)</subject><body>


On Saturday, Jul 5, 2003, at 18:23 Europe/Helsinki, Andrew de los Reyes 
wrote:

&gt; I want to let you guys (Timo Sirainen and the other developers) that I
&gt; have come pretty far in making a Cocoa front-end for Irssi. My goal
&gt; with the project is to make a very userfriendly graphical IRC client
&gt; for Mac OS X. The reason I went with Irssi is because of all the
&gt; opensource IRC clients I looked at, Irssi had the cleanest code base.

Nice :) I just bought a powerbook last thursday, have been playing with 
it ever since. I really like my current wireless setup, especially the 
esound driver that I found which lets me use iTunes and send the audio 
to Linux server via wlan which finally sends it to my amplifier. And 
switching between esd and internal speakers / headphones works with 
just a few clicks without even having to stop the music. I really like 
this thing :)

Anyway, irssix seemed to work fine. I can't really live without black 
background, so I didn't test it too much. /quit seemed to crash it. I 
guess you also have nicklist window in TODO list already? And I 
couldn't really figure out how to build it from sources. "make" ran 
only one command and said "finished", but I couldn't figure out how to 
run it.


</body></email><email><emailId>20030705163524</emailId><senderName>Timo Sirainen</senderName><senderEmail>tss@iki.fi</senderEmail><timestampReceived>2003-07-05 16:35:24-0400</timestampReceived><subject>Re: Mac OS X port of Irssi (Cocoa)</subject><body>


On Saturday, Jul 5, 2003, at 18:23 Europe/Helsinki, Andrew de los Reyes 
wrote:

&gt; I want to let you guys (Timo Sirainen and the other developers) that I
&gt; have come pretty far in making a Cocoa front-end for Irssi.

Oh, and another thing. It seems to be using some weird character set. 
How could I change it to ISO-8859-1?


</body></email><email><emailId>20030805233229</emailId><senderName>neil klopfenstein</senderName><senderEmail>neilk@cs.ucsc.edu</senderEmail><timestampReceived>2003-08-05 23:32:29-0400</timestampReceived><subject>Bug fix for irssi 0.8.6 -- bold attribute not unset after ANSI reset</subject><body>

 Hi there,

 I use irssi 0.8.6 for all my online chat needs, but there was a bit of an
annoying bug on a MUD I use which uses ANSI color. The problem was that when it
was displaying a 'bright' color (color codes 8-15), which is represented by one
of the basic 8 colors plus the bold attribute, and then received an ANSI code
to go back to default color (^[[m), the bold attribute would stay on and turn
the rest of the line bold. This was easily fixed and I include a patch below.

 Regards,

 --neil klopfenstein

---cut here---

--- irssi-0.8.6/src/fe-common/core/formats.c	2002-06-18 20:10:02.000000000 -0700
+++ irssi-0.8.6-mod/src/fe-common/core/formats.c	2003-08-05 16:27:15.000000000 -0700
@@ -740,6 +740,12 @@
 		case 0:
 			/* reset colors back to default */
 			fg = theme-&gt;default_color;
+			if (fg &lt;= 7)
+				flags &amp;= ~GUI_PRINT_FLAG_BOLD;
+			else {
+				if (fg != 8) fg -= 8;
+				flags |= GUI_PRINT_FLAG_BOLD;
+			}
 			bg = -1;
 			flags &amp;= ~GUI_PRINT_FLAG_INDENT;
 			break;
@@ -1017,7 +1023,13 @@
 				break;
 			}
 			case FORMAT_STYLE_DEFAULTS:
-                                fgcolor = theme-&gt;default_color;
+				fgcolor = theme-&gt;default_color;
+				if (fgcolor &lt;= 7)
+					flags &amp;= ~GUI_PRINT_FLAG_BOLD;
+				else {
+					if (fgcolor != 8) fgcolor -= 8;
+					flags |= GUI_PRINT_FLAG_BOLD;
+				}
 				bgcolor = -1;
 				flags &amp;= GUI_PRINT_FLAG_INDENT|GUI_PRINT_FLAG_MONOSPACE;
 				break;

</body></email><email><emailId>20030821145554</emailId><senderName>Elmar Hoffmann</senderName><senderEmail>irssi-dev-ml@elho.net</senderEmail><timestampReceived>2003-08-21 14:55:54-0400</timestampReceived><subject>[Patch] fix theme-indent compile instructions for current irssi</subject><body>

Hi,

theme-indent.c won't compile without HAVE_CONFIG_H defined against
current irssi. As CVS irssi does default to glib2, I also changed that
part though it doesn't really matter in theme-indent's case.

Patch:             http://www.elho.net/irc/irssi/theme-indent.c.cvs.patch
Short Description: http://www.elho.net/irc/irssi/

elmar

-- 

 .'"`.                                                            /"\
| :' :   Elmar Hoffmann &lt;elho@elho.net&gt;    ASCII Ribbon Campaign  \ /
`. `'    PGP key available via pgp.net        against HTML email   X
  `-                                                    &amp; vCards  / \

</body></email><email><emailId>20030824214228</emailId><senderName>wilfried Goesgens</senderName><senderEmail>willi@almado.de</senderEmail><timestampReceived>2003-08-24 21:42:28-0400</timestampReceived><subject>Re: Did some work on the irssi-icq-plugin...</subject><body>

Am Son, 2003-08-24 um 23.38 schrieb Wilfried Goesgens:
&gt; Hya, I did some coding on the icq plugin, to make it more usefull to
&gt; me...
&gt; New Features:
&gt; ~~~~~~~~~~~~~
&gt; * save buddy list. Be careful, its only a nick uin list, so don't
&gt; overwrite your old one. uses /save command of irssi.
&gt; * Ignore cases in opening queries
&gt; * don't print Newline-characters anymore.
&gt; 
&gt; Wilfried Goesgens, Mit Aug  6 16:03:04 CEST 2003
&gt; Contact me in #irssi in ircnet, nick dothebart
&gt; 
&gt; Willi
silly me. forgot the link.
http://tar.gzipped.org/~willi/irssi-icq.tgz


</body></email><email><emailId>20030826180850</emailId><senderName>Valentin Batz</senderName><senderEmail>vb@g-23.org</senderEmail><timestampReceived>2003-08-26 18:08:50-0400</timestampReceived><subject>proxy ctcp patch</subject><body>

Hi there,

I've patched the proxy module.

I changed the CTCP forwarding to the clients.
So every client connected to proxy on different
chatnets is able to receive the incomming CTCPs on his chatnet.
If a new client connects to the proxy where a client is already
connected and receiving the CTCPs and it sends 'proxy ctcp on' then
it will get the CTCPs for that chatnet and the client who was
receiving the CTCPs before will get a notice from proxy,
that some other client will now receive the CTCPs.

patch can be downloaded here:
http://hurzelgnom.bei.t-online.de/irssi/patch/proxy_ctcp_patch.diff

Regards

Valentin Batz

</body></email><email><emailId>20030827115014</emailId><senderName>Valentin Batz</senderName><senderEmail>vb@g-23.org</senderEmail><timestampReceived>2003-08-27 11:50:14-0400</timestampReceived><subject>Re: Typo in special_vars.txt</subject><body>

Hi again,
my mailclient removed all newlines in the patch.
so i uploaded it to the web.

it can be found here:
http://hurzelgnom.bei.t-online.de/irssi/patch/special_vars.txt.patch

Regards

Valentin Batz

</body></email><email><emailId>20030706002741</emailId><senderName>Andrew de los Reyes</senderName><senderEmail>adlr@umich.edu</senderEmail><timestampReceived>2003-07-06 00:27:41-0400</timestampReceived><subject>Re: Mac OS X port of Irssi (Cocoa)</subject><body>

On Sat, Jul 05, 2003 at 07:33:37PM +0300, Timo Sirainen wrote:
&gt; 
&gt; On Saturday, Jul 5, 2003, at 18:23 Europe/Helsinki, Andrew de los Reyes 
&gt; wrote:
&gt; 
&gt; &gt;I want to let you guys (Timo Sirainen and the other developers) that I
&gt; &gt;have come pretty far in making a Cocoa front-end for Irssi. My goal
&gt; &gt;with the project is to make a very userfriendly graphical IRC client
&gt; &gt;for Mac OS X. The reason I went with Irssi is because of all the
&gt; &gt;opensource IRC clients I looked at, Irssi had the cleanest code base.
&gt; 
&gt; Nice :) I just bought a powerbook last thursday, have been playing with 
&gt; it ever since. I really like my current wireless setup, especially the 
&gt; esound driver that I found which lets me use iTunes and send the audio 
&gt; to Linux server via wlan which finally sends it to my amplifier. And 
&gt; switching between esd and internal speakers / headphones works with 
&gt; just a few clicks without even having to stop the music. I really like 
&gt; this thing :)

yeah. i'm using a linux desktop machine and a mac laptop too. :) i'll
have to try out the esound driver you speak of.

&gt; 
&gt; Anyway, irssix seemed to work fine. I can't really live without black 
&gt; background, so I didn't test it too much. /quit seemed to crash it. I 
&gt; guess you also have nicklist window in TODO list already? And I 
&gt; couldn't really figure out how to build it from sources. "make" ran 
&gt; only one command and said "finished", but I couldn't figure out how to 
&gt; run it.
&gt; 

yeah, as you can see it is beta. on the todo list: a gui configuration
would be nice at least for some basic things (e.g. what you would
normally pass on the command line assuming it has a bitchx/ircii style
invocation), nicklist window, a configurable dock badge showing if
you;ve been /msg'd perhaps.

and i guess i'll add in a default fg/bg colors for the windows. :)

as for the character set issues, i haven't played with non-us
characters.  i'll try to play with them soon.  being
internationally-friendly pretty important to me.

i'll keep you informed,
-andrew


</body></email><email><emailId>20030708172150</emailId><senderName>"Janne Enberg"</senderName><senderEmail>janne_enberg@kolumbus.fi</senderEmail><timestampReceived>2003-07-08 17:21:50-0400</timestampReceived><subject>Irssi for QNX</subject><body>

Here is listed the needed changes to irssi 0.8.6 sources so it will compile
under the QNX real time operating
system(http://www.qnx.com).

---------------

src/core/log.c -&gt;
original lines 35-38:
#ifdef HAVE_FCNTL
static struct flock lock;
#endif

lines 35-38 after changes:
#ifdef HAVE_FCNTL
static struct flock locker;
#endif

and then replaced every instance of 'lock' to 'locker' respectively..
for some reason that 'lock' seems to be either reserved or already in use by
some .h file included..
If needed I can try to check what file exactly and where etc..

---------------

src/perl/perl-core.c -&gt;
original line 114:
 newXS("DynaLoader::boot_DynaLoader", boot_DynaLoader, __FILE__);

line 114-117 after changes:
#ifndef __QNXNTO__
 newXS("DynaLoader::boot_DynaLoader", boot_DynaLoader, __FILE__);
#endif

For some reason that DynaLoader line just kills the compilation under QNX,
if anyone has any ideas I can try to check on the details..

---------------

By: Janne Enberg aka. Lietu
email: janne_enberg@kolumbus.fi
IRCNet: Lietu @ #irssi


</body></email><email><emailId>20030725002119</emailId><senderName>tommy-carlos williams</senderName><senderEmail>tommy@devgeeks.org</senderEmail><timestampReceived>2003-07-25 00:21:19-0400</timestampReceived><subject>Irssi compile error under Irix6.5.x - Mipspro7.3</subject><body>

hi,

i was trying to compile irssi  (irssi-0.8.6.CVS) on Irix 6.5.16m using 
Mipspro 7.3 last night and came accross a little sticking point. 


network.c
cc-1101 cc: ERROR File = network.c, Line = 30
  "sockaddr_union" has already been declared in the current scope.

  union sockaddr_union {


i checked on the net for the error to see if there was an obvious fix 
for it (i am relatively new to Irix and Mipspro) and found mention of 
it in a cvs entry for the Silc projects use of irssi. 

i checked if this error had been fixed in the  irssi-latest.tar.gz and 
then in the latest CVS and it had not. i can only assume the Silc 
developers did not feed this fix back to irssi. 

therefore i made this patch against the latest CVS. 

again, i am new to all this, put this patch does allow irssi to compile 
happily on Irix 6.5.x under Mipspro 7.3. (and possibly other versions). 
please let me know if i have submitted this incorrectly as there seems 
to only be information on submitting crash-type bug reports on the 
website. 

thanks,
- tommy-carlos williams

["network.c-irix6.5-mipspro.patch" (application/octet-stream)]

Index: src/core/network.c
===================================================================
RCS file: /home/cvs/irssi/src/core/network.c,v
retrieving revision 1.47
diff -u -r1.47 network.c
--- src/core/network.c	9 Jul 2003 23:34:41 -0000	1.47
+++ src/core/network.c	24 Jul 2003 23:49:00 -0000
@@ -27,7 +27,7 @@
 #  define INADDR_NONE INADDR_BROADCAST
 #endif
 
-union sockaddr_union {
+union irssi_sockaddr_union {
 	struct sockaddr sa;
 	struct sockaddr_in sin;
 #ifdef HAVE_IPV6
@@ -76,7 +76,7 @@
 #else
 static
 #endif
-void sin_set_ip(union sockaddr_union *so, const IPADDR *ip)
+void sin_set_ip(union irssi_sockaddr_union *so, const IPADDR *ip)
 {
 	if (ip == NULL) {
 #ifdef HAVE_IPV6
@@ -98,7 +98,7 @@
 		memcpy(&amp;so-&gt;sin.sin_addr, &amp;ip-&gt;ip, 4);
 }
 
-void sin_get_ip(const union sockaddr_union *so, IPADDR *ip)
+void sin_get_ip(const union irssi_sockaddr_union *so, IPADDR *ip)
 {
 	ip-&gt;family = so-&gt;sin.sin_family;
 
@@ -115,7 +115,7 @@
 #else
 static
 #endif
-void sin_set_port(union sockaddr_union *so, int port)
+void sin_set_port(union irssi_sockaddr_union *so, int port)
 {
 #ifdef HAVE_IPV6
 	if (so-&gt;sin.sin_family == AF_INET6)
@@ -130,7 +130,7 @@
 #else
 static
 #endif
-int sin_get_port(union sockaddr_union *so)
+int sin_get_port(union irssi_sockaddr_union *so)
 {
 #ifdef HAVE_IPV6
 	if (so-&gt;sin.sin_family == AF_INET6)
@@ -178,7 +178,7 @@
 /* Connect to socket with ip address */
 GIOChannel *net_connect_ip(IPADDR *ip, int port, IPADDR *my_ip)
 {
-	union sockaddr_union so;
+	union irssi_sockaddr_union so;
 	int handle, ret, opt = 1;
 
 	if (my_ip != NULL &amp;&amp; ip-&gt;family != my_ip-&gt;family) {
@@ -281,7 +281,7 @@
    address. */
 GIOChannel *net_listen(IPADDR *my_ip, int *port)
 {
-	union sockaddr_union so;
+	union irssi_sockaddr_union so;
 	int ret, handle, opt = 1;
 	socklen_t len;
 
@@ -338,7 +338,7 @@
 /* Accept a connection on a socket */
 GIOChannel *net_accept(GIOChannel *handle, IPADDR *addr, int *port)
 {
-	union sockaddr_union so;
+	union irssi_sockaddr_union so;
 	int ret;
 	socklen_t addrlen;
 
@@ -398,7 +398,7 @@
 /* Get socket address/port */
 int net_getsockname(GIOChannel *handle, IPADDR *addr, int *port)
 {
-	union sockaddr_union so;
+	union irssi_sockaddr_union so;
 	socklen_t addrlen;
 
 	g_return_val_if_fail(handle != NULL, -1);
@@ -421,7 +421,7 @@
 int net_gethostbyname(const char *addr, IPADDR *ip4, IPADDR *ip6)
 {
 #ifdef HAVE_IPV6
-	union sockaddr_union *so;
+	union irssi_sockaddr_union *so;
 	struct addrinfo hints, *ai, *ailist;
 	int ret, count;
 #else
@@ -444,7 +444,7 @@
 
         count = 0;
 	for (ai = ailist; ai != NULL &amp;&amp; count &lt; 2; ai = ai-&gt;ai_next) {
-		so = (union sockaddr_union *) ai-&gt;ai_addr;
+		so = (union irssi_sockaddr_union *) ai-&gt;ai_addr;
 
 		if (ai-&gt;ai_family == AF_INET6 &amp;&amp; ip6-&gt;family == 0) {
 			sin_get_ip(so, ip6);
@@ -473,7 +473,7 @@
 int net_gethostbyaddr(IPADDR *ip, char **name)
 {
 #ifdef HAVE_IPV6
-	union sockaddr_union so;
+	union irssi_sockaddr_union so;
 	int host_error;
 	char hostname[NI_MAXHOST];
 #else


</body></email><email><emailId>20030731101843</emailId><senderName>Nikolai Weibull</senderName><senderEmail>lone-star@home.se</senderEmail><timestampReceived>2003-07-31 10:18:43-0400</timestampReceived><subject>color support.</subject><body>

Hi.  It seems irssi only supports 8-color ansi with bold for bright at
the moment.  Would it be painful to add 16-color or even 88/256 color
support?  I'm toying with 256-color support in xterm, and it would be
great if irssi could support it.  If you (Timo) don't feel like adding
it yourself, could you perhaps give some hints as to what parts of the
code would need alteration?

thanks,
	nikolai

--
::: name: Nikolai Weibull    :: aliases: pcp / lone-star       :::
::: born: Chicago, IL USA    :: loc atm: Gothenburg, Sweden    :::
::: page: www.pcppopper.org  :: fun atm: gf,lps,ruby,php,war3  :::
main(){printf(&amp;linux["\021%six\012\0"],(linux)["have"]+"fun"-97);}

</body></email><email><emailId>20030826174947</emailId><senderName>Valentin Batz</senderName><senderEmail>vb@g-23.org</senderEmail><timestampReceived>2003-08-26 17:49:47-0400</timestampReceived><subject>Typo in special_vars.txt</subject><body>

Hi there,
I found a typo in special_vars.txt

Patch included

Regards

Valentin Batz

["special_vars.txt.patch" (text/plain)]

--- docs/special_vars.txt	2003-08-26 12:17:18.000000000 +0200+++ =
docs/special_vars.txt	2003-08-26 19:37:56.000000000 +0200@@ -80,7 +80,7 @@  =
  $Z         time of day (hh:mm, can be changed with /SET timestamp_format) =
   $$         a literal '$' -   $versiontim          prints time of the =
irssi version in HHMM format+   $versiontime         prints time of the =
irssi version in HHMM format    $sysname             system name (eg. =
Linux)    $sysrelease          system release (eg. 2.2.18)    $sysarch      =
       system architecture (eg. i686)

</body></email></emails>